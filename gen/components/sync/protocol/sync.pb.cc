// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/sync.proto

#include "components/sync/protocol/sync.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR ChromiumExtensionsActivity::ChromiumExtensionsActivity(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.extension_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.bookmark_writes_since_last_commit_)*/ 0u }
{
}
struct ChromiumExtensionsActivityDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ChromiumExtensionsActivityDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ChromiumExtensionsActivityDefaultTypeInternal()
    {
    }
    union {
        ChromiumExtensionsActivity _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromiumExtensionsActivityDefaultTypeInternal
    _ChromiumExtensionsActivity_default_instance_;
PROTOBUF_CONSTEXPR ClientConfigParams::ClientConfigParams(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.enabled_type_ids_)*/ {},
        /*decltype(_impl_.devices_fcm_registration_tokens_)*/ {}, /*decltype(_impl_.fcm_registration_tokens_for_interested_clients_)*/ {},
        /*decltype(_impl_.tabs_datatype_enabled_)*/ false, /*decltype(_impl_.cookie_jar_mismatch_)*/ false, /*decltype(_impl_.single_client_)*/ false,
        /*decltype(_impl_.single_client_with_standalone_invalidations_)*/ false, /*decltype(_impl_.single_client_with_old_invalidations_)*/ false }
{
}
struct ClientConfigParamsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientConfigParamsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientConfigParamsDefaultTypeInternal()
    {
    }
    union {
        ClientConfigParams _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientConfigParamsDefaultTypeInternal _ClientConfigParams_default_instance_;
PROTOBUF_CONSTEXPR CommitMessage::CommitMessage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.entries_)*/ {},
        /*decltype(_impl_.extensions_activity_)*/ {}, /*decltype(_impl_.client_contexts_)*/ {},
        /*decltype(_impl_.cache_guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.padding_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.config_params_)*/ nullptr }
{
}
struct CommitMessageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CommitMessageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CommitMessageDefaultTypeInternal()
    {
    }
    union {
        CommitMessage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitMessageDefaultTypeInternal _CommitMessage_default_instance_;
PROTOBUF_CONSTEXPR GetUpdatesMessage::GetUpdatesMessage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.from_progress_marker_)*/ {},
        /*decltype(_impl_.client_contexts_)*/ {}, /*decltype(_impl_.caller_info_)*/ nullptr, /*decltype(_impl_.streaming_)*/ false,
        /*decltype(_impl_.need_encryption_key_)*/ false, /*decltype(_impl_.is_retry_)*/ false, /*decltype(_impl_.get_updates_origin_)*/ 0,
        /*decltype(_impl_.fetch_folders_)*/ true }
{
}
struct GetUpdatesMessageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetUpdatesMessageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetUpdatesMessageDefaultTypeInternal()
    {
    }
    union {
        GetUpdatesMessage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUpdatesMessageDefaultTypeInternal _GetUpdatesMessage_default_instance_;
PROTOBUF_CONSTEXPR ClearServerDataMessage::ClearServerDataMessage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ClearServerDataMessageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClearServerDataMessageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClearServerDataMessageDefaultTypeInternal()
    {
    }
    union {
        ClearServerDataMessage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearServerDataMessageDefaultTypeInternal
    _ClearServerDataMessage_default_instance_;
PROTOBUF_CONSTEXPR ClearServerDataResponse::ClearServerDataResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ClearServerDataResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClearServerDataResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClearServerDataResponseDefaultTypeInternal()
    {
    }
    union {
        ClearServerDataResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearServerDataResponseDefaultTypeInternal
    _ClearServerDataResponse_default_instance_;
PROTOBUF_CONSTEXPR ChipBag::ChipBag(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.server_chips_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct ChipBagDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ChipBagDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ChipBagDefaultTypeInternal()
    {
    }
    union {
        ChipBag _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChipBagDefaultTypeInternal _ChipBag_default_instance_;
PROTOBUF_CONSTEXPR ClientStatus::ClientStatus(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.hierarchy_conflict_detected_)*/ false,
        /*decltype(_impl_.is_sync_feature_enabled_)*/ false }
{
}
struct ClientStatusDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientStatusDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientStatusDefaultTypeInternal()
    {
    }
    union {
        ClientStatus _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientStatusDefaultTypeInternal _ClientStatus_default_instance_;
PROTOBUF_CONSTEXPR ClientToServerMessage::ClientToServerMessage(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.share_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.store_birthday_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.api_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.invalidator_client_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.commit_)*/ nullptr, /*decltype(_impl_.get_updates_)*/ nullptr, /*decltype(_impl_.debug_info_)*/ nullptr,
        /*decltype(_impl_.bag_of_chips_)*/ nullptr, /*decltype(_impl_.client_status_)*/ nullptr, /*decltype(_impl_.clear_server_data_)*/ nullptr,
        /*decltype(_impl_.protocol_version_)*/ 99, /*decltype(_impl_.message_contents_)*/ 1 }
{
}
struct ClientToServerMessageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientToServerMessageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientToServerMessageDefaultTypeInternal()
    {
    }
    union {
        ClientToServerMessage _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientToServerMessageDefaultTypeInternal
    _ClientToServerMessage_default_instance_;
PROTOBUF_CONSTEXPR CommitResponse_EntryResponse_DatatypeSpecificError::CommitResponse_EntryResponse_DatatypeSpecificError(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.datatype_error_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal()
    {
    }
    union {
        CommitResponse_EntryResponse_DatatypeSpecificError _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal
    _CommitResponse_EntryResponse_DatatypeSpecificError_default_instance_;
PROTOBUF_CONSTEXPR CommitResponse_EntryResponse::CommitResponse_EntryResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.id_string_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.error_message_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.datatype_specific_error_)*/ nullptr, /*decltype(_impl_.version_)*/ int64_t { 0 }, /*decltype(_impl_.mtime_)*/ int64_t { 0 },
        /*decltype(_impl_.response_type_)*/ 1 }
{
}
struct CommitResponse_EntryResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CommitResponse_EntryResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CommitResponse_EntryResponseDefaultTypeInternal()
    {
    }
    union {
        CommitResponse_EntryResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitResponse_EntryResponseDefaultTypeInternal
    _CommitResponse_EntryResponse_default_instance_;
PROTOBUF_CONSTEXPR CommitResponse::CommitResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.entryresponse_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CommitResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CommitResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CommitResponseDefaultTypeInternal()
    {
    }
    union {
        CommitResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitResponseDefaultTypeInternal _CommitResponse_default_instance_;
PROTOBUF_CONSTEXPR GetUpdatesResponse::GetUpdatesResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.entries_)*/ {},
        /*decltype(_impl_.new_progress_marker_)*/ {}, /*decltype(_impl_.encryption_keys_)*/ {}, /*decltype(_impl_.context_mutations_)*/ {},
        /*decltype(_impl_.changes_remaining_)*/ int64_t { 0 } }
{
}
struct GetUpdatesResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetUpdatesResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetUpdatesResponseDefaultTypeInternal()
    {
    }
    union {
        GetUpdatesResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUpdatesResponseDefaultTypeInternal _GetUpdatesResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientToServerResponse_Error::ClientToServerResponse_Error(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.error_data_type_ids_)*/ {},
        /*decltype(_impl_.error_description_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.error_type_)*/ 100,
        /*decltype(_impl_.action_)*/ 5 }
{
}
struct ClientToServerResponse_ErrorDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientToServerResponse_ErrorDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientToServerResponse_ErrorDefaultTypeInternal()
    {
    }
    union {
        ClientToServerResponse_Error _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientToServerResponse_ErrorDefaultTypeInternal
    _ClientToServerResponse_Error_default_instance_;
PROTOBUF_CONSTEXPR ClientToServerResponse::ClientToServerResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.migrated_data_type_id_)*/ {},
        /*decltype(_impl_.error_message_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.store_birthday_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.commit_)*/ nullptr,
        /*decltype(_impl_.get_updates_)*/ nullptr, /*decltype(_impl_.client_command_)*/ nullptr, /*decltype(_impl_.error_)*/ nullptr,
        /*decltype(_impl_.new_bag_of_chips_)*/ nullptr, /*decltype(_impl_.clear_server_data_)*/ nullptr, /*decltype(_impl_.error_code_)*/ 100 }
{
}
struct ClientToServerResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ClientToServerResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ClientToServerResponseDefaultTypeInternal()
    {
    }
    union {
        ClientToServerResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientToServerResponseDefaultTypeInternal
    _ClientToServerResponse_default_instance_;
PROTOBUF_CONSTEXPR EventRequest::EventRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.sync_disabled_)*/ nullptr }
{
}
struct EventRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR EventRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~EventRequestDefaultTypeInternal()
    {
    }
    union {
        EventRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventRequestDefaultTypeInternal _EventRequest_default_instance_;
PROTOBUF_CONSTEXPR EventResponse::EventResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct EventResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR EventResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~EventResponseDefaultTypeInternal()
    {
    }
    union {
        EventResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventResponseDefaultTypeInternal _EventResponse_default_instance_;
PROTOBUF_CONSTEXPR SyncDisabledEvent::SyncDisabledEvent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.cache_guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.store_birthday_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct SyncDisabledEventDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SyncDisabledEventDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SyncDisabledEventDefaultTypeInternal()
    {
    }
    union {
        SyncDisabledEvent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SyncDisabledEventDefaultTypeInternal _SyncDisabledEvent_default_instance_;
} // namespace sync_pb
namespace sync_pb {
bool ClientToServerMessage_Contents_IsValid(int value)
{
    switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientToServerMessage_Contents_strings[5] = {};

static const char ClientToServerMessage_Contents_names[] = "CLEAR_SERVER_DATA"
                                                           "COMMIT"
                                                           "DEPRECATED_3"
                                                           "DEPRECATED_4"
                                                           "GET_UPDATES";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientToServerMessage_Contents_entries[] = {
    { { ClientToServerMessage_Contents_names + 0, 17 }, 5 },
    { { ClientToServerMessage_Contents_names + 17, 6 }, 1 },
    { { ClientToServerMessage_Contents_names + 23, 12 }, 3 },
    { { ClientToServerMessage_Contents_names + 35, 12 }, 4 },
    { { ClientToServerMessage_Contents_names + 47, 11 }, 2 },
};

static const int ClientToServerMessage_Contents_entries_by_number[] = {
    1, // 1 -> COMMIT
    4, // 2 -> GET_UPDATES
    2, // 3 -> DEPRECATED_3
    3, // 4 -> DEPRECATED_4
    0, // 5 -> CLEAR_SERVER_DATA
};

const std::string& ClientToServerMessage_Contents_Name(ClientToServerMessage_Contents value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ClientToServerMessage_Contents_entries, ClientToServerMessage_Contents_entries_by_number, 5, ClientToServerMessage_Contents_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ClientToServerMessage_Contents_entries, ClientToServerMessage_Contents_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ClientToServerMessage_Contents_strings[idx].get();
}
bool ClientToServerMessage_Contents_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientToServerMessage_Contents* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ClientToServerMessage_Contents_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<ClientToServerMessage_Contents>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientToServerMessage_Contents ClientToServerMessage::COMMIT;
constexpr ClientToServerMessage_Contents ClientToServerMessage::GET_UPDATES;
constexpr ClientToServerMessage_Contents ClientToServerMessage::DEPRECATED_3;
constexpr ClientToServerMessage_Contents ClientToServerMessage::DEPRECATED_4;
constexpr ClientToServerMessage_Contents ClientToServerMessage::CLEAR_SERVER_DATA;
constexpr ClientToServerMessage_Contents ClientToServerMessage::Contents_MIN;
constexpr ClientToServerMessage_Contents ClientToServerMessage::Contents_MAX;
constexpr int ClientToServerMessage::Contents_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CommitResponse_ResponseType_IsValid(int value)
{
    switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommitResponse_ResponseType_strings[6] = {};

static const char CommitResponse_ResponseType_names[] = "CONFLICT"
                                                        "INVALID_MESSAGE"
                                                        "OVER_QUOTA"
                                                        "RETRY"
                                                        "SUCCESS"
                                                        "TRANSIENT_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommitResponse_ResponseType_entries[] = {
    { { CommitResponse_ResponseType_names + 0, 8 }, 2 },
    { { CommitResponse_ResponseType_names + 8, 15 }, 4 },
    { { CommitResponse_ResponseType_names + 23, 10 }, 5 },
    { { CommitResponse_ResponseType_names + 33, 5 }, 3 },
    { { CommitResponse_ResponseType_names + 38, 7 }, 1 },
    { { CommitResponse_ResponseType_names + 45, 15 }, 6 },
};

static const int CommitResponse_ResponseType_entries_by_number[] = {
    4, // 1 -> SUCCESS
    0, // 2 -> CONFLICT
    3, // 3 -> RETRY
    1, // 4 -> INVALID_MESSAGE
    2, // 5 -> OVER_QUOTA
    5, // 6 -> TRANSIENT_ERROR
};

const std::string& CommitResponse_ResponseType_Name(CommitResponse_ResponseType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        CommitResponse_ResponseType_entries, CommitResponse_ResponseType_entries_by_number, 6, CommitResponse_ResponseType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(CommitResponse_ResponseType_entries, CommitResponse_ResponseType_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : CommitResponse_ResponseType_strings[idx].get();
}
bool CommitResponse_ResponseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommitResponse_ResponseType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(CommitResponse_ResponseType_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<CommitResponse_ResponseType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CommitResponse_ResponseType CommitResponse::SUCCESS;
constexpr CommitResponse_ResponseType CommitResponse::CONFLICT;
constexpr CommitResponse_ResponseType CommitResponse::RETRY;
constexpr CommitResponse_ResponseType CommitResponse::INVALID_MESSAGE;
constexpr CommitResponse_ResponseType CommitResponse::OVER_QUOTA;
constexpr CommitResponse_ResponseType CommitResponse::TRANSIENT_ERROR;
constexpr CommitResponse_ResponseType CommitResponse::ResponseType_MIN;
constexpr CommitResponse_ResponseType CommitResponse::ResponseType_MAX;
constexpr int CommitResponse::ResponseType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ChromiumExtensionsActivity::_Internal {
public:
    using HasBits = decltype(std::declval<ChromiumExtensionsActivity>()._impl_._has_bits_);
    static void set_has_extension_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_bookmark_writes_since_last_commit(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ChromiumExtensionsActivity::ChromiumExtensionsActivity(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ChromiumExtensionsActivity)
}
ChromiumExtensionsActivity::ChromiumExtensionsActivity(const ChromiumExtensionsActivity& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ChromiumExtensionsActivity* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.extension_id_) {},
        decltype(_impl_.bookmark_writes_since_last_commit_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.extension_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_extension_id()) {
        _this->_impl_.extension_id_.Set(from._internal_extension_id(), _this->GetArenaForAllocation());
    }
    _this->_impl_.bookmark_writes_since_last_commit_ = from._impl_.bookmark_writes_since_last_commit_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.ChromiumExtensionsActivity)
}

inline void ChromiumExtensionsActivity::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.extension_id_) {},
        decltype(_impl_.bookmark_writes_since_last_commit_) { 0u } };
    _impl_.extension_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChromiumExtensionsActivity::~ChromiumExtensionsActivity()
{
    // @@protoc_insertion_point(destructor:sync_pb.ChromiumExtensionsActivity)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ChromiumExtensionsActivity::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.extension_id_.Destroy();
}

void ChromiumExtensionsActivity::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ChromiumExtensionsActivity::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ChromiumExtensionsActivity)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.extension_id_.ClearNonDefaultToEmpty();
    }
    _impl_.bookmark_writes_since_last_commit_ = 0u;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ChromiumExtensionsActivity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string extension_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_extension_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional uint32 bookmark_writes_since_last_commit = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_bookmark_writes_since_last_commit(&has_bits);
                _impl_.bookmark_writes_since_last_commit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ChromiumExtensionsActivity::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ChromiumExtensionsActivity)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string extension_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_extension_id(), target);
    }

    // optional uint32 bookmark_writes_since_last_commit = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_bookmark_writes_since_last_commit(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ChromiumExtensionsActivity)
    return target;
}

size_t ChromiumExtensionsActivity::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ChromiumExtensionsActivity)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string extension_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_extension_id());
        }

        // optional uint32 bookmark_writes_since_last_commit = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bookmark_writes_since_last_commit());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ChromiumExtensionsActivity::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ChromiumExtensionsActivity*>(&from));
}

void ChromiumExtensionsActivity::MergeFrom(const ChromiumExtensionsActivity& from)
{
    ChromiumExtensionsActivity* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ChromiumExtensionsActivity)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_extension_id(from._internal_extension_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.bookmark_writes_since_last_commit_ = from._impl_.bookmark_writes_since_last_commit_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromiumExtensionsActivity::CopyFrom(const ChromiumExtensionsActivity& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ChromiumExtensionsActivity)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ChromiumExtensionsActivity::IsInitialized() const
{
    return true;
}

void ChromiumExtensionsActivity::InternalSwap(ChromiumExtensionsActivity* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.extension_id_, lhs_arena, &other->_impl_.extension_id_, rhs_arena);
    swap(_impl_.bookmark_writes_since_last_commit_, other->_impl_.bookmark_writes_since_last_commit_);
}

std::string ChromiumExtensionsActivity::GetTypeName() const
{
    return "sync_pb.ChromiumExtensionsActivity";
}

// ===================================================================

class ClientConfigParams::_Internal {
public:
    using HasBits = decltype(std::declval<ClientConfigParams>()._impl_._has_bits_);
    static void set_has_tabs_datatype_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_cookie_jar_mismatch(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_single_client(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_single_client_with_standalone_invalidations(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_single_client_with_old_invalidations(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

ClientConfigParams::ClientConfigParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ClientConfigParams)
}
ClientConfigParams::ClientConfigParams(const ClientConfigParams& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientConfigParams* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.enabled_type_ids_) { from._impl_.enabled_type_ids_ },
        decltype(_impl_.devices_fcm_registration_tokens_) { from._impl_.devices_fcm_registration_tokens_ },
        decltype(_impl_.fcm_registration_tokens_for_interested_clients_) { from._impl_.fcm_registration_tokens_for_interested_clients_ },
        decltype(_impl_.tabs_datatype_enabled_) {}, decltype(_impl_.cookie_jar_mismatch_) {}, decltype(_impl_.single_client_) {},
        decltype(_impl_.single_client_with_standalone_invalidations_) {}, decltype(_impl_.single_client_with_old_invalidations_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.tabs_datatype_enabled_, &from._impl_.tabs_datatype_enabled_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.single_client_with_old_invalidations_) - reinterpret_cast<char*>(&_impl_.tabs_datatype_enabled_))
            + sizeof(_impl_.single_client_with_old_invalidations_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.ClientConfigParams)
}

inline void ClientConfigParams::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.enabled_type_ids_) { arena },
        decltype(_impl_.devices_fcm_registration_tokens_) { arena }, decltype(_impl_.fcm_registration_tokens_for_interested_clients_) { arena },
        decltype(_impl_.tabs_datatype_enabled_) { false }, decltype(_impl_.cookie_jar_mismatch_) { false }, decltype(_impl_.single_client_) { false },
        decltype(_impl_.single_client_with_standalone_invalidations_) { false }, decltype(_impl_.single_client_with_old_invalidations_) { false } };
}

ClientConfigParams::~ClientConfigParams()
{
    // @@protoc_insertion_point(destructor:sync_pb.ClientConfigParams)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientConfigParams::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.enabled_type_ids_.~RepeatedField();
    _impl_.devices_fcm_registration_tokens_.~RepeatedPtrField();
    _impl_.fcm_registration_tokens_for_interested_clients_.~RepeatedPtrField();
}

void ClientConfigParams::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientConfigParams::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ClientConfigParams)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.enabled_type_ids_.Clear();
    _impl_.devices_fcm_registration_tokens_.Clear();
    _impl_.fcm_registration_tokens_for_interested_clients_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        ::memset(&_impl_.tabs_datatype_enabled_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.single_client_with_old_invalidations_) - reinterpret_cast<char*>(&_impl_.tabs_datatype_enabled_))
                + sizeof(_impl_.single_client_with_old_invalidations_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientConfigParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 enabled_type_ids = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_enabled_type_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_enabled_type_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool tabs_datatype_enabled = 2 [deprecated = true];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_tabs_datatype_enabled(&has_bits);
                _impl_.tabs_datatype_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool cookie_jar_mismatch = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_cookie_jar_mismatch(&has_bits);
                _impl_.cookie_jar_mismatch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool single_client = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_single_client(&has_bits);
                _impl_.single_client_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string devices_fcm_registration_tokens = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_devices_fcm_registration_tokens();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool single_client_with_standalone_invalidations = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_single_client_with_standalone_invalidations(&has_bits);
                _impl_.single_client_with_standalone_invalidations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string fcm_registration_tokens_for_interested_clients = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_fcm_registration_tokens_for_interested_clients();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool single_client_with_old_invalidations = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_single_client_with_old_invalidations(&has_bits);
                _impl_.single_client_with_old_invalidations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientConfigParams::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientConfigParams)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 enabled_type_ids = 1;
    for (int i = 0, n = this->_internal_enabled_type_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_enabled_type_ids(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool tabs_datatype_enabled = 2 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_tabs_datatype_enabled(), target);
    }

    // optional bool cookie_jar_mismatch = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_cookie_jar_mismatch(), target);
    }

    // optional bool single_client = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_single_client(), target);
    }

    // repeated string devices_fcm_registration_tokens = 5;
    for (int i = 0, n = this->_internal_devices_fcm_registration_tokens_size(); i < n; i++) {
        const auto& s = this->_internal_devices_fcm_registration_tokens(i);
        target = stream->WriteString(5, s, target);
    }

    // optional bool single_client_with_standalone_invalidations = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_single_client_with_standalone_invalidations(), target);
    }

    // repeated string fcm_registration_tokens_for_interested_clients = 7;
    for (int i = 0, n = this->_internal_fcm_registration_tokens_for_interested_clients_size(); i < n; i++) {
        const auto& s = this->_internal_fcm_registration_tokens_for_interested_clients(i);
        target = stream->WriteString(7, s, target);
    }

    // optional bool single_client_with_old_invalidations = 8;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_single_client_with_old_invalidations(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientConfigParams)
    return target;
}

size_t ClientConfigParams::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientConfigParams)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 enabled_type_ids = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.enabled_type_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_enabled_type_ids_size());
        total_size += data_size;
    }

    // repeated string devices_fcm_registration_tokens = 5;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.devices_fcm_registration_tokens_.size());
    for (int i = 0, n = _impl_.devices_fcm_registration_tokens_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.devices_fcm_registration_tokens_.Get(i));
    }

    // repeated string fcm_registration_tokens_for_interested_clients = 7;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.fcm_registration_tokens_for_interested_clients_.size());
    for (int i = 0, n = _impl_.fcm_registration_tokens_for_interested_clients_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.fcm_registration_tokens_for_interested_clients_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional bool tabs_datatype_enabled = 2 [deprecated = true];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        // optional bool cookie_jar_mismatch = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool single_client = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool single_client_with_standalone_invalidations = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional bool single_client_with_old_invalidations = 8;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientConfigParams::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientConfigParams*>(&from));
}

void ClientConfigParams::MergeFrom(const ClientConfigParams& from)
{
    ClientConfigParams* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientConfigParams)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.enabled_type_ids_.MergeFrom(from._impl_.enabled_type_ids_);
    _this->_impl_.devices_fcm_registration_tokens_.MergeFrom(from._impl_.devices_fcm_registration_tokens_);
    _this->_impl_.fcm_registration_tokens_for_interested_clients_.MergeFrom(from._impl_.fcm_registration_tokens_for_interested_clients_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.tabs_datatype_enabled_ = from._impl_.tabs_datatype_enabled_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.cookie_jar_mismatch_ = from._impl_.cookie_jar_mismatch_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.single_client_ = from._impl_.single_client_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.single_client_with_standalone_invalidations_ = from._impl_.single_client_with_standalone_invalidations_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.single_client_with_old_invalidations_ = from._impl_.single_client_with_old_invalidations_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientConfigParams::CopyFrom(const ClientConfigParams& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientConfigParams)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientConfigParams::IsInitialized() const
{
    return true;
}

void ClientConfigParams::InternalSwap(ClientConfigParams* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.enabled_type_ids_.InternalSwap(&other->_impl_.enabled_type_ids_);
    _impl_.devices_fcm_registration_tokens_.InternalSwap(&other->_impl_.devices_fcm_registration_tokens_);
    _impl_.fcm_registration_tokens_for_interested_clients_.InternalSwap(&other->_impl_.fcm_registration_tokens_for_interested_clients_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientConfigParams, _impl_.single_client_with_old_invalidations_)
        + sizeof(ClientConfigParams::_impl_.single_client_with_old_invalidations_) - PROTOBUF_FIELD_OFFSET(ClientConfigParams, _impl_.tabs_datatype_enabled_)>(
        reinterpret_cast<char*>(&_impl_.tabs_datatype_enabled_), reinterpret_cast<char*>(&other->_impl_.tabs_datatype_enabled_));
}

std::string ClientConfigParams::GetTypeName() const
{
    return "sync_pb.ClientConfigParams";
}

// ===================================================================

class CommitMessage::_Internal {
public:
    using HasBits = decltype(std::declval<CommitMessage>()._impl_._has_bits_);
    static void set_has_cache_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::ClientConfigParams& config_params(const CommitMessage* msg);
    static void set_has_config_params(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_padding(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

const ::sync_pb::ClientConfigParams& CommitMessage::_Internal::config_params(const CommitMessage* msg)
{
    return *msg->_impl_.config_params_;
}
void CommitMessage::clear_entries()
{
    _impl_.entries_.Clear();
}
void CommitMessage::clear_client_contexts()
{
    _impl_.client_contexts_.Clear();
}
CommitMessage::CommitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CommitMessage)
}
CommitMessage::CommitMessage(const CommitMessage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CommitMessage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.entries_) { from._impl_.entries_ }, decltype(_impl_.extensions_activity_) { from._impl_.extensions_activity_ },
        decltype(_impl_.client_contexts_) { from._impl_.client_contexts_ }, decltype(_impl_.cache_guid_) {}, decltype(_impl_.padding_) {},
        decltype(_impl_.config_params_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.cache_guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cache_guid()) {
        _this->_impl_.cache_guid_.Set(from._internal_cache_guid(), _this->GetArenaForAllocation());
    }
    _impl_.padding_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.padding_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_padding()) {
        _this->_impl_.padding_.Set(from._internal_padding(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_config_params()) {
        _this->_impl_.config_params_ = new ::sync_pb::ClientConfigParams(*from._impl_.config_params_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.CommitMessage)
}

inline void CommitMessage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.entries_) { arena },
        decltype(_impl_.extensions_activity_) { arena }, decltype(_impl_.client_contexts_) { arena }, decltype(_impl_.cache_guid_) {},
        decltype(_impl_.padding_) {}, decltype(_impl_.config_params_) { nullptr } };
    _impl_.cache_guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.padding_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.padding_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommitMessage::~CommitMessage()
{
    // @@protoc_insertion_point(destructor:sync_pb.CommitMessage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CommitMessage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.entries_.~RepeatedPtrField();
    _impl_.extensions_activity_.~RepeatedPtrField();
    _impl_.client_contexts_.~RepeatedPtrField();
    _impl_.cache_guid_.Destroy();
    _impl_.padding_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.config_params_;
}

void CommitMessage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CommitMessage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CommitMessage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.entries_.Clear();
    _impl_.extensions_activity_.Clear();
    _impl_.client_contexts_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.cache_guid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.padding_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.config_params_ != nullptr);
            _impl_.config_params_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CommitMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .sync_pb.SyncEntity entries = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string cache_guid = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_cache_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_extensions_activity(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ClientConfigParams config_params = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_config_params(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.DataTypeContext client_contexts = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_client_contexts(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string padding = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_padding();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CommitMessage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CommitMessage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .sync_pb.SyncEntity entries = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
        const auto& repfield = this->_internal_entries(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string cache_guid = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_cache_guid(), target);
    }

    // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_extensions_activity_size()); i < n; i++) {
        const auto& repfield = this->_internal_extensions_activity(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .sync_pb.ClientConfigParams config_params = 4;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::config_params(this), _Internal::config_params(this).GetCachedSize(), target, stream);
    }

    // repeated .sync_pb.DataTypeContext client_contexts = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_client_contexts_size()); i < n; i++) {
        const auto& repfield = this->_internal_client_contexts(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string padding = 6;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_padding(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CommitMessage)
    return target;
}

size_t CommitMessage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CommitMessage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.SyncEntity entries = 1;
    total_size += 1UL * this->_internal_entries_size();
    for (const auto& msg : this->_impl_.entries_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
    total_size += 1UL * this->_internal_extensions_activity_size();
    for (const auto& msg : this->_impl_.extensions_activity_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .sync_pb.DataTypeContext client_contexts = 5;
    total_size += 1UL * this->_internal_client_contexts_size();
    for (const auto& msg : this->_impl_.client_contexts_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string cache_guid = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cache_guid());
        }

        // optional string padding = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_padding());
        }

        // optional .sync_pb.ClientConfigParams config_params = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.config_params_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CommitMessage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CommitMessage*>(&from));
}

void CommitMessage::MergeFrom(const CommitMessage& from)
{
    CommitMessage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CommitMessage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
    _this->_impl_.extensions_activity_.MergeFrom(from._impl_.extensions_activity_);
    _this->_impl_.client_contexts_.MergeFrom(from._impl_.client_contexts_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_cache_guid(from._internal_cache_guid());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_padding(from._internal_padding());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_config_params()->::sync_pb::ClientConfigParams::MergeFrom(from._internal_config_params());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommitMessage::CopyFrom(const CommitMessage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CommitMessage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CommitMessage::IsInitialized() const
{
    return true;
}

void CommitMessage::InternalSwap(CommitMessage* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.entries_.InternalSwap(&other->_impl_.entries_);
    _impl_.extensions_activity_.InternalSwap(&other->_impl_.extensions_activity_);
    _impl_.client_contexts_.InternalSwap(&other->_impl_.client_contexts_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cache_guid_, lhs_arena, &other->_impl_.cache_guid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.padding_, lhs_arena, &other->_impl_.padding_, rhs_arena);
    swap(_impl_.config_params_, other->_impl_.config_params_);
}

std::string CommitMessage::GetTypeName() const
{
    return "sync_pb.CommitMessage";
}

// ===================================================================

class GetUpdatesMessage::_Internal {
public:
    using HasBits = decltype(std::declval<GetUpdatesMessage>()._impl_._has_bits_);
    static const ::sync_pb::GetUpdatesCallerInfo& caller_info(const GetUpdatesMessage* msg);
    static void set_has_caller_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_fetch_folders(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_streaming(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_need_encryption_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_get_updates_origin(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_is_retry(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::sync_pb::GetUpdatesCallerInfo& GetUpdatesMessage::_Internal::caller_info(const GetUpdatesMessage* msg)
{
    return *msg->_impl_.caller_info_;
}
void GetUpdatesMessage::clear_caller_info()
{
    if (_impl_.caller_info_ != nullptr)
        _impl_.caller_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
void GetUpdatesMessage::clear_from_progress_marker()
{
    _impl_.from_progress_marker_.Clear();
}
void GetUpdatesMessage::clear_client_contexts()
{
    _impl_.client_contexts_.Clear();
}
GetUpdatesMessage::GetUpdatesMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.GetUpdatesMessage)
}
GetUpdatesMessage::GetUpdatesMessage(const GetUpdatesMessage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetUpdatesMessage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.from_progress_marker_) { from._impl_.from_progress_marker_ }, decltype(_impl_.client_contexts_) { from._impl_.client_contexts_ },
        decltype(_impl_.caller_info_) { nullptr }, decltype(_impl_.streaming_) {}, decltype(_impl_.need_encryption_key_) {}, decltype(_impl_.is_retry_) {},
        decltype(_impl_.get_updates_origin_) {}, decltype(_impl_.fetch_folders_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_caller_info()) {
        _this->_impl_.caller_info_ = new ::sync_pb::GetUpdatesCallerInfo(*from._impl_.caller_info_);
    }
    ::memcpy(&_impl_.streaming_, &from._impl_.streaming_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fetch_folders_) - reinterpret_cast<char*>(&_impl_.streaming_)) + sizeof(_impl_.fetch_folders_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.GetUpdatesMessage)
}

inline void GetUpdatesMessage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.from_progress_marker_) { arena },
        decltype(_impl_.client_contexts_) { arena }, decltype(_impl_.caller_info_) { nullptr }, decltype(_impl_.streaming_) { false },
        decltype(_impl_.need_encryption_key_) { false }, decltype(_impl_.is_retry_) { false }, decltype(_impl_.get_updates_origin_) { 0 },
        decltype(_impl_.fetch_folders_) { true } };
}

GetUpdatesMessage::~GetUpdatesMessage()
{
    // @@protoc_insertion_point(destructor:sync_pb.GetUpdatesMessage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetUpdatesMessage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.from_progress_marker_.~RepeatedPtrField();
    _impl_.client_contexts_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.caller_info_;
}

void GetUpdatesMessage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetUpdatesMessage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.GetUpdatesMessage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.from_progress_marker_.Clear();
    _impl_.client_contexts_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.caller_info_ != nullptr);
        _impl_.caller_info_->Clear();
    }
    if (cached_has_bits & 0x0000003eu) {
        ::memset(&_impl_.streaming_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.get_updates_origin_) - reinterpret_cast<char*>(&_impl_.streaming_))
                + sizeof(_impl_.get_updates_origin_));
        _impl_.fetch_folders_ = true;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GetUpdatesMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_caller_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool fetch_folders = 3 [default = true];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_fetch_folders(&has_bits);
                _impl_.fetch_folders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_from_progress_marker(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bool streaming = 7 [default = false];
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_streaming(&has_bits);
                _impl_.streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool need_encryption_key = 8 [default = false];
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_need_encryption_key(&has_bits);
                _impl_.need_encryption_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_GetUpdatesOrigin_IsValid(val))) {
                    _internal_set_get_updates_origin(static_cast<::sync_pb::SyncEnums_GetUpdatesOrigin>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional bool is_retry = 10 [default = false];
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_is_retry(&has_bits);
                _impl_.is_retry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.DataTypeContext client_contexts = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_client_contexts(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetUpdatesMessage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.GetUpdatesMessage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::caller_info(this), _Internal::caller_info(this).GetCachedSize(), target, stream);
    }

    // optional bool fetch_folders = 3 [default = true];
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_fetch_folders(), target);
    }

    // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_from_progress_marker_size()); i < n; i++) {
        const auto& repfield = this->_internal_from_progress_marker(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bool streaming = 7 [default = false];
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_streaming(), target);
    }

    // optional bool need_encryption_key = 8 [default = false];
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_need_encryption_key(), target);
    }

    // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(9, this->_internal_get_updates_origin(), target);
    }

    // optional bool is_retry = 10 [default = false];
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_retry(), target);
    }

    // repeated .sync_pb.DataTypeContext client_contexts = 11;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_client_contexts_size()); i < n; i++) {
        const auto& repfield = this->_internal_client_contexts(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.GetUpdatesMessage)
    return target;
}

size_t GetUpdatesMessage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.GetUpdatesMessage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
    total_size += 1UL * this->_internal_from_progress_marker_size();
    for (const auto& msg : this->_impl_.from_progress_marker_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .sync_pb.DataTypeContext client_contexts = 11;
    total_size += 1UL * this->_internal_client_contexts_size();
    for (const auto& msg : this->_impl_.client_contexts_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.caller_info_);
        }

        // optional bool streaming = 7 [default = false];
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool need_encryption_key = 8 [default = false];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }

        // optional bool is_retry = 10 [default = false];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_get_updates_origin());
        }

        // optional bool fetch_folders = 3 [default = true];
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetUpdatesMessage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetUpdatesMessage*>(&from));
}

void GetUpdatesMessage::MergeFrom(const GetUpdatesMessage& from)
{
    GetUpdatesMessage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.GetUpdatesMessage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.from_progress_marker_.MergeFrom(from._impl_.from_progress_marker_);
    _this->_impl_.client_contexts_.MergeFrom(from._impl_.client_contexts_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_caller_info()->::sync_pb::GetUpdatesCallerInfo::MergeFrom(from._internal_caller_info());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.streaming_ = from._impl_.streaming_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.need_encryption_key_ = from._impl_.need_encryption_key_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.is_retry_ = from._impl_.is_retry_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.get_updates_origin_ = from._impl_.get_updates_origin_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.fetch_folders_ = from._impl_.fetch_folders_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetUpdatesMessage::CopyFrom(const GetUpdatesMessage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.GetUpdatesMessage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetUpdatesMessage::IsInitialized() const
{
    return true;
}

void GetUpdatesMessage::InternalSwap(GetUpdatesMessage* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.from_progress_marker_.InternalSwap(&other->_impl_.from_progress_marker_);
    _impl_.client_contexts_.InternalSwap(&other->_impl_.client_contexts_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(GetUpdatesMessage, _impl_.get_updates_origin_)
        + sizeof(GetUpdatesMessage::_impl_.get_updates_origin_) - PROTOBUF_FIELD_OFFSET(GetUpdatesMessage, _impl_.caller_info_)>(
        reinterpret_cast<char*>(&_impl_.caller_info_), reinterpret_cast<char*>(&other->_impl_.caller_info_));
    swap(_impl_.fetch_folders_, other->_impl_.fetch_folders_);
}

std::string GetUpdatesMessage::GetTypeName() const
{
    return "sync_pb.GetUpdatesMessage";
}

// ===================================================================

class ClearServerDataMessage::_Internal {
public:
};

ClearServerDataMessage::ClearServerDataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ClearServerDataMessage)
}
ClearServerDataMessage::ClearServerDataMessage(const ClearServerDataMessage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClearServerDataMessage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.ClearServerDataMessage)
}

inline void ClearServerDataMessage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

ClearServerDataMessage::~ClearServerDataMessage()
{
    // @@protoc_insertion_point(destructor:sync_pb.ClearServerDataMessage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClearServerDataMessage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClearServerDataMessage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClearServerDataMessage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ClearServerDataMessage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* ClearServerDataMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClearServerDataMessage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClearServerDataMessage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClearServerDataMessage)
    return target;
}

size_t ClearServerDataMessage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ClearServerDataMessage)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClearServerDataMessage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClearServerDataMessage*>(&from));
}

void ClearServerDataMessage::MergeFrom(const ClearServerDataMessage& from)
{
    ClearServerDataMessage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClearServerDataMessage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClearServerDataMessage::CopyFrom(const ClearServerDataMessage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClearServerDataMessage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClearServerDataMessage::IsInitialized() const
{
    return true;
}

void ClearServerDataMessage::InternalSwap(ClearServerDataMessage* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ClearServerDataMessage::GetTypeName() const
{
    return "sync_pb.ClearServerDataMessage";
}

// ===================================================================

class ClearServerDataResponse::_Internal {
public:
};

ClearServerDataResponse::ClearServerDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ClearServerDataResponse)
}
ClearServerDataResponse::ClearServerDataResponse(const ClearServerDataResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClearServerDataResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.ClearServerDataResponse)
}

inline void ClearServerDataResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

ClearServerDataResponse::~ClearServerDataResponse()
{
    // @@protoc_insertion_point(destructor:sync_pb.ClearServerDataResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClearServerDataResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClearServerDataResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClearServerDataResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ClearServerDataResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* ClearServerDataResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClearServerDataResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClearServerDataResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClearServerDataResponse)
    return target;
}

size_t ClearServerDataResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ClearServerDataResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClearServerDataResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClearServerDataResponse*>(&from));
}

void ClearServerDataResponse::MergeFrom(const ClearServerDataResponse& from)
{
    ClearServerDataResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClearServerDataResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClearServerDataResponse::CopyFrom(const ClearServerDataResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClearServerDataResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClearServerDataResponse::IsInitialized() const
{
    return true;
}

void ClearServerDataResponse::InternalSwap(ClearServerDataResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ClearServerDataResponse::GetTypeName() const
{
    return "sync_pb.ClearServerDataResponse";
}

// ===================================================================

class ChipBag::_Internal {
public:
    using HasBits = decltype(std::declval<ChipBag>()._impl_._has_bits_);
    static void set_has_server_chips(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ChipBag::ChipBag(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ChipBag)
}
ChipBag::ChipBag(const ChipBag& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ChipBag* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.server_chips_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.server_chips_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_chips_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_server_chips()) {
        _this->_impl_.server_chips_.Set(from._internal_server_chips(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.ChipBag)
}

inline void ChipBag::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.server_chips_) {} };
    _impl_.server_chips_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.server_chips_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChipBag::~ChipBag()
{
    // @@protoc_insertion_point(destructor:sync_pb.ChipBag)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ChipBag::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.server_chips_.Destroy();
}

void ChipBag::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ChipBag::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ChipBag)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.server_chips_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ChipBag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes server_chips = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_server_chips();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ChipBag::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ChipBag)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes server_chips = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_server_chips(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ChipBag)
    return target;
}

size_t ChipBag::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ChipBag)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bytes server_chips = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_server_chips());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ChipBag::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ChipBag*>(&from));
}

void ChipBag::MergeFrom(const ChipBag& from)
{
    ChipBag* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ChipBag)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_server_chips()) {
        _this->_internal_set_server_chips(from._internal_server_chips());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChipBag::CopyFrom(const ChipBag& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ChipBag)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ChipBag::IsInitialized() const
{
    return true;
}

void ChipBag::InternalSwap(ChipBag* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.server_chips_, lhs_arena, &other->_impl_.server_chips_, rhs_arena);
}

std::string ChipBag::GetTypeName() const
{
    return "sync_pb.ChipBag";
}

// ===================================================================

class ClientStatus::_Internal {
public:
    using HasBits = decltype(std::declval<ClientStatus>()._impl_._has_bits_);
    static void set_has_hierarchy_conflict_detected(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_is_sync_feature_enabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

ClientStatus::ClientStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ClientStatus)
}
ClientStatus::ClientStatus(const ClientStatus& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientStatus* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.hierarchy_conflict_detected_) {}, decltype(_impl_.is_sync_feature_enabled_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.hierarchy_conflict_detected_, &from._impl_.hierarchy_conflict_detected_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_sync_feature_enabled_) - reinterpret_cast<char*>(&_impl_.hierarchy_conflict_detected_))
            + sizeof(_impl_.is_sync_feature_enabled_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.ClientStatus)
}

inline void ClientStatus::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.hierarchy_conflict_detected_) { false },
        decltype(_impl_.is_sync_feature_enabled_) { false } };
}

ClientStatus::~ClientStatus()
{
    // @@protoc_insertion_point(destructor:sync_pb.ClientStatus)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientStatus::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientStatus::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientStatus::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ClientStatus)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    ::memset(&_impl_.hierarchy_conflict_detected_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_sync_feature_enabled_) - reinterpret_cast<char*>(&_impl_.hierarchy_conflict_detected_))
            + sizeof(_impl_.is_sync_feature_enabled_));
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool hierarchy_conflict_detected = 1 [deprecated = true];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_hierarchy_conflict_detected(&has_bits);
                _impl_.hierarchy_conflict_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_sync_feature_enabled = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_sync_feature_enabled(&has_bits);
                _impl_.is_sync_feature_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientStatus::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientStatus)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool hierarchy_conflict_detected = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_hierarchy_conflict_detected(), target);
    }

    // optional bool is_sync_feature_enabled = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_sync_feature_enabled(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientStatus)
    return target;
}

size_t ClientStatus::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientStatus)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional bool hierarchy_conflict_detected = 1 [deprecated = true];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 1;
        }

        // optional bool is_sync_feature_enabled = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientStatus::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientStatus*>(&from));
}

void ClientStatus::MergeFrom(const ClientStatus& from)
{
    ClientStatus* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientStatus)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.hierarchy_conflict_detected_ = from._impl_.hierarchy_conflict_detected_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.is_sync_feature_enabled_ = from._impl_.is_sync_feature_enabled_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientStatus::CopyFrom(const ClientStatus& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientStatus)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientStatus::IsInitialized() const
{
    return true;
}

void ClientStatus::InternalSwap(ClientStatus* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientStatus, _impl_.is_sync_feature_enabled_)
        + sizeof(ClientStatus::_impl_.is_sync_feature_enabled_) - PROTOBUF_FIELD_OFFSET(ClientStatus, _impl_.hierarchy_conflict_detected_)>(
        reinterpret_cast<char*>(&_impl_.hierarchy_conflict_detected_), reinterpret_cast<char*>(&other->_impl_.hierarchy_conflict_detected_));
}

std::string ClientStatus::GetTypeName() const
{
    return "sync_pb.ClientStatus";
}

// ===================================================================

class ClientToServerMessage::_Internal {
public:
    using HasBits = decltype(std::declval<ClientToServerMessage>()._impl_._has_bits_);
    static void set_has_share(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_protocol_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_message_contents(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static const ::sync_pb::CommitMessage& commit(const ClientToServerMessage* msg);
    static void set_has_commit(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::sync_pb::GetUpdatesMessage& get_updates(const ClientToServerMessage* msg);
    static void set_has_get_updates(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_store_birthday(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::DebugInfo& debug_info(const ClientToServerMessage* msg);
    static void set_has_debug_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::sync_pb::ChipBag& bag_of_chips(const ClientToServerMessage* msg);
    static void set_has_bag_of_chips(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_api_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::sync_pb::ClientStatus& client_status(const ClientToServerMessage* msg);
    static void set_has_client_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_invalidator_client_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::sync_pb::ClearServerDataMessage& clear_server_data(const ClientToServerMessage* msg);
    static void set_has_clear_server_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000801) ^ 0x00000801) != 0;
    }
};

const ::sync_pb::CommitMessage& ClientToServerMessage::_Internal::commit(const ClientToServerMessage* msg)
{
    return *msg->_impl_.commit_;
}
const ::sync_pb::GetUpdatesMessage& ClientToServerMessage::_Internal::get_updates(const ClientToServerMessage* msg)
{
    return *msg->_impl_.get_updates_;
}
const ::sync_pb::DebugInfo& ClientToServerMessage::_Internal::debug_info(const ClientToServerMessage* msg)
{
    return *msg->_impl_.debug_info_;
}
const ::sync_pb::ChipBag& ClientToServerMessage::_Internal::bag_of_chips(const ClientToServerMessage* msg)
{
    return *msg->_impl_.bag_of_chips_;
}
const ::sync_pb::ClientStatus& ClientToServerMessage::_Internal::client_status(const ClientToServerMessage* msg)
{
    return *msg->_impl_.client_status_;
}
const ::sync_pb::ClearServerDataMessage& ClientToServerMessage::_Internal::clear_server_data(const ClientToServerMessage* msg)
{
    return *msg->_impl_.clear_server_data_;
}
void ClientToServerMessage::clear_debug_info()
{
    if (_impl_.debug_info_ != nullptr)
        _impl_.debug_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
ClientToServerMessage::ClientToServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ClientToServerMessage)
}
ClientToServerMessage::ClientToServerMessage(const ClientToServerMessage& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientToServerMessage* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.share_) {},
        decltype(_impl_.store_birthday_) {}, decltype(_impl_.api_key_) {}, decltype(_impl_.invalidator_client_id_) {}, decltype(_impl_.commit_) { nullptr },
        decltype(_impl_.get_updates_) { nullptr }, decltype(_impl_.debug_info_) { nullptr }, decltype(_impl_.bag_of_chips_) { nullptr },
        decltype(_impl_.client_status_) { nullptr }, decltype(_impl_.clear_server_data_) { nullptr }, decltype(_impl_.protocol_version_) {},
        decltype(_impl_.message_contents_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.share_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_share()) {
        _this->_impl_.share_.Set(from._internal_share(), _this->GetArenaForAllocation());
    }
    _impl_.store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_store_birthday()) {
        _this->_impl_.store_birthday_.Set(from._internal_store_birthday(), _this->GetArenaForAllocation());
    }
    _impl_.api_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.api_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_api_key()) {
        _this->_impl_.api_key_.Set(from._internal_api_key(), _this->GetArenaForAllocation());
    }
    _impl_.invalidator_client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidator_client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_invalidator_client_id()) {
        _this->_impl_.invalidator_client_id_.Set(from._internal_invalidator_client_id(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_commit()) {
        _this->_impl_.commit_ = new ::sync_pb::CommitMessage(*from._impl_.commit_);
    }
    if (from._internal_has_get_updates()) {
        _this->_impl_.get_updates_ = new ::sync_pb::GetUpdatesMessage(*from._impl_.get_updates_);
    }
    if (from._internal_has_debug_info()) {
        _this->_impl_.debug_info_ = new ::sync_pb::DebugInfo(*from._impl_.debug_info_);
    }
    if (from._internal_has_bag_of_chips()) {
        _this->_impl_.bag_of_chips_ = new ::sync_pb::ChipBag(*from._impl_.bag_of_chips_);
    }
    if (from._internal_has_client_status()) {
        _this->_impl_.client_status_ = new ::sync_pb::ClientStatus(*from._impl_.client_status_);
    }
    if (from._internal_has_clear_server_data()) {
        _this->_impl_.clear_server_data_ = new ::sync_pb::ClearServerDataMessage(*from._impl_.clear_server_data_);
    }
    ::memcpy(&_impl_.protocol_version_, &from._impl_.protocol_version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.message_contents_) - reinterpret_cast<char*>(&_impl_.protocol_version_))
            + sizeof(_impl_.message_contents_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.ClientToServerMessage)
}

inline void ClientToServerMessage::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.share_) {},
        decltype(_impl_.store_birthday_) {}, decltype(_impl_.api_key_) {}, decltype(_impl_.invalidator_client_id_) {}, decltype(_impl_.commit_) { nullptr },
        decltype(_impl_.get_updates_) { nullptr }, decltype(_impl_.debug_info_) { nullptr }, decltype(_impl_.bag_of_chips_) { nullptr },
        decltype(_impl_.client_status_) { nullptr }, decltype(_impl_.clear_server_data_) { nullptr }, decltype(_impl_.protocol_version_) { 99 },
        decltype(_impl_.message_contents_) { 1 } };
    _impl_.share_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.share_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.api_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.api_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidator_client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.invalidator_client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientToServerMessage::~ClientToServerMessage()
{
    // @@protoc_insertion_point(destructor:sync_pb.ClientToServerMessage)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientToServerMessage::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.share_.Destroy();
    _impl_.store_birthday_.Destroy();
    _impl_.api_key_.Destroy();
    _impl_.invalidator_client_id_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.commit_;
    if (this != internal_default_instance())
        delete _impl_.get_updates_;
    if (this != internal_default_instance())
        delete _impl_.debug_info_;
    if (this != internal_default_instance())
        delete _impl_.bag_of_chips_;
    if (this != internal_default_instance())
        delete _impl_.client_status_;
    if (this != internal_default_instance())
        delete _impl_.clear_server_data_;
}

void ClientToServerMessage::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientToServerMessage::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ClientToServerMessage)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.share_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.store_birthday_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.api_key_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.invalidator_client_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.commit_ != nullptr);
            _impl_.commit_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.get_updates_ != nullptr);
            _impl_.get_updates_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.debug_info_ != nullptr);
            _impl_.debug_info_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.bag_of_chips_ != nullptr);
            _impl_.bag_of_chips_->Clear();
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            GOOGLE_DCHECK(_impl_.client_status_ != nullptr);
            _impl_.client_status_->Clear();
        }
        if (cached_has_bits & 0x00000200u) {
            GOOGLE_DCHECK(_impl_.clear_server_data_ != nullptr);
            _impl_.clear_server_data_->Clear();
        }
        _impl_.protocol_version_ = 99;
        _impl_.message_contents_ = 1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientToServerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required string share = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_share();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 protocol_version = 2 [default = 99];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_protocol_version(&has_bits);
                _impl_.protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::ClientToServerMessage_Contents_IsValid(val))) {
                    _internal_set_message_contents(static_cast<::sync_pb::ClientToServerMessage_Contents>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.CommitMessage commit = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_commit(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.GetUpdatesMessage get_updates = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_get_updates(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string store_birthday = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_store_birthday();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.DebugInfo debug_info = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_debug_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ChipBag bag_of_chips = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_bag_of_chips(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string api_key = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_api_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ClientStatus client_status = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_status(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string invalidator_client_id = 14 [deprecated = true];
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_invalidator_client_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                ptr = ctx->ParseMessage(_internal_mutable_clear_server_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientToServerMessage::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientToServerMessage)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required string share = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_share(), target);
    }

    // optional int32 protocol_version = 2 [default = 99];
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_protocol_version(), target);
    }

    // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_message_contents(), target);
    }

    // optional .sync_pb.CommitMessage commit = 4;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::commit(this), _Internal::commit(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.GetUpdatesMessage get_updates = 5;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::get_updates(this), _Internal::get_updates(this).GetCachedSize(), target, stream);
    }

    // optional string store_birthday = 7;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_store_birthday(), target);
    }

    // optional .sync_pb.DebugInfo debug_info = 10;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::debug_info(this), _Internal::debug_info(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.ChipBag bag_of_chips = 11;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::bag_of_chips(this), _Internal::bag_of_chips(this).GetCachedSize(), target, stream);
    }

    // optional string api_key = 12;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(12, this->_internal_api_key(), target);
    }

    // optional .sync_pb.ClientStatus client_status = 13;
    if (cached_has_bits & 0x00000100u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::client_status(this), _Internal::client_status(this).GetCachedSize(), target, stream);
    }

    // optional string invalidator_client_id = 14 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(14, this->_internal_invalidator_client_id(), target);
    }

    // optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
    if (cached_has_bits & 0x00000200u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            15, _Internal::clear_server_data(this), _Internal::clear_server_data(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientToServerMessage)
    return target;
}

size_t ClientToServerMessage::RequiredFieldsByteSizeFallback() const
{
    // @@protoc_insertion_point(required_fields_byte_size_fallback_start:sync_pb.ClientToServerMessage)
    size_t total_size = 0;

    if (_internal_has_share()) {
        // required string share = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_share());
    }

    if (_internal_has_message_contents()) {
        // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_message_contents());
    }

    return total_size;
}
size_t ClientToServerMessage::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientToServerMessage)
    size_t total_size = 0;

    if (((_impl_._has_bits_[0] & 0x00000801) ^ 0x00000801) == 0) { // All required fields are present.
        // required string share = 1;
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_share());

        // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_message_contents());

    } else {
        total_size += RequiredFieldsByteSizeFallback();
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000feu) {
        // optional string store_birthday = 7;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_store_birthday());
        }

        // optional string api_key = 12;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_api_key());
        }

        // optional string invalidator_client_id = 14 [deprecated = true];
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_invalidator_client_id());
        }

        // optional .sync_pb.CommitMessage commit = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.commit_);
        }

        // optional .sync_pb.GetUpdatesMessage get_updates = 5;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.get_updates_);
        }

        // optional .sync_pb.DebugInfo debug_info = 10;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.debug_info_);
        }

        // optional .sync_pb.ChipBag bag_of_chips = 11;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.bag_of_chips_);
        }
    }
    if (cached_has_bits & 0x00000700u) {
        // optional .sync_pb.ClientStatus client_status = 13;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_status_);
        }

        // optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.clear_server_data_);
        }

        // optional int32 protocol_version = 2 [default = 99];
        if (cached_has_bits & 0x00000400u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_protocol_version());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientToServerMessage::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientToServerMessage*>(&from));
}

void ClientToServerMessage::MergeFrom(const ClientToServerMessage& from)
{
    ClientToServerMessage* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientToServerMessage)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_share(from._internal_share());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_store_birthday(from._internal_store_birthday());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_api_key(from._internal_api_key());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_invalidator_client_id(from._internal_invalidator_client_id());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_commit()->::sync_pb::CommitMessage::MergeFrom(from._internal_commit());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_get_updates()->::sync_pb::GetUpdatesMessage::MergeFrom(from._internal_get_updates());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_debug_info()->::sync_pb::DebugInfo::MergeFrom(from._internal_debug_info());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_bag_of_chips()->::sync_pb::ChipBag::MergeFrom(from._internal_bag_of_chips());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_mutable_client_status()->::sync_pb::ClientStatus::MergeFrom(from._internal_client_status());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_mutable_clear_server_data()->::sync_pb::ClearServerDataMessage::MergeFrom(from._internal_clear_server_data());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.protocol_version_ = from._impl_.protocol_version_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.message_contents_ = from._impl_.message_contents_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientToServerMessage::CopyFrom(const ClientToServerMessage& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientToServerMessage)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientToServerMessage::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void ClientToServerMessage::InternalSwap(ClientToServerMessage* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.share_, lhs_arena, &other->_impl_.share_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.store_birthday_, lhs_arena, &other->_impl_.store_birthday_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.api_key_, lhs_arena, &other->_impl_.api_key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.invalidator_client_id_, lhs_arena, &other->_impl_.invalidator_client_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientToServerMessage, _impl_.clear_server_data_)
        + sizeof(ClientToServerMessage::_impl_.clear_server_data_) - PROTOBUF_FIELD_OFFSET(ClientToServerMessage, _impl_.commit_)>(
        reinterpret_cast<char*>(&_impl_.commit_), reinterpret_cast<char*>(&other->_impl_.commit_));
    swap(_impl_.protocol_version_, other->_impl_.protocol_version_);
    swap(_impl_.message_contents_, other->_impl_.message_contents_);
}

std::string ClientToServerMessage::GetTypeName() const
{
    return "sync_pb.ClientToServerMessage";
}

// ===================================================================

class CommitResponse_EntryResponse_DatatypeSpecificError::_Internal {
public:
    static const ::sync_pb::SharingMessageCommitError& sharing_message_error(const CommitResponse_EntryResponse_DatatypeSpecificError* msg);
    static const ::sync_pb::OutgoingPasswordSharingInvitationCommitError& outgoing_password_sharing_invitation_error(
        const CommitResponse_EntryResponse_DatatypeSpecificError* msg);
};

const ::sync_pb::SharingMessageCommitError& CommitResponse_EntryResponse_DatatypeSpecificError::_Internal::sharing_message_error(
    const CommitResponse_EntryResponse_DatatypeSpecificError* msg)
{
    return *msg->_impl_.datatype_error_.sharing_message_error_;
}
const ::sync_pb::OutgoingPasswordSharingInvitationCommitError&
CommitResponse_EntryResponse_DatatypeSpecificError::_Internal::outgoing_password_sharing_invitation_error(
    const CommitResponse_EntryResponse_DatatypeSpecificError* msg)
{
    return *msg->_impl_.datatype_error_.outgoing_password_sharing_invitation_error_;
}
void CommitResponse_EntryResponse_DatatypeSpecificError::set_allocated_sharing_message_error(::sync_pb::SharingMessageCommitError* sharing_message_error)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_datatype_error();
    if (sharing_message_error) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sharing_message_error));
        if (message_arena != submessage_arena) {
            sharing_message_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, sharing_message_error, submessage_arena);
        }
        set_has_sharing_message_error();
        _impl_.datatype_error_.sharing_message_error_ = sharing_message_error;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
}
void CommitResponse_EntryResponse_DatatypeSpecificError::clear_sharing_message_error()
{
    if (_internal_has_sharing_message_error()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.datatype_error_.sharing_message_error_;
        }
        clear_has_datatype_error();
    }
}
void CommitResponse_EntryResponse_DatatypeSpecificError::set_allocated_outgoing_password_sharing_invitation_error(
    ::sync_pb::OutgoingPasswordSharingInvitationCommitError* outgoing_password_sharing_invitation_error)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_datatype_error();
    if (outgoing_password_sharing_invitation_error) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
            reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(outgoing_password_sharing_invitation_error));
        if (message_arena != submessage_arena) {
            outgoing_password_sharing_invitation_error
                = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, outgoing_password_sharing_invitation_error, submessage_arena);
        }
        set_has_outgoing_password_sharing_invitation_error();
        _impl_.datatype_error_.outgoing_password_sharing_invitation_error_ = outgoing_password_sharing_invitation_error;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.outgoing_password_sharing_invitation_error)
}
void CommitResponse_EntryResponse_DatatypeSpecificError::clear_outgoing_password_sharing_invitation_error()
{
    if (_internal_has_outgoing_password_sharing_invitation_error()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.datatype_error_.outgoing_password_sharing_invitation_error_;
        }
        clear_has_datatype_error();
    }
}
CommitResponse_EntryResponse_DatatypeSpecificError::CommitResponse_EntryResponse_DatatypeSpecificError(
    ::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
}
CommitResponse_EntryResponse_DatatypeSpecificError::CommitResponse_EntryResponse_DatatypeSpecificError(
    const CommitResponse_EntryResponse_DatatypeSpecificError& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CommitResponse_EntryResponse_DatatypeSpecificError* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.datatype_error_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_datatype_error();
    switch (from.datatype_error_case()) {
    case kSharingMessageError: {
        _this->_internal_mutable_sharing_message_error()->::sync_pb::SharingMessageCommitError::MergeFrom(from._internal_sharing_message_error());
        break;
    }
    case kOutgoingPasswordSharingInvitationError: {
        _this->_internal_mutable_outgoing_password_sharing_invitation_error()->::sync_pb::OutgoingPasswordSharingInvitationCommitError::MergeFrom(
            from._internal_outgoing_password_sharing_invitation_error());
        break;
    }
    case DATATYPE_ERROR_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
}

inline void CommitResponse_EntryResponse_DatatypeSpecificError::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.datatype_error_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_datatype_error();
}

CommitResponse_EntryResponse_DatatypeSpecificError::~CommitResponse_EntryResponse_DatatypeSpecificError()
{
    // @@protoc_insertion_point(destructor:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CommitResponse_EntryResponse_DatatypeSpecificError::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_datatype_error()) {
        clear_datatype_error();
    }
}

void CommitResponse_EntryResponse_DatatypeSpecificError::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CommitResponse_EntryResponse_DatatypeSpecificError::clear_datatype_error()
{
    // @@protoc_insertion_point(one_of_clear_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
    switch (datatype_error_case()) {
    case kSharingMessageError: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.datatype_error_.sharing_message_error_;
        }
        break;
    }
    case kOutgoingPasswordSharingInvitationError: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.datatype_error_.outgoing_password_sharing_invitation_error_;
        }
        break;
    }
    case DATATYPE_ERROR_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = DATATYPE_ERROR_NOT_SET;
}

void CommitResponse_EntryResponse_DatatypeSpecificError::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_datatype_error();
    _internal_metadata_.Clear<std::string>();
}

const char* CommitResponse_EntryResponse_DatatypeSpecificError::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .sync_pb.SharingMessageCommitError sharing_message_error = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_sharing_message_error(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.OutgoingPasswordSharingInvitationCommitError outgoing_password_sharing_invitation_error = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_outgoing_password_sharing_invitation_error(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CommitResponse_EntryResponse_DatatypeSpecificError::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (datatype_error_case()) {
    case kSharingMessageError: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::sharing_message_error(this), _Internal::sharing_message_error(this).GetCachedSize(), target, stream);
        break;
    }
    case kOutgoingPasswordSharingInvitationError: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, _Internal::outgoing_password_sharing_invitation_error(this),
            _Internal::outgoing_password_sharing_invitation_error(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
    return target;
}

size_t CommitResponse_EntryResponse_DatatypeSpecificError::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (datatype_error_case()) {
    // .sync_pb.SharingMessageCommitError sharing_message_error = 1;
    case kSharingMessageError: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.datatype_error_.sharing_message_error_);
        break;
    }
    // .sync_pb.OutgoingPasswordSharingInvitationCommitError outgoing_password_sharing_invitation_error = 2;
    case kOutgoingPasswordSharingInvitationError: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.datatype_error_.outgoing_password_sharing_invitation_error_);
        break;
    }
    case DATATYPE_ERROR_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CommitResponse_EntryResponse_DatatypeSpecificError::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CommitResponse_EntryResponse_DatatypeSpecificError*>(&from));
}

void CommitResponse_EntryResponse_DatatypeSpecificError::MergeFrom(const CommitResponse_EntryResponse_DatatypeSpecificError& from)
{
    CommitResponse_EntryResponse_DatatypeSpecificError* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.datatype_error_case()) {
    case kSharingMessageError: {
        _this->_internal_mutable_sharing_message_error()->::sync_pb::SharingMessageCommitError::MergeFrom(from._internal_sharing_message_error());
        break;
    }
    case kOutgoingPasswordSharingInvitationError: {
        _this->_internal_mutable_outgoing_password_sharing_invitation_error()->::sync_pb::OutgoingPasswordSharingInvitationCommitError::MergeFrom(
            from._internal_outgoing_password_sharing_invitation_error());
        break;
    }
    case DATATYPE_ERROR_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommitResponse_EntryResponse_DatatypeSpecificError::CopyFrom(const CommitResponse_EntryResponse_DatatypeSpecificError& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CommitResponse_EntryResponse_DatatypeSpecificError::IsInitialized() const
{
    return true;
}

void CommitResponse_EntryResponse_DatatypeSpecificError::InternalSwap(CommitResponse_EntryResponse_DatatypeSpecificError* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.datatype_error_, other->_impl_.datatype_error_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string CommitResponse_EntryResponse_DatatypeSpecificError::GetTypeName() const
{
    return "sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError";
}

// ===================================================================

class CommitResponse_EntryResponse::_Internal {
public:
    using HasBits = decltype(std::declval<CommitResponse_EntryResponse>()._impl_._has_bits_);
    static void set_has_response_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_id_string(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_version(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_error_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_mtime(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& datatype_specific_error(const CommitResponse_EntryResponse* msg);
    static void set_has_datatype_specific_error(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static bool MissingRequiredFields(const HasBits& has_bits)
    {
        return ((has_bits[0] & 0x00000020) ^ 0x00000020) != 0;
    }
};

const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& CommitResponse_EntryResponse::_Internal::datatype_specific_error(
    const CommitResponse_EntryResponse* msg)
{
    return *msg->_impl_.datatype_specific_error_;
}
CommitResponse_EntryResponse::CommitResponse_EntryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CommitResponse.EntryResponse)
}
CommitResponse_EntryResponse::CommitResponse_EntryResponse(const CommitResponse_EntryResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CommitResponse_EntryResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_string_) {},
        decltype(_impl_.error_message_) {}, decltype(_impl_.datatype_specific_error_) { nullptr }, decltype(_impl_.version_) {}, decltype(_impl_.mtime_) {},
        decltype(_impl_.response_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_string_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_string_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id_string()) {
        _this->_impl_.id_string_.Set(from._internal_id_string(), _this->GetArenaForAllocation());
    }
    _impl_.error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_error_message()) {
        _this->_impl_.error_message_.Set(from._internal_error_message(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_datatype_specific_error()) {
        _this->_impl_.datatype_specific_error_ = new ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError(*from._impl_.datatype_specific_error_);
    }
    ::memcpy(&_impl_.version_, &from._impl_.version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.response_type_) - reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.response_type_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.CommitResponse.EntryResponse)
}

inline void CommitResponse_EntryResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_string_) {},
        decltype(_impl_.error_message_) {}, decltype(_impl_.datatype_specific_error_) { nullptr }, decltype(_impl_.version_) { int64_t { 0 } },
        decltype(_impl_.mtime_) { int64_t { 0 } }, decltype(_impl_.response_type_) { 1 } };
    _impl_.id_string_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_string_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CommitResponse_EntryResponse::~CommitResponse_EntryResponse()
{
    // @@protoc_insertion_point(destructor:sync_pb.CommitResponse.EntryResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CommitResponse_EntryResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.id_string_.Destroy();
    _impl_.error_message_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.datatype_specific_error_;
}

void CommitResponse_EntryResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CommitResponse_EntryResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CommitResponse.EntryResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.id_string_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.error_message_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.datatype_specific_error_ != nullptr);
            _impl_.datatype_specific_error_->Clear();
        }
    }
    if (cached_has_bits & 0x00000038u) {
        ::memset(&_impl_.version_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.mtime_) - reinterpret_cast<char*>(&_impl_.version_)) + sizeof(_impl_.mtime_));
        _impl_.response_type_ = 1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CommitResponse_EntryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // required .sync_pb.CommitResponse.ResponseType response_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::CommitResponse_ResponseType_IsValid(val))) {
                    _internal_set_response_type(static_cast<::sync_pb::CommitResponse_ResponseType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string id_string = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_id_string();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 version = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_version(&has_bits);
                _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string error_message = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_error_message();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 mtime = 10 [deprecated = true];
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_mtime(&has_bits);
                _impl_.mtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_datatype_specific_error(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CommitResponse_EntryResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CommitResponse.EntryResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // required .sync_pb.CommitResponse.ResponseType response_type = 2;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_response_type(), target);
    }

    // optional string id_string = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_id_string(), target);
    }

    // optional int64 version = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_version(), target);
    }

    // optional string error_message = 9;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_error_message(), target);
    }

    // optional int64 mtime = 10 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_mtime(), target);
    }

    // optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::datatype_specific_error(this), _Internal::datatype_specific_error(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CommitResponse.EntryResponse)
    return target;
}

size_t CommitResponse_EntryResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CommitResponse.EntryResponse)
    size_t total_size = 0;

    // required .sync_pb.CommitResponse.ResponseType response_type = 2;
    if (_internal_has_response_type()) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_response_type());
    }
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string id_string = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id_string());
        }

        // optional string error_message = 9;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_error_message());
        }

        // optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.datatype_specific_error_);
        }

        // optional int64 version = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version());
        }

        // optional int64 mtime = 10 [deprecated = true];
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_mtime());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CommitResponse_EntryResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CommitResponse_EntryResponse*>(&from));
}

void CommitResponse_EntryResponse::MergeFrom(const CommitResponse_EntryResponse& from)
{
    CommitResponse_EntryResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CommitResponse.EntryResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_id_string(from._internal_id_string());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_error_message(from._internal_error_message());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_datatype_specific_error()->::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError::MergeFrom(
                from._internal_datatype_specific_error());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.version_ = from._impl_.version_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.mtime_ = from._impl_.mtime_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.response_type_ = from._impl_.response_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommitResponse_EntryResponse::CopyFrom(const CommitResponse_EntryResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CommitResponse.EntryResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CommitResponse_EntryResponse::IsInitialized() const
{
    if (_Internal::MissingRequiredFields(_impl_._has_bits_))
        return false;
    return true;
}

void CommitResponse_EntryResponse::InternalSwap(CommitResponse_EntryResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_string_, lhs_arena, &other->_impl_.id_string_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.error_message_, lhs_arena, &other->_impl_.error_message_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CommitResponse_EntryResponse, _impl_.mtime_)
        + sizeof(CommitResponse_EntryResponse::_impl_.mtime_) - PROTOBUF_FIELD_OFFSET(CommitResponse_EntryResponse, _impl_.datatype_specific_error_)>(
        reinterpret_cast<char*>(&_impl_.datatype_specific_error_), reinterpret_cast<char*>(&other->_impl_.datatype_specific_error_));
    swap(_impl_.response_type_, other->_impl_.response_type_);
}

std::string CommitResponse_EntryResponse::GetTypeName() const
{
    return "sync_pb.CommitResponse.EntryResponse";
}

// ===================================================================

class CommitResponse::_Internal {
public:
};

CommitResponse::CommitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CommitResponse)
}
CommitResponse::CommitResponse(const CommitResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CommitResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.entryresponse_) { from._impl_.entryresponse_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.CommitResponse)
}

inline void CommitResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.entryresponse_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

CommitResponse::~CommitResponse()
{
    // @@protoc_insertion_point(destructor:sync_pb.CommitResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CommitResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.entryresponse_.~RepeatedPtrField();
}

void CommitResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CommitResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CommitResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.entryresponse_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CommitResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated group EntryResponse = 1 { ... };
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 11)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseGroup(_internal_add_entryresponse(), ptr, 11);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<11>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CommitResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CommitResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated group EntryResponse = 1 { ... };
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_entryresponse_size()); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteGroup(1, this->_internal_entryresponse(i), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CommitResponse)
    return target;
}

size_t CommitResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CommitResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated group EntryResponse = 1 { ... };
    total_size += 2UL * this->_internal_entryresponse_size();
    for (const auto& msg : this->_impl_.entryresponse_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GroupSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CommitResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CommitResponse*>(&from));
}

void CommitResponse::MergeFrom(const CommitResponse& from)
{
    CommitResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CommitResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.entryresponse_.MergeFrom(from._impl_.entryresponse_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommitResponse::CopyFrom(const CommitResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CommitResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CommitResponse::IsInitialized() const
{
    if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.entryresponse_))
        return false;
    return true;
}

void CommitResponse::InternalSwap(CommitResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.entryresponse_.InternalSwap(&other->_impl_.entryresponse_);
}

std::string CommitResponse::GetTypeName() const
{
    return "sync_pb.CommitResponse";
}

// ===================================================================

class GetUpdatesResponse::_Internal {
public:
    using HasBits = decltype(std::declval<GetUpdatesResponse>()._impl_._has_bits_);
    static void set_has_changes_remaining(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

void GetUpdatesResponse::clear_entries()
{
    _impl_.entries_.Clear();
}
void GetUpdatesResponse::clear_new_progress_marker()
{
    _impl_.new_progress_marker_.Clear();
}
void GetUpdatesResponse::clear_context_mutations()
{
    _impl_.context_mutations_.Clear();
}
GetUpdatesResponse::GetUpdatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.GetUpdatesResponse)
}
GetUpdatesResponse::GetUpdatesResponse(const GetUpdatesResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetUpdatesResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.entries_) { from._impl_.entries_ }, decltype(_impl_.new_progress_marker_) { from._impl_.new_progress_marker_ },
        decltype(_impl_.encryption_keys_) { from._impl_.encryption_keys_ }, decltype(_impl_.context_mutations_) { from._impl_.context_mutations_ },
        decltype(_impl_.changes_remaining_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.changes_remaining_ = from._impl_.changes_remaining_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.GetUpdatesResponse)
}

inline void GetUpdatesResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.entries_) { arena },
        decltype(_impl_.new_progress_marker_) { arena }, decltype(_impl_.encryption_keys_) { arena }, decltype(_impl_.context_mutations_) { arena },
        decltype(_impl_.changes_remaining_) { int64_t { 0 } } };
}

GetUpdatesResponse::~GetUpdatesResponse()
{
    // @@protoc_insertion_point(destructor:sync_pb.GetUpdatesResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetUpdatesResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.entries_.~RepeatedPtrField();
    _impl_.new_progress_marker_.~RepeatedPtrField();
    _impl_.encryption_keys_.~RepeatedPtrField();
    _impl_.context_mutations_.~RepeatedPtrField();
}

void GetUpdatesResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetUpdatesResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.GetUpdatesResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.entries_.Clear();
    _impl_.new_progress_marker_.Clear();
    _impl_.encryption_keys_.Clear();
    _impl_.context_mutations_.Clear();
    _impl_.changes_remaining_ = int64_t { 0 };
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* GetUpdatesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .sync_pb.SyncEntity entries = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int64 changes_remaining = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_changes_remaining(&has_bits);
                _impl_.changes_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_new_progress_marker(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated bytes encryption_keys = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_encryption_keys();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.DataTypeContext context_mutations = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_context_mutations(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetUpdatesResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.GetUpdatesResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .sync_pb.SyncEntity entries = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
        const auto& repfield = this->_internal_entries(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 changes_remaining = 4;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_changes_remaining(), target);
    }

    // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_new_progress_marker_size()); i < n; i++) {
        const auto& repfield = this->_internal_new_progress_marker(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated bytes encryption_keys = 6;
    for (int i = 0, n = this->_internal_encryption_keys_size(); i < n; i++) {
        const auto& s = this->_internal_encryption_keys(i);
        target = stream->WriteBytes(6, s, target);
    }

    // repeated .sync_pb.DataTypeContext context_mutations = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_context_mutations_size()); i < n; i++) {
        const auto& repfield = this->_internal_context_mutations(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.GetUpdatesResponse)
    return target;
}

size_t GetUpdatesResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.GetUpdatesResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.SyncEntity entries = 1;
    total_size += 1UL * this->_internal_entries_size();
    for (const auto& msg : this->_impl_.entries_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
    total_size += 1UL * this->_internal_new_progress_marker_size();
    for (const auto& msg : this->_impl_.new_progress_marker_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated bytes encryption_keys = 6;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.encryption_keys_.size());
    for (int i = 0, n = _impl_.encryption_keys_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(_impl_.encryption_keys_.Get(i));
    }

    // repeated .sync_pb.DataTypeContext context_mutations = 7;
    total_size += 1UL * this->_internal_context_mutations_size();
    for (const auto& msg : this->_impl_.context_mutations_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional int64 changes_remaining = 4;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_changes_remaining());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetUpdatesResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetUpdatesResponse*>(&from));
}

void GetUpdatesResponse::MergeFrom(const GetUpdatesResponse& from)
{
    GetUpdatesResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.GetUpdatesResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
    _this->_impl_.new_progress_marker_.MergeFrom(from._impl_.new_progress_marker_);
    _this->_impl_.encryption_keys_.MergeFrom(from._impl_.encryption_keys_);
    _this->_impl_.context_mutations_.MergeFrom(from._impl_.context_mutations_);
    if (from._internal_has_changes_remaining()) {
        _this->_internal_set_changes_remaining(from._internal_changes_remaining());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetUpdatesResponse::CopyFrom(const GetUpdatesResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.GetUpdatesResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetUpdatesResponse::IsInitialized() const
{
    return true;
}

void GetUpdatesResponse::InternalSwap(GetUpdatesResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.entries_.InternalSwap(&other->_impl_.entries_);
    _impl_.new_progress_marker_.InternalSwap(&other->_impl_.new_progress_marker_);
    _impl_.encryption_keys_.InternalSwap(&other->_impl_.encryption_keys_);
    _impl_.context_mutations_.InternalSwap(&other->_impl_.context_mutations_);
    swap(_impl_.changes_remaining_, other->_impl_.changes_remaining_);
}

std::string GetUpdatesResponse::GetTypeName() const
{
    return "sync_pb.GetUpdatesResponse";
}

// ===================================================================

class ClientToServerResponse_Error::_Internal {
public:
    using HasBits = decltype(std::declval<ClientToServerResponse_Error>()._impl_._has_bits_);
    static void set_has_error_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_error_description(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_action(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ClientToServerResponse_Error::ClientToServerResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ClientToServerResponse.Error)
}
ClientToServerResponse_Error::ClientToServerResponse_Error(const ClientToServerResponse_Error& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientToServerResponse_Error* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.error_data_type_ids_) { from._impl_.error_data_type_ids_ }, decltype(_impl_.error_description_) {}, decltype(_impl_.error_type_) {},
        decltype(_impl_.action_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.error_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_error_description()) {
        _this->_impl_.error_description_.Set(from._internal_error_description(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.error_type_, &from._impl_.error_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.action_) - reinterpret_cast<char*>(&_impl_.error_type_)) + sizeof(_impl_.action_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.ClientToServerResponse.Error)
}

inline void ClientToServerResponse_Error::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.error_data_type_ids_) { arena },
        decltype(_impl_.error_description_) {}, decltype(_impl_.error_type_) { 100 }, decltype(_impl_.action_) { 5 } };
    _impl_.error_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientToServerResponse_Error::~ClientToServerResponse_Error()
{
    // @@protoc_insertion_point(destructor:sync_pb.ClientToServerResponse.Error)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientToServerResponse_Error::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.error_data_type_ids_.~RepeatedField();
    _impl_.error_description_.Destroy();
}

void ClientToServerResponse_Error::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientToServerResponse_Error::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ClientToServerResponse.Error)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.error_data_type_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.error_description_.ClearNonDefaultToEmpty();
        }
        _impl_.error_type_ = 100;
        _impl_.action_ = 5;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientToServerResponse_Error::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_ErrorType_IsValid(val))) {
                    _internal_set_error_type(static_cast<::sync_pb::SyncEnums_ErrorType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string error_description = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_error_description();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_Action_IsValid(val))) {
                    _internal_set_action(static_cast<::sync_pb::SyncEnums_Action>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated int32 error_data_type_ids = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_error_data_type_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
            } else if (static_cast<uint8_t>(tag) == 42) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_error_data_type_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientToServerResponse_Error::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientToServerResponse.Error)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_error_type(), target);
    }

    // optional string error_description = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_error_description(), target);
    }

    // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_action(), target);
    }

    // repeated int32 error_data_type_ids = 5;
    for (int i = 0, n = this->_internal_error_data_type_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_error_data_type_ids(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientToServerResponse.Error)
    return target;
}

size_t ClientToServerResponse_Error::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientToServerResponse.Error)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 error_data_type_ids = 5;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.error_data_type_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_error_data_type_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string error_description = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_error_description());
        }

        // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_error_type());
        }

        // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientToServerResponse_Error::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientToServerResponse_Error*>(&from));
}

void ClientToServerResponse_Error::MergeFrom(const ClientToServerResponse_Error& from)
{
    ClientToServerResponse_Error* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientToServerResponse.Error)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.error_data_type_ids_.MergeFrom(from._impl_.error_data_type_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_error_description(from._internal_error_description());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.error_type_ = from._impl_.error_type_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.action_ = from._impl_.action_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientToServerResponse_Error::CopyFrom(const ClientToServerResponse_Error& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientToServerResponse.Error)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientToServerResponse_Error::IsInitialized() const
{
    return true;
}

void ClientToServerResponse_Error::InternalSwap(ClientToServerResponse_Error* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.error_data_type_ids_.InternalSwap(&other->_impl_.error_data_type_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.error_description_, lhs_arena, &other->_impl_.error_description_, rhs_arena);
    swap(_impl_.error_type_, other->_impl_.error_type_);
    swap(_impl_.action_, other->_impl_.action_);
}

std::string ClientToServerResponse_Error::GetTypeName() const
{
    return "sync_pb.ClientToServerResponse.Error";
}

// ===================================================================

class ClientToServerResponse::_Internal {
public:
    using HasBits = decltype(std::declval<ClientToServerResponse>()._impl_._has_bits_);
    static const ::sync_pb::CommitResponse& commit(const ClientToServerResponse* msg);
    static void set_has_commit(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::sync_pb::GetUpdatesResponse& get_updates(const ClientToServerResponse* msg);
    static void set_has_get_updates(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_error_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_error_message(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_store_birthday(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::ClientCommand& client_command(const ClientToServerResponse* msg);
    static void set_has_client_command(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::sync_pb::ClientToServerResponse_Error& error(const ClientToServerResponse* msg);
    static void set_has_error(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::sync_pb::ChipBag& new_bag_of_chips(const ClientToServerResponse* msg);
    static void set_has_new_bag_of_chips(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static const ::sync_pb::ClearServerDataResponse& clear_server_data(const ClientToServerResponse* msg);
    static void set_has_clear_server_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
};

const ::sync_pb::CommitResponse& ClientToServerResponse::_Internal::commit(const ClientToServerResponse* msg)
{
    return *msg->_impl_.commit_;
}
const ::sync_pb::GetUpdatesResponse& ClientToServerResponse::_Internal::get_updates(const ClientToServerResponse* msg)
{
    return *msg->_impl_.get_updates_;
}
const ::sync_pb::ClientCommand& ClientToServerResponse::_Internal::client_command(const ClientToServerResponse* msg)
{
    return *msg->_impl_.client_command_;
}
const ::sync_pb::ClientToServerResponse_Error& ClientToServerResponse::_Internal::error(const ClientToServerResponse* msg)
{
    return *msg->_impl_.error_;
}
const ::sync_pb::ChipBag& ClientToServerResponse::_Internal::new_bag_of_chips(const ClientToServerResponse* msg)
{
    return *msg->_impl_.new_bag_of_chips_;
}
const ::sync_pb::ClearServerDataResponse& ClientToServerResponse::_Internal::clear_server_data(const ClientToServerResponse* msg)
{
    return *msg->_impl_.clear_server_data_;
}
void ClientToServerResponse::clear_client_command()
{
    if (_impl_.client_command_ != nullptr)
        _impl_.client_command_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
ClientToServerResponse::ClientToServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ClientToServerResponse)
}
ClientToServerResponse::ClientToServerResponse(const ClientToServerResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ClientToServerResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.migrated_data_type_id_) { from._impl_.migrated_data_type_id_ }, decltype(_impl_.error_message_) {}, decltype(_impl_.store_birthday_) {},
        decltype(_impl_.commit_) { nullptr }, decltype(_impl_.get_updates_) { nullptr }, decltype(_impl_.client_command_) { nullptr },
        decltype(_impl_.error_) { nullptr }, decltype(_impl_.new_bag_of_chips_) { nullptr }, decltype(_impl_.clear_server_data_) { nullptr },
        decltype(_impl_.error_code_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_error_message()) {
        _this->_impl_.error_message_.Set(from._internal_error_message(), _this->GetArenaForAllocation());
    }
    _impl_.store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_store_birthday()) {
        _this->_impl_.store_birthday_.Set(from._internal_store_birthday(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_commit()) {
        _this->_impl_.commit_ = new ::sync_pb::CommitResponse(*from._impl_.commit_);
    }
    if (from._internal_has_get_updates()) {
        _this->_impl_.get_updates_ = new ::sync_pb::GetUpdatesResponse(*from._impl_.get_updates_);
    }
    if (from._internal_has_client_command()) {
        _this->_impl_.client_command_ = new ::sync_pb::ClientCommand(*from._impl_.client_command_);
    }
    if (from._internal_has_error()) {
        _this->_impl_.error_ = new ::sync_pb::ClientToServerResponse_Error(*from._impl_.error_);
    }
    if (from._internal_has_new_bag_of_chips()) {
        _this->_impl_.new_bag_of_chips_ = new ::sync_pb::ChipBag(*from._impl_.new_bag_of_chips_);
    }
    if (from._internal_has_clear_server_data()) {
        _this->_impl_.clear_server_data_ = new ::sync_pb::ClearServerDataResponse(*from._impl_.clear_server_data_);
    }
    _this->_impl_.error_code_ = from._impl_.error_code_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.ClientToServerResponse)
}

inline void ClientToServerResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.migrated_data_type_id_) { arena },
        decltype(_impl_.error_message_) {}, decltype(_impl_.store_birthday_) {}, decltype(_impl_.commit_) { nullptr },
        decltype(_impl_.get_updates_) { nullptr }, decltype(_impl_.client_command_) { nullptr }, decltype(_impl_.error_) { nullptr },
        decltype(_impl_.new_bag_of_chips_) { nullptr }, decltype(_impl_.clear_server_data_) { nullptr }, decltype(_impl_.error_code_) { 100 } };
    _impl_.error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientToServerResponse::~ClientToServerResponse()
{
    // @@protoc_insertion_point(destructor:sync_pb.ClientToServerResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ClientToServerResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.migrated_data_type_id_.~RepeatedField();
    _impl_.error_message_.Destroy();
    _impl_.store_birthday_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.commit_;
    if (this != internal_default_instance())
        delete _impl_.get_updates_;
    if (this != internal_default_instance())
        delete _impl_.client_command_;
    if (this != internal_default_instance())
        delete _impl_.error_;
    if (this != internal_default_instance())
        delete _impl_.new_bag_of_chips_;
    if (this != internal_default_instance())
        delete _impl_.clear_server_data_;
}

void ClientToServerResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ClientToServerResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ClientToServerResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.migrated_data_type_id_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.error_message_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.store_birthday_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.commit_ != nullptr);
            _impl_.commit_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.get_updates_ != nullptr);
            _impl_.get_updates_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.client_command_ != nullptr);
            _impl_.client_command_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.error_ != nullptr);
            _impl_.error_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.new_bag_of_chips_ != nullptr);
            _impl_.new_bag_of_chips_->Clear();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.clear_server_data_ != nullptr);
            _impl_.clear_server_data_->Clear();
        }
    }
    _impl_.error_code_ = 100;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ClientToServerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.CommitResponse commit = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_commit(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.GetUpdatesResponse get_updates = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_get_updates(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_ErrorType_IsValid(val))) {
                    _internal_set_error_code(static_cast<::sync_pb::SyncEnums_ErrorType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string error_message = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_error_message();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string store_birthday = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_store_birthday();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ClientCommand client_command = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_command(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int32 migrated_data_type_id = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_migrated_data_type_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
            } else if (static_cast<uint8_t>(tag) == 98) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_migrated_data_type_id(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ClientToServerResponse.Error error = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ChipBag new_bag_of_chips = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                ptr = ctx->ParseMessage(_internal_mutable_new_bag_of_chips(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                ptr = ctx->ParseMessage(_internal_mutable_clear_server_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ClientToServerResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientToServerResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.CommitResponse commit = 1;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::commit(this), _Internal::commit(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.GetUpdatesResponse get_updates = 2;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::get_updates(this), _Internal::get_updates(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_error_code(), target);
    }

    // optional string error_message = 5;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_error_message(), target);
    }

    // optional string store_birthday = 6;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_store_birthday(), target);
    }

    // optional .sync_pb.ClientCommand client_command = 7;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::client_command(this), _Internal::client_command(this).GetCachedSize(), target, stream);
    }

    // repeated int32 migrated_data_type_id = 12;
    for (int i = 0, n = this->_internal_migrated_data_type_id_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_migrated_data_type_id(i), target);
    }

    // optional .sync_pb.ClientToServerResponse.Error error = 13;
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::error(this), _Internal::error(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.ChipBag new_bag_of_chips = 14;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            14, _Internal::new_bag_of_chips(this), _Internal::new_bag_of_chips(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            15, _Internal::clear_server_data(this), _Internal::clear_server_data(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientToServerResponse)
    return target;
}

size_t ClientToServerResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientToServerResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 migrated_data_type_id = 12;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.migrated_data_type_id_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_migrated_data_type_id_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string error_message = 5;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_error_message());
        }

        // optional string store_birthday = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_store_birthday());
        }

        // optional .sync_pb.CommitResponse commit = 1;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.commit_);
        }

        // optional .sync_pb.GetUpdatesResponse get_updates = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.get_updates_);
        }

        // optional .sync_pb.ClientCommand client_command = 7;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_command_);
        }

        // optional .sync_pb.ClientToServerResponse.Error error = 13;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.error_);
        }

        // optional .sync_pb.ChipBag new_bag_of_chips = 14;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.new_bag_of_chips_);
        }

        // optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.clear_server_data_);
        }
    }
    // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
    if (cached_has_bits & 0x00000100u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ClientToServerResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ClientToServerResponse*>(&from));
}

void ClientToServerResponse::MergeFrom(const ClientToServerResponse& from)
{
    ClientToServerResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientToServerResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.migrated_data_type_id_.MergeFrom(from._impl_.migrated_data_type_id_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_error_message(from._internal_error_message());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_store_birthday(from._internal_store_birthday());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_commit()->::sync_pb::CommitResponse::MergeFrom(from._internal_commit());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_get_updates()->::sync_pb::GetUpdatesResponse::MergeFrom(from._internal_get_updates());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_client_command()->::sync_pb::ClientCommand::MergeFrom(from._internal_client_command());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_error()->::sync_pb::ClientToServerResponse_Error::MergeFrom(from._internal_error());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_new_bag_of_chips()->::sync_pb::ChipBag::MergeFrom(from._internal_new_bag_of_chips());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_clear_server_data()->::sync_pb::ClearServerDataResponse::MergeFrom(from._internal_clear_server_data());
        }
    }
    if (cached_has_bits & 0x00000100u) {
        _this->_internal_set_error_code(from._internal_error_code());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientToServerResponse::CopyFrom(const ClientToServerResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientToServerResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ClientToServerResponse::IsInitialized() const
{
    if (_internal_has_commit()) {
        if (!_impl_.commit_->IsInitialized())
            return false;
    }
    return true;
}

void ClientToServerResponse::InternalSwap(ClientToServerResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.migrated_data_type_id_.InternalSwap(&other->_impl_.migrated_data_type_id_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.error_message_, lhs_arena, &other->_impl_.error_message_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.store_birthday_, lhs_arena, &other->_impl_.store_birthday_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ClientToServerResponse, _impl_.clear_server_data_)
        + sizeof(ClientToServerResponse::_impl_.clear_server_data_) - PROTOBUF_FIELD_OFFSET(ClientToServerResponse, _impl_.commit_)>(
        reinterpret_cast<char*>(&_impl_.commit_), reinterpret_cast<char*>(&other->_impl_.commit_));
    swap(_impl_.error_code_, other->_impl_.error_code_);
}

std::string ClientToServerResponse::GetTypeName() const
{
    return "sync_pb.ClientToServerResponse";
}

// ===================================================================

class EventRequest::_Internal {
public:
    using HasBits = decltype(std::declval<EventRequest>()._impl_._has_bits_);
    static const ::sync_pb::SyncDisabledEvent& sync_disabled(const EventRequest* msg);
    static void set_has_sync_disabled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

const ::sync_pb::SyncDisabledEvent& EventRequest::_Internal::sync_disabled(const EventRequest* msg)
{
    return *msg->_impl_.sync_disabled_;
}
EventRequest::EventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.EventRequest)
}
EventRequest::EventRequest(const EventRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    EventRequest* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sync_disabled_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_sync_disabled()) {
        _this->_impl_.sync_disabled_ = new ::sync_pb::SyncDisabledEvent(*from._impl_.sync_disabled_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.EventRequest)
}

inline void EventRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.sync_disabled_) { nullptr } };
}

EventRequest::~EventRequest()
{
    // @@protoc_insertion_point(destructor:sync_pb.EventRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void EventRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.sync_disabled_;
}

void EventRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void EventRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.EventRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        GOOGLE_DCHECK(_impl_.sync_disabled_ != nullptr);
        _impl_.sync_disabled_->Clear();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* EventRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_sync_disabled(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* EventRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.EventRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::sync_disabled(this), _Internal::sync_disabled(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.EventRequest)
    return target;
}

size_t EventRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.EventRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.sync_disabled_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void EventRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const EventRequest*>(&from));
}

void EventRequest::MergeFrom(const EventRequest& from)
{
    EventRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.EventRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_sync_disabled()) {
        _this->_internal_mutable_sync_disabled()->::sync_pb::SyncDisabledEvent::MergeFrom(from._internal_sync_disabled());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventRequest::CopyFrom(const EventRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.EventRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool EventRequest::IsInitialized() const
{
    return true;
}

void EventRequest::InternalSwap(EventRequest* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.sync_disabled_, other->_impl_.sync_disabled_);
}

std::string EventRequest::GetTypeName() const
{
    return "sync_pb.EventRequest";
}

// ===================================================================

class EventResponse::_Internal {
public:
};

EventResponse::EventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.EventResponse)
}
EventResponse::EventResponse(const EventResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    EventResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.EventResponse)
}

inline void EventResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

EventResponse::~EventResponse()
{
    // @@protoc_insertion_point(destructor:sync_pb.EventResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void EventResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EventResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void EventResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.EventResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* EventResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* EventResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.EventResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.EventResponse)
    return target;
}

size_t EventResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.EventResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void EventResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const EventResponse*>(&from));
}

void EventResponse::MergeFrom(const EventResponse& from)
{
    EventResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.EventResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventResponse::CopyFrom(const EventResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.EventResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool EventResponse::IsInitialized() const
{
    return true;
}

void EventResponse::InternalSwap(EventResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string EventResponse::GetTypeName() const
{
    return "sync_pb.EventResponse";
}

// ===================================================================

class SyncDisabledEvent::_Internal {
public:
    using HasBits = decltype(std::declval<SyncDisabledEvent>()._impl_._has_bits_);
    static void set_has_cache_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_store_birthday(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

SyncDisabledEvent::SyncDisabledEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.SyncDisabledEvent)
}
SyncDisabledEvent::SyncDisabledEvent(const SyncDisabledEvent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SyncDisabledEvent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_guid_) {},
        decltype(_impl_.store_birthday_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.cache_guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_cache_guid()) {
        _this->_impl_.cache_guid_.Set(from._internal_cache_guid(), _this->GetArenaForAllocation());
    }
    _impl_.store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_store_birthday()) {
        _this->_impl_.store_birthday_.Set(from._internal_store_birthday(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.SyncDisabledEvent)
}

inline void SyncDisabledEvent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.cache_guid_) {}, decltype(_impl_.store_birthday_) {} };
    _impl_.cache_guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cache_guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SyncDisabledEvent::~SyncDisabledEvent()
{
    // @@protoc_insertion_point(destructor:sync_pb.SyncDisabledEvent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SyncDisabledEvent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.cache_guid_.Destroy();
    _impl_.store_birthday_.Destroy();
}

void SyncDisabledEvent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SyncDisabledEvent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.SyncDisabledEvent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.cache_guid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.store_birthday_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SyncDisabledEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string cache_guid = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_cache_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string store_birthday = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_store_birthday();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SyncDisabledEvent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.SyncDisabledEvent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string cache_guid = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_cache_guid(), target);
    }

    // optional string store_birthday = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_store_birthday(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.SyncDisabledEvent)
    return target;
}

size_t SyncDisabledEvent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.SyncDisabledEvent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string cache_guid = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_cache_guid());
        }

        // optional string store_birthday = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_store_birthday());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SyncDisabledEvent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SyncDisabledEvent*>(&from));
}

void SyncDisabledEvent::MergeFrom(const SyncDisabledEvent& from)
{
    SyncDisabledEvent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.SyncDisabledEvent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_cache_guid(from._internal_cache_guid());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_store_birthday(from._internal_store_birthday());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SyncDisabledEvent::CopyFrom(const SyncDisabledEvent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.SyncDisabledEvent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SyncDisabledEvent::IsInitialized() const
{
    return true;
}

void SyncDisabledEvent::InternalSwap(SyncDisabledEvent* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.cache_guid_, lhs_arena, &other->_impl_.cache_guid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.store_birthday_, lhs_arena, &other->_impl_.store_birthday_, rhs_arena);
}

std::string SyncDisabledEvent::GetTypeName() const
{
    return "sync_pb.SyncDisabledEvent";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::sync_pb::ChromiumExtensionsActivity* Arena::CreateMaybeMessage<::sync_pb::ChromiumExtensionsActivity>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ChromiumExtensionsActivity>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ClientConfigParams* Arena::CreateMaybeMessage<::sync_pb::ClientConfigParams>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ClientConfigParams>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CommitMessage* Arena::CreateMaybeMessage<::sync_pb::CommitMessage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CommitMessage>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::GetUpdatesMessage* Arena::CreateMaybeMessage<::sync_pb::GetUpdatesMessage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::GetUpdatesMessage>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ClearServerDataMessage* Arena::CreateMaybeMessage<::sync_pb::ClearServerDataMessage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ClearServerDataMessage>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ClearServerDataResponse* Arena::CreateMaybeMessage<::sync_pb::ClearServerDataResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ClearServerDataResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ChipBag* Arena::CreateMaybeMessage<::sync_pb::ChipBag>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ChipBag>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ClientStatus* Arena::CreateMaybeMessage<::sync_pb::ClientStatus>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ClientStatus>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ClientToServerMessage* Arena::CreateMaybeMessage<::sync_pb::ClientToServerMessage>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ClientToServerMessage>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError*
Arena::CreateMaybeMessage<::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CommitResponse_EntryResponse* Arena::CreateMaybeMessage<::sync_pb::CommitResponse_EntryResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CommitResponse_EntryResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CommitResponse* Arena::CreateMaybeMessage<::sync_pb::CommitResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CommitResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::GetUpdatesResponse* Arena::CreateMaybeMessage<::sync_pb::GetUpdatesResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::GetUpdatesResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ClientToServerResponse_Error* Arena::CreateMaybeMessage<::sync_pb::ClientToServerResponse_Error>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ClientToServerResponse_Error>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ClientToServerResponse* Arena::CreateMaybeMessage<::sync_pb::ClientToServerResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ClientToServerResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::EventRequest* Arena::CreateMaybeMessage<::sync_pb::EventRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::EventRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::EventResponse* Arena::CreateMaybeMessage<::sync_pb::EventResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::EventResponse>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::SyncDisabledEvent* Arena::CreateMaybeMessage<::sync_pb::SyncDisabledEvent>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::SyncDisabledEvent>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
