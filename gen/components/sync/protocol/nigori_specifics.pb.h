// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/nigori_specifics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/sync/protocol/encryption.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto {
    static const uint32_t offsets[];
};
namespace sync_pb {
class CrossUserSharingPrivateKey;
struct CrossUserSharingPrivateKeyDefaultTypeInternal;
extern CrossUserSharingPrivateKeyDefaultTypeInternal _CrossUserSharingPrivateKey_default_instance_;
class CrossUserSharingPublicKey;
struct CrossUserSharingPublicKeyDefaultTypeInternal;
extern CrossUserSharingPublicKeyDefaultTypeInternal _CrossUserSharingPublicKey_default_instance_;
class EncryptionKeys;
struct EncryptionKeysDefaultTypeInternal;
extern EncryptionKeysDefaultTypeInternal _EncryptionKeys_default_instance_;
class NigoriKey;
struct NigoriKeyDefaultTypeInternal;
extern NigoriKeyDefaultTypeInternal _NigoriKey_default_instance_;
class NigoriKeyBag;
struct NigoriKeyBagDefaultTypeInternal;
extern NigoriKeyBagDefaultTypeInternal _NigoriKeyBag_default_instance_;
class NigoriSpecifics;
struct NigoriSpecificsDefaultTypeInternal;
extern NigoriSpecificsDefaultTypeInternal _NigoriSpecifics_default_instance_;
class NigoriSpecifics_TrustedVaultDebugInfo;
struct NigoriSpecifics_TrustedVaultDebugInfoDefaultTypeInternal;
extern NigoriSpecifics_TrustedVaultDebugInfoDefaultTypeInternal _NigoriSpecifics_TrustedVaultDebugInfo_default_instance_;
class TrustedVaultAutoUpgradeExperimentGroup;
struct TrustedVaultAutoUpgradeExperimentGroupDefaultTypeInternal;
extern TrustedVaultAutoUpgradeExperimentGroupDefaultTypeInternal _TrustedVaultAutoUpgradeExperimentGroup_default_instance_;
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <>::sync_pb::CrossUserSharingPrivateKey* Arena::CreateMaybeMessage<::sync_pb::CrossUserSharingPrivateKey>(Arena*);
template <>::sync_pb::CrossUserSharingPublicKey* Arena::CreateMaybeMessage<::sync_pb::CrossUserSharingPublicKey>(Arena*);
template <>::sync_pb::EncryptionKeys* Arena::CreateMaybeMessage<::sync_pb::EncryptionKeys>(Arena*);
template <>::sync_pb::NigoriKey* Arena::CreateMaybeMessage<::sync_pb::NigoriKey>(Arena*);
template <>::sync_pb::NigoriKeyBag* Arena::CreateMaybeMessage<::sync_pb::NigoriKeyBag>(Arena*);
template <>::sync_pb::NigoriSpecifics* Arena::CreateMaybeMessage<::sync_pb::NigoriSpecifics>(Arena*);
template <>::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* Arena::CreateMaybeMessage<::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo>(Arena*);
template <>::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* Arena::CreateMaybeMessage<::sync_pb::TrustedVaultAutoUpgradeExperimentGroup>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

enum TrustedVaultAutoUpgradeExperimentGroup_Type : int {
    TrustedVaultAutoUpgradeExperimentGroup_Type_TYPE_UNSPECIFIED = 0,
    TrustedVaultAutoUpgradeExperimentGroup_Type_TREATMENT = 1,
    TrustedVaultAutoUpgradeExperimentGroup_Type_CONTROL = 2,
    TrustedVaultAutoUpgradeExperimentGroup_Type_VALIDATION = 3
};
bool TrustedVaultAutoUpgradeExperimentGroup_Type_IsValid(int value);
constexpr TrustedVaultAutoUpgradeExperimentGroup_Type TrustedVaultAutoUpgradeExperimentGroup_Type_Type_MIN
    = TrustedVaultAutoUpgradeExperimentGroup_Type_TYPE_UNSPECIFIED;
constexpr TrustedVaultAutoUpgradeExperimentGroup_Type TrustedVaultAutoUpgradeExperimentGroup_Type_Type_MAX
    = TrustedVaultAutoUpgradeExperimentGroup_Type_VALIDATION;
constexpr int TrustedVaultAutoUpgradeExperimentGroup_Type_Type_ARRAYSIZE = TrustedVaultAutoUpgradeExperimentGroup_Type_Type_MAX + 1;

const std::string& TrustedVaultAutoUpgradeExperimentGroup_Type_Name(TrustedVaultAutoUpgradeExperimentGroup_Type value);
template <typename T> inline const std::string& TrustedVaultAutoUpgradeExperimentGroup_Type_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, TrustedVaultAutoUpgradeExperimentGroup_Type>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function TrustedVaultAutoUpgradeExperimentGroup_Type_Name.");
    return TrustedVaultAutoUpgradeExperimentGroup_Type_Name(static_cast<TrustedVaultAutoUpgradeExperimentGroup_Type>(enum_t_value));
}
bool TrustedVaultAutoUpgradeExperimentGroup_Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrustedVaultAutoUpgradeExperimentGroup_Type* value);
enum NigoriSpecifics_PassphraseType : int {
    NigoriSpecifics_PassphraseType_UNKNOWN = 0,
    NigoriSpecifics_PassphraseType_IMPLICIT_PASSPHRASE = 1,
    NigoriSpecifics_PassphraseType_KEYSTORE_PASSPHRASE = 2,
    NigoriSpecifics_PassphraseType_FROZEN_IMPLICIT_PASSPHRASE = 3,
    NigoriSpecifics_PassphraseType_CUSTOM_PASSPHRASE = 4,
    NigoriSpecifics_PassphraseType_TRUSTED_VAULT_PASSPHRASE = 5
};
bool NigoriSpecifics_PassphraseType_IsValid(int value);
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics_PassphraseType_PassphraseType_MIN = NigoriSpecifics_PassphraseType_UNKNOWN;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics_PassphraseType_PassphraseType_MAX = NigoriSpecifics_PassphraseType_TRUSTED_VAULT_PASSPHRASE;
constexpr int NigoriSpecifics_PassphraseType_PassphraseType_ARRAYSIZE = NigoriSpecifics_PassphraseType_PassphraseType_MAX + 1;

const std::string& NigoriSpecifics_PassphraseType_Name(NigoriSpecifics_PassphraseType value);
template <typename T> inline const std::string& NigoriSpecifics_PassphraseType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, NigoriSpecifics_PassphraseType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function NigoriSpecifics_PassphraseType_Name.");
    return NigoriSpecifics_PassphraseType_Name(static_cast<NigoriSpecifics_PassphraseType>(enum_t_value));
}
bool NigoriSpecifics_PassphraseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NigoriSpecifics_PassphraseType* value);
enum NigoriSpecifics_KeyDerivationMethod : int {
    NigoriSpecifics_KeyDerivationMethod_UNSPECIFIED = 0,
    NigoriSpecifics_KeyDerivationMethod_PBKDF2_HMAC_SHA1_1003 = 1,
    NigoriSpecifics_KeyDerivationMethod_SCRYPT_8192_8_11 = 2
};
bool NigoriSpecifics_KeyDerivationMethod_IsValid(int value);
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MIN = NigoriSpecifics_KeyDerivationMethod_UNSPECIFIED;
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MAX
    = NigoriSpecifics_KeyDerivationMethod_SCRYPT_8192_8_11;
constexpr int NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_ARRAYSIZE = NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MAX + 1;

const std::string& NigoriSpecifics_KeyDerivationMethod_Name(NigoriSpecifics_KeyDerivationMethod value);
template <typename T> inline const std::string& NigoriSpecifics_KeyDerivationMethod_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, NigoriSpecifics_KeyDerivationMethod>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function NigoriSpecifics_KeyDerivationMethod_Name.");
    return NigoriSpecifics_KeyDerivationMethod_Name(static_cast<NigoriSpecifics_KeyDerivationMethod>(enum_t_value));
}
bool NigoriSpecifics_KeyDerivationMethod_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NigoriSpecifics_KeyDerivationMethod* value);
// ===================================================================

class NigoriKey final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NigoriKey) */ {
public:
    inline NigoriKey()
        : NigoriKey(nullptr)
    {
    }
    ~NigoriKey() override;
    explicit PROTOBUF_CONSTEXPR NigoriKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NigoriKey(const NigoriKey& from);
    NigoriKey(NigoriKey&& from) noexcept
        : NigoriKey()
    {
        *this = ::std::move(from);
    }

    inline NigoriKey& operator=(const NigoriKey& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NigoriKey& operator=(NigoriKey&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NigoriKey& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NigoriKey* internal_default_instance()
    {
        return reinterpret_cast<const NigoriKey*>(&_NigoriKey_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(NigoriKey& a, NigoriKey& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NigoriKey* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NigoriKey* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NigoriKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NigoriKey>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NigoriKey& from);
    void MergeFrom(const NigoriKey& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NigoriKey* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.NigoriKey";
    }

protected:
    explicit NigoriKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDeprecatedNameFieldNumber = 1,
        kDeprecatedUserKeyFieldNumber = 2,
        kEncryptionKeyFieldNumber = 3,
        kMacKeyFieldNumber = 4,
    };
    // optional string deprecated_name = 1 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_deprecated_name() const;

private:
    bool _internal_has_deprecated_name() const;

public:
    PROTOBUF_DEPRECATED void clear_deprecated_name();
    PROTOBUF_DEPRECATED const std::string& deprecated_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_deprecated_name(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_deprecated_name();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_deprecated_name();
    PROTOBUF_DEPRECATED void set_allocated_deprecated_name(std::string* deprecated_name);

private:
    const std::string& _internal_deprecated_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecated_name(const std::string& value);
    std::string* _internal_mutable_deprecated_name();

public:
    // optional bytes deprecated_user_key = 2 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_deprecated_user_key() const;

private:
    bool _internal_has_deprecated_user_key() const;

public:
    PROTOBUF_DEPRECATED void clear_deprecated_user_key();
    PROTOBUF_DEPRECATED const std::string& deprecated_user_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_deprecated_user_key(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_deprecated_user_key();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_deprecated_user_key();
    PROTOBUF_DEPRECATED void set_allocated_deprecated_user_key(std::string* deprecated_user_key);

private:
    const std::string& _internal_deprecated_user_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_deprecated_user_key(const std::string& value);
    std::string* _internal_mutable_deprecated_user_key();

public:
    // optional bytes encryption_key = 3;
    bool has_encryption_key() const;

private:
    bool _internal_has_encryption_key() const;

public:
    void clear_encryption_key();
    const std::string& encryption_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_encryption_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_encryption_key();
    PROTOBUF_NODISCARD std::string* release_encryption_key();
    void set_allocated_encryption_key(std::string* encryption_key);

private:
    const std::string& _internal_encryption_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_encryption_key(const std::string& value);
    std::string* _internal_mutable_encryption_key();

public:
    // optional bytes mac_key = 4;
    bool has_mac_key() const;

private:
    bool _internal_has_mac_key() const;

public:
    void clear_mac_key();
    const std::string& mac_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_mac_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_mac_key();
    PROTOBUF_NODISCARD std::string* release_mac_key();
    void set_allocated_mac_key(std::string* mac_key);

private:
    const std::string& _internal_mac_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_mac_key(const std::string& value);
    std::string* _internal_mutable_mac_key();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.NigoriKey)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecated_name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deprecated_user_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mac_key_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class CrossUserSharingPrivateKey final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CrossUserSharingPrivateKey) */ {
public:
    inline CrossUserSharingPrivateKey()
        : CrossUserSharingPrivateKey(nullptr)
    {
    }
    ~CrossUserSharingPrivateKey() override;
    explicit PROTOBUF_CONSTEXPR CrossUserSharingPrivateKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CrossUserSharingPrivateKey(const CrossUserSharingPrivateKey& from);
    CrossUserSharingPrivateKey(CrossUserSharingPrivateKey&& from) noexcept
        : CrossUserSharingPrivateKey()
    {
        *this = ::std::move(from);
    }

    inline CrossUserSharingPrivateKey& operator=(const CrossUserSharingPrivateKey& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CrossUserSharingPrivateKey& operator=(CrossUserSharingPrivateKey&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CrossUserSharingPrivateKey& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CrossUserSharingPrivateKey* internal_default_instance()
    {
        return reinterpret_cast<const CrossUserSharingPrivateKey*>(&_CrossUserSharingPrivateKey_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(CrossUserSharingPrivateKey& a, CrossUserSharingPrivateKey& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CrossUserSharingPrivateKey* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CrossUserSharingPrivateKey* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CrossUserSharingPrivateKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CrossUserSharingPrivateKey>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CrossUserSharingPrivateKey& from);
    void MergeFrom(const CrossUserSharingPrivateKey& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CrossUserSharingPrivateKey* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.CrossUserSharingPrivateKey";
    }

protected:
    explicit CrossUserSharingPrivateKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kX25519PrivateKeyFieldNumber = 2,
        kVersionFieldNumber = 1,
    };
    // optional bytes x25519_private_key = 2;
    bool has_x25519_private_key() const;

private:
    bool _internal_has_x25519_private_key() const;

public:
    void clear_x25519_private_key();
    const std::string& x25519_private_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_x25519_private_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_x25519_private_key();
    PROTOBUF_NODISCARD std::string* release_x25519_private_key();
    void set_allocated_x25519_private_key(std::string* x25519_private_key);

private:
    const std::string& _internal_x25519_private_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_x25519_private_key(const std::string& value);
    std::string* _internal_mutable_x25519_private_key();

public:
    // optional int32 version = 1;
    bool has_version() const;

private:
    bool _internal_has_version() const;

public:
    void clear_version();
    int32_t version() const;
    void set_version(int32_t value);

private:
    int32_t _internal_version() const;
    void _internal_set_version(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.CrossUserSharingPrivateKey)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x25519_private_key_;
        int32_t version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class CrossUserSharingPublicKey final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CrossUserSharingPublicKey) */ {
public:
    inline CrossUserSharingPublicKey()
        : CrossUserSharingPublicKey(nullptr)
    {
    }
    ~CrossUserSharingPublicKey() override;
    explicit PROTOBUF_CONSTEXPR CrossUserSharingPublicKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CrossUserSharingPublicKey(const CrossUserSharingPublicKey& from);
    CrossUserSharingPublicKey(CrossUserSharingPublicKey&& from) noexcept
        : CrossUserSharingPublicKey()
    {
        *this = ::std::move(from);
    }

    inline CrossUserSharingPublicKey& operator=(const CrossUserSharingPublicKey& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CrossUserSharingPublicKey& operator=(CrossUserSharingPublicKey&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CrossUserSharingPublicKey& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CrossUserSharingPublicKey* internal_default_instance()
    {
        return reinterpret_cast<const CrossUserSharingPublicKey*>(&_CrossUserSharingPublicKey_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(CrossUserSharingPublicKey& a, CrossUserSharingPublicKey& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CrossUserSharingPublicKey* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CrossUserSharingPublicKey* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CrossUserSharingPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CrossUserSharingPublicKey>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CrossUserSharingPublicKey& from);
    void MergeFrom(const CrossUserSharingPublicKey& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CrossUserSharingPublicKey* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.CrossUserSharingPublicKey";
    }

protected:
    explicit CrossUserSharingPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kX25519PublicKeyFieldNumber = 2,
        kVersionFieldNumber = 1,
    };
    // optional bytes x25519_public_key = 2;
    bool has_x25519_public_key() const;

private:
    bool _internal_has_x25519_public_key() const;

public:
    void clear_x25519_public_key();
    const std::string& x25519_public_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_x25519_public_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_x25519_public_key();
    PROTOBUF_NODISCARD std::string* release_x25519_public_key();
    void set_allocated_x25519_public_key(std::string* x25519_public_key);

private:
    const std::string& _internal_x25519_public_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_x25519_public_key(const std::string& value);
    std::string* _internal_mutable_x25519_public_key();

public:
    // optional int32 version = 1;
    bool has_version() const;

private:
    bool _internal_has_version() const;

public:
    void clear_version();
    int32_t version() const;
    void set_version(int32_t value);

private:
    int32_t _internal_version() const;
    void _internal_set_version(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.CrossUserSharingPublicKey)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x25519_public_key_;
        int32_t version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class EncryptionKeys final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.EncryptionKeys) */ {
public:
    inline EncryptionKeys()
        : EncryptionKeys(nullptr)
    {
    }
    ~EncryptionKeys() override;
    explicit PROTOBUF_CONSTEXPR EncryptionKeys(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    EncryptionKeys(const EncryptionKeys& from);
    EncryptionKeys(EncryptionKeys&& from) noexcept
        : EncryptionKeys()
    {
        *this = ::std::move(from);
    }

    inline EncryptionKeys& operator=(const EncryptionKeys& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EncryptionKeys& operator=(EncryptionKeys&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const EncryptionKeys& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const EncryptionKeys* internal_default_instance()
    {
        return reinterpret_cast<const EncryptionKeys*>(&_EncryptionKeys_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(EncryptionKeys& a, EncryptionKeys& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(EncryptionKeys* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EncryptionKeys* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    EncryptionKeys* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<EncryptionKeys>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const EncryptionKeys& from);
    void MergeFrom(const EncryptionKeys& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(EncryptionKeys* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.EncryptionKeys";
    }

protected:
    explicit EncryptionKeys(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kKeyFieldNumber = 2,
        kCrossUserSharingPrivateKeyFieldNumber = 3,
    };
    // repeated .sync_pb.NigoriKey key = 2;
    int key_size() const;

private:
    int _internal_key_size() const;

public:
    void clear_key();
    ::sync_pb::NigoriKey* mutable_key(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey>* mutable_key();

private:
    const ::sync_pb::NigoriKey& _internal_key(int index) const;
    ::sync_pb::NigoriKey* _internal_add_key();

public:
    const ::sync_pb::NigoriKey& key(int index) const;
    ::sync_pb::NigoriKey* add_key();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey>& key() const;

    // repeated .sync_pb.CrossUserSharingPrivateKey cross_user_sharing_private_key = 3;
    int cross_user_sharing_private_key_size() const;

private:
    int _internal_cross_user_sharing_private_key_size() const;

public:
    void clear_cross_user_sharing_private_key();
    ::sync_pb::CrossUserSharingPrivateKey* mutable_cross_user_sharing_private_key(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CrossUserSharingPrivateKey>* mutable_cross_user_sharing_private_key();

private:
    const ::sync_pb::CrossUserSharingPrivateKey& _internal_cross_user_sharing_private_key(int index) const;
    ::sync_pb::CrossUserSharingPrivateKey* _internal_add_cross_user_sharing_private_key();

public:
    const ::sync_pb::CrossUserSharingPrivateKey& cross_user_sharing_private_key(int index) const;
    ::sync_pb::CrossUserSharingPrivateKey* add_cross_user_sharing_private_key();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CrossUserSharingPrivateKey>& cross_user_sharing_private_key() const;

    // @@protoc_insertion_point(class_scope:sync_pb.EncryptionKeys)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey> key_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CrossUserSharingPrivateKey> cross_user_sharing_private_key_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class NigoriKeyBag final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NigoriKeyBag) */ {
public:
    inline NigoriKeyBag()
        : NigoriKeyBag(nullptr)
    {
    }
    ~NigoriKeyBag() override;
    explicit PROTOBUF_CONSTEXPR NigoriKeyBag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NigoriKeyBag(const NigoriKeyBag& from);
    NigoriKeyBag(NigoriKeyBag&& from) noexcept
        : NigoriKeyBag()
    {
        *this = ::std::move(from);
    }

    inline NigoriKeyBag& operator=(const NigoriKeyBag& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NigoriKeyBag& operator=(NigoriKeyBag&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NigoriKeyBag& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NigoriKeyBag* internal_default_instance()
    {
        return reinterpret_cast<const NigoriKeyBag*>(&_NigoriKeyBag_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(NigoriKeyBag& a, NigoriKeyBag& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NigoriKeyBag* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NigoriKeyBag* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NigoriKeyBag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NigoriKeyBag>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NigoriKeyBag& from);
    void MergeFrom(const NigoriKeyBag& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NigoriKeyBag* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.NigoriKeyBag";
    }

protected:
    explicit NigoriKeyBag(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kKeyFieldNumber = 2,
    };
    // repeated .sync_pb.NigoriKey key = 2;
    int key_size() const;

private:
    int _internal_key_size() const;

public:
    void clear_key();
    ::sync_pb::NigoriKey* mutable_key(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey>* mutable_key();

private:
    const ::sync_pb::NigoriKey& _internal_key(int index) const;
    ::sync_pb::NigoriKey* _internal_add_key();

public:
    const ::sync_pb::NigoriKey& key(int index) const;
    ::sync_pb::NigoriKey* add_key();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey>& key() const;

    // @@protoc_insertion_point(class_scope:sync_pb.NigoriKeyBag)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey> key_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class TrustedVaultAutoUpgradeExperimentGroup final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.TrustedVaultAutoUpgradeExperimentGroup) */ {
public:
    inline TrustedVaultAutoUpgradeExperimentGroup()
        : TrustedVaultAutoUpgradeExperimentGroup(nullptr)
    {
    }
    ~TrustedVaultAutoUpgradeExperimentGroup() override;
    explicit PROTOBUF_CONSTEXPR TrustedVaultAutoUpgradeExperimentGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TrustedVaultAutoUpgradeExperimentGroup(const TrustedVaultAutoUpgradeExperimentGroup& from);
    TrustedVaultAutoUpgradeExperimentGroup(TrustedVaultAutoUpgradeExperimentGroup&& from) noexcept
        : TrustedVaultAutoUpgradeExperimentGroup()
    {
        *this = ::std::move(from);
    }

    inline TrustedVaultAutoUpgradeExperimentGroup& operator=(const TrustedVaultAutoUpgradeExperimentGroup& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TrustedVaultAutoUpgradeExperimentGroup& operator=(TrustedVaultAutoUpgradeExperimentGroup&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TrustedVaultAutoUpgradeExperimentGroup& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TrustedVaultAutoUpgradeExperimentGroup* internal_default_instance()
    {
        return reinterpret_cast<const TrustedVaultAutoUpgradeExperimentGroup*>(&_TrustedVaultAutoUpgradeExperimentGroup_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(TrustedVaultAutoUpgradeExperimentGroup& a, TrustedVaultAutoUpgradeExperimentGroup& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TrustedVaultAutoUpgradeExperimentGroup* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TrustedVaultAutoUpgradeExperimentGroup* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TrustedVaultAutoUpgradeExperimentGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TrustedVaultAutoUpgradeExperimentGroup>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TrustedVaultAutoUpgradeExperimentGroup& from);
    void MergeFrom(const TrustedVaultAutoUpgradeExperimentGroup& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TrustedVaultAutoUpgradeExperimentGroup* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.TrustedVaultAutoUpgradeExperimentGroup";
    }

protected:
    explicit TrustedVaultAutoUpgradeExperimentGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef TrustedVaultAutoUpgradeExperimentGroup_Type Type;
    static constexpr Type TYPE_UNSPECIFIED = TrustedVaultAutoUpgradeExperimentGroup_Type_TYPE_UNSPECIFIED;
    static constexpr Type TREATMENT = TrustedVaultAutoUpgradeExperimentGroup_Type_TREATMENT;
    static constexpr Type CONTROL = TrustedVaultAutoUpgradeExperimentGroup_Type_CONTROL;
    static constexpr Type VALIDATION = TrustedVaultAutoUpgradeExperimentGroup_Type_VALIDATION;
    static inline bool Type_IsValid(int value)
    {
        return TrustedVaultAutoUpgradeExperimentGroup_Type_IsValid(value);
    }
    static constexpr Type Type_MIN = TrustedVaultAutoUpgradeExperimentGroup_Type_Type_MIN;
    static constexpr Type Type_MAX = TrustedVaultAutoUpgradeExperimentGroup_Type_Type_MAX;
    static constexpr int Type_ARRAYSIZE = TrustedVaultAutoUpgradeExperimentGroup_Type_Type_ARRAYSIZE;
    template <typename T> static inline const std::string& Type_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Type>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Type_Name.");
        return TrustedVaultAutoUpgradeExperimentGroup_Type_Name(enum_t_value);
    }
    static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value)
    {
        return TrustedVaultAutoUpgradeExperimentGroup_Type_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kCohortFieldNumber = 1,
        kTypeFieldNumber = 2,
        kTypeIndexFieldNumber = 3,
    };
    // optional int32 cohort = 1;
    bool has_cohort() const;

private:
    bool _internal_has_cohort() const;

public:
    void clear_cohort();
    int32_t cohort() const;
    void set_cohort(int32_t value);

private:
    int32_t _internal_cohort() const;
    void _internal_set_cohort(int32_t value);

public:
    // optional .sync_pb.TrustedVaultAutoUpgradeExperimentGroup.Type type = 2;
    bool has_type() const;

private:
    bool _internal_has_type() const;

public:
    void clear_type();
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type type() const;
    void set_type(::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type value);

private:
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type _internal_type() const;
    void _internal_set_type(::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type value);

public:
    // optional int32 type_index = 3;
    bool has_type_index() const;

private:
    bool _internal_has_type_index() const;

public:
    void clear_type_index();
    int32_t type_index() const;
    void set_type_index(int32_t value);

private:
    int32_t _internal_type_index() const;
    void _internal_set_type_index(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.TrustedVaultAutoUpgradeExperimentGroup)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        int32_t cohort_;
        int type_;
        int32_t type_index_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class NigoriSpecifics_TrustedVaultDebugInfo final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo) */ {
public:
    inline NigoriSpecifics_TrustedVaultDebugInfo()
        : NigoriSpecifics_TrustedVaultDebugInfo(nullptr)
    {
    }
    ~NigoriSpecifics_TrustedVaultDebugInfo() override;
    explicit PROTOBUF_CONSTEXPR NigoriSpecifics_TrustedVaultDebugInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NigoriSpecifics_TrustedVaultDebugInfo(const NigoriSpecifics_TrustedVaultDebugInfo& from);
    NigoriSpecifics_TrustedVaultDebugInfo(NigoriSpecifics_TrustedVaultDebugInfo&& from) noexcept
        : NigoriSpecifics_TrustedVaultDebugInfo()
    {
        *this = ::std::move(from);
    }

    inline NigoriSpecifics_TrustedVaultDebugInfo& operator=(const NigoriSpecifics_TrustedVaultDebugInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NigoriSpecifics_TrustedVaultDebugInfo& operator=(NigoriSpecifics_TrustedVaultDebugInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NigoriSpecifics_TrustedVaultDebugInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NigoriSpecifics_TrustedVaultDebugInfo* internal_default_instance()
    {
        return reinterpret_cast<const NigoriSpecifics_TrustedVaultDebugInfo*>(&_NigoriSpecifics_TrustedVaultDebugInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(NigoriSpecifics_TrustedVaultDebugInfo& a, NigoriSpecifics_TrustedVaultDebugInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NigoriSpecifics_TrustedVaultDebugInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NigoriSpecifics_TrustedVaultDebugInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NigoriSpecifics_TrustedVaultDebugInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NigoriSpecifics_TrustedVaultDebugInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NigoriSpecifics_TrustedVaultDebugInfo& from);
    void MergeFrom(const NigoriSpecifics_TrustedVaultDebugInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NigoriSpecifics_TrustedVaultDebugInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.NigoriSpecifics.TrustedVaultDebugInfo";
    }

protected:
    explicit NigoriSpecifics_TrustedVaultDebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAutoUpgradeExperimentGroupFieldNumber = 5,
        kMigrationTimeFieldNumber = 1,
        kAutoUpgradeExperimentGroupModificationTimeUnixEpochMillisFieldNumber = 6,
        kKeyVersionFieldNumber = 2,
    };
    // optional .sync_pb.TrustedVaultAutoUpgradeExperimentGroup auto_upgrade_experiment_group = 5;
    bool has_auto_upgrade_experiment_group() const;

private:
    bool _internal_has_auto_upgrade_experiment_group() const;

public:
    void clear_auto_upgrade_experiment_group();
    const ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup& auto_upgrade_experiment_group() const;
    PROTOBUF_NODISCARD ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* release_auto_upgrade_experiment_group();
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* mutable_auto_upgrade_experiment_group();
    void set_allocated_auto_upgrade_experiment_group(::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* auto_upgrade_experiment_group);

private:
    const ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup& _internal_auto_upgrade_experiment_group() const;
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* _internal_mutable_auto_upgrade_experiment_group();

public:
    void unsafe_arena_set_allocated_auto_upgrade_experiment_group(::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* auto_upgrade_experiment_group);
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* unsafe_arena_release_auto_upgrade_experiment_group();

    // optional int64 migration_time = 1;
    bool has_migration_time() const;

private:
    bool _internal_has_migration_time() const;

public:
    void clear_migration_time();
    int64_t migration_time() const;
    void set_migration_time(int64_t value);

private:
    int64_t _internal_migration_time() const;
    void _internal_set_migration_time(int64_t value);

public:
    // optional int64 auto_upgrade_experiment_group_modification_time_unix_epoch_millis = 6;
    bool has_auto_upgrade_experiment_group_modification_time_unix_epoch_millis() const;

private:
    bool _internal_has_auto_upgrade_experiment_group_modification_time_unix_epoch_millis() const;

public:
    void clear_auto_upgrade_experiment_group_modification_time_unix_epoch_millis();
    int64_t auto_upgrade_experiment_group_modification_time_unix_epoch_millis() const;
    void set_auto_upgrade_experiment_group_modification_time_unix_epoch_millis(int64_t value);

private:
    int64_t _internal_auto_upgrade_experiment_group_modification_time_unix_epoch_millis() const;
    void _internal_set_auto_upgrade_experiment_group_modification_time_unix_epoch_millis(int64_t value);

public:
    // optional int32 key_version = 2;
    bool has_key_version() const;

private:
    bool _internal_has_key_version() const;

public:
    void clear_key_version();
    int32_t key_version() const;
    void set_key_version(int32_t value);

private:
    int32_t _internal_key_version() const;
    void _internal_set_key_version(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* auto_upgrade_experiment_group_;
        int64_t migration_time_;
        int64_t auto_upgrade_experiment_group_modification_time_unix_epoch_millis_;
        int32_t key_version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class NigoriSpecifics final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NigoriSpecifics) */ {
public:
    inline NigoriSpecifics()
        : NigoriSpecifics(nullptr)
    {
    }
    ~NigoriSpecifics() override;
    explicit PROTOBUF_CONSTEXPR NigoriSpecifics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NigoriSpecifics(const NigoriSpecifics& from);
    NigoriSpecifics(NigoriSpecifics&& from) noexcept
        : NigoriSpecifics()
    {
        *this = ::std::move(from);
    }

    inline NigoriSpecifics& operator=(const NigoriSpecifics& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NigoriSpecifics& operator=(NigoriSpecifics&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NigoriSpecifics& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NigoriSpecifics* internal_default_instance()
    {
        return reinterpret_cast<const NigoriSpecifics*>(&_NigoriSpecifics_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(NigoriSpecifics& a, NigoriSpecifics& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NigoriSpecifics* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NigoriSpecifics* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NigoriSpecifics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NigoriSpecifics>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NigoriSpecifics& from);
    void MergeFrom(const NigoriSpecifics& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NigoriSpecifics* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.NigoriSpecifics";
    }

protected:
    explicit NigoriSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef NigoriSpecifics_TrustedVaultDebugInfo TrustedVaultDebugInfo;

    typedef NigoriSpecifics_PassphraseType PassphraseType;
    static constexpr PassphraseType UNKNOWN = NigoriSpecifics_PassphraseType_UNKNOWN;
    static constexpr PassphraseType IMPLICIT_PASSPHRASE = NigoriSpecifics_PassphraseType_IMPLICIT_PASSPHRASE;
    static constexpr PassphraseType KEYSTORE_PASSPHRASE = NigoriSpecifics_PassphraseType_KEYSTORE_PASSPHRASE;
    static constexpr PassphraseType FROZEN_IMPLICIT_PASSPHRASE = NigoriSpecifics_PassphraseType_FROZEN_IMPLICIT_PASSPHRASE;
    static constexpr PassphraseType CUSTOM_PASSPHRASE = NigoriSpecifics_PassphraseType_CUSTOM_PASSPHRASE;
    static constexpr PassphraseType TRUSTED_VAULT_PASSPHRASE = NigoriSpecifics_PassphraseType_TRUSTED_VAULT_PASSPHRASE;
    static inline bool PassphraseType_IsValid(int value)
    {
        return NigoriSpecifics_PassphraseType_IsValid(value);
    }
    static constexpr PassphraseType PassphraseType_MIN = NigoriSpecifics_PassphraseType_PassphraseType_MIN;
    static constexpr PassphraseType PassphraseType_MAX = NigoriSpecifics_PassphraseType_PassphraseType_MAX;
    static constexpr int PassphraseType_ARRAYSIZE = NigoriSpecifics_PassphraseType_PassphraseType_ARRAYSIZE;
    template <typename T> static inline const std::string& PassphraseType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, PassphraseType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function PassphraseType_Name.");
        return NigoriSpecifics_PassphraseType_Name(enum_t_value);
    }
    static inline bool PassphraseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PassphraseType* value)
    {
        return NigoriSpecifics_PassphraseType_Parse(name, value);
    }

    typedef NigoriSpecifics_KeyDerivationMethod KeyDerivationMethod;
    static constexpr KeyDerivationMethod UNSPECIFIED = NigoriSpecifics_KeyDerivationMethod_UNSPECIFIED;
    static constexpr KeyDerivationMethod PBKDF2_HMAC_SHA1_1003 = NigoriSpecifics_KeyDerivationMethod_PBKDF2_HMAC_SHA1_1003;
    static constexpr KeyDerivationMethod SCRYPT_8192_8_11 = NigoriSpecifics_KeyDerivationMethod_SCRYPT_8192_8_11;
    static inline bool KeyDerivationMethod_IsValid(int value)
    {
        return NigoriSpecifics_KeyDerivationMethod_IsValid(value);
    }
    static constexpr KeyDerivationMethod KeyDerivationMethod_MIN = NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MIN;
    static constexpr KeyDerivationMethod KeyDerivationMethod_MAX = NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_MAX;
    static constexpr int KeyDerivationMethod_ARRAYSIZE = NigoriSpecifics_KeyDerivationMethod_KeyDerivationMethod_ARRAYSIZE;
    template <typename T> static inline const std::string& KeyDerivationMethod_Name(T enum_t_value)
    {
        static_assert(
            ::std::is_same<T, KeyDerivationMethod>::value || ::std::is_integral<T>::value, "Incorrect type passed to function KeyDerivationMethod_Name.");
        return NigoriSpecifics_KeyDerivationMethod_Name(enum_t_value);
    }
    static inline bool KeyDerivationMethod_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyDerivationMethod* value)
    {
        return NigoriSpecifics_KeyDerivationMethod_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kCustomPassphraseKeyDerivationSaltFieldNumber = 46,
        kEncryptionKeybagFieldNumber = 1,
        kKeystoreDecryptorTokenFieldNumber = 31,
        kTrustedVaultDebugInfoFieldNumber = 50,
        kCrossUserSharingPublicKeyFieldNumber = 53,
        kKeybagIsFrozenFieldNumber = 2,
        kEncryptEverythingFieldNumber = 24,
        kSyncTabFaviconsFieldNumber = 29,
        kServerOnlyWasMissingKeystoreMigrationTimeFieldNumber = 40,
        kCustomPassphraseKeyDerivationMethodFieldNumber = 45,
        kKeystoreMigrationTimeFieldNumber = 32,
        kCustomPassphraseTimeFieldNumber = 33,
        kPassphraseTypeFieldNumber = 30,
    };
    // optional string custom_passphrase_key_derivation_salt = 46;
    bool has_custom_passphrase_key_derivation_salt() const;

private:
    bool _internal_has_custom_passphrase_key_derivation_salt() const;

public:
    void clear_custom_passphrase_key_derivation_salt();
    const std::string& custom_passphrase_key_derivation_salt() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_custom_passphrase_key_derivation_salt(ArgT0&& arg0, ArgT... args);
    std::string* mutable_custom_passphrase_key_derivation_salt();
    PROTOBUF_NODISCARD std::string* release_custom_passphrase_key_derivation_salt();
    void set_allocated_custom_passphrase_key_derivation_salt(std::string* custom_passphrase_key_derivation_salt);

private:
    const std::string& _internal_custom_passphrase_key_derivation_salt() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_passphrase_key_derivation_salt(const std::string& value);
    std::string* _internal_mutable_custom_passphrase_key_derivation_salt();

public:
    // optional .sync_pb.EncryptedData encryption_keybag = 1;
    bool has_encryption_keybag() const;

private:
    bool _internal_has_encryption_keybag() const;

public:
    void clear_encryption_keybag();
    const ::sync_pb::EncryptedData& encryption_keybag() const;
    PROTOBUF_NODISCARD ::sync_pb::EncryptedData* release_encryption_keybag();
    ::sync_pb::EncryptedData* mutable_encryption_keybag();
    void set_allocated_encryption_keybag(::sync_pb::EncryptedData* encryption_keybag);

private:
    const ::sync_pb::EncryptedData& _internal_encryption_keybag() const;
    ::sync_pb::EncryptedData* _internal_mutable_encryption_keybag();

public:
    void unsafe_arena_set_allocated_encryption_keybag(::sync_pb::EncryptedData* encryption_keybag);
    ::sync_pb::EncryptedData* unsafe_arena_release_encryption_keybag();

    // optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
    bool has_keystore_decryptor_token() const;

private:
    bool _internal_has_keystore_decryptor_token() const;

public:
    void clear_keystore_decryptor_token();
    const ::sync_pb::EncryptedData& keystore_decryptor_token() const;
    PROTOBUF_NODISCARD ::sync_pb::EncryptedData* release_keystore_decryptor_token();
    ::sync_pb::EncryptedData* mutable_keystore_decryptor_token();
    void set_allocated_keystore_decryptor_token(::sync_pb::EncryptedData* keystore_decryptor_token);

private:
    const ::sync_pb::EncryptedData& _internal_keystore_decryptor_token() const;
    ::sync_pb::EncryptedData* _internal_mutable_keystore_decryptor_token();

public:
    void unsafe_arena_set_allocated_keystore_decryptor_token(::sync_pb::EncryptedData* keystore_decryptor_token);
    ::sync_pb::EncryptedData* unsafe_arena_release_keystore_decryptor_token();

    // optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 50;
    bool has_trusted_vault_debug_info() const;

private:
    bool _internal_has_trusted_vault_debug_info() const;

public:
    void clear_trusted_vault_debug_info();
    const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& trusted_vault_debug_info() const;
    PROTOBUF_NODISCARD ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* release_trusted_vault_debug_info();
    ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* mutable_trusted_vault_debug_info();
    void set_allocated_trusted_vault_debug_info(::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info);

private:
    const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& _internal_trusted_vault_debug_info() const;
    ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* _internal_mutable_trusted_vault_debug_info();

public:
    void unsafe_arena_set_allocated_trusted_vault_debug_info(::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info);
    ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* unsafe_arena_release_trusted_vault_debug_info();

    // optional .sync_pb.CrossUserSharingPublicKey cross_user_sharing_public_key = 53;
    bool has_cross_user_sharing_public_key() const;

private:
    bool _internal_has_cross_user_sharing_public_key() const;

public:
    void clear_cross_user_sharing_public_key();
    const ::sync_pb::CrossUserSharingPublicKey& cross_user_sharing_public_key() const;
    PROTOBUF_NODISCARD ::sync_pb::CrossUserSharingPublicKey* release_cross_user_sharing_public_key();
    ::sync_pb::CrossUserSharingPublicKey* mutable_cross_user_sharing_public_key();
    void set_allocated_cross_user_sharing_public_key(::sync_pb::CrossUserSharingPublicKey* cross_user_sharing_public_key);

private:
    const ::sync_pb::CrossUserSharingPublicKey& _internal_cross_user_sharing_public_key() const;
    ::sync_pb::CrossUserSharingPublicKey* _internal_mutable_cross_user_sharing_public_key();

public:
    void unsafe_arena_set_allocated_cross_user_sharing_public_key(::sync_pb::CrossUserSharingPublicKey* cross_user_sharing_public_key);
    ::sync_pb::CrossUserSharingPublicKey* unsafe_arena_release_cross_user_sharing_public_key();

    // optional bool keybag_is_frozen = 2;
    bool has_keybag_is_frozen() const;

private:
    bool _internal_has_keybag_is_frozen() const;

public:
    void clear_keybag_is_frozen();
    bool keybag_is_frozen() const;
    void set_keybag_is_frozen(bool value);

private:
    bool _internal_keybag_is_frozen() const;
    void _internal_set_keybag_is_frozen(bool value);

public:
    // optional bool encrypt_everything = 24;
    bool has_encrypt_everything() const;

private:
    bool _internal_has_encrypt_everything() const;

public:
    void clear_encrypt_everything();
    bool encrypt_everything() const;
    void set_encrypt_everything(bool value);

private:
    bool _internal_encrypt_everything() const;
    void _internal_set_encrypt_everything(bool value);

public:
    // optional bool sync_tab_favicons = 29;
    bool has_sync_tab_favicons() const;

private:
    bool _internal_has_sync_tab_favicons() const;

public:
    void clear_sync_tab_favicons();
    bool sync_tab_favicons() const;
    void set_sync_tab_favicons(bool value);

private:
    bool _internal_sync_tab_favicons() const;
    void _internal_set_sync_tab_favicons(bool value);

public:
    // optional bool server_only_was_missing_keystore_migration_time = 40;
    bool has_server_only_was_missing_keystore_migration_time() const;

private:
    bool _internal_has_server_only_was_missing_keystore_migration_time() const;

public:
    void clear_server_only_was_missing_keystore_migration_time();
    bool server_only_was_missing_keystore_migration_time() const;
    void set_server_only_was_missing_keystore_migration_time(bool value);

private:
    bool _internal_server_only_was_missing_keystore_migration_time() const;
    void _internal_set_server_only_was_missing_keystore_migration_time(bool value);

public:
    // optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];
    bool has_custom_passphrase_key_derivation_method() const;

private:
    bool _internal_has_custom_passphrase_key_derivation_method() const;

public:
    void clear_custom_passphrase_key_derivation_method();
    int32_t custom_passphrase_key_derivation_method() const;
    void set_custom_passphrase_key_derivation_method(int32_t value);

private:
    int32_t _internal_custom_passphrase_key_derivation_method() const;
    void _internal_set_custom_passphrase_key_derivation_method(int32_t value);

public:
    // optional int64 keystore_migration_time = 32;
    bool has_keystore_migration_time() const;

private:
    bool _internal_has_keystore_migration_time() const;

public:
    void clear_keystore_migration_time();
    int64_t keystore_migration_time() const;
    void set_keystore_migration_time(int64_t value);

private:
    int64_t _internal_keystore_migration_time() const;
    void _internal_set_keystore_migration_time(int64_t value);

public:
    // optional int64 custom_passphrase_time = 33;
    bool has_custom_passphrase_time() const;

private:
    bool _internal_has_custom_passphrase_time() const;

public:
    void clear_custom_passphrase_time();
    int64_t custom_passphrase_time() const;
    void set_custom_passphrase_time(int64_t value);

private:
    int64_t _internal_custom_passphrase_time() const;
    void _internal_set_custom_passphrase_time(int64_t value);

public:
    // optional int32 passphrase_type = 30 [default = 1];
    bool has_passphrase_type() const;

private:
    bool _internal_has_passphrase_type() const;

public:
    void clear_passphrase_type();
    int32_t passphrase_type() const;
    void set_passphrase_type(int32_t value);

private:
    int32_t _internal_passphrase_type() const;
    void _internal_set_passphrase_type(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.NigoriSpecifics)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_passphrase_key_derivation_salt_;
        ::sync_pb::EncryptedData* encryption_keybag_;
        ::sync_pb::EncryptedData* keystore_decryptor_token_;
        ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info_;
        ::sync_pb::CrossUserSharingPublicKey* cross_user_sharing_public_key_;
        bool keybag_is_frozen_;
        bool encrypt_everything_;
        bool sync_tab_favicons_;
        bool server_only_was_missing_keystore_migration_time_;
        int32_t custom_passphrase_key_derivation_method_;
        int64_t keystore_migration_time_;
        int64_t custom_passphrase_time_;
        int32_t passphrase_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// NigoriKey

// optional string deprecated_name = 1 [deprecated = true];
inline bool NigoriKey::_internal_has_deprecated_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool NigoriKey::has_deprecated_name() const
{
    return _internal_has_deprecated_name();
}
inline void NigoriKey::clear_deprecated_name()
{
    _impl_.deprecated_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NigoriKey::deprecated_name() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriKey.deprecated_name)
    return _internal_deprecated_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NigoriKey::set_deprecated_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.deprecated_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.NigoriKey.deprecated_name)
}
inline std::string* NigoriKey::mutable_deprecated_name()
{
    std::string* _s = _internal_mutable_deprecated_name();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKey.deprecated_name)
    return _s;
}
inline const std::string& NigoriKey::_internal_deprecated_name() const
{
    return _impl_.deprecated_name_.Get();
}
inline void NigoriKey::_internal_set_deprecated_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.deprecated_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriKey::_internal_mutable_deprecated_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.deprecated_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriKey::release_deprecated_name()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriKey.deprecated_name)
    if (!_internal_has_deprecated_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.deprecated_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.deprecated_name_.IsDefault()) {
        _impl_.deprecated_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NigoriKey::set_allocated_deprecated_name(std::string* deprecated_name)
{
    if (deprecated_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.deprecated_name_.SetAllocated(deprecated_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.deprecated_name_.IsDefault()) {
        _impl_.deprecated_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriKey.deprecated_name)
}

// optional bytes deprecated_user_key = 2 [deprecated = true];
inline bool NigoriKey::_internal_has_deprecated_user_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool NigoriKey::has_deprecated_user_key() const
{
    return _internal_has_deprecated_user_key();
}
inline void NigoriKey::clear_deprecated_user_key()
{
    _impl_.deprecated_user_key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NigoriKey::deprecated_user_key() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriKey.deprecated_user_key)
    return _internal_deprecated_user_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NigoriKey::set_deprecated_user_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.deprecated_user_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.NigoriKey.deprecated_user_key)
}
inline std::string* NigoriKey::mutable_deprecated_user_key()
{
    std::string* _s = _internal_mutable_deprecated_user_key();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKey.deprecated_user_key)
    return _s;
}
inline const std::string& NigoriKey::_internal_deprecated_user_key() const
{
    return _impl_.deprecated_user_key_.Get();
}
inline void NigoriKey::_internal_set_deprecated_user_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.deprecated_user_key_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriKey::_internal_mutable_deprecated_user_key()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.deprecated_user_key_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriKey::release_deprecated_user_key()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriKey.deprecated_user_key)
    if (!_internal_has_deprecated_user_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.deprecated_user_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.deprecated_user_key_.IsDefault()) {
        _impl_.deprecated_user_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NigoriKey::set_allocated_deprecated_user_key(std::string* deprecated_user_key)
{
    if (deprecated_user_key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.deprecated_user_key_.SetAllocated(deprecated_user_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.deprecated_user_key_.IsDefault()) {
        _impl_.deprecated_user_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriKey.deprecated_user_key)
}

// optional bytes encryption_key = 3;
inline bool NigoriKey::_internal_has_encryption_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool NigoriKey::has_encryption_key() const
{
    return _internal_has_encryption_key();
}
inline void NigoriKey::clear_encryption_key()
{
    _impl_.encryption_key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NigoriKey::encryption_key() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriKey.encryption_key)
    return _internal_encryption_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NigoriKey::set_encryption_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.encryption_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.NigoriKey.encryption_key)
}
inline std::string* NigoriKey::mutable_encryption_key()
{
    std::string* _s = _internal_mutable_encryption_key();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKey.encryption_key)
    return _s;
}
inline const std::string& NigoriKey::_internal_encryption_key() const
{
    return _impl_.encryption_key_.Get();
}
inline void NigoriKey::_internal_set_encryption_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.encryption_key_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriKey::_internal_mutable_encryption_key()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.encryption_key_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriKey::release_encryption_key()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriKey.encryption_key)
    if (!_internal_has_encryption_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.encryption_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.encryption_key_.IsDefault()) {
        _impl_.encryption_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NigoriKey::set_allocated_encryption_key(std::string* encryption_key)
{
    if (encryption_key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.encryption_key_.SetAllocated(encryption_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.encryption_key_.IsDefault()) {
        _impl_.encryption_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriKey.encryption_key)
}

// optional bytes mac_key = 4;
inline bool NigoriKey::_internal_has_mac_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool NigoriKey::has_mac_key() const
{
    return _internal_has_mac_key();
}
inline void NigoriKey::clear_mac_key()
{
    _impl_.mac_key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& NigoriKey::mac_key() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriKey.mac_key)
    return _internal_mac_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NigoriKey::set_mac_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.mac_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.NigoriKey.mac_key)
}
inline std::string* NigoriKey::mutable_mac_key()
{
    std::string* _s = _internal_mutable_mac_key();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKey.mac_key)
    return _s;
}
inline const std::string& NigoriKey::_internal_mac_key() const
{
    return _impl_.mac_key_.Get();
}
inline void NigoriKey::_internal_set_mac_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.mac_key_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriKey::_internal_mutable_mac_key()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.mac_key_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriKey::release_mac_key()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriKey.mac_key)
    if (!_internal_has_mac_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.mac_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mac_key_.IsDefault()) {
        _impl_.mac_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NigoriKey::set_allocated_mac_key(std::string* mac_key)
{
    if (mac_key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.mac_key_.SetAllocated(mac_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.mac_key_.IsDefault()) {
        _impl_.mac_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriKey.mac_key)
}

// -------------------------------------------------------------------

// CrossUserSharingPrivateKey

// optional int32 version = 1;
inline bool CrossUserSharingPrivateKey::_internal_has_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CrossUserSharingPrivateKey::has_version() const
{
    return _internal_has_version();
}
inline void CrossUserSharingPrivateKey::clear_version()
{
    _impl_.version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CrossUserSharingPrivateKey::_internal_version() const
{
    return _impl_.version_;
}
inline int32_t CrossUserSharingPrivateKey::version() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CrossUserSharingPrivateKey.version)
    return _internal_version();
}
inline void CrossUserSharingPrivateKey::_internal_set_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.version_ = value;
}
inline void CrossUserSharingPrivateKey::set_version(int32_t value)
{
    _internal_set_version(value);
    // @@protoc_insertion_point(field_set:sync_pb.CrossUserSharingPrivateKey.version)
}

// optional bytes x25519_private_key = 2;
inline bool CrossUserSharingPrivateKey::_internal_has_x25519_private_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CrossUserSharingPrivateKey::has_x25519_private_key() const
{
    return _internal_has_x25519_private_key();
}
inline void CrossUserSharingPrivateKey::clear_x25519_private_key()
{
    _impl_.x25519_private_key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrossUserSharingPrivateKey::x25519_private_key() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CrossUserSharingPrivateKey.x25519_private_key)
    return _internal_x25519_private_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CrossUserSharingPrivateKey::set_x25519_private_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.x25519_private_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.CrossUserSharingPrivateKey.x25519_private_key)
}
inline std::string* CrossUserSharingPrivateKey::mutable_x25519_private_key()
{
    std::string* _s = _internal_mutable_x25519_private_key();
    // @@protoc_insertion_point(field_mutable:sync_pb.CrossUserSharingPrivateKey.x25519_private_key)
    return _s;
}
inline const std::string& CrossUserSharingPrivateKey::_internal_x25519_private_key() const
{
    return _impl_.x25519_private_key_.Get();
}
inline void CrossUserSharingPrivateKey::_internal_set_x25519_private_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.x25519_private_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CrossUserSharingPrivateKey::_internal_mutable_x25519_private_key()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.x25519_private_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CrossUserSharingPrivateKey::release_x25519_private_key()
{
    // @@protoc_insertion_point(field_release:sync_pb.CrossUserSharingPrivateKey.x25519_private_key)
    if (!_internal_has_x25519_private_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.x25519_private_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.x25519_private_key_.IsDefault()) {
        _impl_.x25519_private_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CrossUserSharingPrivateKey::set_allocated_x25519_private_key(std::string* x25519_private_key)
{
    if (x25519_private_key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.x25519_private_key_.SetAllocated(x25519_private_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.x25519_private_key_.IsDefault()) {
        _impl_.x25519_private_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CrossUserSharingPrivateKey.x25519_private_key)
}

// -------------------------------------------------------------------

// CrossUserSharingPublicKey

// optional int32 version = 1;
inline bool CrossUserSharingPublicKey::_internal_has_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CrossUserSharingPublicKey::has_version() const
{
    return _internal_has_version();
}
inline void CrossUserSharingPublicKey::clear_version()
{
    _impl_.version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t CrossUserSharingPublicKey::_internal_version() const
{
    return _impl_.version_;
}
inline int32_t CrossUserSharingPublicKey::version() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CrossUserSharingPublicKey.version)
    return _internal_version();
}
inline void CrossUserSharingPublicKey::_internal_set_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.version_ = value;
}
inline void CrossUserSharingPublicKey::set_version(int32_t value)
{
    _internal_set_version(value);
    // @@protoc_insertion_point(field_set:sync_pb.CrossUserSharingPublicKey.version)
}

// optional bytes x25519_public_key = 2;
inline bool CrossUserSharingPublicKey::_internal_has_x25519_public_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CrossUserSharingPublicKey::has_x25519_public_key() const
{
    return _internal_has_x25519_public_key();
}
inline void CrossUserSharingPublicKey::clear_x25519_public_key()
{
    _impl_.x25519_public_key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CrossUserSharingPublicKey::x25519_public_key() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CrossUserSharingPublicKey.x25519_public_key)
    return _internal_x25519_public_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CrossUserSharingPublicKey::set_x25519_public_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.x25519_public_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.CrossUserSharingPublicKey.x25519_public_key)
}
inline std::string* CrossUserSharingPublicKey::mutable_x25519_public_key()
{
    std::string* _s = _internal_mutable_x25519_public_key();
    // @@protoc_insertion_point(field_mutable:sync_pb.CrossUserSharingPublicKey.x25519_public_key)
    return _s;
}
inline const std::string& CrossUserSharingPublicKey::_internal_x25519_public_key() const
{
    return _impl_.x25519_public_key_.Get();
}
inline void CrossUserSharingPublicKey::_internal_set_x25519_public_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.x25519_public_key_.Set(value, GetArenaForAllocation());
}
inline std::string* CrossUserSharingPublicKey::_internal_mutable_x25519_public_key()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.x25519_public_key_.Mutable(GetArenaForAllocation());
}
inline std::string* CrossUserSharingPublicKey::release_x25519_public_key()
{
    // @@protoc_insertion_point(field_release:sync_pb.CrossUserSharingPublicKey.x25519_public_key)
    if (!_internal_has_x25519_public_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.x25519_public_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.x25519_public_key_.IsDefault()) {
        _impl_.x25519_public_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CrossUserSharingPublicKey::set_allocated_x25519_public_key(std::string* x25519_public_key)
{
    if (x25519_public_key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.x25519_public_key_.SetAllocated(x25519_public_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.x25519_public_key_.IsDefault()) {
        _impl_.x25519_public_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CrossUserSharingPublicKey.x25519_public_key)
}

// -------------------------------------------------------------------

// EncryptionKeys

// repeated .sync_pb.NigoriKey key = 2;
inline int EncryptionKeys::_internal_key_size() const
{
    return _impl_.key_.size();
}
inline int EncryptionKeys::key_size() const
{
    return _internal_key_size();
}
inline void EncryptionKeys::clear_key()
{
    _impl_.key_.Clear();
}
inline ::sync_pb::NigoriKey* EncryptionKeys::mutable_key(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.EncryptionKeys.key)
    return _impl_.key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey>* EncryptionKeys::mutable_key()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.EncryptionKeys.key)
    return &_impl_.key_;
}
inline const ::sync_pb::NigoriKey& EncryptionKeys::_internal_key(int index) const
{
    return _impl_.key_.Get(index);
}
inline const ::sync_pb::NigoriKey& EncryptionKeys::key(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.EncryptionKeys.key)
    return _internal_key(index);
}
inline ::sync_pb::NigoriKey* EncryptionKeys::_internal_add_key()
{
    return _impl_.key_.Add();
}
inline ::sync_pb::NigoriKey* EncryptionKeys::add_key()
{
    ::sync_pb::NigoriKey* _add = _internal_add_key();
    // @@protoc_insertion_point(field_add:sync_pb.EncryptionKeys.key)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey>& EncryptionKeys::key() const
{
    // @@protoc_insertion_point(field_list:sync_pb.EncryptionKeys.key)
    return _impl_.key_;
}

// repeated .sync_pb.CrossUserSharingPrivateKey cross_user_sharing_private_key = 3;
inline int EncryptionKeys::_internal_cross_user_sharing_private_key_size() const
{
    return _impl_.cross_user_sharing_private_key_.size();
}
inline int EncryptionKeys::cross_user_sharing_private_key_size() const
{
    return _internal_cross_user_sharing_private_key_size();
}
inline void EncryptionKeys::clear_cross_user_sharing_private_key()
{
    _impl_.cross_user_sharing_private_key_.Clear();
}
inline ::sync_pb::CrossUserSharingPrivateKey* EncryptionKeys::mutable_cross_user_sharing_private_key(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.EncryptionKeys.cross_user_sharing_private_key)
    return _impl_.cross_user_sharing_private_key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CrossUserSharingPrivateKey>* EncryptionKeys::mutable_cross_user_sharing_private_key()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.EncryptionKeys.cross_user_sharing_private_key)
    return &_impl_.cross_user_sharing_private_key_;
}
inline const ::sync_pb::CrossUserSharingPrivateKey& EncryptionKeys::_internal_cross_user_sharing_private_key(int index) const
{
    return _impl_.cross_user_sharing_private_key_.Get(index);
}
inline const ::sync_pb::CrossUserSharingPrivateKey& EncryptionKeys::cross_user_sharing_private_key(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.EncryptionKeys.cross_user_sharing_private_key)
    return _internal_cross_user_sharing_private_key(index);
}
inline ::sync_pb::CrossUserSharingPrivateKey* EncryptionKeys::_internal_add_cross_user_sharing_private_key()
{
    return _impl_.cross_user_sharing_private_key_.Add();
}
inline ::sync_pb::CrossUserSharingPrivateKey* EncryptionKeys::add_cross_user_sharing_private_key()
{
    ::sync_pb::CrossUserSharingPrivateKey* _add = _internal_add_cross_user_sharing_private_key();
    // @@protoc_insertion_point(field_add:sync_pb.EncryptionKeys.cross_user_sharing_private_key)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CrossUserSharingPrivateKey>& EncryptionKeys::cross_user_sharing_private_key() const
{
    // @@protoc_insertion_point(field_list:sync_pb.EncryptionKeys.cross_user_sharing_private_key)
    return _impl_.cross_user_sharing_private_key_;
}

// -------------------------------------------------------------------

// NigoriKeyBag

// repeated .sync_pb.NigoriKey key = 2;
inline int NigoriKeyBag::_internal_key_size() const
{
    return _impl_.key_.size();
}
inline int NigoriKeyBag::key_size() const
{
    return _internal_key_size();
}
inline void NigoriKeyBag::clear_key()
{
    _impl_.key_.Clear();
}
inline ::sync_pb::NigoriKey* NigoriKeyBag::mutable_key(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriKeyBag.key)
    return _impl_.key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey>* NigoriKeyBag::mutable_key()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.NigoriKeyBag.key)
    return &_impl_.key_;
}
inline const ::sync_pb::NigoriKey& NigoriKeyBag::_internal_key(int index) const
{
    return _impl_.key_.Get(index);
}
inline const ::sync_pb::NigoriKey& NigoriKeyBag::key(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriKeyBag.key)
    return _internal_key(index);
}
inline ::sync_pb::NigoriKey* NigoriKeyBag::_internal_add_key()
{
    return _impl_.key_.Add();
}
inline ::sync_pb::NigoriKey* NigoriKeyBag::add_key()
{
    ::sync_pb::NigoriKey* _add = _internal_add_key();
    // @@protoc_insertion_point(field_add:sync_pb.NigoriKeyBag.key)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NigoriKey>& NigoriKeyBag::key() const
{
    // @@protoc_insertion_point(field_list:sync_pb.NigoriKeyBag.key)
    return _impl_.key_;
}

// -------------------------------------------------------------------

// TrustedVaultAutoUpgradeExperimentGroup

// optional int32 cohort = 1;
inline bool TrustedVaultAutoUpgradeExperimentGroup::_internal_has_cohort() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TrustedVaultAutoUpgradeExperimentGroup::has_cohort() const
{
    return _internal_has_cohort();
}
inline void TrustedVaultAutoUpgradeExperimentGroup::clear_cohort()
{
    _impl_.cohort_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t TrustedVaultAutoUpgradeExperimentGroup::_internal_cohort() const
{
    return _impl_.cohort_;
}
inline int32_t TrustedVaultAutoUpgradeExperimentGroup::cohort() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TrustedVaultAutoUpgradeExperimentGroup.cohort)
    return _internal_cohort();
}
inline void TrustedVaultAutoUpgradeExperimentGroup::_internal_set_cohort(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cohort_ = value;
}
inline void TrustedVaultAutoUpgradeExperimentGroup::set_cohort(int32_t value)
{
    _internal_set_cohort(value);
    // @@protoc_insertion_point(field_set:sync_pb.TrustedVaultAutoUpgradeExperimentGroup.cohort)
}

// optional .sync_pb.TrustedVaultAutoUpgradeExperimentGroup.Type type = 2;
inline bool TrustedVaultAutoUpgradeExperimentGroup::_internal_has_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool TrustedVaultAutoUpgradeExperimentGroup::has_type() const
{
    return _internal_has_type();
}
inline void TrustedVaultAutoUpgradeExperimentGroup::clear_type()
{
    _impl_.type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type TrustedVaultAutoUpgradeExperimentGroup::_internal_type() const
{
    return static_cast<::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type>(_impl_.type_);
}
inline ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type TrustedVaultAutoUpgradeExperimentGroup::type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TrustedVaultAutoUpgradeExperimentGroup.type)
    return _internal_type();
}
inline void TrustedVaultAutoUpgradeExperimentGroup::_internal_set_type(::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type value)
{
    assert(::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.type_ = value;
}
inline void TrustedVaultAutoUpgradeExperimentGroup::set_type(::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.TrustedVaultAutoUpgradeExperimentGroup.type)
}

// optional int32 type_index = 3;
inline bool TrustedVaultAutoUpgradeExperimentGroup::_internal_has_type_index() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool TrustedVaultAutoUpgradeExperimentGroup::has_type_index() const
{
    return _internal_has_type_index();
}
inline void TrustedVaultAutoUpgradeExperimentGroup::clear_type_index()
{
    _impl_.type_index_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t TrustedVaultAutoUpgradeExperimentGroup::_internal_type_index() const
{
    return _impl_.type_index_;
}
inline int32_t TrustedVaultAutoUpgradeExperimentGroup::type_index() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TrustedVaultAutoUpgradeExperimentGroup.type_index)
    return _internal_type_index();
}
inline void TrustedVaultAutoUpgradeExperimentGroup::_internal_set_type_index(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.type_index_ = value;
}
inline void TrustedVaultAutoUpgradeExperimentGroup::set_type_index(int32_t value)
{
    _internal_set_type_index(value);
    // @@protoc_insertion_point(field_set:sync_pb.TrustedVaultAutoUpgradeExperimentGroup.type_index)
}

// -------------------------------------------------------------------

// NigoriSpecifics_TrustedVaultDebugInfo

// optional int64 migration_time = 1;
inline bool NigoriSpecifics_TrustedVaultDebugInfo::_internal_has_migration_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool NigoriSpecifics_TrustedVaultDebugInfo::has_migration_time() const
{
    return _internal_has_migration_time();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::clear_migration_time()
{
    _impl_.migration_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t NigoriSpecifics_TrustedVaultDebugInfo::_internal_migration_time() const
{
    return _impl_.migration_time_;
}
inline int64_t NigoriSpecifics_TrustedVaultDebugInfo::migration_time() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.migration_time)
    return _internal_migration_time();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::_internal_set_migration_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.migration_time_ = value;
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::set_migration_time(int64_t value)
{
    _internal_set_migration_time(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.migration_time)
}

// optional int32 key_version = 2;
inline bool NigoriSpecifics_TrustedVaultDebugInfo::_internal_has_key_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool NigoriSpecifics_TrustedVaultDebugInfo::has_key_version() const
{
    return _internal_has_key_version();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::clear_key_version()
{
    _impl_.key_version_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t NigoriSpecifics_TrustedVaultDebugInfo::_internal_key_version() const
{
    return _impl_.key_version_;
}
inline int32_t NigoriSpecifics_TrustedVaultDebugInfo::key_version() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.key_version)
    return _internal_key_version();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::_internal_set_key_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.key_version_ = value;
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::set_key_version(int32_t value)
{
    _internal_set_key_version(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.key_version)
}

// optional .sync_pb.TrustedVaultAutoUpgradeExperimentGroup auto_upgrade_experiment_group = 5;
inline bool NigoriSpecifics_TrustedVaultDebugInfo::_internal_has_auto_upgrade_experiment_group() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.auto_upgrade_experiment_group_ != nullptr);
    return value;
}
inline bool NigoriSpecifics_TrustedVaultDebugInfo::has_auto_upgrade_experiment_group() const
{
    return _internal_has_auto_upgrade_experiment_group();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::clear_auto_upgrade_experiment_group()
{
    if (_impl_.auto_upgrade_experiment_group_ != nullptr)
        _impl_.auto_upgrade_experiment_group_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup& NigoriSpecifics_TrustedVaultDebugInfo::_internal_auto_upgrade_experiment_group() const
{
    const ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* p = _impl_.auto_upgrade_experiment_group_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup&>(::sync_pb::_TrustedVaultAutoUpgradeExperimentGroup_default_instance_);
}
inline const ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup& NigoriSpecifics_TrustedVaultDebugInfo::auto_upgrade_experiment_group() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.auto_upgrade_experiment_group)
    return _internal_auto_upgrade_experiment_group();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::unsafe_arena_set_allocated_auto_upgrade_experiment_group(
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* auto_upgrade_experiment_group)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.auto_upgrade_experiment_group_);
    }
    _impl_.auto_upgrade_experiment_group_ = auto_upgrade_experiment_group;
    if (auto_upgrade_experiment_group) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.auto_upgrade_experiment_group)
}
inline ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* NigoriSpecifics_TrustedVaultDebugInfo::release_auto_upgrade_experiment_group()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* temp = _impl_.auto_upgrade_experiment_group_;
    _impl_.auto_upgrade_experiment_group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* NigoriSpecifics_TrustedVaultDebugInfo::unsafe_arena_release_auto_upgrade_experiment_group()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.auto_upgrade_experiment_group)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* temp = _impl_.auto_upgrade_experiment_group_;
    _impl_.auto_upgrade_experiment_group_ = nullptr;
    return temp;
}
inline ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* NigoriSpecifics_TrustedVaultDebugInfo::_internal_mutable_auto_upgrade_experiment_group()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.auto_upgrade_experiment_group_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::TrustedVaultAutoUpgradeExperimentGroup>(GetArenaForAllocation());
        _impl_.auto_upgrade_experiment_group_ = p;
    }
    return _impl_.auto_upgrade_experiment_group_;
}
inline ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* NigoriSpecifics_TrustedVaultDebugInfo::mutable_auto_upgrade_experiment_group()
{
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* _msg = _internal_mutable_auto_upgrade_experiment_group();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.auto_upgrade_experiment_group)
    return _msg;
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::set_allocated_auto_upgrade_experiment_group(
    ::sync_pb::TrustedVaultAutoUpgradeExperimentGroup* auto_upgrade_experiment_group)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.auto_upgrade_experiment_group_;
    }
    if (auto_upgrade_experiment_group) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(auto_upgrade_experiment_group);
        if (message_arena != submessage_arena) {
            auto_upgrade_experiment_group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, auto_upgrade_experiment_group, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.auto_upgrade_experiment_group_ = auto_upgrade_experiment_group;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.auto_upgrade_experiment_group)
}

// optional int64 auto_upgrade_experiment_group_modification_time_unix_epoch_millis = 6;
inline bool NigoriSpecifics_TrustedVaultDebugInfo::_internal_has_auto_upgrade_experiment_group_modification_time_unix_epoch_millis() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool NigoriSpecifics_TrustedVaultDebugInfo::has_auto_upgrade_experiment_group_modification_time_unix_epoch_millis() const
{
    return _internal_has_auto_upgrade_experiment_group_modification_time_unix_epoch_millis();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::clear_auto_upgrade_experiment_group_modification_time_unix_epoch_millis()
{
    _impl_.auto_upgrade_experiment_group_modification_time_unix_epoch_millis_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t NigoriSpecifics_TrustedVaultDebugInfo::_internal_auto_upgrade_experiment_group_modification_time_unix_epoch_millis() const
{
    return _impl_.auto_upgrade_experiment_group_modification_time_unix_epoch_millis_;
}
inline int64_t NigoriSpecifics_TrustedVaultDebugInfo::auto_upgrade_experiment_group_modification_time_unix_epoch_millis() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.auto_upgrade_experiment_group_modification_time_unix_epoch_millis)
    return _internal_auto_upgrade_experiment_group_modification_time_unix_epoch_millis();
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::_internal_set_auto_upgrade_experiment_group_modification_time_unix_epoch_millis(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.auto_upgrade_experiment_group_modification_time_unix_epoch_millis_ = value;
}
inline void NigoriSpecifics_TrustedVaultDebugInfo::set_auto_upgrade_experiment_group_modification_time_unix_epoch_millis(int64_t value)
{
    _internal_set_auto_upgrade_experiment_group_modification_time_unix_epoch_millis(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo.auto_upgrade_experiment_group_modification_time_unix_epoch_millis)
}

// -------------------------------------------------------------------

// NigoriSpecifics

// optional .sync_pb.EncryptedData encryption_keybag = 1;
inline bool NigoriSpecifics::_internal_has_encryption_keybag() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.encryption_keybag_ != nullptr);
    return value;
}
inline bool NigoriSpecifics::has_encryption_keybag() const
{
    return _internal_has_encryption_keybag();
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::_internal_encryption_keybag() const
{
    const ::sync_pb::EncryptedData* p = _impl_.encryption_keybag_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::EncryptedData&>(::sync_pb::_EncryptedData_default_instance_);
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::encryption_keybag() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encryption_keybag)
    return _internal_encryption_keybag();
}
inline void NigoriSpecifics::unsafe_arena_set_allocated_encryption_keybag(::sync_pb::EncryptedData* encryption_keybag)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_keybag_);
    }
    _impl_.encryption_keybag_ = encryption_keybag;
    if (encryption_keybag) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.NigoriSpecifics.encryption_keybag)
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::release_encryption_keybag()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::sync_pb::EncryptedData* temp = _impl_.encryption_keybag_;
    _impl_.encryption_keybag_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::unsafe_arena_release_encryption_keybag()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.encryption_keybag)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::sync_pb::EncryptedData* temp = _impl_.encryption_keybag_;
    _impl_.encryption_keybag_ = nullptr;
    return temp;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::_internal_mutable_encryption_keybag()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.encryption_keybag_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::EncryptedData>(GetArenaForAllocation());
        _impl_.encryption_keybag_ = p;
    }
    return _impl_.encryption_keybag_;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::mutable_encryption_keybag()
{
    ::sync_pb::EncryptedData* _msg = _internal_mutable_encryption_keybag();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.encryption_keybag)
    return _msg;
}
inline void NigoriSpecifics::set_allocated_encryption_keybag(::sync_pb::EncryptedData* encryption_keybag)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.encryption_keybag_);
    }
    if (encryption_keybag) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(encryption_keybag));
        if (message_arena != submessage_arena) {
            encryption_keybag = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, encryption_keybag, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.encryption_keybag_ = encryption_keybag;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.encryption_keybag)
}

// optional bool keybag_is_frozen = 2;
inline bool NigoriSpecifics::_internal_has_keybag_is_frozen() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_keybag_is_frozen() const
{
    return _internal_has_keybag_is_frozen();
}
inline void NigoriSpecifics::clear_keybag_is_frozen()
{
    _impl_.keybag_is_frozen_ = false;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool NigoriSpecifics::_internal_keybag_is_frozen() const
{
    return _impl_.keybag_is_frozen_;
}
inline bool NigoriSpecifics::keybag_is_frozen() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.keybag_is_frozen)
    return _internal_keybag_is_frozen();
}
inline void NigoriSpecifics::_internal_set_keybag_is_frozen(bool value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.keybag_is_frozen_ = value;
}
inline void NigoriSpecifics::set_keybag_is_frozen(bool value)
{
    _internal_set_keybag_is_frozen(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.keybag_is_frozen)
}

// optional bool encrypt_everything = 24;
inline bool NigoriSpecifics::_internal_has_encrypt_everything() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_encrypt_everything() const
{
    return _internal_has_encrypt_everything();
}
inline void NigoriSpecifics::clear_encrypt_everything()
{
    _impl_.encrypt_everything_ = false;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool NigoriSpecifics::_internal_encrypt_everything() const
{
    return _impl_.encrypt_everything_;
}
inline bool NigoriSpecifics::encrypt_everything() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.encrypt_everything)
    return _internal_encrypt_everything();
}
inline void NigoriSpecifics::_internal_set_encrypt_everything(bool value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.encrypt_everything_ = value;
}
inline void NigoriSpecifics::set_encrypt_everything(bool value)
{
    _internal_set_encrypt_everything(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.encrypt_everything)
}

// optional bool sync_tab_favicons = 29;
inline bool NigoriSpecifics::_internal_has_sync_tab_favicons() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_sync_tab_favicons() const
{
    return _internal_has_sync_tab_favicons();
}
inline void NigoriSpecifics::clear_sync_tab_favicons()
{
    _impl_.sync_tab_favicons_ = false;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool NigoriSpecifics::_internal_sync_tab_favicons() const
{
    return _impl_.sync_tab_favicons_;
}
inline bool NigoriSpecifics::sync_tab_favicons() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.sync_tab_favicons)
    return _internal_sync_tab_favicons();
}
inline void NigoriSpecifics::_internal_set_sync_tab_favicons(bool value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.sync_tab_favicons_ = value;
}
inline void NigoriSpecifics::set_sync_tab_favicons(bool value)
{
    _internal_set_sync_tab_favicons(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.sync_tab_favicons)
}

// optional int32 passphrase_type = 30 [default = 1];
inline bool NigoriSpecifics::_internal_has_passphrase_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_passphrase_type() const
{
    return _internal_has_passphrase_type();
}
inline void NigoriSpecifics::clear_passphrase_type()
{
    _impl_.passphrase_type_ = 1;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline int32_t NigoriSpecifics::_internal_passphrase_type() const
{
    return _impl_.passphrase_type_;
}
inline int32_t NigoriSpecifics::passphrase_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.passphrase_type)
    return _internal_passphrase_type();
}
inline void NigoriSpecifics::_internal_set_passphrase_type(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.passphrase_type_ = value;
}
inline void NigoriSpecifics::set_passphrase_type(int32_t value)
{
    _internal_set_passphrase_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.passphrase_type)
}

// optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
inline bool NigoriSpecifics::_internal_has_keystore_decryptor_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.keystore_decryptor_token_ != nullptr);
    return value;
}
inline bool NigoriSpecifics::has_keystore_decryptor_token() const
{
    return _internal_has_keystore_decryptor_token();
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::_internal_keystore_decryptor_token() const
{
    const ::sync_pb::EncryptedData* p = _impl_.keystore_decryptor_token_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::EncryptedData&>(::sync_pb::_EncryptedData_default_instance_);
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::keystore_decryptor_token() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.keystore_decryptor_token)
    return _internal_keystore_decryptor_token();
}
inline void NigoriSpecifics::unsafe_arena_set_allocated_keystore_decryptor_token(::sync_pb::EncryptedData* keystore_decryptor_token)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keystore_decryptor_token_);
    }
    _impl_.keystore_decryptor_token_ = keystore_decryptor_token;
    if (keystore_decryptor_token) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.NigoriSpecifics.keystore_decryptor_token)
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::release_keystore_decryptor_token()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::EncryptedData* temp = _impl_.keystore_decryptor_token_;
    _impl_.keystore_decryptor_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::unsafe_arena_release_keystore_decryptor_token()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.keystore_decryptor_token)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::EncryptedData* temp = _impl_.keystore_decryptor_token_;
    _impl_.keystore_decryptor_token_ = nullptr;
    return temp;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::_internal_mutable_keystore_decryptor_token()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.keystore_decryptor_token_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::EncryptedData>(GetArenaForAllocation());
        _impl_.keystore_decryptor_token_ = p;
    }
    return _impl_.keystore_decryptor_token_;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::mutable_keystore_decryptor_token()
{
    ::sync_pb::EncryptedData* _msg = _internal_mutable_keystore_decryptor_token();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.keystore_decryptor_token)
    return _msg;
}
inline void NigoriSpecifics::set_allocated_keystore_decryptor_token(::sync_pb::EncryptedData* keystore_decryptor_token)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.keystore_decryptor_token_);
    }
    if (keystore_decryptor_token) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keystore_decryptor_token));
        if (message_arena != submessage_arena) {
            keystore_decryptor_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, keystore_decryptor_token, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.keystore_decryptor_token_ = keystore_decryptor_token;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.keystore_decryptor_token)
}

// optional int64 keystore_migration_time = 32;
inline bool NigoriSpecifics::_internal_has_keystore_migration_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_keystore_migration_time() const
{
    return _internal_has_keystore_migration_time();
}
inline void NigoriSpecifics::clear_keystore_migration_time()
{
    _impl_.keystore_migration_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t NigoriSpecifics::_internal_keystore_migration_time() const
{
    return _impl_.keystore_migration_time_;
}
inline int64_t NigoriSpecifics::keystore_migration_time() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.keystore_migration_time)
    return _internal_keystore_migration_time();
}
inline void NigoriSpecifics::_internal_set_keystore_migration_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.keystore_migration_time_ = value;
}
inline void NigoriSpecifics::set_keystore_migration_time(int64_t value)
{
    _internal_set_keystore_migration_time(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.keystore_migration_time)
}

// optional int64 custom_passphrase_time = 33;
inline bool NigoriSpecifics::_internal_has_custom_passphrase_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_custom_passphrase_time() const
{
    return _internal_has_custom_passphrase_time();
}
inline void NigoriSpecifics::clear_custom_passphrase_time()
{
    _impl_.custom_passphrase_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t NigoriSpecifics::_internal_custom_passphrase_time() const
{
    return _impl_.custom_passphrase_time_;
}
inline int64_t NigoriSpecifics::custom_passphrase_time() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.custom_passphrase_time)
    return _internal_custom_passphrase_time();
}
inline void NigoriSpecifics::_internal_set_custom_passphrase_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.custom_passphrase_time_ = value;
}
inline void NigoriSpecifics::set_custom_passphrase_time(int64_t value)
{
    _internal_set_custom_passphrase_time(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.custom_passphrase_time)
}

// optional bool server_only_was_missing_keystore_migration_time = 40;
inline bool NigoriSpecifics::_internal_has_server_only_was_missing_keystore_migration_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_server_only_was_missing_keystore_migration_time() const
{
    return _internal_has_server_only_was_missing_keystore_migration_time();
}
inline void NigoriSpecifics::clear_server_only_was_missing_keystore_migration_time()
{
    _impl_.server_only_was_missing_keystore_migration_time_ = false;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool NigoriSpecifics::_internal_server_only_was_missing_keystore_migration_time() const
{
    return _impl_.server_only_was_missing_keystore_migration_time_;
}
inline bool NigoriSpecifics::server_only_was_missing_keystore_migration_time() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.server_only_was_missing_keystore_migration_time)
    return _internal_server_only_was_missing_keystore_migration_time();
}
inline void NigoriSpecifics::_internal_set_server_only_was_missing_keystore_migration_time(bool value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.server_only_was_missing_keystore_migration_time_ = value;
}
inline void NigoriSpecifics::set_server_only_was_missing_keystore_migration_time(bool value)
{
    _internal_set_server_only_was_missing_keystore_migration_time(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.server_only_was_missing_keystore_migration_time)
}

// optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];
inline bool NigoriSpecifics::_internal_has_custom_passphrase_key_derivation_method() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_custom_passphrase_key_derivation_method() const
{
    return _internal_has_custom_passphrase_key_derivation_method();
}
inline void NigoriSpecifics::clear_custom_passphrase_key_derivation_method()
{
    _impl_.custom_passphrase_key_derivation_method_ = 0;
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t NigoriSpecifics::_internal_custom_passphrase_key_derivation_method() const
{
    return _impl_.custom_passphrase_key_derivation_method_;
}
inline int32_t NigoriSpecifics::custom_passphrase_key_derivation_method() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_method)
    return _internal_custom_passphrase_key_derivation_method();
}
inline void NigoriSpecifics::_internal_set_custom_passphrase_key_derivation_method(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.custom_passphrase_key_derivation_method_ = value;
}
inline void NigoriSpecifics::set_custom_passphrase_key_derivation_method(int32_t value)
{
    _internal_set_custom_passphrase_key_derivation_method(value);
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_method)
}

// optional string custom_passphrase_key_derivation_salt = 46;
inline bool NigoriSpecifics::_internal_has_custom_passphrase_key_derivation_salt() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool NigoriSpecifics::has_custom_passphrase_key_derivation_salt() const
{
    return _internal_has_custom_passphrase_key_derivation_salt();
}
inline void NigoriSpecifics::clear_custom_passphrase_key_derivation_salt()
{
    _impl_.custom_passphrase_key_derivation_salt_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NigoriSpecifics::custom_passphrase_key_derivation_salt() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
    return _internal_custom_passphrase_key_derivation_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void NigoriSpecifics::set_custom_passphrase_key_derivation_salt(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.custom_passphrase_key_derivation_salt_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
}
inline std::string* NigoriSpecifics::mutable_custom_passphrase_key_derivation_salt()
{
    std::string* _s = _internal_mutable_custom_passphrase_key_derivation_salt();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
    return _s;
}
inline const std::string& NigoriSpecifics::_internal_custom_passphrase_key_derivation_salt() const
{
    return _impl_.custom_passphrase_key_derivation_salt_.Get();
}
inline void NigoriSpecifics::_internal_set_custom_passphrase_key_derivation_salt(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.custom_passphrase_key_derivation_salt_.Set(value, GetArenaForAllocation());
}
inline std::string* NigoriSpecifics::_internal_mutable_custom_passphrase_key_derivation_salt()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.custom_passphrase_key_derivation_salt_.Mutable(GetArenaForAllocation());
}
inline std::string* NigoriSpecifics::release_custom_passphrase_key_derivation_salt()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
    if (!_internal_has_custom_passphrase_key_derivation_salt()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.custom_passphrase_key_derivation_salt_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.custom_passphrase_key_derivation_salt_.IsDefault()) {
        _impl_.custom_passphrase_key_derivation_salt_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NigoriSpecifics::set_allocated_custom_passphrase_key_derivation_salt(std::string* custom_passphrase_key_derivation_salt)
{
    if (custom_passphrase_key_derivation_salt != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.custom_passphrase_key_derivation_salt_.SetAllocated(custom_passphrase_key_derivation_salt, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.custom_passphrase_key_derivation_salt_.IsDefault()) {
        _impl_.custom_passphrase_key_derivation_salt_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.custom_passphrase_key_derivation_salt)
}

// optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 50;
inline bool NigoriSpecifics::_internal_has_trusted_vault_debug_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.trusted_vault_debug_info_ != nullptr);
    return value;
}
inline bool NigoriSpecifics::has_trusted_vault_debug_info() const
{
    return _internal_has_trusted_vault_debug_info();
}
inline void NigoriSpecifics::clear_trusted_vault_debug_info()
{
    if (_impl_.trusted_vault_debug_info_ != nullptr)
        _impl_.trusted_vault_debug_info_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& NigoriSpecifics::_internal_trusted_vault_debug_info() const
{
    const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* p = _impl_.trusted_vault_debug_info_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo&>(::sync_pb::_NigoriSpecifics_TrustedVaultDebugInfo_default_instance_);
}
inline const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& NigoriSpecifics::trusted_vault_debug_info() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
    return _internal_trusted_vault_debug_info();
}
inline void NigoriSpecifics::unsafe_arena_set_allocated_trusted_vault_debug_info(::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.trusted_vault_debug_info_);
    }
    _impl_.trusted_vault_debug_info_ = trusted_vault_debug_info;
    if (trusted_vault_debug_info) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
}
inline ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* NigoriSpecifics::release_trusted_vault_debug_info()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* temp = _impl_.trusted_vault_debug_info_;
    _impl_.trusted_vault_debug_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* NigoriSpecifics::unsafe_arena_release_trusted_vault_debug_info()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* temp = _impl_.trusted_vault_debug_info_;
    _impl_.trusted_vault_debug_info_ = nullptr;
    return temp;
}
inline ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* NigoriSpecifics::_internal_mutable_trusted_vault_debug_info()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.trusted_vault_debug_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo>(GetArenaForAllocation());
        _impl_.trusted_vault_debug_info_ = p;
    }
    return _impl_.trusted_vault_debug_info_;
}
inline ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* NigoriSpecifics::mutable_trusted_vault_debug_info()
{
    ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* _msg = _internal_mutable_trusted_vault_debug_info();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
    return _msg;
}
inline void NigoriSpecifics::set_allocated_trusted_vault_debug_info(::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo* trusted_vault_debug_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.trusted_vault_debug_info_;
    }
    if (trusted_vault_debug_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trusted_vault_debug_info);
        if (message_arena != submessage_arena) {
            trusted_vault_debug_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, trusted_vault_debug_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.trusted_vault_debug_info_ = trusted_vault_debug_info;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.trusted_vault_debug_info)
}

// optional .sync_pb.CrossUserSharingPublicKey cross_user_sharing_public_key = 53;
inline bool NigoriSpecifics::_internal_has_cross_user_sharing_public_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.cross_user_sharing_public_key_ != nullptr);
    return value;
}
inline bool NigoriSpecifics::has_cross_user_sharing_public_key() const
{
    return _internal_has_cross_user_sharing_public_key();
}
inline void NigoriSpecifics::clear_cross_user_sharing_public_key()
{
    if (_impl_.cross_user_sharing_public_key_ != nullptr)
        _impl_.cross_user_sharing_public_key_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::sync_pb::CrossUserSharingPublicKey& NigoriSpecifics::_internal_cross_user_sharing_public_key() const
{
    const ::sync_pb::CrossUserSharingPublicKey* p = _impl_.cross_user_sharing_public_key_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::CrossUserSharingPublicKey&>(::sync_pb::_CrossUserSharingPublicKey_default_instance_);
}
inline const ::sync_pb::CrossUserSharingPublicKey& NigoriSpecifics::cross_user_sharing_public_key() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NigoriSpecifics.cross_user_sharing_public_key)
    return _internal_cross_user_sharing_public_key();
}
inline void NigoriSpecifics::unsafe_arena_set_allocated_cross_user_sharing_public_key(::sync_pb::CrossUserSharingPublicKey* cross_user_sharing_public_key)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cross_user_sharing_public_key_);
    }
    _impl_.cross_user_sharing_public_key_ = cross_user_sharing_public_key;
    if (cross_user_sharing_public_key) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.NigoriSpecifics.cross_user_sharing_public_key)
}
inline ::sync_pb::CrossUserSharingPublicKey* NigoriSpecifics::release_cross_user_sharing_public_key()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::sync_pb::CrossUserSharingPublicKey* temp = _impl_.cross_user_sharing_public_key_;
    _impl_.cross_user_sharing_public_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::CrossUserSharingPublicKey* NigoriSpecifics::unsafe_arena_release_cross_user_sharing_public_key()
{
    // @@protoc_insertion_point(field_release:sync_pb.NigoriSpecifics.cross_user_sharing_public_key)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::sync_pb::CrossUserSharingPublicKey* temp = _impl_.cross_user_sharing_public_key_;
    _impl_.cross_user_sharing_public_key_ = nullptr;
    return temp;
}
inline ::sync_pb::CrossUserSharingPublicKey* NigoriSpecifics::_internal_mutable_cross_user_sharing_public_key()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.cross_user_sharing_public_key_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::CrossUserSharingPublicKey>(GetArenaForAllocation());
        _impl_.cross_user_sharing_public_key_ = p;
    }
    return _impl_.cross_user_sharing_public_key_;
}
inline ::sync_pb::CrossUserSharingPublicKey* NigoriSpecifics::mutable_cross_user_sharing_public_key()
{
    ::sync_pb::CrossUserSharingPublicKey* _msg = _internal_mutable_cross_user_sharing_public_key();
    // @@protoc_insertion_point(field_mutable:sync_pb.NigoriSpecifics.cross_user_sharing_public_key)
    return _msg;
}
inline void NigoriSpecifics::set_allocated_cross_user_sharing_public_key(::sync_pb::CrossUserSharingPublicKey* cross_user_sharing_public_key)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.cross_user_sharing_public_key_;
    }
    if (cross_user_sharing_public_key) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cross_user_sharing_public_key);
        if (message_arena != submessage_arena) {
            cross_user_sharing_public_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, cross_user_sharing_public_key, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.cross_user_sharing_public_key_ = cross_user_sharing_public_key;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NigoriSpecifics.cross_user_sharing_public_key)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace sync_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::sync_pb::TrustedVaultAutoUpgradeExperimentGroup_Type> : ::std::true_type { };
template <> struct is_proto_enum<::sync_pb::NigoriSpecifics_PassphraseType> : ::std::true_type { };
template <> struct is_proto_enum<::sync_pb::NigoriSpecifics_KeyDerivationMethod> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fnigori_5fspecifics_2eproto
