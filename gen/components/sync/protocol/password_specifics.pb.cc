// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/password_specifics.proto

#include "components/sync/protocol/password_specifics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR PasswordIssues_PasswordIssue::PasswordIssues_PasswordIssue(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.date_first_detection_windows_epoch_micros_)*/ uint64_t { 0u }, /*decltype(_impl_.is_muted_)*/ false,
        /*decltype(_impl_.trigger_notification_from_backend_on_detection_)*/ false }
{
}
struct PasswordIssues_PasswordIssueDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordIssues_PasswordIssueDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordIssues_PasswordIssueDefaultTypeInternal()
    {
    }
    union {
        PasswordIssues_PasswordIssue _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordIssues_PasswordIssueDefaultTypeInternal
    _PasswordIssues_PasswordIssue_default_instance_;
PROTOBUF_CONSTEXPR PasswordIssues::PasswordIssues(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.leaked_password_issue_)*/ nullptr,
        /*decltype(_impl_.reused_password_issue_)*/ nullptr, /*decltype(_impl_.weak_password_issue_)*/ nullptr,
        /*decltype(_impl_.phished_password_issue_)*/ nullptr }
{
}
struct PasswordIssuesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordIssuesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordIssuesDefaultTypeInternal()
    {
    }
    union {
        PasswordIssues _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordIssuesDefaultTypeInternal _PasswordIssues_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsData_Notes_Note::PasswordSpecificsData_Notes_Note(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.unique_display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.date_created_windows_epoch_micros_)*/ int64_t { 0 }, /*decltype(_impl_.hide_by_default_)*/ false }
{
}
struct PasswordSpecificsData_Notes_NoteDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordSpecificsData_Notes_NoteDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordSpecificsData_Notes_NoteDefaultTypeInternal()
    {
    }
    union {
        PasswordSpecificsData_Notes_Note _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsData_Notes_NoteDefaultTypeInternal
    _PasswordSpecificsData_Notes_Note_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsData_Notes::PasswordSpecificsData_Notes(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.note_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PasswordSpecificsData_NotesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordSpecificsData_NotesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordSpecificsData_NotesDefaultTypeInternal()
    {
    }
    union {
        PasswordSpecificsData_Notes _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsData_NotesDefaultTypeInternal
    _PasswordSpecificsData_Notes_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsData::PasswordSpecificsData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.signon_realm_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.origin_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.action_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.username_element_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.username_value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.password_element_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.password_value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.avatar_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.federation_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sender_profile_image_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.password_issues_)*/ nullptr, /*decltype(_impl_.notes_)*/ nullptr, /*decltype(_impl_.scheme_)*/ 0, /*decltype(_impl_.type_)*/ 0,
        /*decltype(_impl_.date_created_)*/ int64_t { 0 }, /*decltype(_impl_.times_used_)*/ 0, /*decltype(_impl_.ssl_valid_)*/ false,
        /*decltype(_impl_.preferred_)*/ false, /*decltype(_impl_.blacklisted_)*/ false, /*decltype(_impl_.sharing_notification_displayed_)*/ false,
        /*decltype(_impl_.date_last_used_)*/ int64_t { 0 }, /*decltype(_impl_.date_password_modified_windows_epoch_micros_)*/ int64_t { 0 },
        /*decltype(_impl_.date_received_windows_epoch_micros_)*/ int64_t { 0 } }
{
}
struct PasswordSpecificsDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordSpecificsDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordSpecificsDataDefaultTypeInternal()
    {
    }
    union {
        PasswordSpecificsData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsDataDefaultTypeInternal
    _PasswordSpecificsData_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecificsMetadata::PasswordSpecificsMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.password_issues_)*/ nullptr,
        /*decltype(_impl_.date_last_used_windows_epoch_micros_)*/ int64_t { 0 }, /*decltype(_impl_.blacklisted_)*/ false, /*decltype(_impl_.type_)*/ 0 }
{
}
struct PasswordSpecificsMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordSpecificsMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordSpecificsMetadataDefaultTypeInternal()
    {
    }
    union {
        PasswordSpecificsMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsMetadataDefaultTypeInternal
    _PasswordSpecificsMetadata_default_instance_;
PROTOBUF_CONSTEXPR PasswordSpecifics::PasswordSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.encrypted_)*/ nullptr,
        /*decltype(_impl_.client_only_encrypted_data_)*/ nullptr, /*decltype(_impl_.unencrypted_metadata_)*/ nullptr,
        /*decltype(_impl_.encrypted_notes_backup_)*/ nullptr }
{
}
struct PasswordSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PasswordSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PasswordSpecificsDefaultTypeInternal()
    {
    }
    union {
        PasswordSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PasswordSpecificsDefaultTypeInternal _PasswordSpecifics_default_instance_;
} // namespace sync_pb
namespace sync_pb {
bool PasswordSpecificsData_Scheme_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PasswordSpecificsData_Scheme_strings[5] = {};

static const char PasswordSpecificsData_Scheme_names[] = "SCHEME_BASIC"
                                                         "SCHEME_DIGEST"
                                                         "SCHEME_HTML"
                                                         "SCHEME_OTHER"
                                                         "USERNAME_ONLY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PasswordSpecificsData_Scheme_entries[] = {
    { { PasswordSpecificsData_Scheme_names + 0, 12 }, 1 },
    { { PasswordSpecificsData_Scheme_names + 12, 13 }, 2 },
    { { PasswordSpecificsData_Scheme_names + 25, 11 }, 0 },
    { { PasswordSpecificsData_Scheme_names + 36, 12 }, 3 },
    { { PasswordSpecificsData_Scheme_names + 48, 13 }, 4 },
};

static const int PasswordSpecificsData_Scheme_entries_by_number[] = {
    2, // 0 -> SCHEME_HTML
    0, // 1 -> SCHEME_BASIC
    1, // 2 -> SCHEME_DIGEST
    3, // 3 -> SCHEME_OTHER
    4, // 4 -> USERNAME_ONLY
};

const std::string& PasswordSpecificsData_Scheme_Name(PasswordSpecificsData_Scheme value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        PasswordSpecificsData_Scheme_entries, PasswordSpecificsData_Scheme_entries_by_number, 5, PasswordSpecificsData_Scheme_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(PasswordSpecificsData_Scheme_entries, PasswordSpecificsData_Scheme_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : PasswordSpecificsData_Scheme_strings[idx].get();
}
bool PasswordSpecificsData_Scheme_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PasswordSpecificsData_Scheme* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(PasswordSpecificsData_Scheme_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<PasswordSpecificsData_Scheme>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::SCHEME_HTML;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::SCHEME_BASIC;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::SCHEME_DIGEST;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::SCHEME_OTHER;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::USERNAME_ONLY;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::Scheme_MIN;
constexpr PasswordSpecificsData_Scheme PasswordSpecificsData::Scheme_MAX;
constexpr int PasswordSpecificsData::Scheme_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class PasswordIssues_PasswordIssue::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordIssues_PasswordIssue>()._impl_._has_bits_);
    static void set_has_date_first_detection_windows_epoch_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_is_muted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_trigger_notification_from_backend_on_detection(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

PasswordIssues_PasswordIssue::PasswordIssues_PasswordIssue(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordIssues.PasswordIssue)
}
PasswordIssues_PasswordIssue::PasswordIssues_PasswordIssue(const PasswordIssues_PasswordIssue& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordIssues_PasswordIssue* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.date_first_detection_windows_epoch_micros_) {}, decltype(_impl_.is_muted_) {},
        decltype(_impl_.trigger_notification_from_backend_on_detection_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.date_first_detection_windows_epoch_micros_, &from._impl_.date_first_detection_windows_epoch_micros_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.trigger_notification_from_backend_on_detection_)
            - reinterpret_cast<char*>(&_impl_.date_first_detection_windows_epoch_micros_))
            + sizeof(_impl_.trigger_notification_from_backend_on_detection_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordIssues.PasswordIssue)
}

inline void PasswordIssues_PasswordIssue::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.date_first_detection_windows_epoch_micros_) { uint64_t { 0u } }, decltype(_impl_.is_muted_) { false },
        decltype(_impl_.trigger_notification_from_backend_on_detection_) { false } };
}

PasswordIssues_PasswordIssue::~PasswordIssues_PasswordIssue()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordIssues.PasswordIssue)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordIssues_PasswordIssue::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PasswordIssues_PasswordIssue::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordIssues_PasswordIssue::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordIssues.PasswordIssue)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        ::memset(&_impl_.date_first_detection_windows_epoch_micros_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.trigger_notification_from_backend_on_detection_)
                - reinterpret_cast<char*>(&_impl_.date_first_detection_windows_epoch_micros_))
                + sizeof(_impl_.trigger_notification_from_backend_on_detection_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordIssues_PasswordIssue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional uint64 date_first_detection_windows_epoch_micros = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_date_first_detection_windows_epoch_micros(&has_bits);
                _impl_.date_first_detection_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_muted = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_is_muted(&has_bits);
                _impl_.is_muted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool trigger_notification_from_backend_on_detection = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_trigger_notification_from_backend_on_detection(&has_bits);
                _impl_.trigger_notification_from_backend_on_detection_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordIssues_PasswordIssue::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordIssues.PasswordIssue)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional uint64 date_first_detection_windows_epoch_micros = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_date_first_detection_windows_epoch_micros(), target);
    }

    // optional bool is_muted = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_muted(), target);
    }

    // optional bool trigger_notification_from_backend_on_detection = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_trigger_notification_from_backend_on_detection(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordIssues.PasswordIssue)
    return target;
}

size_t PasswordIssues_PasswordIssue::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordIssues.PasswordIssue)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional uint64 date_first_detection_windows_epoch_micros = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_date_first_detection_windows_epoch_micros());
        }

        // optional bool is_muted = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 1;
        }

        // optional bool trigger_notification_from_backend_on_detection = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordIssues_PasswordIssue::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordIssues_PasswordIssue*>(&from));
}

void PasswordIssues_PasswordIssue::MergeFrom(const PasswordIssues_PasswordIssue& from)
{
    PasswordIssues_PasswordIssue* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordIssues.PasswordIssue)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.date_first_detection_windows_epoch_micros_ = from._impl_.date_first_detection_windows_epoch_micros_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.is_muted_ = from._impl_.is_muted_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.trigger_notification_from_backend_on_detection_ = from._impl_.trigger_notification_from_backend_on_detection_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordIssues_PasswordIssue::CopyFrom(const PasswordIssues_PasswordIssue& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordIssues.PasswordIssue)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordIssues_PasswordIssue::IsInitialized() const
{
    return true;
}

void PasswordIssues_PasswordIssue::InternalSwap(PasswordIssues_PasswordIssue* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PasswordIssues_PasswordIssue, _impl_.trigger_notification_from_backend_on_detection_)
        + sizeof(PasswordIssues_PasswordIssue::_impl_.trigger_notification_from_backend_on_detection_)
        - PROTOBUF_FIELD_OFFSET(PasswordIssues_PasswordIssue, _impl_.date_first_detection_windows_epoch_micros_)>(
        reinterpret_cast<char*>(&_impl_.date_first_detection_windows_epoch_micros_),
        reinterpret_cast<char*>(&other->_impl_.date_first_detection_windows_epoch_micros_));
}

std::string PasswordIssues_PasswordIssue::GetTypeName() const
{
    return "sync_pb.PasswordIssues.PasswordIssue";
}

// ===================================================================

class PasswordIssues::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordIssues>()._impl_._has_bits_);
    static const ::sync_pb::PasswordIssues_PasswordIssue& leaked_password_issue(const PasswordIssues* msg);
    static void set_has_leaked_password_issue(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::PasswordIssues_PasswordIssue& reused_password_issue(const PasswordIssues* msg);
    static void set_has_reused_password_issue(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::PasswordIssues_PasswordIssue& weak_password_issue(const PasswordIssues* msg);
    static void set_has_weak_password_issue(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::sync_pb::PasswordIssues_PasswordIssue& phished_password_issue(const PasswordIssues* msg);
    static void set_has_phished_password_issue(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::sync_pb::PasswordIssues_PasswordIssue& PasswordIssues::_Internal::leaked_password_issue(const PasswordIssues* msg)
{
    return *msg->_impl_.leaked_password_issue_;
}
const ::sync_pb::PasswordIssues_PasswordIssue& PasswordIssues::_Internal::reused_password_issue(const PasswordIssues* msg)
{
    return *msg->_impl_.reused_password_issue_;
}
const ::sync_pb::PasswordIssues_PasswordIssue& PasswordIssues::_Internal::weak_password_issue(const PasswordIssues* msg)
{
    return *msg->_impl_.weak_password_issue_;
}
const ::sync_pb::PasswordIssues_PasswordIssue& PasswordIssues::_Internal::phished_password_issue(const PasswordIssues* msg)
{
    return *msg->_impl_.phished_password_issue_;
}
PasswordIssues::PasswordIssues(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordIssues)
}
PasswordIssues::PasswordIssues(const PasswordIssues& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordIssues* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.leaked_password_issue_) { nullptr }, decltype(_impl_.reused_password_issue_) { nullptr },
        decltype(_impl_.weak_password_issue_) { nullptr }, decltype(_impl_.phished_password_issue_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_leaked_password_issue()) {
        _this->_impl_.leaked_password_issue_ = new ::sync_pb::PasswordIssues_PasswordIssue(*from._impl_.leaked_password_issue_);
    }
    if (from._internal_has_reused_password_issue()) {
        _this->_impl_.reused_password_issue_ = new ::sync_pb::PasswordIssues_PasswordIssue(*from._impl_.reused_password_issue_);
    }
    if (from._internal_has_weak_password_issue()) {
        _this->_impl_.weak_password_issue_ = new ::sync_pb::PasswordIssues_PasswordIssue(*from._impl_.weak_password_issue_);
    }
    if (from._internal_has_phished_password_issue()) {
        _this->_impl_.phished_password_issue_ = new ::sync_pb::PasswordIssues_PasswordIssue(*from._impl_.phished_password_issue_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordIssues)
}

inline void PasswordIssues::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.leaked_password_issue_) { nullptr },
        decltype(_impl_.reused_password_issue_) { nullptr }, decltype(_impl_.weak_password_issue_) { nullptr },
        decltype(_impl_.phished_password_issue_) { nullptr } };
}

PasswordIssues::~PasswordIssues()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordIssues)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordIssues::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.leaked_password_issue_;
    if (this != internal_default_instance())
        delete _impl_.reused_password_issue_;
    if (this != internal_default_instance())
        delete _impl_.weak_password_issue_;
    if (this != internal_default_instance())
        delete _impl_.phished_password_issue_;
}

void PasswordIssues::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordIssues::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordIssues)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.leaked_password_issue_ != nullptr);
            _impl_.leaked_password_issue_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.reused_password_issue_ != nullptr);
            _impl_.reused_password_issue_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.weak_password_issue_ != nullptr);
            _impl_.weak_password_issue_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.phished_password_issue_ != nullptr);
            _impl_.phished_password_issue_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordIssues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.PasswordIssues.PasswordIssue leaked_password_issue = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_leaked_password_issue(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordIssues.PasswordIssue reused_password_issue = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_reused_password_issue(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordIssues.PasswordIssue weak_password_issue = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_weak_password_issue(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordIssues.PasswordIssue phished_password_issue = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_phished_password_issue(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordIssues::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordIssues)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.PasswordIssues.PasswordIssue leaked_password_issue = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::leaked_password_issue(this), _Internal::leaked_password_issue(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PasswordIssues.PasswordIssue reused_password_issue = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::reused_password_issue(this), _Internal::reused_password_issue(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PasswordIssues.PasswordIssue weak_password_issue = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::weak_password_issue(this), _Internal::weak_password_issue(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PasswordIssues.PasswordIssue phished_password_issue = 4;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::phished_password_issue(this), _Internal::phished_password_issue(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordIssues)
    return target;
}

size_t PasswordIssues::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordIssues)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .sync_pb.PasswordIssues.PasswordIssue leaked_password_issue = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.leaked_password_issue_);
        }

        // optional .sync_pb.PasswordIssues.PasswordIssue reused_password_issue = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.reused_password_issue_);
        }

        // optional .sync_pb.PasswordIssues.PasswordIssue weak_password_issue = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.weak_password_issue_);
        }

        // optional .sync_pb.PasswordIssues.PasswordIssue phished_password_issue = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.phished_password_issue_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordIssues::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordIssues*>(&from));
}

void PasswordIssues::MergeFrom(const PasswordIssues& from)
{
    PasswordIssues* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordIssues)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_leaked_password_issue()->::sync_pb::PasswordIssues_PasswordIssue::MergeFrom(from._internal_leaked_password_issue());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_reused_password_issue()->::sync_pb::PasswordIssues_PasswordIssue::MergeFrom(from._internal_reused_password_issue());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_weak_password_issue()->::sync_pb::PasswordIssues_PasswordIssue::MergeFrom(from._internal_weak_password_issue());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_phished_password_issue()->::sync_pb::PasswordIssues_PasswordIssue::MergeFrom(from._internal_phished_password_issue());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordIssues::CopyFrom(const PasswordIssues& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordIssues)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordIssues::IsInitialized() const
{
    return true;
}

void PasswordIssues::InternalSwap(PasswordIssues* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PasswordIssues, _impl_.phished_password_issue_)
        + sizeof(PasswordIssues::_impl_.phished_password_issue_) - PROTOBUF_FIELD_OFFSET(PasswordIssues, _impl_.leaked_password_issue_)>(
        reinterpret_cast<char*>(&_impl_.leaked_password_issue_), reinterpret_cast<char*>(&other->_impl_.leaked_password_issue_));
}

std::string PasswordIssues::GetTypeName() const
{
    return "sync_pb.PasswordIssues";
}

// ===================================================================

class PasswordSpecificsData_Notes_Note::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordSpecificsData_Notes_Note>()._impl_._has_bits_);
    static void set_has_unique_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_date_created_windows_epoch_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_hide_by_default(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

PasswordSpecificsData_Notes_Note::PasswordSpecificsData_Notes_Note(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsData.Notes.Note)
}
PasswordSpecificsData_Notes_Note::PasswordSpecificsData_Notes_Note(const PasswordSpecificsData_Notes_Note& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordSpecificsData_Notes_Note* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.unique_display_name_) {},
            decltype(_impl_.value_) {}, decltype(_impl_.date_created_windows_epoch_micros_) {}, decltype(_impl_.hide_by_default_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.unique_display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unique_display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_unique_display_name()) {
        _this->_impl_.unique_display_name_.Set(from._internal_unique_display_name(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.date_created_windows_epoch_micros_, &from._impl_.date_created_windows_epoch_micros_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hide_by_default_) - reinterpret_cast<char*>(&_impl_.date_created_windows_epoch_micros_))
            + sizeof(_impl_.hide_by_default_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsData.Notes.Note)
}

inline void PasswordSpecificsData_Notes_Note::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.unique_display_name_) {},
        decltype(_impl_.value_) {}, decltype(_impl_.date_created_windows_epoch_micros_) { int64_t { 0 } }, decltype(_impl_.hide_by_default_) { false } };
    _impl_.unique_display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unique_display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PasswordSpecificsData_Notes_Note::~PasswordSpecificsData_Notes_Note()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsData.Notes.Note)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordSpecificsData_Notes_Note::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.unique_display_name_.Destroy();
    _impl_.value_.Destroy();
}

void PasswordSpecificsData_Notes_Note::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordSpecificsData_Notes_Note::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsData.Notes.Note)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.unique_display_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.value_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.date_created_windows_epoch_micros_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.hide_by_default_) - reinterpret_cast<char*>(&_impl_.date_created_windows_epoch_micros_))
                + sizeof(_impl_.hide_by_default_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsData_Notes_Note::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string unique_display_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_unique_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 date_created_windows_epoch_micros = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_date_created_windows_epoch_micros(&has_bits);
                _impl_.date_created_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool hide_by_default = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_hide_by_default(&has_bits);
                _impl_.hide_by_default_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsData_Notes_Note::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsData.Notes.Note)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string unique_display_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_unique_display_name(), target);
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_value(), target);
    }

    // optional int64 date_created_windows_epoch_micros = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_date_created_windows_epoch_micros(), target);
    }

    // optional bool hide_by_default = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_hide_by_default(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsData.Notes.Note)
    return target;
}

size_t PasswordSpecificsData_Notes_Note::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsData.Notes.Note)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string unique_display_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_unique_display_name());
        }

        // optional string value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
        }

        // optional int64 date_created_windows_epoch_micros = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_date_created_windows_epoch_micros());
        }

        // optional bool hide_by_default = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordSpecificsData_Notes_Note::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordSpecificsData_Notes_Note*>(&from));
}

void PasswordSpecificsData_Notes_Note::MergeFrom(const PasswordSpecificsData_Notes_Note& from)
{
    PasswordSpecificsData_Notes_Note* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsData.Notes.Note)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_unique_display_name(from._internal_unique_display_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_value(from._internal_value());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.date_created_windows_epoch_micros_ = from._impl_.date_created_windows_epoch_micros_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.hide_by_default_ = from._impl_.hide_by_default_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsData_Notes_Note::CopyFrom(const PasswordSpecificsData_Notes_Note& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsData.Notes.Note)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordSpecificsData_Notes_Note::IsInitialized() const
{
    return true;
}

void PasswordSpecificsData_Notes_Note::InternalSwap(PasswordSpecificsData_Notes_Note* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.unique_display_name_, lhs_arena, &other->_impl_.unique_display_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PasswordSpecificsData_Notes_Note, _impl_.hide_by_default_)
        + sizeof(PasswordSpecificsData_Notes_Note::_impl_.hide_by_default_)
        - PROTOBUF_FIELD_OFFSET(PasswordSpecificsData_Notes_Note, _impl_.date_created_windows_epoch_micros_)>(
        reinterpret_cast<char*>(&_impl_.date_created_windows_epoch_micros_), reinterpret_cast<char*>(&other->_impl_.date_created_windows_epoch_micros_));
}

std::string PasswordSpecificsData_Notes_Note::GetTypeName() const
{
    return "sync_pb.PasswordSpecificsData.Notes.Note";
}

// ===================================================================

class PasswordSpecificsData_Notes::_Internal {
public:
};

PasswordSpecificsData_Notes::PasswordSpecificsData_Notes(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsData.Notes)
}
PasswordSpecificsData_Notes::PasswordSpecificsData_Notes(const PasswordSpecificsData_Notes& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordSpecificsData_Notes* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.note_) { from._impl_.note_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsData.Notes)
}

inline void PasswordSpecificsData_Notes::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.note_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

PasswordSpecificsData_Notes::~PasswordSpecificsData_Notes()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsData.Notes)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordSpecificsData_Notes::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.note_.~RepeatedPtrField();
}

void PasswordSpecificsData_Notes::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordSpecificsData_Notes::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsData.Notes)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.note_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsData_Notes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .sync_pb.PasswordSpecificsData.Notes.Note note = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_note(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsData_Notes::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsData.Notes)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .sync_pb.PasswordSpecificsData.Notes.Note note = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_note_size()); i < n; i++) {
        const auto& repfield = this->_internal_note(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsData.Notes)
    return target;
}

size_t PasswordSpecificsData_Notes::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsData.Notes)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.PasswordSpecificsData.Notes.Note note = 1;
    total_size += 1UL * this->_internal_note_size();
    for (const auto& msg : this->_impl_.note_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordSpecificsData_Notes::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordSpecificsData_Notes*>(&from));
}

void PasswordSpecificsData_Notes::MergeFrom(const PasswordSpecificsData_Notes& from)
{
    PasswordSpecificsData_Notes* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsData.Notes)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.note_.MergeFrom(from._impl_.note_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsData_Notes::CopyFrom(const PasswordSpecificsData_Notes& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsData.Notes)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordSpecificsData_Notes::IsInitialized() const
{
    return true;
}

void PasswordSpecificsData_Notes::InternalSwap(PasswordSpecificsData_Notes* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.note_.InternalSwap(&other->_impl_.note_);
}

std::string PasswordSpecificsData_Notes::GetTypeName() const
{
    return "sync_pb.PasswordSpecificsData.Notes";
}

// ===================================================================

class PasswordSpecificsData::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordSpecificsData>()._impl_._has_bits_);
    static void set_has_scheme(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_signon_realm(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_origin(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_action(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_username_element(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_username_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_password_element(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_password_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_ssl_valid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 524288u;
    }
    static void set_has_preferred(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1048576u;
    }
    static void set_has_date_created(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_blacklisted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2097152u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_times_used(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
    static void set_has_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_avatar_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_federation_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_date_last_used(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8388608u;
    }
    static const ::sync_pb::PasswordIssues& password_issues(const PasswordSpecificsData* msg);
    static void set_has_password_issues(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_date_password_modified_windows_epoch_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16777216u;
    }
    static const ::sync_pb::PasswordSpecificsData_Notes& notes(const PasswordSpecificsData* msg);
    static void set_has_notes(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_sender_email(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_sender_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_date_received_windows_epoch_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 33554432u;
    }
    static void set_has_sharing_notification_displayed(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4194304u;
    }
    static void set_has_sender_profile_image_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
};

const ::sync_pb::PasswordIssues& PasswordSpecificsData::_Internal::password_issues(const PasswordSpecificsData* msg)
{
    return *msg->_impl_.password_issues_;
}
const ::sync_pb::PasswordSpecificsData_Notes& PasswordSpecificsData::_Internal::notes(const PasswordSpecificsData* msg)
{
    return *msg->_impl_.notes_;
}
PasswordSpecificsData::PasswordSpecificsData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsData)
}
PasswordSpecificsData::PasswordSpecificsData(const PasswordSpecificsData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordSpecificsData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.signon_realm_) {},
        decltype(_impl_.origin_) {}, decltype(_impl_.action_) {}, decltype(_impl_.username_element_) {}, decltype(_impl_.username_value_) {},
        decltype(_impl_.password_element_) {}, decltype(_impl_.password_value_) {}, decltype(_impl_.display_name_) {}, decltype(_impl_.avatar_url_) {},
        decltype(_impl_.federation_url_) {}, decltype(_impl_.sender_email_) {}, decltype(_impl_.sender_name_) {}, decltype(_impl_.sender_profile_image_url_) {},
        decltype(_impl_.password_issues_) { nullptr }, decltype(_impl_.notes_) { nullptr }, decltype(_impl_.scheme_) {}, decltype(_impl_.type_) {},
        decltype(_impl_.date_created_) {}, decltype(_impl_.times_used_) {}, decltype(_impl_.ssl_valid_) {}, decltype(_impl_.preferred_) {},
        decltype(_impl_.blacklisted_) {}, decltype(_impl_.sharing_notification_displayed_) {}, decltype(_impl_.date_last_used_) {},
        decltype(_impl_.date_password_modified_windows_epoch_micros_) {}, decltype(_impl_.date_received_windows_epoch_micros_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.signon_realm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signon_realm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_signon_realm()) {
        _this->_impl_.signon_realm_.Set(from._internal_signon_realm(), _this->GetArenaForAllocation());
    }
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_origin()) {
        _this->_impl_.origin_.Set(from._internal_origin(), _this->GetArenaForAllocation());
    }
    _impl_.action_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_action()) {
        _this->_impl_.action_.Set(from._internal_action(), _this->GetArenaForAllocation());
    }
    _impl_.username_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_username_element()) {
        _this->_impl_.username_element_.Set(from._internal_username_element(), _this->GetArenaForAllocation());
    }
    _impl_.username_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_username_value()) {
        _this->_impl_.username_value_.Set(from._internal_username_value(), _this->GetArenaForAllocation());
    }
    _impl_.password_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_password_element()) {
        _this->_impl_.password_element_.Set(from._internal_password_element(), _this->GetArenaForAllocation());
    }
    _impl_.password_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_password_value()) {
        _this->_impl_.password_value_.Set(from._internal_password_value(), _this->GetArenaForAllocation());
    }
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_display_name()) {
        _this->_impl_.display_name_.Set(from._internal_display_name(), _this->GetArenaForAllocation());
    }
    _impl_.avatar_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_avatar_url()) {
        _this->_impl_.avatar_url_.Set(from._internal_avatar_url(), _this->GetArenaForAllocation());
    }
    _impl_.federation_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.federation_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_federation_url()) {
        _this->_impl_.federation_url_.Set(from._internal_federation_url(), _this->GetArenaForAllocation());
    }
    _impl_.sender_email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_email()) {
        _this->_impl_.sender_email_.Set(from._internal_sender_email(), _this->GetArenaForAllocation());
    }
    _impl_.sender_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_name()) {
        _this->_impl_.sender_name_.Set(from._internal_sender_name(), _this->GetArenaForAllocation());
    }
    _impl_.sender_profile_image_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_profile_image_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sender_profile_image_url()) {
        _this->_impl_.sender_profile_image_url_.Set(from._internal_sender_profile_image_url(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_password_issues()) {
        _this->_impl_.password_issues_ = new ::sync_pb::PasswordIssues(*from._impl_.password_issues_);
    }
    if (from._internal_has_notes()) {
        _this->_impl_.notes_ = new ::sync_pb::PasswordSpecificsData_Notes(*from._impl_.notes_);
    }
    ::memcpy(&_impl_.scheme_, &from._impl_.scheme_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.date_received_windows_epoch_micros_) - reinterpret_cast<char*>(&_impl_.scheme_))
            + sizeof(_impl_.date_received_windows_epoch_micros_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsData)
}

inline void PasswordSpecificsData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.signon_realm_) {}, decltype(_impl_.origin_) {},
        decltype(_impl_.action_) {}, decltype(_impl_.username_element_) {}, decltype(_impl_.username_value_) {}, decltype(_impl_.password_element_) {},
        decltype(_impl_.password_value_) {}, decltype(_impl_.display_name_) {}, decltype(_impl_.avatar_url_) {}, decltype(_impl_.federation_url_) {},
        decltype(_impl_.sender_email_) {}, decltype(_impl_.sender_name_) {}, decltype(_impl_.sender_profile_image_url_) {},
        decltype(_impl_.password_issues_) { nullptr }, decltype(_impl_.notes_) { nullptr }, decltype(_impl_.scheme_) { 0 }, decltype(_impl_.type_) { 0 },
        decltype(_impl_.date_created_) { int64_t { 0 } }, decltype(_impl_.times_used_) { 0 }, decltype(_impl_.ssl_valid_) { false },
        decltype(_impl_.preferred_) { false }, decltype(_impl_.blacklisted_) { false }, decltype(_impl_.sharing_notification_displayed_) { false },
        decltype(_impl_.date_last_used_) { int64_t { 0 } }, decltype(_impl_.date_password_modified_windows_epoch_micros_) { int64_t { 0 } },
        decltype(_impl_.date_received_windows_epoch_micros_) { int64_t { 0 } } };
    _impl_.signon_realm_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.signon_realm_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.action_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.username_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_element_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_element_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.password_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.avatar_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.federation_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.federation_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_profile_image_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sender_profile_image_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PasswordSpecificsData::~PasswordSpecificsData()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordSpecificsData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.signon_realm_.Destroy();
    _impl_.origin_.Destroy();
    _impl_.action_.Destroy();
    _impl_.username_element_.Destroy();
    _impl_.username_value_.Destroy();
    _impl_.password_element_.Destroy();
    _impl_.password_value_.Destroy();
    _impl_.display_name_.Destroy();
    _impl_.avatar_url_.Destroy();
    _impl_.federation_url_.Destroy();
    _impl_.sender_email_.Destroy();
    _impl_.sender_name_.Destroy();
    _impl_.sender_profile_image_url_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.password_issues_;
    if (this != internal_default_instance())
        delete _impl_.notes_;
}

void PasswordSpecificsData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordSpecificsData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.signon_realm_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.origin_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.action_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.username_element_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.username_value_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.password_element_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.password_value_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            _impl_.display_name_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00007f00u) {
        if (cached_has_bits & 0x00000100u) {
            _impl_.avatar_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000200u) {
            _impl_.federation_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000400u) {
            _impl_.sender_email_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000800u) {
            _impl_.sender_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00001000u) {
            _impl_.sender_profile_image_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00002000u) {
            GOOGLE_DCHECK(_impl_.password_issues_ != nullptr);
            _impl_.password_issues_->Clear();
        }
        if (cached_has_bits & 0x00004000u) {
            GOOGLE_DCHECK(_impl_.notes_ != nullptr);
            _impl_.notes_->Clear();
        }
    }
    _impl_.scheme_ = 0;
    if (cached_has_bits & 0x00ff0000u) {
        ::memset(&_impl_.type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.date_last_used_) - reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.date_last_used_));
    }
    if (cached_has_bits & 0x03000000u) {
        ::memset(&_impl_.date_password_modified_windows_epoch_micros_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.date_received_windows_epoch_micros_)
                - reinterpret_cast<char*>(&_impl_.date_password_modified_windows_epoch_micros_))
                + sizeof(_impl_.date_received_windows_epoch_micros_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 scheme = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_scheme(&has_bits);
                _impl_.scheme_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string signon_realm = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_signon_realm();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string origin = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_origin();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string action = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_action();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string username_element = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_username_element();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string username_value = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_username_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string password_element = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_password_element();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string password_value = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_password_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool ssl_valid = 9 [deprecated = true];
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_ssl_valid(&has_bits);
                _impl_.ssl_valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool preferred = 10 [deprecated = true];
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_preferred(&has_bits);
                _impl_.preferred_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 date_created = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _Internal::set_has_date_created(&has_bits);
                _impl_.date_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool blacklisted = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _Internal::set_has_blacklisted(&has_bits);
                _impl_.blacklisted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 type = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_type(&has_bits);
                _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 times_used = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _Internal::set_has_times_used(&has_bits);
                _impl_.times_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string display_name = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                auto str = _internal_mutable_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string avatar_url = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                auto str = _internal_mutable_avatar_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string federation_url = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
                auto str = _internal_mutable_federation_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 date_last_used = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                _Internal::set_has_date_last_used(&has_bits);
                _impl_.date_last_used_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordIssues password_issues = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
                ptr = ctx->ParseMessage(_internal_mutable_password_issues(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 date_password_modified_windows_epoch_micros = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                _Internal::set_has_date_password_modified_windows_epoch_micros(&has_bits);
                _impl_.date_password_modified_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordSpecificsData.Notes notes = 22;
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
                ptr = ctx->ParseMessage(_internal_mutable_notes(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string sender_email = 23;
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
                auto str = _internal_mutable_sender_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string sender_name = 24;
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
                auto str = _internal_mutable_sender_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 date_received_windows_epoch_micros = 25;
        case 25:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
                _Internal::set_has_date_received_windows_epoch_micros(&has_bits);
                _impl_.date_received_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool sharing_notification_displayed = 26;
        case 26:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
                _Internal::set_has_sharing_notification_displayed(&has_bits);
                _impl_.sharing_notification_displayed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string sender_profile_image_url = 27;
        case 27:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
                auto str = _internal_mutable_sender_profile_image_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 scheme = 1;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_scheme(), target);
    }

    // optional string signon_realm = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_signon_realm(), target);
    }

    // optional string origin = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_origin(), target);
    }

    // optional string action = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_action(), target);
    }

    // optional string username_element = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_username_element(), target);
    }

    // optional string username_value = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_username_value(), target);
    }

    // optional string password_element = 7;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_password_element(), target);
    }

    // optional string password_value = 8;
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_password_value(), target);
    }

    // optional bool ssl_valid = 9 [deprecated = true];
    if (cached_has_bits & 0x00080000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_ssl_valid(), target);
    }

    // optional bool preferred = 10 [deprecated = true];
    if (cached_has_bits & 0x00100000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_preferred(), target);
    }

    // optional int64 date_created = 11;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(11, this->_internal_date_created(), target);
    }

    // optional bool blacklisted = 12;
    if (cached_has_bits & 0x00200000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_blacklisted(), target);
    }

    // optional int32 type = 13;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_type(), target);
    }

    // optional int32 times_used = 14;
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_times_used(), target);
    }

    // optional string display_name = 15;
    if (cached_has_bits & 0x00000080u) {
        target = stream->WriteStringMaybeAliased(15, this->_internal_display_name(), target);
    }

    // optional string avatar_url = 16;
    if (cached_has_bits & 0x00000100u) {
        target = stream->WriteStringMaybeAliased(16, this->_internal_avatar_url(), target);
    }

    // optional string federation_url = 17;
    if (cached_has_bits & 0x00000200u) {
        target = stream->WriteStringMaybeAliased(17, this->_internal_federation_url(), target);
    }

    // optional int64 date_last_used = 18;
    if (cached_has_bits & 0x00800000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(18, this->_internal_date_last_used(), target);
    }

    // optional .sync_pb.PasswordIssues password_issues = 19;
    if (cached_has_bits & 0x00002000u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            19, _Internal::password_issues(this), _Internal::password_issues(this).GetCachedSize(), target, stream);
    }

    // optional int64 date_password_modified_windows_epoch_micros = 20;
    if (cached_has_bits & 0x01000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(20, this->_internal_date_password_modified_windows_epoch_micros(), target);
    }

    // optional .sync_pb.PasswordSpecificsData.Notes notes = 22;
    if (cached_has_bits & 0x00004000u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            22, _Internal::notes(this), _Internal::notes(this).GetCachedSize(), target, stream);
    }

    // optional string sender_email = 23;
    if (cached_has_bits & 0x00000400u) {
        target = stream->WriteStringMaybeAliased(23, this->_internal_sender_email(), target);
    }

    // optional string sender_name = 24;
    if (cached_has_bits & 0x00000800u) {
        target = stream->WriteStringMaybeAliased(24, this->_internal_sender_name(), target);
    }

    // optional int64 date_received_windows_epoch_micros = 25;
    if (cached_has_bits & 0x02000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(25, this->_internal_date_received_windows_epoch_micros(), target);
    }

    // optional bool sharing_notification_displayed = 26;
    if (cached_has_bits & 0x00400000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_sharing_notification_displayed(), target);
    }

    // optional string sender_profile_image_url = 27;
    if (cached_has_bits & 0x00001000u) {
        target = stream->WriteStringMaybeAliased(27, this->_internal_sender_profile_image_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsData)
    return target;
}

size_t PasswordSpecificsData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string signon_realm = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_signon_realm());
        }

        // optional string origin = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_origin());
        }

        // optional string action = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_action());
        }

        // optional string username_element = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_username_element());
        }

        // optional string username_value = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_username_value());
        }

        // optional string password_element = 7;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_password_element());
        }

        // optional string password_value = 8;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_password_value());
        }

        // optional string display_name = 15;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_display_name());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional string avatar_url = 16;
        if (cached_has_bits & 0x00000100u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_avatar_url());
        }

        // optional string federation_url = 17;
        if (cached_has_bits & 0x00000200u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_federation_url());
        }

        // optional string sender_email = 23;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sender_email());
        }

        // optional string sender_name = 24;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sender_name());
        }

        // optional string sender_profile_image_url = 27;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sender_profile_image_url());
        }

        // optional .sync_pb.PasswordIssues password_issues = 19;
        if (cached_has_bits & 0x00002000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.password_issues_);
        }

        // optional .sync_pb.PasswordSpecificsData.Notes notes = 22;
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.notes_);
        }

        // optional int32 scheme = 1;
        if (cached_has_bits & 0x00008000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_scheme());
        }
    }
    if (cached_has_bits & 0x00ff0000u) {
        // optional int32 type = 13;
        if (cached_has_bits & 0x00010000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
        }

        // optional int64 date_created = 11;
        if (cached_has_bits & 0x00020000u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_date_created());
        }

        // optional int32 times_used = 14;
        if (cached_has_bits & 0x00040000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_times_used());
        }

        // optional bool ssl_valid = 9 [deprecated = true];
        if (cached_has_bits & 0x00080000u) {
            total_size += 1 + 1;
        }

        // optional bool preferred = 10 [deprecated = true];
        if (cached_has_bits & 0x00100000u) {
            total_size += 1 + 1;
        }

        // optional bool blacklisted = 12;
        if (cached_has_bits & 0x00200000u) {
            total_size += 1 + 1;
        }

        // optional bool sharing_notification_displayed = 26;
        if (cached_has_bits & 0x00400000u) {
            total_size += 2 + 1;
        }

        // optional int64 date_last_used = 18;
        if (cached_has_bits & 0x00800000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_date_last_used());
        }
    }
    if (cached_has_bits & 0x03000000u) {
        // optional int64 date_password_modified_windows_epoch_micros = 20;
        if (cached_has_bits & 0x01000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_date_password_modified_windows_epoch_micros());
        }

        // optional int64 date_received_windows_epoch_micros = 25;
        if (cached_has_bits & 0x02000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_date_received_windows_epoch_micros());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordSpecificsData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordSpecificsData*>(&from));
}

void PasswordSpecificsData::MergeFrom(const PasswordSpecificsData& from)
{
    PasswordSpecificsData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_signon_realm(from._internal_signon_realm());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_origin(from._internal_origin());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_action(from._internal_action());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_username_element(from._internal_username_element());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_username_value(from._internal_username_value());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_password_element(from._internal_password_element());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_password_value(from._internal_password_value());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_set_display_name(from._internal_display_name());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_set_avatar_url(from._internal_avatar_url());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_set_federation_url(from._internal_federation_url());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_set_sender_email(from._internal_sender_email());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_internal_set_sender_name(from._internal_sender_name());
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_internal_set_sender_profile_image_url(from._internal_sender_profile_image_url());
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_internal_mutable_password_issues()->::sync_pb::PasswordIssues::MergeFrom(from._internal_password_issues());
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_internal_mutable_notes()->::sync_pb::PasswordSpecificsData_Notes::MergeFrom(from._internal_notes());
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.scheme_ = from._impl_.scheme_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00ff0000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.date_created_ = from._impl_.date_created_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.times_used_ = from._impl_.times_used_;
        }
        if (cached_has_bits & 0x00080000u) {
            _this->_impl_.ssl_valid_ = from._impl_.ssl_valid_;
        }
        if (cached_has_bits & 0x00100000u) {
            _this->_impl_.preferred_ = from._impl_.preferred_;
        }
        if (cached_has_bits & 0x00200000u) {
            _this->_impl_.blacklisted_ = from._impl_.blacklisted_;
        }
        if (cached_has_bits & 0x00400000u) {
            _this->_impl_.sharing_notification_displayed_ = from._impl_.sharing_notification_displayed_;
        }
        if (cached_has_bits & 0x00800000u) {
            _this->_impl_.date_last_used_ = from._impl_.date_last_used_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x03000000u) {
        if (cached_has_bits & 0x01000000u) {
            _this->_impl_.date_password_modified_windows_epoch_micros_ = from._impl_.date_password_modified_windows_epoch_micros_;
        }
        if (cached_has_bits & 0x02000000u) {
            _this->_impl_.date_received_windows_epoch_micros_ = from._impl_.date_received_windows_epoch_micros_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsData::CopyFrom(const PasswordSpecificsData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordSpecificsData::IsInitialized() const
{
    return true;
}

void PasswordSpecificsData::InternalSwap(PasswordSpecificsData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.signon_realm_, lhs_arena, &other->_impl_.signon_realm_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.origin_, lhs_arena, &other->_impl_.origin_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.action_, lhs_arena, &other->_impl_.action_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.username_element_, lhs_arena, &other->_impl_.username_element_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.username_value_, lhs_arena, &other->_impl_.username_value_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.password_element_, lhs_arena, &other->_impl_.password_element_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.password_value_, lhs_arena, &other->_impl_.password_value_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.display_name_, lhs_arena, &other->_impl_.display_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.avatar_url_, lhs_arena, &other->_impl_.avatar_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.federation_url_, lhs_arena, &other->_impl_.federation_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sender_email_, lhs_arena, &other->_impl_.sender_email_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sender_name_, lhs_arena, &other->_impl_.sender_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.sender_profile_image_url_, lhs_arena, &other->_impl_.sender_profile_image_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PasswordSpecificsData, _impl_.date_received_windows_epoch_micros_)
        + sizeof(PasswordSpecificsData::_impl_.date_received_windows_epoch_micros_) - PROTOBUF_FIELD_OFFSET(PasswordSpecificsData, _impl_.password_issues_)>(
        reinterpret_cast<char*>(&_impl_.password_issues_), reinterpret_cast<char*>(&other->_impl_.password_issues_));
}

std::string PasswordSpecificsData::GetTypeName() const
{
    return "sync_pb.PasswordSpecificsData";
}

// ===================================================================

class PasswordSpecificsMetadata::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordSpecificsMetadata>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_blacklisted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_date_last_used_windows_epoch_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::sync_pb::PasswordIssues& password_issues(const PasswordSpecificsMetadata* msg);
    static void set_has_password_issues(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

const ::sync_pb::PasswordIssues& PasswordSpecificsMetadata::_Internal::password_issues(const PasswordSpecificsMetadata* msg)
{
    return *msg->_impl_.password_issues_;
}
PasswordSpecificsMetadata::PasswordSpecificsMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecificsMetadata)
}
PasswordSpecificsMetadata::PasswordSpecificsMetadata(const PasswordSpecificsMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordSpecificsMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {},
        decltype(_impl_.password_issues_) { nullptr }, decltype(_impl_.date_last_used_windows_epoch_micros_) {}, decltype(_impl_.blacklisted_) {},
        decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_password_issues()) {
        _this->_impl_.password_issues_ = new ::sync_pb::PasswordIssues(*from._impl_.password_issues_);
    }
    ::memcpy(&_impl_.date_last_used_windows_epoch_micros_, &from._impl_.date_last_used_windows_epoch_micros_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) - reinterpret_cast<char*>(&_impl_.date_last_used_windows_epoch_micros_))
            + sizeof(_impl_.type_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecificsMetadata)
}

inline void PasswordSpecificsMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {}, decltype(_impl_.password_issues_) { nullptr },
            decltype(_impl_.date_last_used_windows_epoch_micros_) { int64_t { 0 } }, decltype(_impl_.blacklisted_) { false }, decltype(_impl_.type_) { 0 } };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PasswordSpecificsMetadata::~PasswordSpecificsMetadata()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecificsMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordSpecificsMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.password_issues_;
}

void PasswordSpecificsMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordSpecificsMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecificsMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.password_issues_ != nullptr);
            _impl_.password_issues_->Clear();
        }
    }
    if (cached_has_bits & 0x0000001cu) {
        ::memset(&_impl_.date_last_used_windows_epoch_micros_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) - reinterpret_cast<char*>(&_impl_.date_last_used_windows_epoch_micros_))
                + sizeof(_impl_.type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecificsMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool blacklisted = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_blacklisted(&has_bits);
                _impl_.blacklisted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 date_last_used_windows_epoch_micros = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_date_last_used_windows_epoch_micros(&has_bits);
                _impl_.date_last_used_windows_epoch_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordIssues password_issues = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_password_issues(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 type = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_type(&has_bits);
                _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecificsMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecificsMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    // optional bool blacklisted = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_blacklisted(), target);
    }

    // optional int64 date_last_used_windows_epoch_micros = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_date_last_used_windows_epoch_micros(), target);
    }

    // optional .sync_pb.PasswordIssues password_issues = 4;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::password_issues(this), _Internal::password_issues(this).GetCachedSize(), target, stream);
    }

    // optional int32 type = 13;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecificsMetadata)
    return target;
}

size_t PasswordSpecificsMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecificsMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
        }

        // optional .sync_pb.PasswordIssues password_issues = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.password_issues_);
        }

        // optional int64 date_last_used_windows_epoch_micros = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_date_last_used_windows_epoch_micros());
        }

        // optional bool blacklisted = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 1;
        }

        // optional int32 type = 13;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordSpecificsMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordSpecificsMetadata*>(&from));
}

void PasswordSpecificsMetadata::MergeFrom(const PasswordSpecificsMetadata& from)
{
    PasswordSpecificsMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecificsMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_url(from._internal_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_password_issues()->::sync_pb::PasswordIssues::MergeFrom(from._internal_password_issues());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.date_last_used_windows_epoch_micros_ = from._impl_.date_last_used_windows_epoch_micros_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.blacklisted_ = from._impl_.blacklisted_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecificsMetadata::CopyFrom(const PasswordSpecificsMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecificsMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordSpecificsMetadata::IsInitialized() const
{
    return true;
}

void PasswordSpecificsMetadata::InternalSwap(PasswordSpecificsMetadata* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PasswordSpecificsMetadata, _impl_.type_) + sizeof(PasswordSpecificsMetadata::_impl_.type_)
        - PROTOBUF_FIELD_OFFSET(PasswordSpecificsMetadata, _impl_.password_issues_)>(
        reinterpret_cast<char*>(&_impl_.password_issues_), reinterpret_cast<char*>(&other->_impl_.password_issues_));
}

std::string PasswordSpecificsMetadata::GetTypeName() const
{
    return "sync_pb.PasswordSpecificsMetadata";
}

// ===================================================================

class PasswordSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<PasswordSpecifics>()._impl_._has_bits_);
    static const ::sync_pb::EncryptedData& encrypted(const PasswordSpecifics* msg);
    static void set_has_encrypted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::PasswordSpecificsData& client_only_encrypted_data(const PasswordSpecifics* msg);
    static void set_has_client_only_encrypted_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::PasswordSpecificsMetadata& unencrypted_metadata(const PasswordSpecifics* msg);
    static void set_has_unencrypted_metadata(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::sync_pb::EncryptedData& encrypted_notes_backup(const PasswordSpecifics* msg);
    static void set_has_encrypted_notes_backup(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::sync_pb::EncryptedData& PasswordSpecifics::_Internal::encrypted(const PasswordSpecifics* msg)
{
    return *msg->_impl_.encrypted_;
}
const ::sync_pb::PasswordSpecificsData& PasswordSpecifics::_Internal::client_only_encrypted_data(const PasswordSpecifics* msg)
{
    return *msg->_impl_.client_only_encrypted_data_;
}
const ::sync_pb::PasswordSpecificsMetadata& PasswordSpecifics::_Internal::unencrypted_metadata(const PasswordSpecifics* msg)
{
    return *msg->_impl_.unencrypted_metadata_;
}
const ::sync_pb::EncryptedData& PasswordSpecifics::_Internal::encrypted_notes_backup(const PasswordSpecifics* msg)
{
    return *msg->_impl_.encrypted_notes_backup_;
}
void PasswordSpecifics::clear_encrypted()
{
    if (_impl_.encrypted_ != nullptr)
        _impl_.encrypted_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
void PasswordSpecifics::clear_encrypted_notes_backup()
{
    if (_impl_.encrypted_notes_backup_ != nullptr)
        _impl_.encrypted_notes_backup_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
PasswordSpecifics::PasswordSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PasswordSpecifics)
}
PasswordSpecifics::PasswordSpecifics(const PasswordSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PasswordSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.encrypted_) { nullptr }, decltype(_impl_.client_only_encrypted_data_) { nullptr }, decltype(_impl_.unencrypted_metadata_) { nullptr },
        decltype(_impl_.encrypted_notes_backup_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_encrypted()) {
        _this->_impl_.encrypted_ = new ::sync_pb::EncryptedData(*from._impl_.encrypted_);
    }
    if (from._internal_has_client_only_encrypted_data()) {
        _this->_impl_.client_only_encrypted_data_ = new ::sync_pb::PasswordSpecificsData(*from._impl_.client_only_encrypted_data_);
    }
    if (from._internal_has_unencrypted_metadata()) {
        _this->_impl_.unencrypted_metadata_ = new ::sync_pb::PasswordSpecificsMetadata(*from._impl_.unencrypted_metadata_);
    }
    if (from._internal_has_encrypted_notes_backup()) {
        _this->_impl_.encrypted_notes_backup_ = new ::sync_pb::EncryptedData(*from._impl_.encrypted_notes_backup_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.PasswordSpecifics)
}

inline void PasswordSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.encrypted_) { nullptr },
        decltype(_impl_.client_only_encrypted_data_) { nullptr }, decltype(_impl_.unencrypted_metadata_) { nullptr },
        decltype(_impl_.encrypted_notes_backup_) { nullptr } };
}

PasswordSpecifics::~PasswordSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.PasswordSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PasswordSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.encrypted_;
    if (this != internal_default_instance())
        delete _impl_.client_only_encrypted_data_;
    if (this != internal_default_instance())
        delete _impl_.unencrypted_metadata_;
    if (this != internal_default_instance())
        delete _impl_.encrypted_notes_backup_;
}

void PasswordSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PasswordSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PasswordSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.encrypted_ != nullptr);
            _impl_.encrypted_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.client_only_encrypted_data_ != nullptr);
            _impl_.client_only_encrypted_data_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.unencrypted_metadata_ != nullptr);
            _impl_.unencrypted_metadata_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.encrypted_notes_backup_ != nullptr);
            _impl_.encrypted_notes_backup_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PasswordSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.EncryptedData encrypted = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_encrypted(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordSpecificsData client_only_encrypted_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_client_only_encrypted_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PasswordSpecificsMetadata unencrypted_metadata = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_unencrypted_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.EncryptedData encrypted_notes_backup = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_encrypted_notes_backup(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PasswordSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PasswordSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.EncryptedData encrypted = 1;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::encrypted(this), _Internal::encrypted(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PasswordSpecificsData client_only_encrypted_data = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::client_only_encrypted_data(this), _Internal::client_only_encrypted_data(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PasswordSpecificsMetadata unencrypted_metadata = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::unencrypted_metadata(this), _Internal::unencrypted_metadata(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.EncryptedData encrypted_notes_backup = 5;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::encrypted_notes_backup(this), _Internal::encrypted_notes_backup(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PasswordSpecifics)
    return target;
}

size_t PasswordSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PasswordSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional .sync_pb.EncryptedData encrypted = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.encrypted_);
        }

        // optional .sync_pb.PasswordSpecificsData client_only_encrypted_data = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.client_only_encrypted_data_);
        }

        // optional .sync_pb.PasswordSpecificsMetadata unencrypted_metadata = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.unencrypted_metadata_);
        }

        // optional .sync_pb.EncryptedData encrypted_notes_backup = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.encrypted_notes_backup_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PasswordSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PasswordSpecifics*>(&from));
}

void PasswordSpecifics::MergeFrom(const PasswordSpecifics& from)
{
    PasswordSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PasswordSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_encrypted()->::sync_pb::EncryptedData::MergeFrom(from._internal_encrypted());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_client_only_encrypted_data()->::sync_pb::PasswordSpecificsData::MergeFrom(from._internal_client_only_encrypted_data());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_unencrypted_metadata()->::sync_pb::PasswordSpecificsMetadata::MergeFrom(from._internal_unencrypted_metadata());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_encrypted_notes_backup()->::sync_pb::EncryptedData::MergeFrom(from._internal_encrypted_notes_backup());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PasswordSpecifics::CopyFrom(const PasswordSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PasswordSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PasswordSpecifics::IsInitialized() const
{
    return true;
}

void PasswordSpecifics::InternalSwap(PasswordSpecifics* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PasswordSpecifics, _impl_.encrypted_notes_backup_)
        + sizeof(PasswordSpecifics::_impl_.encrypted_notes_backup_) - PROTOBUF_FIELD_OFFSET(PasswordSpecifics, _impl_.encrypted_)>(
        reinterpret_cast<char*>(&_impl_.encrypted_), reinterpret_cast<char*>(&other->_impl_.encrypted_));
}

std::string PasswordSpecifics::GetTypeName() const
{
    return "sync_pb.PasswordSpecifics";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::sync_pb::PasswordIssues_PasswordIssue* Arena::CreateMaybeMessage<::sync_pb::PasswordIssues_PasswordIssue>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordIssues_PasswordIssue>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PasswordIssues* Arena::CreateMaybeMessage<::sync_pb::PasswordIssues>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordIssues>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsData_Notes_Note* Arena::CreateMaybeMessage<::sync_pb::PasswordSpecificsData_Notes_Note>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordSpecificsData_Notes_Note>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsData_Notes* Arena::CreateMaybeMessage<::sync_pb::PasswordSpecificsData_Notes>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordSpecificsData_Notes>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsData* Arena::CreateMaybeMessage<::sync_pb::PasswordSpecificsData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordSpecificsData>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecificsMetadata* Arena::CreateMaybeMessage<::sync_pb::PasswordSpecificsMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordSpecificsMetadata>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PasswordSpecifics* Arena::CreateMaybeMessage<::sync_pb::PasswordSpecifics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PasswordSpecifics>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
