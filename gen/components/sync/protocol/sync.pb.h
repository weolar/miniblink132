// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/sync.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsync_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsync_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/sync/protocol/client_commands.pb.h"
#include "components/sync/protocol/client_debug_info.pb.h"
#include "components/sync/protocol/data_type_progress_marker.pb.h"
#include "components/sync/protocol/get_updates_caller_info.pb.h"
#include "components/sync/protocol/password_sharing_invitation_specifics.pb.h"
#include "components/sync/protocol/sync_entity.pb.h"
#include "components/sync/protocol/sync_enums.pb.h"
#include "components/sync/protocol/sharing_message_specifics.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fsync_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fsync_2eproto {
    static const uint32_t offsets[];
};
namespace sync_pb {
class ChipBag;
struct ChipBagDefaultTypeInternal;
extern ChipBagDefaultTypeInternal _ChipBag_default_instance_;
class ChromiumExtensionsActivity;
struct ChromiumExtensionsActivityDefaultTypeInternal;
extern ChromiumExtensionsActivityDefaultTypeInternal _ChromiumExtensionsActivity_default_instance_;
class ClearServerDataMessage;
struct ClearServerDataMessageDefaultTypeInternal;
extern ClearServerDataMessageDefaultTypeInternal _ClearServerDataMessage_default_instance_;
class ClearServerDataResponse;
struct ClearServerDataResponseDefaultTypeInternal;
extern ClearServerDataResponseDefaultTypeInternal _ClearServerDataResponse_default_instance_;
class ClientConfigParams;
struct ClientConfigParamsDefaultTypeInternal;
extern ClientConfigParamsDefaultTypeInternal _ClientConfigParams_default_instance_;
class ClientStatus;
struct ClientStatusDefaultTypeInternal;
extern ClientStatusDefaultTypeInternal _ClientStatus_default_instance_;
class ClientToServerMessage;
struct ClientToServerMessageDefaultTypeInternal;
extern ClientToServerMessageDefaultTypeInternal _ClientToServerMessage_default_instance_;
class ClientToServerResponse;
struct ClientToServerResponseDefaultTypeInternal;
extern ClientToServerResponseDefaultTypeInternal _ClientToServerResponse_default_instance_;
class ClientToServerResponse_Error;
struct ClientToServerResponse_ErrorDefaultTypeInternal;
extern ClientToServerResponse_ErrorDefaultTypeInternal _ClientToServerResponse_Error_default_instance_;
class CommitMessage;
struct CommitMessageDefaultTypeInternal;
extern CommitMessageDefaultTypeInternal _CommitMessage_default_instance_;
class CommitResponse;
struct CommitResponseDefaultTypeInternal;
extern CommitResponseDefaultTypeInternal _CommitResponse_default_instance_;
class CommitResponse_EntryResponse;
struct CommitResponse_EntryResponseDefaultTypeInternal;
extern CommitResponse_EntryResponseDefaultTypeInternal _CommitResponse_EntryResponse_default_instance_;
class CommitResponse_EntryResponse_DatatypeSpecificError;
struct CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal;
extern CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal _CommitResponse_EntryResponse_DatatypeSpecificError_default_instance_;
class EventRequest;
struct EventRequestDefaultTypeInternal;
extern EventRequestDefaultTypeInternal _EventRequest_default_instance_;
class EventResponse;
struct EventResponseDefaultTypeInternal;
extern EventResponseDefaultTypeInternal _EventResponse_default_instance_;
class GetUpdatesMessage;
struct GetUpdatesMessageDefaultTypeInternal;
extern GetUpdatesMessageDefaultTypeInternal _GetUpdatesMessage_default_instance_;
class GetUpdatesResponse;
struct GetUpdatesResponseDefaultTypeInternal;
extern GetUpdatesResponseDefaultTypeInternal _GetUpdatesResponse_default_instance_;
class SyncDisabledEvent;
struct SyncDisabledEventDefaultTypeInternal;
extern SyncDisabledEventDefaultTypeInternal _SyncDisabledEvent_default_instance_;
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <>::sync_pb::ChipBag* Arena::CreateMaybeMessage<::sync_pb::ChipBag>(Arena*);
template <>::sync_pb::ChromiumExtensionsActivity* Arena::CreateMaybeMessage<::sync_pb::ChromiumExtensionsActivity>(Arena*);
template <>::sync_pb::ClearServerDataMessage* Arena::CreateMaybeMessage<::sync_pb::ClearServerDataMessage>(Arena*);
template <>::sync_pb::ClearServerDataResponse* Arena::CreateMaybeMessage<::sync_pb::ClearServerDataResponse>(Arena*);
template <>::sync_pb::ClientConfigParams* Arena::CreateMaybeMessage<::sync_pb::ClientConfigParams>(Arena*);
template <>::sync_pb::ClientStatus* Arena::CreateMaybeMessage<::sync_pb::ClientStatus>(Arena*);
template <>::sync_pb::ClientToServerMessage* Arena::CreateMaybeMessage<::sync_pb::ClientToServerMessage>(Arena*);
template <>::sync_pb::ClientToServerResponse* Arena::CreateMaybeMessage<::sync_pb::ClientToServerResponse>(Arena*);
template <>::sync_pb::ClientToServerResponse_Error* Arena::CreateMaybeMessage<::sync_pb::ClientToServerResponse_Error>(Arena*);
template <>::sync_pb::CommitMessage* Arena::CreateMaybeMessage<::sync_pb::CommitMessage>(Arena*);
template <>::sync_pb::CommitResponse* Arena::CreateMaybeMessage<::sync_pb::CommitResponse>(Arena*);
template <>::sync_pb::CommitResponse_EntryResponse* Arena::CreateMaybeMessage<::sync_pb::CommitResponse_EntryResponse>(Arena*);
template <>
::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* Arena::CreateMaybeMessage<::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError>(Arena*);
template <>::sync_pb::EventRequest* Arena::CreateMaybeMessage<::sync_pb::EventRequest>(Arena*);
template <>::sync_pb::EventResponse* Arena::CreateMaybeMessage<::sync_pb::EventResponse>(Arena*);
template <>::sync_pb::GetUpdatesMessage* Arena::CreateMaybeMessage<::sync_pb::GetUpdatesMessage>(Arena*);
template <>::sync_pb::GetUpdatesResponse* Arena::CreateMaybeMessage<::sync_pb::GetUpdatesResponse>(Arena*);
template <>::sync_pb::SyncDisabledEvent* Arena::CreateMaybeMessage<::sync_pb::SyncDisabledEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

enum ClientToServerMessage_Contents : int {
    ClientToServerMessage_Contents_COMMIT = 1,
    ClientToServerMessage_Contents_GET_UPDATES = 2,
    ClientToServerMessage_Contents_DEPRECATED_3 = 3,
    ClientToServerMessage_Contents_DEPRECATED_4 = 4,
    ClientToServerMessage_Contents_CLEAR_SERVER_DATA = 5
};
bool ClientToServerMessage_Contents_IsValid(int value);
constexpr ClientToServerMessage_Contents ClientToServerMessage_Contents_Contents_MIN = ClientToServerMessage_Contents_COMMIT;
constexpr ClientToServerMessage_Contents ClientToServerMessage_Contents_Contents_MAX = ClientToServerMessage_Contents_CLEAR_SERVER_DATA;
constexpr int ClientToServerMessage_Contents_Contents_ARRAYSIZE = ClientToServerMessage_Contents_Contents_MAX + 1;

const std::string& ClientToServerMessage_Contents_Name(ClientToServerMessage_Contents value);
template <typename T> inline const std::string& ClientToServerMessage_Contents_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ClientToServerMessage_Contents>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function ClientToServerMessage_Contents_Name.");
    return ClientToServerMessage_Contents_Name(static_cast<ClientToServerMessage_Contents>(enum_t_value));
}
bool ClientToServerMessage_Contents_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientToServerMessage_Contents* value);
enum CommitResponse_ResponseType : int {
    CommitResponse_ResponseType_SUCCESS = 1,
    CommitResponse_ResponseType_CONFLICT = 2,
    CommitResponse_ResponseType_RETRY = 3,
    CommitResponse_ResponseType_INVALID_MESSAGE = 4,
    CommitResponse_ResponseType_OVER_QUOTA = 5,
    CommitResponse_ResponseType_TRANSIENT_ERROR = 6
};
bool CommitResponse_ResponseType_IsValid(int value);
constexpr CommitResponse_ResponseType CommitResponse_ResponseType_ResponseType_MIN = CommitResponse_ResponseType_SUCCESS;
constexpr CommitResponse_ResponseType CommitResponse_ResponseType_ResponseType_MAX = CommitResponse_ResponseType_TRANSIENT_ERROR;
constexpr int CommitResponse_ResponseType_ResponseType_ARRAYSIZE = CommitResponse_ResponseType_ResponseType_MAX + 1;

const std::string& CommitResponse_ResponseType_Name(CommitResponse_ResponseType value);
template <typename T> inline const std::string& CommitResponse_ResponseType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, CommitResponse_ResponseType>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function CommitResponse_ResponseType_Name.");
    return CommitResponse_ResponseType_Name(static_cast<CommitResponse_ResponseType>(enum_t_value));
}
bool CommitResponse_ResponseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommitResponse_ResponseType* value);
// ===================================================================

class ChromiumExtensionsActivity final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ChromiumExtensionsActivity) */ {
public:
    inline ChromiumExtensionsActivity()
        : ChromiumExtensionsActivity(nullptr)
    {
    }
    ~ChromiumExtensionsActivity() override;
    explicit PROTOBUF_CONSTEXPR ChromiumExtensionsActivity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ChromiumExtensionsActivity(const ChromiumExtensionsActivity& from);
    ChromiumExtensionsActivity(ChromiumExtensionsActivity&& from) noexcept
        : ChromiumExtensionsActivity()
    {
        *this = ::std::move(from);
    }

    inline ChromiumExtensionsActivity& operator=(const ChromiumExtensionsActivity& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ChromiumExtensionsActivity& operator=(ChromiumExtensionsActivity&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ChromiumExtensionsActivity& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ChromiumExtensionsActivity* internal_default_instance()
    {
        return reinterpret_cast<const ChromiumExtensionsActivity*>(&_ChromiumExtensionsActivity_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(ChromiumExtensionsActivity& a, ChromiumExtensionsActivity& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ChromiumExtensionsActivity* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ChromiumExtensionsActivity* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ChromiumExtensionsActivity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ChromiumExtensionsActivity>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ChromiumExtensionsActivity& from);
    void MergeFrom(const ChromiumExtensionsActivity& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ChromiumExtensionsActivity* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ChromiumExtensionsActivity";
    }

protected:
    explicit ChromiumExtensionsActivity(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kExtensionIdFieldNumber = 1,
        kBookmarkWritesSinceLastCommitFieldNumber = 2,
    };
    // optional string extension_id = 1;
    bool has_extension_id() const;

private:
    bool _internal_has_extension_id() const;

public:
    void clear_extension_id();
    const std::string& extension_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_extension_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_extension_id();
    PROTOBUF_NODISCARD std::string* release_extension_id();
    void set_allocated_extension_id(std::string* extension_id);

private:
    const std::string& _internal_extension_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_id(const std::string& value);
    std::string* _internal_mutable_extension_id();

public:
    // optional uint32 bookmark_writes_since_last_commit = 2;
    bool has_bookmark_writes_since_last_commit() const;

private:
    bool _internal_has_bookmark_writes_since_last_commit() const;

public:
    void clear_bookmark_writes_since_last_commit();
    uint32_t bookmark_writes_since_last_commit() const;
    void set_bookmark_writes_since_last_commit(uint32_t value);

private:
    uint32_t _internal_bookmark_writes_since_last_commit() const;
    void _internal_set_bookmark_writes_since_last_commit(uint32_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ChromiumExtensionsActivity)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_id_;
        uint32_t bookmark_writes_since_last_commit_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientConfigParams final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientConfigParams) */ {
public:
    inline ClientConfigParams()
        : ClientConfigParams(nullptr)
    {
    }
    ~ClientConfigParams() override;
    explicit PROTOBUF_CONSTEXPR ClientConfigParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientConfigParams(const ClientConfigParams& from);
    ClientConfigParams(ClientConfigParams&& from) noexcept
        : ClientConfigParams()
    {
        *this = ::std::move(from);
    }

    inline ClientConfigParams& operator=(const ClientConfigParams& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientConfigParams& operator=(ClientConfigParams&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientConfigParams& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientConfigParams* internal_default_instance()
    {
        return reinterpret_cast<const ClientConfigParams*>(&_ClientConfigParams_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(ClientConfigParams& a, ClientConfigParams& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientConfigParams* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientConfigParams* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientConfigParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientConfigParams>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientConfigParams& from);
    void MergeFrom(const ClientConfigParams& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientConfigParams* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ClientConfigParams";
    }

protected:
    explicit ClientConfigParams(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEnabledTypeIdsFieldNumber = 1,
        kDevicesFcmRegistrationTokensFieldNumber = 5,
        kFcmRegistrationTokensForInterestedClientsFieldNumber = 7,
        kTabsDatatypeEnabledFieldNumber = 2,
        kCookieJarMismatchFieldNumber = 3,
        kSingleClientFieldNumber = 4,
        kSingleClientWithStandaloneInvalidationsFieldNumber = 6,
        kSingleClientWithOldInvalidationsFieldNumber = 8,
    };
    // repeated int32 enabled_type_ids = 1;
    int enabled_type_ids_size() const;

private:
    int _internal_enabled_type_ids_size() const;

public:
    void clear_enabled_type_ids();

private:
    int32_t _internal_enabled_type_ids(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_enabled_type_ids() const;
    void _internal_add_enabled_type_ids(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_enabled_type_ids();

public:
    int32_t enabled_type_ids(int index) const;
    void set_enabled_type_ids(int index, int32_t value);
    void add_enabled_type_ids(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& enabled_type_ids() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_enabled_type_ids();

    // repeated string devices_fcm_registration_tokens = 5;
    int devices_fcm_registration_tokens_size() const;

private:
    int _internal_devices_fcm_registration_tokens_size() const;

public:
    void clear_devices_fcm_registration_tokens();
    const std::string& devices_fcm_registration_tokens(int index) const;
    std::string* mutable_devices_fcm_registration_tokens(int index);
    void set_devices_fcm_registration_tokens(int index, const std::string& value);
    void set_devices_fcm_registration_tokens(int index, std::string&& value);
    void set_devices_fcm_registration_tokens(int index, const char* value);
    void set_devices_fcm_registration_tokens(int index, const char* value, size_t size);
    std::string* add_devices_fcm_registration_tokens();
    void add_devices_fcm_registration_tokens(const std::string& value);
    void add_devices_fcm_registration_tokens(std::string&& value);
    void add_devices_fcm_registration_tokens(const char* value);
    void add_devices_fcm_registration_tokens(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& devices_fcm_registration_tokens() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_devices_fcm_registration_tokens();

private:
    const std::string& _internal_devices_fcm_registration_tokens(int index) const;
    std::string* _internal_add_devices_fcm_registration_tokens();

public:
    // repeated string fcm_registration_tokens_for_interested_clients = 7;
    int fcm_registration_tokens_for_interested_clients_size() const;

private:
    int _internal_fcm_registration_tokens_for_interested_clients_size() const;

public:
    void clear_fcm_registration_tokens_for_interested_clients();
    const std::string& fcm_registration_tokens_for_interested_clients(int index) const;
    std::string* mutable_fcm_registration_tokens_for_interested_clients(int index);
    void set_fcm_registration_tokens_for_interested_clients(int index, const std::string& value);
    void set_fcm_registration_tokens_for_interested_clients(int index, std::string&& value);
    void set_fcm_registration_tokens_for_interested_clients(int index, const char* value);
    void set_fcm_registration_tokens_for_interested_clients(int index, const char* value, size_t size);
    std::string* add_fcm_registration_tokens_for_interested_clients();
    void add_fcm_registration_tokens_for_interested_clients(const std::string& value);
    void add_fcm_registration_tokens_for_interested_clients(std::string&& value);
    void add_fcm_registration_tokens_for_interested_clients(const char* value);
    void add_fcm_registration_tokens_for_interested_clients(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fcm_registration_tokens_for_interested_clients() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fcm_registration_tokens_for_interested_clients();

private:
    const std::string& _internal_fcm_registration_tokens_for_interested_clients(int index) const;
    std::string* _internal_add_fcm_registration_tokens_for_interested_clients();

public:
    // optional bool tabs_datatype_enabled = 2 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_tabs_datatype_enabled() const;

private:
    bool _internal_has_tabs_datatype_enabled() const;

public:
    PROTOBUF_DEPRECATED void clear_tabs_datatype_enabled();
    PROTOBUF_DEPRECATED bool tabs_datatype_enabled() const;
    PROTOBUF_DEPRECATED void set_tabs_datatype_enabled(bool value);

private:
    bool _internal_tabs_datatype_enabled() const;
    void _internal_set_tabs_datatype_enabled(bool value);

public:
    // optional bool cookie_jar_mismatch = 3;
    bool has_cookie_jar_mismatch() const;

private:
    bool _internal_has_cookie_jar_mismatch() const;

public:
    void clear_cookie_jar_mismatch();
    bool cookie_jar_mismatch() const;
    void set_cookie_jar_mismatch(bool value);

private:
    bool _internal_cookie_jar_mismatch() const;
    void _internal_set_cookie_jar_mismatch(bool value);

public:
    // optional bool single_client = 4;
    bool has_single_client() const;

private:
    bool _internal_has_single_client() const;

public:
    void clear_single_client();
    bool single_client() const;
    void set_single_client(bool value);

private:
    bool _internal_single_client() const;
    void _internal_set_single_client(bool value);

public:
    // optional bool single_client_with_standalone_invalidations = 6;
    bool has_single_client_with_standalone_invalidations() const;

private:
    bool _internal_has_single_client_with_standalone_invalidations() const;

public:
    void clear_single_client_with_standalone_invalidations();
    bool single_client_with_standalone_invalidations() const;
    void set_single_client_with_standalone_invalidations(bool value);

private:
    bool _internal_single_client_with_standalone_invalidations() const;
    void _internal_set_single_client_with_standalone_invalidations(bool value);

public:
    // optional bool single_client_with_old_invalidations = 8;
    bool has_single_client_with_old_invalidations() const;

private:
    bool _internal_has_single_client_with_old_invalidations() const;

public:
    void clear_single_client_with_old_invalidations();
    bool single_client_with_old_invalidations() const;
    void set_single_client_with_old_invalidations(bool value);

private:
    bool _internal_single_client_with_old_invalidations() const;
    void _internal_set_single_client_with_old_invalidations(bool value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ClientConfigParams)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> enabled_type_ids_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> devices_fcm_registration_tokens_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fcm_registration_tokens_for_interested_clients_;
        bool tabs_datatype_enabled_;
        bool cookie_jar_mismatch_;
        bool single_client_;
        bool single_client_with_standalone_invalidations_;
        bool single_client_with_old_invalidations_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class CommitMessage final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CommitMessage) */ {
public:
    inline CommitMessage()
        : CommitMessage(nullptr)
    {
    }
    ~CommitMessage() override;
    explicit PROTOBUF_CONSTEXPR CommitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CommitMessage(const CommitMessage& from);
    CommitMessage(CommitMessage&& from) noexcept
        : CommitMessage()
    {
        *this = ::std::move(from);
    }

    inline CommitMessage& operator=(const CommitMessage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CommitMessage& operator=(CommitMessage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CommitMessage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CommitMessage* internal_default_instance()
    {
        return reinterpret_cast<const CommitMessage*>(&_CommitMessage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(CommitMessage& a, CommitMessage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CommitMessage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CommitMessage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CommitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CommitMessage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CommitMessage& from);
    void MergeFrom(const CommitMessage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CommitMessage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.CommitMessage";
    }

protected:
    explicit CommitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEntriesFieldNumber = 1,
        kExtensionsActivityFieldNumber = 3,
        kClientContextsFieldNumber = 5,
        kCacheGuidFieldNumber = 2,
        kPaddingFieldNumber = 6,
        kConfigParamsFieldNumber = 4,
    };
    // repeated .sync_pb.SyncEntity entries = 1;
    int entries_size() const;

private:
    int _internal_entries_size() const;

public:
    void clear_entries();
    ::sync_pb::SyncEntity* mutable_entries(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity>* mutable_entries();

private:
    const ::sync_pb::SyncEntity& _internal_entries(int index) const;
    ::sync_pb::SyncEntity* _internal_add_entries();

public:
    const ::sync_pb::SyncEntity& entries(int index) const;
    ::sync_pb::SyncEntity* add_entries();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity>& entries() const;

    // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
    int extensions_activity_size() const;

private:
    int _internal_extensions_activity_size() const;

public:
    void clear_extensions_activity();
    ::sync_pb::ChromiumExtensionsActivity* mutable_extensions_activity(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::ChromiumExtensionsActivity>* mutable_extensions_activity();

private:
    const ::sync_pb::ChromiumExtensionsActivity& _internal_extensions_activity(int index) const;
    ::sync_pb::ChromiumExtensionsActivity* _internal_add_extensions_activity();

public:
    const ::sync_pb::ChromiumExtensionsActivity& extensions_activity(int index) const;
    ::sync_pb::ChromiumExtensionsActivity* add_extensions_activity();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::ChromiumExtensionsActivity>& extensions_activity() const;

    // repeated .sync_pb.DataTypeContext client_contexts = 5;
    int client_contexts_size() const;

private:
    int _internal_client_contexts_size() const;

public:
    void clear_client_contexts();
    ::sync_pb::DataTypeContext* mutable_client_contexts(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>* mutable_client_contexts();

private:
    const ::sync_pb::DataTypeContext& _internal_client_contexts(int index) const;
    ::sync_pb::DataTypeContext* _internal_add_client_contexts();

public:
    const ::sync_pb::DataTypeContext& client_contexts(int index) const;
    ::sync_pb::DataTypeContext* add_client_contexts();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>& client_contexts() const;

    // optional string cache_guid = 2;
    bool has_cache_guid() const;

private:
    bool _internal_has_cache_guid() const;

public:
    void clear_cache_guid();
    const std::string& cache_guid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_cache_guid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_cache_guid();
    PROTOBUF_NODISCARD std::string* release_cache_guid();
    void set_allocated_cache_guid(std::string* cache_guid);

private:
    const std::string& _internal_cache_guid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_guid(const std::string& value);
    std::string* _internal_mutable_cache_guid();

public:
    // optional string padding = 6;
    bool has_padding() const;

private:
    bool _internal_has_padding() const;

public:
    void clear_padding();
    const std::string& padding() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_padding(ArgT0&& arg0, ArgT... args);
    std::string* mutable_padding();
    PROTOBUF_NODISCARD std::string* release_padding();
    void set_allocated_padding(std::string* padding);

private:
    const std::string& _internal_padding() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_padding(const std::string& value);
    std::string* _internal_mutable_padding();

public:
    // optional .sync_pb.ClientConfigParams config_params = 4;
    bool has_config_params() const;

private:
    bool _internal_has_config_params() const;

public:
    void clear_config_params();
    const ::sync_pb::ClientConfigParams& config_params() const;
    PROTOBUF_NODISCARD ::sync_pb::ClientConfigParams* release_config_params();
    ::sync_pb::ClientConfigParams* mutable_config_params();
    void set_allocated_config_params(::sync_pb::ClientConfigParams* config_params);

private:
    const ::sync_pb::ClientConfigParams& _internal_config_params() const;
    ::sync_pb::ClientConfigParams* _internal_mutable_config_params();

public:
    void unsafe_arena_set_allocated_config_params(::sync_pb::ClientConfigParams* config_params);
    ::sync_pb::ClientConfigParams* unsafe_arena_release_config_params();

    // @@protoc_insertion_point(class_scope:sync_pb.CommitMessage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity> entries_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::ChromiumExtensionsActivity> extensions_activity_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext> client_contexts_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_guid_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr padding_;
        ::sync_pb::ClientConfigParams* config_params_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class GetUpdatesMessage final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.GetUpdatesMessage) */ {
public:
    inline GetUpdatesMessage()
        : GetUpdatesMessage(nullptr)
    {
    }
    ~GetUpdatesMessage() override;
    explicit PROTOBUF_CONSTEXPR GetUpdatesMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    GetUpdatesMessage(const GetUpdatesMessage& from);
    GetUpdatesMessage(GetUpdatesMessage&& from) noexcept
        : GetUpdatesMessage()
    {
        *this = ::std::move(from);
    }

    inline GetUpdatesMessage& operator=(const GetUpdatesMessage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline GetUpdatesMessage& operator=(GetUpdatesMessage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const GetUpdatesMessage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const GetUpdatesMessage* internal_default_instance()
    {
        return reinterpret_cast<const GetUpdatesMessage*>(&_GetUpdatesMessage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(GetUpdatesMessage& a, GetUpdatesMessage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(GetUpdatesMessage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(GetUpdatesMessage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    GetUpdatesMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<GetUpdatesMessage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const GetUpdatesMessage& from);
    void MergeFrom(const GetUpdatesMessage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GetUpdatesMessage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.GetUpdatesMessage";
    }

protected:
    explicit GetUpdatesMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFromProgressMarkerFieldNumber = 6,
        kClientContextsFieldNumber = 11,
        kCallerInfoFieldNumber = 2,
        kStreamingFieldNumber = 7,
        kNeedEncryptionKeyFieldNumber = 8,
        kIsRetryFieldNumber = 10,
        kGetUpdatesOriginFieldNumber = 9,
        kFetchFoldersFieldNumber = 3,
    };
    // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
    int from_progress_marker_size() const;

private:
    int _internal_from_progress_marker_size() const;

public:
    void clear_from_progress_marker();
    ::sync_pb::DataTypeProgressMarker* mutable_from_progress_marker(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker>* mutable_from_progress_marker();

private:
    const ::sync_pb::DataTypeProgressMarker& _internal_from_progress_marker(int index) const;
    ::sync_pb::DataTypeProgressMarker* _internal_add_from_progress_marker();

public:
    const ::sync_pb::DataTypeProgressMarker& from_progress_marker(int index) const;
    ::sync_pb::DataTypeProgressMarker* add_from_progress_marker();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker>& from_progress_marker() const;

    // repeated .sync_pb.DataTypeContext client_contexts = 11;
    int client_contexts_size() const;

private:
    int _internal_client_contexts_size() const;

public:
    void clear_client_contexts();
    ::sync_pb::DataTypeContext* mutable_client_contexts(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>* mutable_client_contexts();

private:
    const ::sync_pb::DataTypeContext& _internal_client_contexts(int index) const;
    ::sync_pb::DataTypeContext* _internal_add_client_contexts();

public:
    const ::sync_pb::DataTypeContext& client_contexts(int index) const;
    ::sync_pb::DataTypeContext* add_client_contexts();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>& client_contexts() const;

    // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
    bool has_caller_info() const;

private:
    bool _internal_has_caller_info() const;

public:
    void clear_caller_info();
    const ::sync_pb::GetUpdatesCallerInfo& caller_info() const;
    PROTOBUF_NODISCARD ::sync_pb::GetUpdatesCallerInfo* release_caller_info();
    ::sync_pb::GetUpdatesCallerInfo* mutable_caller_info();
    void set_allocated_caller_info(::sync_pb::GetUpdatesCallerInfo* caller_info);

private:
    const ::sync_pb::GetUpdatesCallerInfo& _internal_caller_info() const;
    ::sync_pb::GetUpdatesCallerInfo* _internal_mutable_caller_info();

public:
    void unsafe_arena_set_allocated_caller_info(::sync_pb::GetUpdatesCallerInfo* caller_info);
    ::sync_pb::GetUpdatesCallerInfo* unsafe_arena_release_caller_info();

    // optional bool streaming = 7 [default = false];
    bool has_streaming() const;

private:
    bool _internal_has_streaming() const;

public:
    void clear_streaming();
    bool streaming() const;
    void set_streaming(bool value);

private:
    bool _internal_streaming() const;
    void _internal_set_streaming(bool value);

public:
    // optional bool need_encryption_key = 8 [default = false];
    bool has_need_encryption_key() const;

private:
    bool _internal_has_need_encryption_key() const;

public:
    void clear_need_encryption_key();
    bool need_encryption_key() const;
    void set_need_encryption_key(bool value);

private:
    bool _internal_need_encryption_key() const;
    void _internal_set_need_encryption_key(bool value);

public:
    // optional bool is_retry = 10 [default = false];
    bool has_is_retry() const;

private:
    bool _internal_has_is_retry() const;

public:
    void clear_is_retry();
    bool is_retry() const;
    void set_is_retry(bool value);

private:
    bool _internal_is_retry() const;
    void _internal_set_is_retry(bool value);

public:
    // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
    bool has_get_updates_origin() const;

private:
    bool _internal_has_get_updates_origin() const;

public:
    void clear_get_updates_origin();
    ::sync_pb::SyncEnums_GetUpdatesOrigin get_updates_origin() const;
    void set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value);

private:
    ::sync_pb::SyncEnums_GetUpdatesOrigin _internal_get_updates_origin() const;
    void _internal_set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value);

public:
    // optional bool fetch_folders = 3 [default = true];
    bool has_fetch_folders() const;

private:
    bool _internal_has_fetch_folders() const;

public:
    void clear_fetch_folders();
    bool fetch_folders() const;
    void set_fetch_folders(bool value);

private:
    bool _internal_fetch_folders() const;
    void _internal_set_fetch_folders(bool value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesMessage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker> from_progress_marker_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext> client_contexts_;
        ::sync_pb::GetUpdatesCallerInfo* caller_info_;
        bool streaming_;
        bool need_encryption_key_;
        bool is_retry_;
        int get_updates_origin_;
        bool fetch_folders_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClearServerDataMessage final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClearServerDataMessage) */ {
public:
    inline ClearServerDataMessage()
        : ClearServerDataMessage(nullptr)
    {
    }
    ~ClearServerDataMessage() override;
    explicit PROTOBUF_CONSTEXPR ClearServerDataMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClearServerDataMessage(const ClearServerDataMessage& from);
    ClearServerDataMessage(ClearServerDataMessage&& from) noexcept
        : ClearServerDataMessage()
    {
        *this = ::std::move(from);
    }

    inline ClearServerDataMessage& operator=(const ClearServerDataMessage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClearServerDataMessage& operator=(ClearServerDataMessage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClearServerDataMessage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClearServerDataMessage* internal_default_instance()
    {
        return reinterpret_cast<const ClearServerDataMessage*>(&_ClearServerDataMessage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(ClearServerDataMessage& a, ClearServerDataMessage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClearServerDataMessage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClearServerDataMessage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClearServerDataMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClearServerDataMessage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClearServerDataMessage& from);
    void MergeFrom(const ClearServerDataMessage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClearServerDataMessage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ClearServerDataMessage";
    }

protected:
    explicit ClearServerDataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:sync_pb.ClearServerDataMessage)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClearServerDataResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClearServerDataResponse) */ {
public:
    inline ClearServerDataResponse()
        : ClearServerDataResponse(nullptr)
    {
    }
    ~ClearServerDataResponse() override;
    explicit PROTOBUF_CONSTEXPR ClearServerDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClearServerDataResponse(const ClearServerDataResponse& from);
    ClearServerDataResponse(ClearServerDataResponse&& from) noexcept
        : ClearServerDataResponse()
    {
        *this = ::std::move(from);
    }

    inline ClearServerDataResponse& operator=(const ClearServerDataResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClearServerDataResponse& operator=(ClearServerDataResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClearServerDataResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClearServerDataResponse* internal_default_instance()
    {
        return reinterpret_cast<const ClearServerDataResponse*>(&_ClearServerDataResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(ClearServerDataResponse& a, ClearServerDataResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClearServerDataResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClearServerDataResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClearServerDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClearServerDataResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClearServerDataResponse& from);
    void MergeFrom(const ClearServerDataResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClearServerDataResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ClearServerDataResponse";
    }

protected:
    explicit ClearServerDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:sync_pb.ClearServerDataResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ChipBag final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ChipBag) */ {
public:
    inline ChipBag()
        : ChipBag(nullptr)
    {
    }
    ~ChipBag() override;
    explicit PROTOBUF_CONSTEXPR ChipBag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ChipBag(const ChipBag& from);
    ChipBag(ChipBag&& from) noexcept
        : ChipBag()
    {
        *this = ::std::move(from);
    }

    inline ChipBag& operator=(const ChipBag& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ChipBag& operator=(ChipBag&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ChipBag& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ChipBag* internal_default_instance()
    {
        return reinterpret_cast<const ChipBag*>(&_ChipBag_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(ChipBag& a, ChipBag& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ChipBag* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ChipBag* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ChipBag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ChipBag>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ChipBag& from);
    void MergeFrom(const ChipBag& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ChipBag* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ChipBag";
    }

protected:
    explicit ChipBag(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kServerChipsFieldNumber = 1,
    };
    // optional bytes server_chips = 1;
    bool has_server_chips() const;

private:
    bool _internal_has_server_chips() const;

public:
    void clear_server_chips();
    const std::string& server_chips() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_server_chips(ArgT0&& arg0, ArgT... args);
    std::string* mutable_server_chips();
    PROTOBUF_NODISCARD std::string* release_server_chips();
    void set_allocated_server_chips(std::string* server_chips);

private:
    const std::string& _internal_server_chips() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_chips(const std::string& value);
    std::string* _internal_mutable_server_chips();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ChipBag)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_chips_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientStatus final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientStatus) */ {
public:
    inline ClientStatus()
        : ClientStatus(nullptr)
    {
    }
    ~ClientStatus() override;
    explicit PROTOBUF_CONSTEXPR ClientStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientStatus(const ClientStatus& from);
    ClientStatus(ClientStatus&& from) noexcept
        : ClientStatus()
    {
        *this = ::std::move(from);
    }

    inline ClientStatus& operator=(const ClientStatus& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientStatus& operator=(ClientStatus&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientStatus& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientStatus* internal_default_instance()
    {
        return reinterpret_cast<const ClientStatus*>(&_ClientStatus_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(ClientStatus& a, ClientStatus& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientStatus* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientStatus* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientStatus>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientStatus& from);
    void MergeFrom(const ClientStatus& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientStatus* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ClientStatus";
    }

protected:
    explicit ClientStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kHierarchyConflictDetectedFieldNumber = 1,
        kIsSyncFeatureEnabledFieldNumber = 2,
    };
    // optional bool hierarchy_conflict_detected = 1 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_hierarchy_conflict_detected() const;

private:
    bool _internal_has_hierarchy_conflict_detected() const;

public:
    PROTOBUF_DEPRECATED void clear_hierarchy_conflict_detected();
    PROTOBUF_DEPRECATED bool hierarchy_conflict_detected() const;
    PROTOBUF_DEPRECATED void set_hierarchy_conflict_detected(bool value);

private:
    bool _internal_hierarchy_conflict_detected() const;
    void _internal_set_hierarchy_conflict_detected(bool value);

public:
    // optional bool is_sync_feature_enabled = 2;
    bool has_is_sync_feature_enabled() const;

private:
    bool _internal_has_is_sync_feature_enabled() const;

public:
    void clear_is_sync_feature_enabled();
    bool is_sync_feature_enabled() const;
    void set_is_sync_feature_enabled(bool value);

private:
    bool _internal_is_sync_feature_enabled() const;
    void _internal_set_is_sync_feature_enabled(bool value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ClientStatus)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        bool hierarchy_conflict_detected_;
        bool is_sync_feature_enabled_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientToServerMessage final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientToServerMessage) */ {
public:
    inline ClientToServerMessage()
        : ClientToServerMessage(nullptr)
    {
    }
    ~ClientToServerMessage() override;
    explicit PROTOBUF_CONSTEXPR ClientToServerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientToServerMessage(const ClientToServerMessage& from);
    ClientToServerMessage(ClientToServerMessage&& from) noexcept
        : ClientToServerMessage()
    {
        *this = ::std::move(from);
    }

    inline ClientToServerMessage& operator=(const ClientToServerMessage& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientToServerMessage& operator=(ClientToServerMessage&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientToServerMessage& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientToServerMessage* internal_default_instance()
    {
        return reinterpret_cast<const ClientToServerMessage*>(&_ClientToServerMessage_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(ClientToServerMessage& a, ClientToServerMessage& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientToServerMessage* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientToServerMessage* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientToServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientToServerMessage>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientToServerMessage& from);
    void MergeFrom(const ClientToServerMessage& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientToServerMessage* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ClientToServerMessage";
    }

protected:
    explicit ClientToServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ClientToServerMessage_Contents Contents;
    static constexpr Contents COMMIT = ClientToServerMessage_Contents_COMMIT;
    static constexpr Contents GET_UPDATES = ClientToServerMessage_Contents_GET_UPDATES;
    static constexpr Contents DEPRECATED_3 = ClientToServerMessage_Contents_DEPRECATED_3;
    static constexpr Contents DEPRECATED_4 = ClientToServerMessage_Contents_DEPRECATED_4;
    static constexpr Contents CLEAR_SERVER_DATA = ClientToServerMessage_Contents_CLEAR_SERVER_DATA;
    static inline bool Contents_IsValid(int value)
    {
        return ClientToServerMessage_Contents_IsValid(value);
    }
    static constexpr Contents Contents_MIN = ClientToServerMessage_Contents_Contents_MIN;
    static constexpr Contents Contents_MAX = ClientToServerMessage_Contents_Contents_MAX;
    static constexpr int Contents_ARRAYSIZE = ClientToServerMessage_Contents_Contents_ARRAYSIZE;
    template <typename T> static inline const std::string& Contents_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Contents>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Contents_Name.");
        return ClientToServerMessage_Contents_Name(enum_t_value);
    }
    static inline bool Contents_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Contents* value)
    {
        return ClientToServerMessage_Contents_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kShareFieldNumber = 1,
        kStoreBirthdayFieldNumber = 7,
        kApiKeyFieldNumber = 12,
        kInvalidatorClientIdFieldNumber = 14,
        kCommitFieldNumber = 4,
        kGetUpdatesFieldNumber = 5,
        kDebugInfoFieldNumber = 10,
        kBagOfChipsFieldNumber = 11,
        kClientStatusFieldNumber = 13,
        kClearServerDataFieldNumber = 15,
        kProtocolVersionFieldNumber = 2,
        kMessageContentsFieldNumber = 3,
    };
    // required string share = 1;
    bool has_share() const;

private:
    bool _internal_has_share() const;

public:
    void clear_share();
    const std::string& share() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_share(ArgT0&& arg0, ArgT... args);
    std::string* mutable_share();
    PROTOBUF_NODISCARD std::string* release_share();
    void set_allocated_share(std::string* share);

private:
    const std::string& _internal_share() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_share(const std::string& value);
    std::string* _internal_mutable_share();

public:
    // optional string store_birthday = 7;
    bool has_store_birthday() const;

private:
    bool _internal_has_store_birthday() const;

public:
    void clear_store_birthday();
    const std::string& store_birthday() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_store_birthday(ArgT0&& arg0, ArgT... args);
    std::string* mutable_store_birthday();
    PROTOBUF_NODISCARD std::string* release_store_birthday();
    void set_allocated_store_birthday(std::string* store_birthday);

private:
    const std::string& _internal_store_birthday() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_birthday(const std::string& value);
    std::string* _internal_mutable_store_birthday();

public:
    // optional string api_key = 12;
    bool has_api_key() const;

private:
    bool _internal_has_api_key() const;

public:
    void clear_api_key();
    const std::string& api_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_api_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_api_key();
    PROTOBUF_NODISCARD std::string* release_api_key();
    void set_allocated_api_key(std::string* api_key);

private:
    const std::string& _internal_api_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
    std::string* _internal_mutable_api_key();

public:
    // optional string invalidator_client_id = 14 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_invalidator_client_id() const;

private:
    bool _internal_has_invalidator_client_id() const;

public:
    PROTOBUF_DEPRECATED void clear_invalidator_client_id();
    PROTOBUF_DEPRECATED const std::string& invalidator_client_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_invalidator_client_id(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_invalidator_client_id();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_invalidator_client_id();
    PROTOBUF_DEPRECATED void set_allocated_invalidator_client_id(std::string* invalidator_client_id);

private:
    const std::string& _internal_invalidator_client_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_invalidator_client_id(const std::string& value);
    std::string* _internal_mutable_invalidator_client_id();

public:
    // optional .sync_pb.CommitMessage commit = 4;
    bool has_commit() const;

private:
    bool _internal_has_commit() const;

public:
    void clear_commit();
    const ::sync_pb::CommitMessage& commit() const;
    PROTOBUF_NODISCARD ::sync_pb::CommitMessage* release_commit();
    ::sync_pb::CommitMessage* mutable_commit();
    void set_allocated_commit(::sync_pb::CommitMessage* commit);

private:
    const ::sync_pb::CommitMessage& _internal_commit() const;
    ::sync_pb::CommitMessage* _internal_mutable_commit();

public:
    void unsafe_arena_set_allocated_commit(::sync_pb::CommitMessage* commit);
    ::sync_pb::CommitMessage* unsafe_arena_release_commit();

    // optional .sync_pb.GetUpdatesMessage get_updates = 5;
    bool has_get_updates() const;

private:
    bool _internal_has_get_updates() const;

public:
    void clear_get_updates();
    const ::sync_pb::GetUpdatesMessage& get_updates() const;
    PROTOBUF_NODISCARD ::sync_pb::GetUpdatesMessage* release_get_updates();
    ::sync_pb::GetUpdatesMessage* mutable_get_updates();
    void set_allocated_get_updates(::sync_pb::GetUpdatesMessage* get_updates);

private:
    const ::sync_pb::GetUpdatesMessage& _internal_get_updates() const;
    ::sync_pb::GetUpdatesMessage* _internal_mutable_get_updates();

public:
    void unsafe_arena_set_allocated_get_updates(::sync_pb::GetUpdatesMessage* get_updates);
    ::sync_pb::GetUpdatesMessage* unsafe_arena_release_get_updates();

    // optional .sync_pb.DebugInfo debug_info = 10;
    bool has_debug_info() const;

private:
    bool _internal_has_debug_info() const;

public:
    void clear_debug_info();
    const ::sync_pb::DebugInfo& debug_info() const;
    PROTOBUF_NODISCARD ::sync_pb::DebugInfo* release_debug_info();
    ::sync_pb::DebugInfo* mutable_debug_info();
    void set_allocated_debug_info(::sync_pb::DebugInfo* debug_info);

private:
    const ::sync_pb::DebugInfo& _internal_debug_info() const;
    ::sync_pb::DebugInfo* _internal_mutable_debug_info();

public:
    void unsafe_arena_set_allocated_debug_info(::sync_pb::DebugInfo* debug_info);
    ::sync_pb::DebugInfo* unsafe_arena_release_debug_info();

    // optional .sync_pb.ChipBag bag_of_chips = 11;
    bool has_bag_of_chips() const;

private:
    bool _internal_has_bag_of_chips() const;

public:
    void clear_bag_of_chips();
    const ::sync_pb::ChipBag& bag_of_chips() const;
    PROTOBUF_NODISCARD ::sync_pb::ChipBag* release_bag_of_chips();
    ::sync_pb::ChipBag* mutable_bag_of_chips();
    void set_allocated_bag_of_chips(::sync_pb::ChipBag* bag_of_chips);

private:
    const ::sync_pb::ChipBag& _internal_bag_of_chips() const;
    ::sync_pb::ChipBag* _internal_mutable_bag_of_chips();

public:
    void unsafe_arena_set_allocated_bag_of_chips(::sync_pb::ChipBag* bag_of_chips);
    ::sync_pb::ChipBag* unsafe_arena_release_bag_of_chips();

    // optional .sync_pb.ClientStatus client_status = 13;
    bool has_client_status() const;

private:
    bool _internal_has_client_status() const;

public:
    void clear_client_status();
    const ::sync_pb::ClientStatus& client_status() const;
    PROTOBUF_NODISCARD ::sync_pb::ClientStatus* release_client_status();
    ::sync_pb::ClientStatus* mutable_client_status();
    void set_allocated_client_status(::sync_pb::ClientStatus* client_status);

private:
    const ::sync_pb::ClientStatus& _internal_client_status() const;
    ::sync_pb::ClientStatus* _internal_mutable_client_status();

public:
    void unsafe_arena_set_allocated_client_status(::sync_pb::ClientStatus* client_status);
    ::sync_pb::ClientStatus* unsafe_arena_release_client_status();

    // optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
    bool has_clear_server_data() const;

private:
    bool _internal_has_clear_server_data() const;

public:
    void clear_clear_server_data();
    const ::sync_pb::ClearServerDataMessage& clear_server_data() const;
    PROTOBUF_NODISCARD ::sync_pb::ClearServerDataMessage* release_clear_server_data();
    ::sync_pb::ClearServerDataMessage* mutable_clear_server_data();
    void set_allocated_clear_server_data(::sync_pb::ClearServerDataMessage* clear_server_data);

private:
    const ::sync_pb::ClearServerDataMessage& _internal_clear_server_data() const;
    ::sync_pb::ClearServerDataMessage* _internal_mutable_clear_server_data();

public:
    void unsafe_arena_set_allocated_clear_server_data(::sync_pb::ClearServerDataMessage* clear_server_data);
    ::sync_pb::ClearServerDataMessage* unsafe_arena_release_clear_server_data();

    // optional int32 protocol_version = 2 [default = 99];
    bool has_protocol_version() const;

private:
    bool _internal_has_protocol_version() const;

public:
    void clear_protocol_version();
    int32_t protocol_version() const;
    void set_protocol_version(int32_t value);

private:
    int32_t _internal_protocol_version() const;
    void _internal_set_protocol_version(int32_t value);

public:
    // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
    bool has_message_contents() const;

private:
    bool _internal_has_message_contents() const;

public:
    void clear_message_contents();
    ::sync_pb::ClientToServerMessage_Contents message_contents() const;
    void set_message_contents(::sync_pb::ClientToServerMessage_Contents value);

private:
    ::sync_pb::ClientToServerMessage_Contents _internal_message_contents() const;
    void _internal_set_message_contents(::sync_pb::ClientToServerMessage_Contents value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerMessage)
private:
    class _Internal;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr share_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_birthday_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidator_client_id_;
        ::sync_pb::CommitMessage* commit_;
        ::sync_pb::GetUpdatesMessage* get_updates_;
        ::sync_pb::DebugInfo* debug_info_;
        ::sync_pb::ChipBag* bag_of_chips_;
        ::sync_pb::ClientStatus* client_status_;
        ::sync_pb::ClearServerDataMessage* clear_server_data_;
        int32_t protocol_version_;
        int message_contents_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class CommitResponse_EntryResponse_DatatypeSpecificError final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError) */ {
public:
    inline CommitResponse_EntryResponse_DatatypeSpecificError()
        : CommitResponse_EntryResponse_DatatypeSpecificError(nullptr)
    {
    }
    ~CommitResponse_EntryResponse_DatatypeSpecificError() override;
    explicit PROTOBUF_CONSTEXPR CommitResponse_EntryResponse_DatatypeSpecificError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CommitResponse_EntryResponse_DatatypeSpecificError(const CommitResponse_EntryResponse_DatatypeSpecificError& from);
    CommitResponse_EntryResponse_DatatypeSpecificError(CommitResponse_EntryResponse_DatatypeSpecificError&& from) noexcept
        : CommitResponse_EntryResponse_DatatypeSpecificError()
    {
        *this = ::std::move(from);
    }

    inline CommitResponse_EntryResponse_DatatypeSpecificError& operator=(const CommitResponse_EntryResponse_DatatypeSpecificError& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CommitResponse_EntryResponse_DatatypeSpecificError& operator=(CommitResponse_EntryResponse_DatatypeSpecificError&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CommitResponse_EntryResponse_DatatypeSpecificError& default_instance()
    {
        return *internal_default_instance();
    }
    enum DatatypeErrorCase {
        kSharingMessageError = 1,
        kOutgoingPasswordSharingInvitationError = 2,
        DATATYPE_ERROR_NOT_SET = 0,
    };

    static inline const CommitResponse_EntryResponse_DatatypeSpecificError* internal_default_instance()
    {
        return reinterpret_cast<const CommitResponse_EntryResponse_DatatypeSpecificError*>(
            &_CommitResponse_EntryResponse_DatatypeSpecificError_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(CommitResponse_EntryResponse_DatatypeSpecificError& a, CommitResponse_EntryResponse_DatatypeSpecificError& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CommitResponse_EntryResponse_DatatypeSpecificError* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CommitResponse_EntryResponse_DatatypeSpecificError* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CommitResponse_EntryResponse_DatatypeSpecificError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CommitResponse_EntryResponse_DatatypeSpecificError>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CommitResponse_EntryResponse_DatatypeSpecificError& from);
    void MergeFrom(const CommitResponse_EntryResponse_DatatypeSpecificError& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CommitResponse_EntryResponse_DatatypeSpecificError* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError";
    }

protected:
    explicit CommitResponse_EntryResponse_DatatypeSpecificError(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSharingMessageErrorFieldNumber = 1,
        kOutgoingPasswordSharingInvitationErrorFieldNumber = 2,
    };
    // .sync_pb.SharingMessageCommitError sharing_message_error = 1;
    bool has_sharing_message_error() const;

private:
    bool _internal_has_sharing_message_error() const;

public:
    void clear_sharing_message_error();
    const ::sync_pb::SharingMessageCommitError& sharing_message_error() const;
    PROTOBUF_NODISCARD ::sync_pb::SharingMessageCommitError* release_sharing_message_error();
    ::sync_pb::SharingMessageCommitError* mutable_sharing_message_error();
    void set_allocated_sharing_message_error(::sync_pb::SharingMessageCommitError* sharing_message_error);

private:
    const ::sync_pb::SharingMessageCommitError& _internal_sharing_message_error() const;
    ::sync_pb::SharingMessageCommitError* _internal_mutable_sharing_message_error();

public:
    void unsafe_arena_set_allocated_sharing_message_error(::sync_pb::SharingMessageCommitError* sharing_message_error);
    ::sync_pb::SharingMessageCommitError* unsafe_arena_release_sharing_message_error();

    // .sync_pb.OutgoingPasswordSharingInvitationCommitError outgoing_password_sharing_invitation_error = 2;
    bool has_outgoing_password_sharing_invitation_error() const;

private:
    bool _internal_has_outgoing_password_sharing_invitation_error() const;

public:
    void clear_outgoing_password_sharing_invitation_error();
    const ::sync_pb::OutgoingPasswordSharingInvitationCommitError& outgoing_password_sharing_invitation_error() const;
    PROTOBUF_NODISCARD ::sync_pb::OutgoingPasswordSharingInvitationCommitError* release_outgoing_password_sharing_invitation_error();
    ::sync_pb::OutgoingPasswordSharingInvitationCommitError* mutable_outgoing_password_sharing_invitation_error();
    void set_allocated_outgoing_password_sharing_invitation_error(
        ::sync_pb::OutgoingPasswordSharingInvitationCommitError* outgoing_password_sharing_invitation_error);

private:
    const ::sync_pb::OutgoingPasswordSharingInvitationCommitError& _internal_outgoing_password_sharing_invitation_error() const;
    ::sync_pb::OutgoingPasswordSharingInvitationCommitError* _internal_mutable_outgoing_password_sharing_invitation_error();

public:
    void unsafe_arena_set_allocated_outgoing_password_sharing_invitation_error(
        ::sync_pb::OutgoingPasswordSharingInvitationCommitError* outgoing_password_sharing_invitation_error);
    ::sync_pb::OutgoingPasswordSharingInvitationCommitError* unsafe_arena_release_outgoing_password_sharing_invitation_error();

    void clear_datatype_error();
    DatatypeErrorCase datatype_error_case() const;
    // @@protoc_insertion_point(class_scope:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
private:
    class _Internal;
    void set_has_sharing_message_error();
    void set_has_outgoing_password_sharing_invitation_error();

    inline bool has_datatype_error() const;
    inline void clear_has_datatype_error();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union DatatypeErrorUnion {
            constexpr DatatypeErrorUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::sync_pb::SharingMessageCommitError* sharing_message_error_;
            ::sync_pb::OutgoingPasswordSharingInvitationCommitError* outgoing_password_sharing_invitation_error_;
        } datatype_error_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class CommitResponse_EntryResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CommitResponse.EntryResponse) */ {
public:
    inline CommitResponse_EntryResponse()
        : CommitResponse_EntryResponse(nullptr)
    {
    }
    ~CommitResponse_EntryResponse() override;
    explicit PROTOBUF_CONSTEXPR CommitResponse_EntryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CommitResponse_EntryResponse(const CommitResponse_EntryResponse& from);
    CommitResponse_EntryResponse(CommitResponse_EntryResponse&& from) noexcept
        : CommitResponse_EntryResponse()
    {
        *this = ::std::move(from);
    }

    inline CommitResponse_EntryResponse& operator=(const CommitResponse_EntryResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CommitResponse_EntryResponse& operator=(CommitResponse_EntryResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CommitResponse_EntryResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CommitResponse_EntryResponse* internal_default_instance()
    {
        return reinterpret_cast<const CommitResponse_EntryResponse*>(&_CommitResponse_EntryResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(CommitResponse_EntryResponse& a, CommitResponse_EntryResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CommitResponse_EntryResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CommitResponse_EntryResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CommitResponse_EntryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CommitResponse_EntryResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CommitResponse_EntryResponse& from);
    void MergeFrom(const CommitResponse_EntryResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CommitResponse_EntryResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.CommitResponse.EntryResponse";
    }

protected:
    explicit CommitResponse_EntryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef CommitResponse_EntryResponse_DatatypeSpecificError DatatypeSpecificError;

    // accessors -------------------------------------------------------

    enum : int {
        kIdStringFieldNumber = 3,
        kErrorMessageFieldNumber = 9,
        kDatatypeSpecificErrorFieldNumber = 11,
        kVersionFieldNumber = 6,
        kMtimeFieldNumber = 10,
        kResponseTypeFieldNumber = 2,
    };
    // optional string id_string = 3;
    bool has_id_string() const;

private:
    bool _internal_has_id_string() const;

public:
    void clear_id_string();
    const std::string& id_string() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_id_string(ArgT0&& arg0, ArgT... args);
    std::string* mutable_id_string();
    PROTOBUF_NODISCARD std::string* release_id_string();
    void set_allocated_id_string(std::string* id_string);

private:
    const std::string& _internal_id_string() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_string(const std::string& value);
    std::string* _internal_mutable_id_string();

public:
    // optional string error_message = 9;
    bool has_error_message() const;

private:
    bool _internal_has_error_message() const;

public:
    void clear_error_message();
    const std::string& error_message() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_error_message(ArgT0&& arg0, ArgT... args);
    std::string* mutable_error_message();
    PROTOBUF_NODISCARD std::string* release_error_message();
    void set_allocated_error_message(std::string* error_message);

private:
    const std::string& _internal_error_message() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
    std::string* _internal_mutable_error_message();

public:
    // optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
    bool has_datatype_specific_error() const;

private:
    bool _internal_has_datatype_specific_error() const;

public:
    void clear_datatype_specific_error();
    const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& datatype_specific_error() const;
    PROTOBUF_NODISCARD ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* release_datatype_specific_error();
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* mutable_datatype_specific_error();
    void set_allocated_datatype_specific_error(::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error);

private:
    const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& _internal_datatype_specific_error() const;
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* _internal_mutable_datatype_specific_error();

public:
    void unsafe_arena_set_allocated_datatype_specific_error(::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error);
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* unsafe_arena_release_datatype_specific_error();

    // optional int64 version = 6;
    bool has_version() const;

private:
    bool _internal_has_version() const;

public:
    void clear_version();
    int64_t version() const;
    void set_version(int64_t value);

private:
    int64_t _internal_version() const;
    void _internal_set_version(int64_t value);

public:
    // optional int64 mtime = 10 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_mtime() const;

private:
    bool _internal_has_mtime() const;

public:
    PROTOBUF_DEPRECATED void clear_mtime();
    PROTOBUF_DEPRECATED int64_t mtime() const;
    PROTOBUF_DEPRECATED void set_mtime(int64_t value);

private:
    int64_t _internal_mtime() const;
    void _internal_set_mtime(int64_t value);

public:
    // required .sync_pb.CommitResponse.ResponseType response_type = 2;
    bool has_response_type() const;

private:
    bool _internal_has_response_type() const;

public:
    void clear_response_type();
    ::sync_pb::CommitResponse_ResponseType response_type() const;
    void set_response_type(::sync_pb::CommitResponse_ResponseType value);

private:
    ::sync_pb::CommitResponse_ResponseType _internal_response_type() const;
    void _internal_set_response_type(::sync_pb::CommitResponse_ResponseType value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.CommitResponse.EntryResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_string_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
        ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error_;
        int64_t version_;
        int64_t mtime_;
        int response_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class CommitResponse final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CommitResponse) */ {
public:
    inline CommitResponse()
        : CommitResponse(nullptr)
    {
    }
    ~CommitResponse() override;
    explicit PROTOBUF_CONSTEXPR CommitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CommitResponse(const CommitResponse& from);
    CommitResponse(CommitResponse&& from) noexcept
        : CommitResponse()
    {
        *this = ::std::move(from);
    }

    inline CommitResponse& operator=(const CommitResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CommitResponse& operator=(CommitResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CommitResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CommitResponse* internal_default_instance()
    {
        return reinterpret_cast<const CommitResponse*>(&_CommitResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(CommitResponse& a, CommitResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CommitResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CommitResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CommitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CommitResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CommitResponse& from);
    void MergeFrom(const CommitResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CommitResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.CommitResponse";
    }

protected:
    explicit CommitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef CommitResponse_EntryResponse EntryResponse;

    typedef CommitResponse_ResponseType ResponseType;
    static constexpr ResponseType SUCCESS = CommitResponse_ResponseType_SUCCESS;
    static constexpr ResponseType CONFLICT = CommitResponse_ResponseType_CONFLICT;
    static constexpr ResponseType RETRY = CommitResponse_ResponseType_RETRY;
    static constexpr ResponseType INVALID_MESSAGE = CommitResponse_ResponseType_INVALID_MESSAGE;
    static constexpr ResponseType OVER_QUOTA = CommitResponse_ResponseType_OVER_QUOTA;
    static constexpr ResponseType TRANSIENT_ERROR = CommitResponse_ResponseType_TRANSIENT_ERROR;
    static inline bool ResponseType_IsValid(int value)
    {
        return CommitResponse_ResponseType_IsValid(value);
    }
    static constexpr ResponseType ResponseType_MIN = CommitResponse_ResponseType_ResponseType_MIN;
    static constexpr ResponseType ResponseType_MAX = CommitResponse_ResponseType_ResponseType_MAX;
    static constexpr int ResponseType_ARRAYSIZE = CommitResponse_ResponseType_ResponseType_ARRAYSIZE;
    template <typename T> static inline const std::string& ResponseType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, ResponseType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ResponseType_Name.");
        return CommitResponse_ResponseType_Name(enum_t_value);
    }
    static inline bool ResponseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ResponseType* value)
    {
        return CommitResponse_ResponseType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kEntryresponseFieldNumber = 1,
    };
    // repeated group EntryResponse = 1 { ... };
    int entryresponse_size() const;

private:
    int _internal_entryresponse_size() const;

public:
    void clear_entryresponse();
    ::sync_pb::CommitResponse_EntryResponse* mutable_entryresponse(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CommitResponse_EntryResponse>* mutable_entryresponse();

private:
    const ::sync_pb::CommitResponse_EntryResponse& _internal_entryresponse(int index) const;
    ::sync_pb::CommitResponse_EntryResponse* _internal_add_entryresponse();

public:
    const ::sync_pb::CommitResponse_EntryResponse& entryresponse(int index) const;
    ::sync_pb::CommitResponse_EntryResponse* add_entryresponse();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CommitResponse_EntryResponse>& entryresponse() const;

    // @@protoc_insertion_point(class_scope:sync_pb.CommitResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CommitResponse_EntryResponse> entryresponse_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class GetUpdatesResponse final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.GetUpdatesResponse) */ {
public:
    inline GetUpdatesResponse()
        : GetUpdatesResponse(nullptr)
    {
    }
    ~GetUpdatesResponse() override;
    explicit PROTOBUF_CONSTEXPR GetUpdatesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    GetUpdatesResponse(const GetUpdatesResponse& from);
    GetUpdatesResponse(GetUpdatesResponse&& from) noexcept
        : GetUpdatesResponse()
    {
        *this = ::std::move(from);
    }

    inline GetUpdatesResponse& operator=(const GetUpdatesResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline GetUpdatesResponse& operator=(GetUpdatesResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const GetUpdatesResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const GetUpdatesResponse* internal_default_instance()
    {
        return reinterpret_cast<const GetUpdatesResponse*>(&_GetUpdatesResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(GetUpdatesResponse& a, GetUpdatesResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(GetUpdatesResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(GetUpdatesResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    GetUpdatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<GetUpdatesResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const GetUpdatesResponse& from);
    void MergeFrom(const GetUpdatesResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(GetUpdatesResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.GetUpdatesResponse";
    }

protected:
    explicit GetUpdatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEntriesFieldNumber = 1,
        kNewProgressMarkerFieldNumber = 5,
        kEncryptionKeysFieldNumber = 6,
        kContextMutationsFieldNumber = 7,
        kChangesRemainingFieldNumber = 4,
    };
    // repeated .sync_pb.SyncEntity entries = 1;
    int entries_size() const;

private:
    int _internal_entries_size() const;

public:
    void clear_entries();
    ::sync_pb::SyncEntity* mutable_entries(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity>* mutable_entries();

private:
    const ::sync_pb::SyncEntity& _internal_entries(int index) const;
    ::sync_pb::SyncEntity* _internal_add_entries();

public:
    const ::sync_pb::SyncEntity& entries(int index) const;
    ::sync_pb::SyncEntity* add_entries();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity>& entries() const;

    // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
    int new_progress_marker_size() const;

private:
    int _internal_new_progress_marker_size() const;

public:
    void clear_new_progress_marker();
    ::sync_pb::DataTypeProgressMarker* mutable_new_progress_marker(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker>* mutable_new_progress_marker();

private:
    const ::sync_pb::DataTypeProgressMarker& _internal_new_progress_marker(int index) const;
    ::sync_pb::DataTypeProgressMarker* _internal_add_new_progress_marker();

public:
    const ::sync_pb::DataTypeProgressMarker& new_progress_marker(int index) const;
    ::sync_pb::DataTypeProgressMarker* add_new_progress_marker();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker>& new_progress_marker() const;

    // repeated bytes encryption_keys = 6;
    int encryption_keys_size() const;

private:
    int _internal_encryption_keys_size() const;

public:
    void clear_encryption_keys();
    const std::string& encryption_keys(int index) const;
    std::string* mutable_encryption_keys(int index);
    void set_encryption_keys(int index, const std::string& value);
    void set_encryption_keys(int index, std::string&& value);
    void set_encryption_keys(int index, const char* value);
    void set_encryption_keys(int index, const void* value, size_t size);
    std::string* add_encryption_keys();
    void add_encryption_keys(const std::string& value);
    void add_encryption_keys(std::string&& value);
    void add_encryption_keys(const char* value);
    void add_encryption_keys(const void* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& encryption_keys() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_encryption_keys();

private:
    const std::string& _internal_encryption_keys(int index) const;
    std::string* _internal_add_encryption_keys();

public:
    // repeated .sync_pb.DataTypeContext context_mutations = 7;
    int context_mutations_size() const;

private:
    int _internal_context_mutations_size() const;

public:
    void clear_context_mutations();
    ::sync_pb::DataTypeContext* mutable_context_mutations(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>* mutable_context_mutations();

private:
    const ::sync_pb::DataTypeContext& _internal_context_mutations(int index) const;
    ::sync_pb::DataTypeContext* _internal_add_context_mutations();

public:
    const ::sync_pb::DataTypeContext& context_mutations(int index) const;
    ::sync_pb::DataTypeContext* add_context_mutations();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>& context_mutations() const;

    // optional int64 changes_remaining = 4;
    bool has_changes_remaining() const;

private:
    bool _internal_has_changes_remaining() const;

public:
    void clear_changes_remaining();
    int64_t changes_remaining() const;
    void set_changes_remaining(int64_t value);

private:
    int64_t _internal_changes_remaining() const;
    void _internal_set_changes_remaining(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity> entries_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker> new_progress_marker_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> encryption_keys_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext> context_mutations_;
        int64_t changes_remaining_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientToServerResponse_Error final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientToServerResponse.Error) */ {
public:
    inline ClientToServerResponse_Error()
        : ClientToServerResponse_Error(nullptr)
    {
    }
    ~ClientToServerResponse_Error() override;
    explicit PROTOBUF_CONSTEXPR ClientToServerResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientToServerResponse_Error(const ClientToServerResponse_Error& from);
    ClientToServerResponse_Error(ClientToServerResponse_Error&& from) noexcept
        : ClientToServerResponse_Error()
    {
        *this = ::std::move(from);
    }

    inline ClientToServerResponse_Error& operator=(const ClientToServerResponse_Error& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientToServerResponse_Error& operator=(ClientToServerResponse_Error&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientToServerResponse_Error& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientToServerResponse_Error* internal_default_instance()
    {
        return reinterpret_cast<const ClientToServerResponse_Error*>(&_ClientToServerResponse_Error_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(ClientToServerResponse_Error& a, ClientToServerResponse_Error& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientToServerResponse_Error* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientToServerResponse_Error* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientToServerResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientToServerResponse_Error>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientToServerResponse_Error& from);
    void MergeFrom(const ClientToServerResponse_Error& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientToServerResponse_Error* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ClientToServerResponse.Error";
    }

protected:
    explicit ClientToServerResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kErrorDataTypeIdsFieldNumber = 5,
        kErrorDescriptionFieldNumber = 2,
        kErrorTypeFieldNumber = 1,
        kActionFieldNumber = 4,
    };
    // repeated int32 error_data_type_ids = 5;
    int error_data_type_ids_size() const;

private:
    int _internal_error_data_type_ids_size() const;

public:
    void clear_error_data_type_ids();

private:
    int32_t _internal_error_data_type_ids(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_error_data_type_ids() const;
    void _internal_add_error_data_type_ids(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_error_data_type_ids();

public:
    int32_t error_data_type_ids(int index) const;
    void set_error_data_type_ids(int index, int32_t value);
    void add_error_data_type_ids(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& error_data_type_ids() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_error_data_type_ids();

    // optional string error_description = 2;
    bool has_error_description() const;

private:
    bool _internal_has_error_description() const;

public:
    void clear_error_description();
    const std::string& error_description() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_error_description(ArgT0&& arg0, ArgT... args);
    std::string* mutable_error_description();
    PROTOBUF_NODISCARD std::string* release_error_description();
    void set_allocated_error_description(std::string* error_description);

private:
    const std::string& _internal_error_description() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_description(const std::string& value);
    std::string* _internal_mutable_error_description();

public:
    // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
    bool has_error_type() const;

private:
    bool _internal_has_error_type() const;

public:
    void clear_error_type();
    ::sync_pb::SyncEnums_ErrorType error_type() const;
    void set_error_type(::sync_pb::SyncEnums_ErrorType value);

private:
    ::sync_pb::SyncEnums_ErrorType _internal_error_type() const;
    void _internal_set_error_type(::sync_pb::SyncEnums_ErrorType value);

public:
    // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
    bool has_action() const;

private:
    bool _internal_has_action() const;

public:
    void clear_action();
    ::sync_pb::SyncEnums_Action action() const;
    void set_action(::sync_pb::SyncEnums_Action value);

private:
    ::sync_pb::SyncEnums_Action _internal_action() const;
    void _internal_set_action(::sync_pb::SyncEnums_Action value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerResponse.Error)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> error_data_type_ids_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_description_;
        int error_type_;
        int action_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientToServerResponse final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientToServerResponse) */ {
public:
    inline ClientToServerResponse()
        : ClientToServerResponse(nullptr)
    {
    }
    ~ClientToServerResponse() override;
    explicit PROTOBUF_CONSTEXPR ClientToServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ClientToServerResponse(const ClientToServerResponse& from);
    ClientToServerResponse(ClientToServerResponse&& from) noexcept
        : ClientToServerResponse()
    {
        *this = ::std::move(from);
    }

    inline ClientToServerResponse& operator=(const ClientToServerResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ClientToServerResponse& operator=(ClientToServerResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ClientToServerResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ClientToServerResponse* internal_default_instance()
    {
        return reinterpret_cast<const ClientToServerResponse*>(&_ClientToServerResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 14;

    friend void swap(ClientToServerResponse& a, ClientToServerResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ClientToServerResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ClientToServerResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ClientToServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ClientToServerResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ClientToServerResponse& from);
    void MergeFrom(const ClientToServerResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ClientToServerResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ClientToServerResponse";
    }

protected:
    explicit ClientToServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef ClientToServerResponse_Error Error;

    // accessors -------------------------------------------------------

    enum : int {
        kMigratedDataTypeIdFieldNumber = 12,
        kErrorMessageFieldNumber = 5,
        kStoreBirthdayFieldNumber = 6,
        kCommitFieldNumber = 1,
        kGetUpdatesFieldNumber = 2,
        kClientCommandFieldNumber = 7,
        kErrorFieldNumber = 13,
        kNewBagOfChipsFieldNumber = 14,
        kClearServerDataFieldNumber = 15,
        kErrorCodeFieldNumber = 4,
    };
    // repeated int32 migrated_data_type_id = 12;
    int migrated_data_type_id_size() const;

private:
    int _internal_migrated_data_type_id_size() const;

public:
    void clear_migrated_data_type_id();

private:
    int32_t _internal_migrated_data_type_id(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_migrated_data_type_id() const;
    void _internal_add_migrated_data_type_id(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_migrated_data_type_id();

public:
    int32_t migrated_data_type_id(int index) const;
    void set_migrated_data_type_id(int index, int32_t value);
    void add_migrated_data_type_id(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& migrated_data_type_id() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_migrated_data_type_id();

    // optional string error_message = 5;
    bool has_error_message() const;

private:
    bool _internal_has_error_message() const;

public:
    void clear_error_message();
    const std::string& error_message() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_error_message(ArgT0&& arg0, ArgT... args);
    std::string* mutable_error_message();
    PROTOBUF_NODISCARD std::string* release_error_message();
    void set_allocated_error_message(std::string* error_message);

private:
    const std::string& _internal_error_message() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
    std::string* _internal_mutable_error_message();

public:
    // optional string store_birthday = 6;
    bool has_store_birthday() const;

private:
    bool _internal_has_store_birthday() const;

public:
    void clear_store_birthday();
    const std::string& store_birthday() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_store_birthday(ArgT0&& arg0, ArgT... args);
    std::string* mutable_store_birthday();
    PROTOBUF_NODISCARD std::string* release_store_birthday();
    void set_allocated_store_birthday(std::string* store_birthday);

private:
    const std::string& _internal_store_birthday() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_birthday(const std::string& value);
    std::string* _internal_mutable_store_birthday();

public:
    // optional .sync_pb.CommitResponse commit = 1;
    bool has_commit() const;

private:
    bool _internal_has_commit() const;

public:
    void clear_commit();
    const ::sync_pb::CommitResponse& commit() const;
    PROTOBUF_NODISCARD ::sync_pb::CommitResponse* release_commit();
    ::sync_pb::CommitResponse* mutable_commit();
    void set_allocated_commit(::sync_pb::CommitResponse* commit);

private:
    const ::sync_pb::CommitResponse& _internal_commit() const;
    ::sync_pb::CommitResponse* _internal_mutable_commit();

public:
    void unsafe_arena_set_allocated_commit(::sync_pb::CommitResponse* commit);
    ::sync_pb::CommitResponse* unsafe_arena_release_commit();

    // optional .sync_pb.GetUpdatesResponse get_updates = 2;
    bool has_get_updates() const;

private:
    bool _internal_has_get_updates() const;

public:
    void clear_get_updates();
    const ::sync_pb::GetUpdatesResponse& get_updates() const;
    PROTOBUF_NODISCARD ::sync_pb::GetUpdatesResponse* release_get_updates();
    ::sync_pb::GetUpdatesResponse* mutable_get_updates();
    void set_allocated_get_updates(::sync_pb::GetUpdatesResponse* get_updates);

private:
    const ::sync_pb::GetUpdatesResponse& _internal_get_updates() const;
    ::sync_pb::GetUpdatesResponse* _internal_mutable_get_updates();

public:
    void unsafe_arena_set_allocated_get_updates(::sync_pb::GetUpdatesResponse* get_updates);
    ::sync_pb::GetUpdatesResponse* unsafe_arena_release_get_updates();

    // optional .sync_pb.ClientCommand client_command = 7;
    bool has_client_command() const;

private:
    bool _internal_has_client_command() const;

public:
    void clear_client_command();
    const ::sync_pb::ClientCommand& client_command() const;
    PROTOBUF_NODISCARD ::sync_pb::ClientCommand* release_client_command();
    ::sync_pb::ClientCommand* mutable_client_command();
    void set_allocated_client_command(::sync_pb::ClientCommand* client_command);

private:
    const ::sync_pb::ClientCommand& _internal_client_command() const;
    ::sync_pb::ClientCommand* _internal_mutable_client_command();

public:
    void unsafe_arena_set_allocated_client_command(::sync_pb::ClientCommand* client_command);
    ::sync_pb::ClientCommand* unsafe_arena_release_client_command();

    // optional .sync_pb.ClientToServerResponse.Error error = 13;
    bool has_error() const;

private:
    bool _internal_has_error() const;

public:
    void clear_error();
    const ::sync_pb::ClientToServerResponse_Error& error() const;
    PROTOBUF_NODISCARD ::sync_pb::ClientToServerResponse_Error* release_error();
    ::sync_pb::ClientToServerResponse_Error* mutable_error();
    void set_allocated_error(::sync_pb::ClientToServerResponse_Error* error);

private:
    const ::sync_pb::ClientToServerResponse_Error& _internal_error() const;
    ::sync_pb::ClientToServerResponse_Error* _internal_mutable_error();

public:
    void unsafe_arena_set_allocated_error(::sync_pb::ClientToServerResponse_Error* error);
    ::sync_pb::ClientToServerResponse_Error* unsafe_arena_release_error();

    // optional .sync_pb.ChipBag new_bag_of_chips = 14;
    bool has_new_bag_of_chips() const;

private:
    bool _internal_has_new_bag_of_chips() const;

public:
    void clear_new_bag_of_chips();
    const ::sync_pb::ChipBag& new_bag_of_chips() const;
    PROTOBUF_NODISCARD ::sync_pb::ChipBag* release_new_bag_of_chips();
    ::sync_pb::ChipBag* mutable_new_bag_of_chips();
    void set_allocated_new_bag_of_chips(::sync_pb::ChipBag* new_bag_of_chips);

private:
    const ::sync_pb::ChipBag& _internal_new_bag_of_chips() const;
    ::sync_pb::ChipBag* _internal_mutable_new_bag_of_chips();

public:
    void unsafe_arena_set_allocated_new_bag_of_chips(::sync_pb::ChipBag* new_bag_of_chips);
    ::sync_pb::ChipBag* unsafe_arena_release_new_bag_of_chips();

    // optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
    bool has_clear_server_data() const;

private:
    bool _internal_has_clear_server_data() const;

public:
    void clear_clear_server_data();
    const ::sync_pb::ClearServerDataResponse& clear_server_data() const;
    PROTOBUF_NODISCARD ::sync_pb::ClearServerDataResponse* release_clear_server_data();
    ::sync_pb::ClearServerDataResponse* mutable_clear_server_data();
    void set_allocated_clear_server_data(::sync_pb::ClearServerDataResponse* clear_server_data);

private:
    const ::sync_pb::ClearServerDataResponse& _internal_clear_server_data() const;
    ::sync_pb::ClearServerDataResponse* _internal_mutable_clear_server_data();

public:
    void unsafe_arena_set_allocated_clear_server_data(::sync_pb::ClearServerDataResponse* clear_server_data);
    ::sync_pb::ClearServerDataResponse* unsafe_arena_release_clear_server_data();

    // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
    bool has_error_code() const;

private:
    bool _internal_has_error_code() const;

public:
    void clear_error_code();
    ::sync_pb::SyncEnums_ErrorType error_code() const;
    void set_error_code(::sync_pb::SyncEnums_ErrorType value);

private:
    ::sync_pb::SyncEnums_ErrorType _internal_error_code() const;
    void _internal_set_error_code(::sync_pb::SyncEnums_ErrorType value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> migrated_data_type_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_birthday_;
        ::sync_pb::CommitResponse* commit_;
        ::sync_pb::GetUpdatesResponse* get_updates_;
        ::sync_pb::ClientCommand* client_command_;
        ::sync_pb::ClientToServerResponse_Error* error_;
        ::sync_pb::ChipBag* new_bag_of_chips_;
        ::sync_pb::ClearServerDataResponse* clear_server_data_;
        int error_code_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class EventRequest final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.EventRequest) */ {
public:
    inline EventRequest()
        : EventRequest(nullptr)
    {
    }
    ~EventRequest() override;
    explicit PROTOBUF_CONSTEXPR EventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    EventRequest(const EventRequest& from);
    EventRequest(EventRequest&& from) noexcept
        : EventRequest()
    {
        *this = ::std::move(from);
    }

    inline EventRequest& operator=(const EventRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EventRequest& operator=(EventRequest&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const EventRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const EventRequest* internal_default_instance()
    {
        return reinterpret_cast<const EventRequest*>(&_EventRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 15;

    friend void swap(EventRequest& a, EventRequest& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(EventRequest* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EventRequest* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    EventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<EventRequest>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const EventRequest& from);
    void MergeFrom(const EventRequest& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(EventRequest* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.EventRequest";
    }

protected:
    explicit EventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSyncDisabledFieldNumber = 1,
    };
    // optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
    bool has_sync_disabled() const;

private:
    bool _internal_has_sync_disabled() const;

public:
    void clear_sync_disabled();
    const ::sync_pb::SyncDisabledEvent& sync_disabled() const;
    PROTOBUF_NODISCARD ::sync_pb::SyncDisabledEvent* release_sync_disabled();
    ::sync_pb::SyncDisabledEvent* mutable_sync_disabled();
    void set_allocated_sync_disabled(::sync_pb::SyncDisabledEvent* sync_disabled);

private:
    const ::sync_pb::SyncDisabledEvent& _internal_sync_disabled() const;
    ::sync_pb::SyncDisabledEvent* _internal_mutable_sync_disabled();

public:
    void unsafe_arena_set_allocated_sync_disabled(::sync_pb::SyncDisabledEvent* sync_disabled);
    ::sync_pb::SyncDisabledEvent* unsafe_arena_release_sync_disabled();

    // @@protoc_insertion_point(class_scope:sync_pb.EventRequest)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::sync_pb::SyncDisabledEvent* sync_disabled_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class EventResponse final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.EventResponse) */ {
public:
    inline EventResponse()
        : EventResponse(nullptr)
    {
    }
    ~EventResponse() override;
    explicit PROTOBUF_CONSTEXPR EventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    EventResponse(const EventResponse& from);
    EventResponse(EventResponse&& from) noexcept
        : EventResponse()
    {
        *this = ::std::move(from);
    }

    inline EventResponse& operator=(const EventResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EventResponse& operator=(EventResponse&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const EventResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const EventResponse* internal_default_instance()
    {
        return reinterpret_cast<const EventResponse*>(&_EventResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 16;

    friend void swap(EventResponse& a, EventResponse& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(EventResponse* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EventResponse* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    EventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<EventResponse>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const EventResponse& from);
    void MergeFrom(const EventResponse& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(EventResponse* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.EventResponse";
    }

protected:
    explicit EventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    // @@protoc_insertion_point(class_scope:sync_pb.EventResponse)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class SyncDisabledEvent final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SyncDisabledEvent) */ {
public:
    inline SyncDisabledEvent()
        : SyncDisabledEvent(nullptr)
    {
    }
    ~SyncDisabledEvent() override;
    explicit PROTOBUF_CONSTEXPR SyncDisabledEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SyncDisabledEvent(const SyncDisabledEvent& from);
    SyncDisabledEvent(SyncDisabledEvent&& from) noexcept
        : SyncDisabledEvent()
    {
        *this = ::std::move(from);
    }

    inline SyncDisabledEvent& operator=(const SyncDisabledEvent& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SyncDisabledEvent& operator=(SyncDisabledEvent&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SyncDisabledEvent& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SyncDisabledEvent* internal_default_instance()
    {
        return reinterpret_cast<const SyncDisabledEvent*>(&_SyncDisabledEvent_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 17;

    friend void swap(SyncDisabledEvent& a, SyncDisabledEvent& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SyncDisabledEvent* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SyncDisabledEvent* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SyncDisabledEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SyncDisabledEvent>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SyncDisabledEvent& from);
    void MergeFrom(const SyncDisabledEvent& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SyncDisabledEvent* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.SyncDisabledEvent";
    }

protected:
    explicit SyncDisabledEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCacheGuidFieldNumber = 1,
        kStoreBirthdayFieldNumber = 2,
    };
    // optional string cache_guid = 1;
    bool has_cache_guid() const;

private:
    bool _internal_has_cache_guid() const;

public:
    void clear_cache_guid();
    const std::string& cache_guid() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_cache_guid(ArgT0&& arg0, ArgT... args);
    std::string* mutable_cache_guid();
    PROTOBUF_NODISCARD std::string* release_cache_guid();
    void set_allocated_cache_guid(std::string* cache_guid);

private:
    const std::string& _internal_cache_guid() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_guid(const std::string& value);
    std::string* _internal_mutable_cache_guid();

public:
    // optional string store_birthday = 2;
    bool has_store_birthday() const;

private:
    bool _internal_has_store_birthday() const;

public:
    void clear_store_birthday();
    const std::string& store_birthday() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_store_birthday(ArgT0&& arg0, ArgT... args);
    std::string* mutable_store_birthday();
    PROTOBUF_NODISCARD std::string* release_store_birthday();
    void set_allocated_store_birthday(std::string* store_birthday);

private:
    const std::string& _internal_store_birthday() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_birthday(const std::string& value);
    std::string* _internal_mutable_store_birthday();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.SyncDisabledEvent)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_guid_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_birthday_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// ChromiumExtensionsActivity

// optional string extension_id = 1;
inline bool ChromiumExtensionsActivity::_internal_has_extension_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ChromiumExtensionsActivity::has_extension_id() const
{
    return _internal_has_extension_id();
}
inline void ChromiumExtensionsActivity::clear_extension_id()
{
    _impl_.extension_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromiumExtensionsActivity::extension_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ChromiumExtensionsActivity.extension_id)
    return _internal_extension_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ChromiumExtensionsActivity::set_extension_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.extension_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ChromiumExtensionsActivity.extension_id)
}
inline std::string* ChromiumExtensionsActivity::mutable_extension_id()
{
    std::string* _s = _internal_mutable_extension_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.ChromiumExtensionsActivity.extension_id)
    return _s;
}
inline const std::string& ChromiumExtensionsActivity::_internal_extension_id() const
{
    return _impl_.extension_id_.Get();
}
inline void ChromiumExtensionsActivity::_internal_set_extension_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.extension_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromiumExtensionsActivity::_internal_mutable_extension_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.extension_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromiumExtensionsActivity::release_extension_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.ChromiumExtensionsActivity.extension_id)
    if (!_internal_has_extension_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.extension_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.extension_id_.IsDefault()) {
        _impl_.extension_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ChromiumExtensionsActivity::set_allocated_extension_id(std::string* extension_id)
{
    if (extension_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.extension_id_.SetAllocated(extension_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.extension_id_.IsDefault()) {
        _impl_.extension_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ChromiumExtensionsActivity.extension_id)
}

// optional uint32 bookmark_writes_since_last_commit = 2;
inline bool ChromiumExtensionsActivity::_internal_has_bookmark_writes_since_last_commit() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ChromiumExtensionsActivity::has_bookmark_writes_since_last_commit() const
{
    return _internal_has_bookmark_writes_since_last_commit();
}
inline void ChromiumExtensionsActivity::clear_bookmark_writes_since_last_commit()
{
    _impl_.bookmark_writes_since_last_commit_ = 0u;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ChromiumExtensionsActivity::_internal_bookmark_writes_since_last_commit() const
{
    return _impl_.bookmark_writes_since_last_commit_;
}
inline uint32_t ChromiumExtensionsActivity::bookmark_writes_since_last_commit() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ChromiumExtensionsActivity.bookmark_writes_since_last_commit)
    return _internal_bookmark_writes_since_last_commit();
}
inline void ChromiumExtensionsActivity::_internal_set_bookmark_writes_since_last_commit(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.bookmark_writes_since_last_commit_ = value;
}
inline void ChromiumExtensionsActivity::set_bookmark_writes_since_last_commit(uint32_t value)
{
    _internal_set_bookmark_writes_since_last_commit(value);
    // @@protoc_insertion_point(field_set:sync_pb.ChromiumExtensionsActivity.bookmark_writes_since_last_commit)
}

// -------------------------------------------------------------------

// ClientConfigParams

// repeated int32 enabled_type_ids = 1;
inline int ClientConfigParams::_internal_enabled_type_ids_size() const
{
    return _impl_.enabled_type_ids_.size();
}
inline int ClientConfigParams::enabled_type_ids_size() const
{
    return _internal_enabled_type_ids_size();
}
inline void ClientConfigParams::clear_enabled_type_ids()
{
    _impl_.enabled_type_ids_.Clear();
}
inline int32_t ClientConfigParams::_internal_enabled_type_ids(int index) const
{
    return _impl_.enabled_type_ids_.Get(index);
}
inline int32_t ClientConfigParams::enabled_type_ids(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.enabled_type_ids)
    return _internal_enabled_type_ids(index);
}
inline void ClientConfigParams::set_enabled_type_ids(int index, int32_t value)
{
    _impl_.enabled_type_ids_.Set(index, value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.enabled_type_ids)
}
inline void ClientConfigParams::_internal_add_enabled_type_ids(int32_t value)
{
    _impl_.enabled_type_ids_.Add(value);
}
inline void ClientConfigParams::add_enabled_type_ids(int32_t value)
{
    _internal_add_enabled_type_ids(value);
    // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.enabled_type_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& ClientConfigParams::_internal_enabled_type_ids() const
{
    return _impl_.enabled_type_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& ClientConfigParams::enabled_type_ids() const
{
    // @@protoc_insertion_point(field_list:sync_pb.ClientConfigParams.enabled_type_ids)
    return _internal_enabled_type_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* ClientConfigParams::_internal_mutable_enabled_type_ids()
{
    return &_impl_.enabled_type_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* ClientConfigParams::mutable_enabled_type_ids()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientConfigParams.enabled_type_ids)
    return _internal_mutable_enabled_type_ids();
}

// optional bool tabs_datatype_enabled = 2 [deprecated = true];
inline bool ClientConfigParams::_internal_has_tabs_datatype_enabled() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClientConfigParams::has_tabs_datatype_enabled() const
{
    return _internal_has_tabs_datatype_enabled();
}
inline void ClientConfigParams::clear_tabs_datatype_enabled()
{
    _impl_.tabs_datatype_enabled_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ClientConfigParams::_internal_tabs_datatype_enabled() const
{
    return _impl_.tabs_datatype_enabled_;
}
inline bool ClientConfigParams::tabs_datatype_enabled() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.tabs_datatype_enabled)
    return _internal_tabs_datatype_enabled();
}
inline void ClientConfigParams::_internal_set_tabs_datatype_enabled(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.tabs_datatype_enabled_ = value;
}
inline void ClientConfigParams::set_tabs_datatype_enabled(bool value)
{
    _internal_set_tabs_datatype_enabled(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.tabs_datatype_enabled)
}

// optional bool cookie_jar_mismatch = 3;
inline bool ClientConfigParams::_internal_has_cookie_jar_mismatch() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientConfigParams::has_cookie_jar_mismatch() const
{
    return _internal_has_cookie_jar_mismatch();
}
inline void ClientConfigParams::clear_cookie_jar_mismatch()
{
    _impl_.cookie_jar_mismatch_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ClientConfigParams::_internal_cookie_jar_mismatch() const
{
    return _impl_.cookie_jar_mismatch_;
}
inline bool ClientConfigParams::cookie_jar_mismatch() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.cookie_jar_mismatch)
    return _internal_cookie_jar_mismatch();
}
inline void ClientConfigParams::_internal_set_cookie_jar_mismatch(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.cookie_jar_mismatch_ = value;
}
inline void ClientConfigParams::set_cookie_jar_mismatch(bool value)
{
    _internal_set_cookie_jar_mismatch(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.cookie_jar_mismatch)
}

// optional bool single_client = 4;
inline bool ClientConfigParams::_internal_has_single_client() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ClientConfigParams::has_single_client() const
{
    return _internal_has_single_client();
}
inline void ClientConfigParams::clear_single_client()
{
    _impl_.single_client_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool ClientConfigParams::_internal_single_client() const
{
    return _impl_.single_client_;
}
inline bool ClientConfigParams::single_client() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.single_client)
    return _internal_single_client();
}
inline void ClientConfigParams::_internal_set_single_client(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.single_client_ = value;
}
inline void ClientConfigParams::set_single_client(bool value)
{
    _internal_set_single_client(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.single_client)
}

// repeated string devices_fcm_registration_tokens = 5;
inline int ClientConfigParams::_internal_devices_fcm_registration_tokens_size() const
{
    return _impl_.devices_fcm_registration_tokens_.size();
}
inline int ClientConfigParams::devices_fcm_registration_tokens_size() const
{
    return _internal_devices_fcm_registration_tokens_size();
}
inline void ClientConfigParams::clear_devices_fcm_registration_tokens()
{
    _impl_.devices_fcm_registration_tokens_.Clear();
}
inline std::string* ClientConfigParams::add_devices_fcm_registration_tokens()
{
    std::string* _s = _internal_add_devices_fcm_registration_tokens();
    // @@protoc_insertion_point(field_add_mutable:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
    return _s;
}
inline const std::string& ClientConfigParams::_internal_devices_fcm_registration_tokens(int index) const
{
    return _impl_.devices_fcm_registration_tokens_.Get(index);
}
inline const std::string& ClientConfigParams::devices_fcm_registration_tokens(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
    return _internal_devices_fcm_registration_tokens(index);
}
inline std::string* ClientConfigParams::mutable_devices_fcm_registration_tokens(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
    return _impl_.devices_fcm_registration_tokens_.Mutable(index);
}
inline void ClientConfigParams::set_devices_fcm_registration_tokens(int index, const std::string& value)
{
    _impl_.devices_fcm_registration_tokens_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::set_devices_fcm_registration_tokens(int index, std::string&& value)
{
    _impl_.devices_fcm_registration_tokens_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::set_devices_fcm_registration_tokens(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.devices_fcm_registration_tokens_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::set_devices_fcm_registration_tokens(int index, const char* value, size_t size)
{
    _impl_.devices_fcm_registration_tokens_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline std::string* ClientConfigParams::_internal_add_devices_fcm_registration_tokens()
{
    return _impl_.devices_fcm_registration_tokens_.Add();
}
inline void ClientConfigParams::add_devices_fcm_registration_tokens(const std::string& value)
{
    _impl_.devices_fcm_registration_tokens_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::add_devices_fcm_registration_tokens(std::string&& value)
{
    _impl_.devices_fcm_registration_tokens_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::add_devices_fcm_registration_tokens(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.devices_fcm_registration_tokens_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::add_devices_fcm_registration_tokens(const char* value, size_t size)
{
    _impl_.devices_fcm_registration_tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ClientConfigParams::devices_fcm_registration_tokens() const
{
    // @@protoc_insertion_point(field_list:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
    return _impl_.devices_fcm_registration_tokens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ClientConfigParams::mutable_devices_fcm_registration_tokens()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
    return &_impl_.devices_fcm_registration_tokens_;
}

// optional bool single_client_with_standalone_invalidations = 6;
inline bool ClientConfigParams::_internal_has_single_client_with_standalone_invalidations() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ClientConfigParams::has_single_client_with_standalone_invalidations() const
{
    return _internal_has_single_client_with_standalone_invalidations();
}
inline void ClientConfigParams::clear_single_client_with_standalone_invalidations()
{
    _impl_.single_client_with_standalone_invalidations_ = false;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool ClientConfigParams::_internal_single_client_with_standalone_invalidations() const
{
    return _impl_.single_client_with_standalone_invalidations_;
}
inline bool ClientConfigParams::single_client_with_standalone_invalidations() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.single_client_with_standalone_invalidations)
    return _internal_single_client_with_standalone_invalidations();
}
inline void ClientConfigParams::_internal_set_single_client_with_standalone_invalidations(bool value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.single_client_with_standalone_invalidations_ = value;
}
inline void ClientConfigParams::set_single_client_with_standalone_invalidations(bool value)
{
    _internal_set_single_client_with_standalone_invalidations(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.single_client_with_standalone_invalidations)
}

// repeated string fcm_registration_tokens_for_interested_clients = 7;
inline int ClientConfigParams::_internal_fcm_registration_tokens_for_interested_clients_size() const
{
    return _impl_.fcm_registration_tokens_for_interested_clients_.size();
}
inline int ClientConfigParams::fcm_registration_tokens_for_interested_clients_size() const
{
    return _internal_fcm_registration_tokens_for_interested_clients_size();
}
inline void ClientConfigParams::clear_fcm_registration_tokens_for_interested_clients()
{
    _impl_.fcm_registration_tokens_for_interested_clients_.Clear();
}
inline std::string* ClientConfigParams::add_fcm_registration_tokens_for_interested_clients()
{
    std::string* _s = _internal_add_fcm_registration_tokens_for_interested_clients();
    // @@protoc_insertion_point(field_add_mutable:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
    return _s;
}
inline const std::string& ClientConfigParams::_internal_fcm_registration_tokens_for_interested_clients(int index) const
{
    return _impl_.fcm_registration_tokens_for_interested_clients_.Get(index);
}
inline const std::string& ClientConfigParams::fcm_registration_tokens_for_interested_clients(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
    return _internal_fcm_registration_tokens_for_interested_clients(index);
}
inline std::string* ClientConfigParams::mutable_fcm_registration_tokens_for_interested_clients(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
    return _impl_.fcm_registration_tokens_for_interested_clients_.Mutable(index);
}
inline void ClientConfigParams::set_fcm_registration_tokens_for_interested_clients(int index, const std::string& value)
{
    _impl_.fcm_registration_tokens_for_interested_clients_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::set_fcm_registration_tokens_for_interested_clients(int index, std::string&& value)
{
    _impl_.fcm_registration_tokens_for_interested_clients_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::set_fcm_registration_tokens_for_interested_clients(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.fcm_registration_tokens_for_interested_clients_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::set_fcm_registration_tokens_for_interested_clients(int index, const char* value, size_t size)
{
    _impl_.fcm_registration_tokens_for_interested_clients_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline std::string* ClientConfigParams::_internal_add_fcm_registration_tokens_for_interested_clients()
{
    return _impl_.fcm_registration_tokens_for_interested_clients_.Add();
}
inline void ClientConfigParams::add_fcm_registration_tokens_for_interested_clients(const std::string& value)
{
    _impl_.fcm_registration_tokens_for_interested_clients_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::add_fcm_registration_tokens_for_interested_clients(std::string&& value)
{
    _impl_.fcm_registration_tokens_for_interested_clients_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::add_fcm_registration_tokens_for_interested_clients(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.fcm_registration_tokens_for_interested_clients_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::add_fcm_registration_tokens_for_interested_clients(const char* value, size_t size)
{
    _impl_.fcm_registration_tokens_for_interested_clients_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ClientConfigParams::fcm_registration_tokens_for_interested_clients() const
{
    // @@protoc_insertion_point(field_list:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
    return _impl_.fcm_registration_tokens_for_interested_clients_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* ClientConfigParams::mutable_fcm_registration_tokens_for_interested_clients()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
    return &_impl_.fcm_registration_tokens_for_interested_clients_;
}

// optional bool single_client_with_old_invalidations = 8;
inline bool ClientConfigParams::_internal_has_single_client_with_old_invalidations() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool ClientConfigParams::has_single_client_with_old_invalidations() const
{
    return _internal_has_single_client_with_old_invalidations();
}
inline void ClientConfigParams::clear_single_client_with_old_invalidations()
{
    _impl_.single_client_with_old_invalidations_ = false;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool ClientConfigParams::_internal_single_client_with_old_invalidations() const
{
    return _impl_.single_client_with_old_invalidations_;
}
inline bool ClientConfigParams::single_client_with_old_invalidations() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.single_client_with_old_invalidations)
    return _internal_single_client_with_old_invalidations();
}
inline void ClientConfigParams::_internal_set_single_client_with_old_invalidations(bool value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.single_client_with_old_invalidations_ = value;
}
inline void ClientConfigParams::set_single_client_with_old_invalidations(bool value)
{
    _internal_set_single_client_with_old_invalidations(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.single_client_with_old_invalidations)
}

// -------------------------------------------------------------------

// CommitMessage

// repeated .sync_pb.SyncEntity entries = 1;
inline int CommitMessage::_internal_entries_size() const
{
    return _impl_.entries_.size();
}
inline int CommitMessage::entries_size() const
{
    return _internal_entries_size();
}
inline ::sync_pb::SyncEntity* CommitMessage::mutable_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.entries)
    return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity>* CommitMessage::mutable_entries()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.CommitMessage.entries)
    return &_impl_.entries_;
}
inline const ::sync_pb::SyncEntity& CommitMessage::_internal_entries(int index) const
{
    return _impl_.entries_.Get(index);
}
inline const ::sync_pb::SyncEntity& CommitMessage::entries(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.entries)
    return _internal_entries(index);
}
inline ::sync_pb::SyncEntity* CommitMessage::_internal_add_entries()
{
    return _impl_.entries_.Add();
}
inline ::sync_pb::SyncEntity* CommitMessage::add_entries()
{
    ::sync_pb::SyncEntity* _add = _internal_add_entries();
    // @@protoc_insertion_point(field_add:sync_pb.CommitMessage.entries)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity>& CommitMessage::entries() const
{
    // @@protoc_insertion_point(field_list:sync_pb.CommitMessage.entries)
    return _impl_.entries_;
}

// optional string cache_guid = 2;
inline bool CommitMessage::_internal_has_cache_guid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CommitMessage::has_cache_guid() const
{
    return _internal_has_cache_guid();
}
inline void CommitMessage::clear_cache_guid()
{
    _impl_.cache_guid_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommitMessage::cache_guid() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.cache_guid)
    return _internal_cache_guid();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CommitMessage::set_cache_guid(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_guid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.CommitMessage.cache_guid)
}
inline std::string* CommitMessage::mutable_cache_guid()
{
    std::string* _s = _internal_mutable_cache_guid();
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.cache_guid)
    return _s;
}
inline const std::string& CommitMessage::_internal_cache_guid() const
{
    return _impl_.cache_guid_.Get();
}
inline void CommitMessage::_internal_set_cache_guid(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitMessage::_internal_mutable_cache_guid()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.cache_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitMessage::release_cache_guid()
{
    // @@protoc_insertion_point(field_release:sync_pb.CommitMessage.cache_guid)
    if (!_internal_has_cache_guid()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.cache_guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_guid_.IsDefault()) {
        _impl_.cache_guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CommitMessage::set_allocated_cache_guid(std::string* cache_guid)
{
    if (cache_guid != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.cache_guid_.SetAllocated(cache_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_guid_.IsDefault()) {
        _impl_.cache_guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitMessage.cache_guid)
}

// repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
inline int CommitMessage::_internal_extensions_activity_size() const
{
    return _impl_.extensions_activity_.size();
}
inline int CommitMessage::extensions_activity_size() const
{
    return _internal_extensions_activity_size();
}
inline void CommitMessage::clear_extensions_activity()
{
    _impl_.extensions_activity_.Clear();
}
inline ::sync_pb::ChromiumExtensionsActivity* CommitMessage::mutable_extensions_activity(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.extensions_activity)
    return _impl_.extensions_activity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::ChromiumExtensionsActivity>* CommitMessage::mutable_extensions_activity()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.CommitMessage.extensions_activity)
    return &_impl_.extensions_activity_;
}
inline const ::sync_pb::ChromiumExtensionsActivity& CommitMessage::_internal_extensions_activity(int index) const
{
    return _impl_.extensions_activity_.Get(index);
}
inline const ::sync_pb::ChromiumExtensionsActivity& CommitMessage::extensions_activity(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.extensions_activity)
    return _internal_extensions_activity(index);
}
inline ::sync_pb::ChromiumExtensionsActivity* CommitMessage::_internal_add_extensions_activity()
{
    return _impl_.extensions_activity_.Add();
}
inline ::sync_pb::ChromiumExtensionsActivity* CommitMessage::add_extensions_activity()
{
    ::sync_pb::ChromiumExtensionsActivity* _add = _internal_add_extensions_activity();
    // @@protoc_insertion_point(field_add:sync_pb.CommitMessage.extensions_activity)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::ChromiumExtensionsActivity>& CommitMessage::extensions_activity() const
{
    // @@protoc_insertion_point(field_list:sync_pb.CommitMessage.extensions_activity)
    return _impl_.extensions_activity_;
}

// optional .sync_pb.ClientConfigParams config_params = 4;
inline bool CommitMessage::_internal_has_config_params() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.config_params_ != nullptr);
    return value;
}
inline bool CommitMessage::has_config_params() const
{
    return _internal_has_config_params();
}
inline void CommitMessage::clear_config_params()
{
    if (_impl_.config_params_ != nullptr)
        _impl_.config_params_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sync_pb::ClientConfigParams& CommitMessage::_internal_config_params() const
{
    const ::sync_pb::ClientConfigParams* p = _impl_.config_params_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClientConfigParams&>(::sync_pb::_ClientConfigParams_default_instance_);
}
inline const ::sync_pb::ClientConfigParams& CommitMessage::config_params() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.config_params)
    return _internal_config_params();
}
inline void CommitMessage::unsafe_arena_set_allocated_config_params(::sync_pb::ClientConfigParams* config_params)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.config_params_);
    }
    _impl_.config_params_ = config_params;
    if (config_params) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.CommitMessage.config_params)
}
inline ::sync_pb::ClientConfigParams* CommitMessage::release_config_params()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::ClientConfigParams* temp = _impl_.config_params_;
    _impl_.config_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ClientConfigParams* CommitMessage::unsafe_arena_release_config_params()
{
    // @@protoc_insertion_point(field_release:sync_pb.CommitMessage.config_params)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::ClientConfigParams* temp = _impl_.config_params_;
    _impl_.config_params_ = nullptr;
    return temp;
}
inline ::sync_pb::ClientConfigParams* CommitMessage::_internal_mutable_config_params()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.config_params_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ClientConfigParams>(GetArenaForAllocation());
        _impl_.config_params_ = p;
    }
    return _impl_.config_params_;
}
inline ::sync_pb::ClientConfigParams* CommitMessage::mutable_config_params()
{
    ::sync_pb::ClientConfigParams* _msg = _internal_mutable_config_params();
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.config_params)
    return _msg;
}
inline void CommitMessage::set_allocated_config_params(::sync_pb::ClientConfigParams* config_params)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.config_params_;
    }
    if (config_params) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config_params);
        if (message_arena != submessage_arena) {
            config_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, config_params, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.config_params_ = config_params;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitMessage.config_params)
}

// repeated .sync_pb.DataTypeContext client_contexts = 5;
inline int CommitMessage::_internal_client_contexts_size() const
{
    return _impl_.client_contexts_.size();
}
inline int CommitMessage::client_contexts_size() const
{
    return _internal_client_contexts_size();
}
inline ::sync_pb::DataTypeContext* CommitMessage::mutable_client_contexts(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.client_contexts)
    return _impl_.client_contexts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>* CommitMessage::mutable_client_contexts()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.CommitMessage.client_contexts)
    return &_impl_.client_contexts_;
}
inline const ::sync_pb::DataTypeContext& CommitMessage::_internal_client_contexts(int index) const
{
    return _impl_.client_contexts_.Get(index);
}
inline const ::sync_pb::DataTypeContext& CommitMessage::client_contexts(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.client_contexts)
    return _internal_client_contexts(index);
}
inline ::sync_pb::DataTypeContext* CommitMessage::_internal_add_client_contexts()
{
    return _impl_.client_contexts_.Add();
}
inline ::sync_pb::DataTypeContext* CommitMessage::add_client_contexts()
{
    ::sync_pb::DataTypeContext* _add = _internal_add_client_contexts();
    // @@protoc_insertion_point(field_add:sync_pb.CommitMessage.client_contexts)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>& CommitMessage::client_contexts() const
{
    // @@protoc_insertion_point(field_list:sync_pb.CommitMessage.client_contexts)
    return _impl_.client_contexts_;
}

// optional string padding = 6;
inline bool CommitMessage::_internal_has_padding() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CommitMessage::has_padding() const
{
    return _internal_has_padding();
}
inline void CommitMessage::clear_padding()
{
    _impl_.padding_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommitMessage::padding() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.padding)
    return _internal_padding();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CommitMessage::set_padding(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.padding_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.CommitMessage.padding)
}
inline std::string* CommitMessage::mutable_padding()
{
    std::string* _s = _internal_mutable_padding();
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.padding)
    return _s;
}
inline const std::string& CommitMessage::_internal_padding() const
{
    return _impl_.padding_.Get();
}
inline void CommitMessage::_internal_set_padding(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.padding_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitMessage::_internal_mutable_padding()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.padding_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitMessage::release_padding()
{
    // @@protoc_insertion_point(field_release:sync_pb.CommitMessage.padding)
    if (!_internal_has_padding()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.padding_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.padding_.IsDefault()) {
        _impl_.padding_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CommitMessage::set_allocated_padding(std::string* padding)
{
    if (padding != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.padding_.SetAllocated(padding, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.padding_.IsDefault()) {
        _impl_.padding_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitMessage.padding)
}

// -------------------------------------------------------------------

// GetUpdatesMessage

// optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
inline bool GetUpdatesMessage::_internal_has_caller_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.caller_info_ != nullptr);
    return value;
}
inline bool GetUpdatesMessage::has_caller_info() const
{
    return _internal_has_caller_info();
}
inline const ::sync_pb::GetUpdatesCallerInfo& GetUpdatesMessage::_internal_caller_info() const
{
    const ::sync_pb::GetUpdatesCallerInfo* p = _impl_.caller_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::GetUpdatesCallerInfo&>(::sync_pb::_GetUpdatesCallerInfo_default_instance_);
}
inline const ::sync_pb::GetUpdatesCallerInfo& GetUpdatesMessage::caller_info() const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.caller_info)
    return _internal_caller_info();
}
inline void GetUpdatesMessage::unsafe_arena_set_allocated_caller_info(::sync_pb::GetUpdatesCallerInfo* caller_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caller_info_);
    }
    _impl_.caller_info_ = caller_info;
    if (caller_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.GetUpdatesMessage.caller_info)
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::release_caller_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::sync_pb::GetUpdatesCallerInfo* temp = _impl_.caller_info_;
    _impl_.caller_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::unsafe_arena_release_caller_info()
{
    // @@protoc_insertion_point(field_release:sync_pb.GetUpdatesMessage.caller_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::sync_pb::GetUpdatesCallerInfo* temp = _impl_.caller_info_;
    _impl_.caller_info_ = nullptr;
    return temp;
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::_internal_mutable_caller_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.caller_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::GetUpdatesCallerInfo>(GetArenaForAllocation());
        _impl_.caller_info_ = p;
    }
    return _impl_.caller_info_;
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::mutable_caller_info()
{
    ::sync_pb::GetUpdatesCallerInfo* _msg = _internal_mutable_caller_info();
    // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesMessage.caller_info)
    return _msg;
}
inline void GetUpdatesMessage::set_allocated_caller_info(::sync_pb::GetUpdatesCallerInfo* caller_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.caller_info_);
    }
    if (caller_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caller_info));
        if (message_arena != submessage_arena) {
            caller_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, caller_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.caller_info_ = caller_info;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.GetUpdatesMessage.caller_info)
}

// optional bool fetch_folders = 3 [default = true];
inline bool GetUpdatesMessage::_internal_has_fetch_folders() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool GetUpdatesMessage::has_fetch_folders() const
{
    return _internal_has_fetch_folders();
}
inline void GetUpdatesMessage::clear_fetch_folders()
{
    _impl_.fetch_folders_ = true;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool GetUpdatesMessage::_internal_fetch_folders() const
{
    return _impl_.fetch_folders_;
}
inline bool GetUpdatesMessage::fetch_folders() const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.fetch_folders)
    return _internal_fetch_folders();
}
inline void GetUpdatesMessage::_internal_set_fetch_folders(bool value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.fetch_folders_ = value;
}
inline void GetUpdatesMessage::set_fetch_folders(bool value)
{
    _internal_set_fetch_folders(value);
    // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.fetch_folders)
}

// repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
inline int GetUpdatesMessage::_internal_from_progress_marker_size() const
{
    return _impl_.from_progress_marker_.size();
}
inline int GetUpdatesMessage::from_progress_marker_size() const
{
    return _internal_from_progress_marker_size();
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMessage::mutable_from_progress_marker(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesMessage.from_progress_marker)
    return _impl_.from_progress_marker_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker>* GetUpdatesMessage::mutable_from_progress_marker()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesMessage.from_progress_marker)
    return &_impl_.from_progress_marker_;
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesMessage::_internal_from_progress_marker(int index) const
{
    return _impl_.from_progress_marker_.Get(index);
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesMessage::from_progress_marker(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.from_progress_marker)
    return _internal_from_progress_marker(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMessage::_internal_add_from_progress_marker()
{
    return _impl_.from_progress_marker_.Add();
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMessage::add_from_progress_marker()
{
    ::sync_pb::DataTypeProgressMarker* _add = _internal_add_from_progress_marker();
    // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesMessage.from_progress_marker)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker>& GetUpdatesMessage::from_progress_marker() const
{
    // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesMessage.from_progress_marker)
    return _impl_.from_progress_marker_;
}

// optional bool streaming = 7 [default = false];
inline bool GetUpdatesMessage::_internal_has_streaming() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool GetUpdatesMessage::has_streaming() const
{
    return _internal_has_streaming();
}
inline void GetUpdatesMessage::clear_streaming()
{
    _impl_.streaming_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool GetUpdatesMessage::_internal_streaming() const
{
    return _impl_.streaming_;
}
inline bool GetUpdatesMessage::streaming() const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.streaming)
    return _internal_streaming();
}
inline void GetUpdatesMessage::_internal_set_streaming(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.streaming_ = value;
}
inline void GetUpdatesMessage::set_streaming(bool value)
{
    _internal_set_streaming(value);
    // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.streaming)
}

// optional bool need_encryption_key = 8 [default = false];
inline bool GetUpdatesMessage::_internal_has_need_encryption_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool GetUpdatesMessage::has_need_encryption_key() const
{
    return _internal_has_need_encryption_key();
}
inline void GetUpdatesMessage::clear_need_encryption_key()
{
    _impl_.need_encryption_key_ = false;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool GetUpdatesMessage::_internal_need_encryption_key() const
{
    return _impl_.need_encryption_key_;
}
inline bool GetUpdatesMessage::need_encryption_key() const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.need_encryption_key)
    return _internal_need_encryption_key();
}
inline void GetUpdatesMessage::_internal_set_need_encryption_key(bool value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.need_encryption_key_ = value;
}
inline void GetUpdatesMessage::set_need_encryption_key(bool value)
{
    _internal_set_need_encryption_key(value);
    // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.need_encryption_key)
}

// optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
inline bool GetUpdatesMessage::_internal_has_get_updates_origin() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool GetUpdatesMessage::has_get_updates_origin() const
{
    return _internal_has_get_updates_origin();
}
inline void GetUpdatesMessage::clear_get_updates_origin()
{
    _impl_.get_updates_origin_ = 0;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::sync_pb::SyncEnums_GetUpdatesOrigin GetUpdatesMessage::_internal_get_updates_origin() const
{
    return static_cast<::sync_pb::SyncEnums_GetUpdatesOrigin>(_impl_.get_updates_origin_);
}
inline ::sync_pb::SyncEnums_GetUpdatesOrigin GetUpdatesMessage::get_updates_origin() const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.get_updates_origin)
    return _internal_get_updates_origin();
}
inline void GetUpdatesMessage::_internal_set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value)
{
    assert(::sync_pb::SyncEnums_GetUpdatesOrigin_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.get_updates_origin_ = value;
}
inline void GetUpdatesMessage::set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value)
{
    _internal_set_get_updates_origin(value);
    // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.get_updates_origin)
}

// optional bool is_retry = 10 [default = false];
inline bool GetUpdatesMessage::_internal_has_is_retry() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool GetUpdatesMessage::has_is_retry() const
{
    return _internal_has_is_retry();
}
inline void GetUpdatesMessage::clear_is_retry()
{
    _impl_.is_retry_ = false;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool GetUpdatesMessage::_internal_is_retry() const
{
    return _impl_.is_retry_;
}
inline bool GetUpdatesMessage::is_retry() const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.is_retry)
    return _internal_is_retry();
}
inline void GetUpdatesMessage::_internal_set_is_retry(bool value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.is_retry_ = value;
}
inline void GetUpdatesMessage::set_is_retry(bool value)
{
    _internal_set_is_retry(value);
    // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.is_retry)
}

// repeated .sync_pb.DataTypeContext client_contexts = 11;
inline int GetUpdatesMessage::_internal_client_contexts_size() const
{
    return _impl_.client_contexts_.size();
}
inline int GetUpdatesMessage::client_contexts_size() const
{
    return _internal_client_contexts_size();
}
inline ::sync_pb::DataTypeContext* GetUpdatesMessage::mutable_client_contexts(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesMessage.client_contexts)
    return _impl_.client_contexts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>* GetUpdatesMessage::mutable_client_contexts()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesMessage.client_contexts)
    return &_impl_.client_contexts_;
}
inline const ::sync_pb::DataTypeContext& GetUpdatesMessage::_internal_client_contexts(int index) const
{
    return _impl_.client_contexts_.Get(index);
}
inline const ::sync_pb::DataTypeContext& GetUpdatesMessage::client_contexts(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.client_contexts)
    return _internal_client_contexts(index);
}
inline ::sync_pb::DataTypeContext* GetUpdatesMessage::_internal_add_client_contexts()
{
    return _impl_.client_contexts_.Add();
}
inline ::sync_pb::DataTypeContext* GetUpdatesMessage::add_client_contexts()
{
    ::sync_pb::DataTypeContext* _add = _internal_add_client_contexts();
    // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesMessage.client_contexts)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>& GetUpdatesMessage::client_contexts() const
{
    // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesMessage.client_contexts)
    return _impl_.client_contexts_;
}

// -------------------------------------------------------------------

// ClearServerDataMessage

// -------------------------------------------------------------------

// ClearServerDataResponse

// -------------------------------------------------------------------

// ChipBag

// optional bytes server_chips = 1;
inline bool ChipBag::_internal_has_server_chips() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ChipBag::has_server_chips() const
{
    return _internal_has_server_chips();
}
inline void ChipBag::clear_server_chips()
{
    _impl_.server_chips_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChipBag::server_chips() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ChipBag.server_chips)
    return _internal_server_chips();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ChipBag::set_server_chips(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.server_chips_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ChipBag.server_chips)
}
inline std::string* ChipBag::mutable_server_chips()
{
    std::string* _s = _internal_mutable_server_chips();
    // @@protoc_insertion_point(field_mutable:sync_pb.ChipBag.server_chips)
    return _s;
}
inline const std::string& ChipBag::_internal_server_chips() const
{
    return _impl_.server_chips_.Get();
}
inline void ChipBag::_internal_set_server_chips(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.server_chips_.Set(value, GetArenaForAllocation());
}
inline std::string* ChipBag::_internal_mutable_server_chips()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.server_chips_.Mutable(GetArenaForAllocation());
}
inline std::string* ChipBag::release_server_chips()
{
    // @@protoc_insertion_point(field_release:sync_pb.ChipBag.server_chips)
    if (!_internal_has_server_chips()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.server_chips_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.server_chips_.IsDefault()) {
        _impl_.server_chips_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ChipBag::set_allocated_server_chips(std::string* server_chips)
{
    if (server_chips != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.server_chips_.SetAllocated(server_chips, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.server_chips_.IsDefault()) {
        _impl_.server_chips_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ChipBag.server_chips)
}

// -------------------------------------------------------------------

// ClientStatus

// optional bool hierarchy_conflict_detected = 1 [deprecated = true];
inline bool ClientStatus::_internal_has_hierarchy_conflict_detected() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClientStatus::has_hierarchy_conflict_detected() const
{
    return _internal_has_hierarchy_conflict_detected();
}
inline void ClientStatus::clear_hierarchy_conflict_detected()
{
    _impl_.hierarchy_conflict_detected_ = false;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool ClientStatus::_internal_hierarchy_conflict_detected() const
{
    return _impl_.hierarchy_conflict_detected_;
}
inline bool ClientStatus::hierarchy_conflict_detected() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientStatus.hierarchy_conflict_detected)
    return _internal_hierarchy_conflict_detected();
}
inline void ClientStatus::_internal_set_hierarchy_conflict_detected(bool value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.hierarchy_conflict_detected_ = value;
}
inline void ClientStatus::set_hierarchy_conflict_detected(bool value)
{
    _internal_set_hierarchy_conflict_detected(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientStatus.hierarchy_conflict_detected)
}

// optional bool is_sync_feature_enabled = 2;
inline bool ClientStatus::_internal_has_is_sync_feature_enabled() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientStatus::has_is_sync_feature_enabled() const
{
    return _internal_has_is_sync_feature_enabled();
}
inline void ClientStatus::clear_is_sync_feature_enabled()
{
    _impl_.is_sync_feature_enabled_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool ClientStatus::_internal_is_sync_feature_enabled() const
{
    return _impl_.is_sync_feature_enabled_;
}
inline bool ClientStatus::is_sync_feature_enabled() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientStatus.is_sync_feature_enabled)
    return _internal_is_sync_feature_enabled();
}
inline void ClientStatus::_internal_set_is_sync_feature_enabled(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.is_sync_feature_enabled_ = value;
}
inline void ClientStatus::set_is_sync_feature_enabled(bool value)
{
    _internal_set_is_sync_feature_enabled(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientStatus.is_sync_feature_enabled)
}

// -------------------------------------------------------------------

// ClientToServerMessage

// required string share = 1;
inline bool ClientToServerMessage::_internal_has_share() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClientToServerMessage::has_share() const
{
    return _internal_has_share();
}
inline void ClientToServerMessage::clear_share()
{
    _impl_.share_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientToServerMessage::share() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.share)
    return _internal_share();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientToServerMessage::set_share(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.share_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.share)
}
inline std::string* ClientToServerMessage::mutable_share()
{
    std::string* _s = _internal_mutable_share();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.share)
    return _s;
}
inline const std::string& ClientToServerMessage::_internal_share() const
{
    return _impl_.share_.Get();
}
inline void ClientToServerMessage::_internal_set_share(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.share_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::_internal_mutable_share()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.share_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::release_share()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.share)
    if (!_internal_has_share()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.share_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.share_.IsDefault()) {
        _impl_.share_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientToServerMessage::set_allocated_share(std::string* share)
{
    if (share != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.share_.SetAllocated(share, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.share_.IsDefault()) {
        _impl_.share_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.share)
}

// optional int32 protocol_version = 2 [default = 99];
inline bool ClientToServerMessage::_internal_has_protocol_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool ClientToServerMessage::has_protocol_version() const
{
    return _internal_has_protocol_version();
}
inline void ClientToServerMessage::clear_protocol_version()
{
    _impl_.protocol_version_ = 99;
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int32_t ClientToServerMessage::_internal_protocol_version() const
{
    return _impl_.protocol_version_;
}
inline int32_t ClientToServerMessage::protocol_version() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.protocol_version)
    return _internal_protocol_version();
}
inline void ClientToServerMessage::_internal_set_protocol_version(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.protocol_version_ = value;
}
inline void ClientToServerMessage::set_protocol_version(int32_t value)
{
    _internal_set_protocol_version(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.protocol_version)
}

// required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
inline bool ClientToServerMessage::_internal_has_message_contents() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool ClientToServerMessage::has_message_contents() const
{
    return _internal_has_message_contents();
}
inline void ClientToServerMessage::clear_message_contents()
{
    _impl_.message_contents_ = 1;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::sync_pb::ClientToServerMessage_Contents ClientToServerMessage::_internal_message_contents() const
{
    return static_cast<::sync_pb::ClientToServerMessage_Contents>(_impl_.message_contents_);
}
inline ::sync_pb::ClientToServerMessage_Contents ClientToServerMessage::message_contents() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.message_contents)
    return _internal_message_contents();
}
inline void ClientToServerMessage::_internal_set_message_contents(::sync_pb::ClientToServerMessage_Contents value)
{
    assert(::sync_pb::ClientToServerMessage_Contents_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.message_contents_ = value;
}
inline void ClientToServerMessage::set_message_contents(::sync_pb::ClientToServerMessage_Contents value)
{
    _internal_set_message_contents(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.message_contents)
}

// optional .sync_pb.CommitMessage commit = 4;
inline bool ClientToServerMessage::_internal_has_commit() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.commit_ != nullptr);
    return value;
}
inline bool ClientToServerMessage::has_commit() const
{
    return _internal_has_commit();
}
inline void ClientToServerMessage::clear_commit()
{
    if (_impl_.commit_ != nullptr)
        _impl_.commit_->Clear();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::sync_pb::CommitMessage& ClientToServerMessage::_internal_commit() const
{
    const ::sync_pb::CommitMessage* p = _impl_.commit_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::CommitMessage&>(::sync_pb::_CommitMessage_default_instance_);
}
inline const ::sync_pb::CommitMessage& ClientToServerMessage::commit() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.commit)
    return _internal_commit();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_commit(::sync_pb::CommitMessage* commit)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commit_);
    }
    _impl_.commit_ = commit;
    if (commit) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.commit)
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::release_commit()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::sync_pb::CommitMessage* temp = _impl_.commit_;
    _impl_.commit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::unsafe_arena_release_commit()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.commit)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::sync_pb::CommitMessage* temp = _impl_.commit_;
    _impl_.commit_ = nullptr;
    return temp;
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::_internal_mutable_commit()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.commit_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::CommitMessage>(GetArenaForAllocation());
        _impl_.commit_ = p;
    }
    return _impl_.commit_;
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::mutable_commit()
{
    ::sync_pb::CommitMessage* _msg = _internal_mutable_commit();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.commit)
    return _msg;
}
inline void ClientToServerMessage::set_allocated_commit(::sync_pb::CommitMessage* commit)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.commit_;
    }
    if (commit) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commit);
        if (message_arena != submessage_arena) {
            commit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, commit, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.commit_ = commit;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.commit)
}

// optional .sync_pb.GetUpdatesMessage get_updates = 5;
inline bool ClientToServerMessage::_internal_has_get_updates() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.get_updates_ != nullptr);
    return value;
}
inline bool ClientToServerMessage::has_get_updates() const
{
    return _internal_has_get_updates();
}
inline void ClientToServerMessage::clear_get_updates()
{
    if (_impl_.get_updates_ != nullptr)
        _impl_.get_updates_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::sync_pb::GetUpdatesMessage& ClientToServerMessage::_internal_get_updates() const
{
    const ::sync_pb::GetUpdatesMessage* p = _impl_.get_updates_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::GetUpdatesMessage&>(::sync_pb::_GetUpdatesMessage_default_instance_);
}
inline const ::sync_pb::GetUpdatesMessage& ClientToServerMessage::get_updates() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.get_updates)
    return _internal_get_updates();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_get_updates(::sync_pb::GetUpdatesMessage* get_updates)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.get_updates_);
    }
    _impl_.get_updates_ = get_updates;
    if (get_updates) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.get_updates)
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::release_get_updates()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::sync_pb::GetUpdatesMessage* temp = _impl_.get_updates_;
    _impl_.get_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::unsafe_arena_release_get_updates()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.get_updates)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::sync_pb::GetUpdatesMessage* temp = _impl_.get_updates_;
    _impl_.get_updates_ = nullptr;
    return temp;
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::_internal_mutable_get_updates()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.get_updates_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::GetUpdatesMessage>(GetArenaForAllocation());
        _impl_.get_updates_ = p;
    }
    return _impl_.get_updates_;
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::mutable_get_updates()
{
    ::sync_pb::GetUpdatesMessage* _msg = _internal_mutable_get_updates();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.get_updates)
    return _msg;
}
inline void ClientToServerMessage::set_allocated_get_updates(::sync_pb::GetUpdatesMessage* get_updates)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.get_updates_;
    }
    if (get_updates) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_updates);
        if (message_arena != submessage_arena) {
            get_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, get_updates, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.get_updates_ = get_updates;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.get_updates)
}

// optional string store_birthday = 7;
inline bool ClientToServerMessage::_internal_has_store_birthday() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientToServerMessage::has_store_birthday() const
{
    return _internal_has_store_birthday();
}
inline void ClientToServerMessage::clear_store_birthday()
{
    _impl_.store_birthday_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientToServerMessage::store_birthday() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.store_birthday)
    return _internal_store_birthday();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientToServerMessage::set_store_birthday(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.store_birthday_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.store_birthday)
}
inline std::string* ClientToServerMessage::mutable_store_birthday()
{
    std::string* _s = _internal_mutable_store_birthday();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.store_birthday)
    return _s;
}
inline const std::string& ClientToServerMessage::_internal_store_birthday() const
{
    return _impl_.store_birthday_.Get();
}
inline void ClientToServerMessage::_internal_set_store_birthday(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.store_birthday_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::_internal_mutable_store_birthday()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.store_birthday_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::release_store_birthday()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.store_birthday)
    if (!_internal_has_store_birthday()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.store_birthday_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.store_birthday_.IsDefault()) {
        _impl_.store_birthday_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientToServerMessage::set_allocated_store_birthday(std::string* store_birthday)
{
    if (store_birthday != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.store_birthday_.SetAllocated(store_birthday, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.store_birthday_.IsDefault()) {
        _impl_.store_birthday_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.store_birthday)
}

// optional .sync_pb.DebugInfo debug_info = 10;
inline bool ClientToServerMessage::_internal_has_debug_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.debug_info_ != nullptr);
    return value;
}
inline bool ClientToServerMessage::has_debug_info() const
{
    return _internal_has_debug_info();
}
inline const ::sync_pb::DebugInfo& ClientToServerMessage::_internal_debug_info() const
{
    const ::sync_pb::DebugInfo* p = _impl_.debug_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::DebugInfo&>(::sync_pb::_DebugInfo_default_instance_);
}
inline const ::sync_pb::DebugInfo& ClientToServerMessage::debug_info() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.debug_info)
    return _internal_debug_info();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_debug_info(::sync_pb::DebugInfo* debug_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.debug_info_);
    }
    _impl_.debug_info_ = debug_info;
    if (debug_info) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.debug_info)
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::release_debug_info()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::sync_pb::DebugInfo* temp = _impl_.debug_info_;
    _impl_.debug_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::unsafe_arena_release_debug_info()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.debug_info)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::sync_pb::DebugInfo* temp = _impl_.debug_info_;
    _impl_.debug_info_ = nullptr;
    return temp;
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::_internal_mutable_debug_info()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.debug_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::DebugInfo>(GetArenaForAllocation());
        _impl_.debug_info_ = p;
    }
    return _impl_.debug_info_;
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::mutable_debug_info()
{
    ::sync_pb::DebugInfo* _msg = _internal_mutable_debug_info();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.debug_info)
    return _msg;
}
inline void ClientToServerMessage::set_allocated_debug_info(::sync_pb::DebugInfo* debug_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.debug_info_);
    }
    if (debug_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debug_info));
        if (message_arena != submessage_arena) {
            debug_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, debug_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.debug_info_ = debug_info;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.debug_info)
}

// optional .sync_pb.ChipBag bag_of_chips = 11;
inline bool ClientToServerMessage::_internal_has_bag_of_chips() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.bag_of_chips_ != nullptr);
    return value;
}
inline bool ClientToServerMessage::has_bag_of_chips() const
{
    return _internal_has_bag_of_chips();
}
inline void ClientToServerMessage::clear_bag_of_chips()
{
    if (_impl_.bag_of_chips_ != nullptr)
        _impl_.bag_of_chips_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::sync_pb::ChipBag& ClientToServerMessage::_internal_bag_of_chips() const
{
    const ::sync_pb::ChipBag* p = _impl_.bag_of_chips_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ChipBag&>(::sync_pb::_ChipBag_default_instance_);
}
inline const ::sync_pb::ChipBag& ClientToServerMessage::bag_of_chips() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.bag_of_chips)
    return _internal_bag_of_chips();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_bag_of_chips(::sync_pb::ChipBag* bag_of_chips)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bag_of_chips_);
    }
    _impl_.bag_of_chips_ = bag_of_chips;
    if (bag_of_chips) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.bag_of_chips)
}
inline ::sync_pb::ChipBag* ClientToServerMessage::release_bag_of_chips()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::sync_pb::ChipBag* temp = _impl_.bag_of_chips_;
    _impl_.bag_of_chips_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ChipBag* ClientToServerMessage::unsafe_arena_release_bag_of_chips()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.bag_of_chips)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::sync_pb::ChipBag* temp = _impl_.bag_of_chips_;
    _impl_.bag_of_chips_ = nullptr;
    return temp;
}
inline ::sync_pb::ChipBag* ClientToServerMessage::_internal_mutable_bag_of_chips()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.bag_of_chips_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ChipBag>(GetArenaForAllocation());
        _impl_.bag_of_chips_ = p;
    }
    return _impl_.bag_of_chips_;
}
inline ::sync_pb::ChipBag* ClientToServerMessage::mutable_bag_of_chips()
{
    ::sync_pb::ChipBag* _msg = _internal_mutable_bag_of_chips();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.bag_of_chips)
    return _msg;
}
inline void ClientToServerMessage::set_allocated_bag_of_chips(::sync_pb::ChipBag* bag_of_chips)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.bag_of_chips_;
    }
    if (bag_of_chips) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bag_of_chips);
        if (message_arena != submessage_arena) {
            bag_of_chips = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, bag_of_chips, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.bag_of_chips_ = bag_of_chips;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.bag_of_chips)
}

// optional string api_key = 12;
inline bool ClientToServerMessage::_internal_has_api_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ClientToServerMessage::has_api_key() const
{
    return _internal_has_api_key();
}
inline void ClientToServerMessage::clear_api_key()
{
    _impl_.api_key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientToServerMessage::api_key() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.api_key)
    return _internal_api_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientToServerMessage::set_api_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.api_key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.api_key)
}
inline std::string* ClientToServerMessage::mutable_api_key()
{
    std::string* _s = _internal_mutable_api_key();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.api_key)
    return _s;
}
inline const std::string& ClientToServerMessage::_internal_api_key() const
{
    return _impl_.api_key_.Get();
}
inline void ClientToServerMessage::_internal_set_api_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::_internal_mutable_api_key()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::release_api_key()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.api_key)
    if (!_internal_has_api_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.api_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.api_key_.IsDefault()) {
        _impl_.api_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientToServerMessage::set_allocated_api_key(std::string* api_key)
{
    if (api_key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.api_key_.IsDefault()) {
        _impl_.api_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.api_key)
}

// optional .sync_pb.ClientStatus client_status = 13;
inline bool ClientToServerMessage::_internal_has_client_status() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.client_status_ != nullptr);
    return value;
}
inline bool ClientToServerMessage::has_client_status() const
{
    return _internal_has_client_status();
}
inline void ClientToServerMessage::clear_client_status()
{
    if (_impl_.client_status_ != nullptr)
        _impl_.client_status_->Clear();
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::sync_pb::ClientStatus& ClientToServerMessage::_internal_client_status() const
{
    const ::sync_pb::ClientStatus* p = _impl_.client_status_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClientStatus&>(::sync_pb::_ClientStatus_default_instance_);
}
inline const ::sync_pb::ClientStatus& ClientToServerMessage::client_status() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.client_status)
    return _internal_client_status();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_client_status(::sync_pb::ClientStatus* client_status)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_status_);
    }
    _impl_.client_status_ = client_status;
    if (client_status) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.client_status)
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::release_client_status()
{
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::sync_pb::ClientStatus* temp = _impl_.client_status_;
    _impl_.client_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::unsafe_arena_release_client_status()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.client_status)
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::sync_pb::ClientStatus* temp = _impl_.client_status_;
    _impl_.client_status_ = nullptr;
    return temp;
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::_internal_mutable_client_status()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    if (_impl_.client_status_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ClientStatus>(GetArenaForAllocation());
        _impl_.client_status_ = p;
    }
    return _impl_.client_status_;
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::mutable_client_status()
{
    ::sync_pb::ClientStatus* _msg = _internal_mutable_client_status();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.client_status)
    return _msg;
}
inline void ClientToServerMessage::set_allocated_client_status(::sync_pb::ClientStatus* client_status)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.client_status_;
    }
    if (client_status) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_status);
        if (message_arena != submessage_arena) {
            client_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, client_status, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.client_status_ = client_status;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.client_status)
}

// optional string invalidator_client_id = 14 [deprecated = true];
inline bool ClientToServerMessage::_internal_has_invalidator_client_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool ClientToServerMessage::has_invalidator_client_id() const
{
    return _internal_has_invalidator_client_id();
}
inline void ClientToServerMessage::clear_invalidator_client_id()
{
    _impl_.invalidator_client_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClientToServerMessage::invalidator_client_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.invalidator_client_id)
    return _internal_invalidator_client_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientToServerMessage::set_invalidator_client_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.invalidator_client_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.invalidator_client_id)
}
inline std::string* ClientToServerMessage::mutable_invalidator_client_id()
{
    std::string* _s = _internal_mutable_invalidator_client_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.invalidator_client_id)
    return _s;
}
inline const std::string& ClientToServerMessage::_internal_invalidator_client_id() const
{
    return _impl_.invalidator_client_id_.Get();
}
inline void ClientToServerMessage::_internal_set_invalidator_client_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.invalidator_client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::_internal_mutable_invalidator_client_id()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.invalidator_client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::release_invalidator_client_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.invalidator_client_id)
    if (!_internal_has_invalidator_client_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.invalidator_client_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.invalidator_client_id_.IsDefault()) {
        _impl_.invalidator_client_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientToServerMessage::set_allocated_invalidator_client_id(std::string* invalidator_client_id)
{
    if (invalidator_client_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.invalidator_client_id_.SetAllocated(invalidator_client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.invalidator_client_id_.IsDefault()) {
        _impl_.invalidator_client_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.invalidator_client_id)
}

// optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
inline bool ClientToServerMessage::_internal_has_clear_server_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.clear_server_data_ != nullptr);
    return value;
}
inline bool ClientToServerMessage::has_clear_server_data() const
{
    return _internal_has_clear_server_data();
}
inline void ClientToServerMessage::clear_clear_server_data()
{
    if (_impl_.clear_server_data_ != nullptr)
        _impl_.clear_server_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::sync_pb::ClearServerDataMessage& ClientToServerMessage::_internal_clear_server_data() const
{
    const ::sync_pb::ClearServerDataMessage* p = _impl_.clear_server_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClearServerDataMessage&>(::sync_pb::_ClearServerDataMessage_default_instance_);
}
inline const ::sync_pb::ClearServerDataMessage& ClientToServerMessage::clear_server_data() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.clear_server_data)
    return _internal_clear_server_data();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_clear_server_data(::sync_pb::ClearServerDataMessage* clear_server_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clear_server_data_);
    }
    _impl_.clear_server_data_ = clear_server_data;
    if (clear_server_data) {
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.clear_server_data)
}
inline ::sync_pb::ClearServerDataMessage* ClientToServerMessage::release_clear_server_data()
{
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::sync_pb::ClearServerDataMessage* temp = _impl_.clear_server_data_;
    _impl_.clear_server_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ClearServerDataMessage* ClientToServerMessage::unsafe_arena_release_clear_server_data()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.clear_server_data)
    _impl_._has_bits_[0] &= ~0x00000200u;
    ::sync_pb::ClearServerDataMessage* temp = _impl_.clear_server_data_;
    _impl_.clear_server_data_ = nullptr;
    return temp;
}
inline ::sync_pb::ClearServerDataMessage* ClientToServerMessage::_internal_mutable_clear_server_data()
{
    _impl_._has_bits_[0] |= 0x00000200u;
    if (_impl_.clear_server_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ClearServerDataMessage>(GetArenaForAllocation());
        _impl_.clear_server_data_ = p;
    }
    return _impl_.clear_server_data_;
}
inline ::sync_pb::ClearServerDataMessage* ClientToServerMessage::mutable_clear_server_data()
{
    ::sync_pb::ClearServerDataMessage* _msg = _internal_mutable_clear_server_data();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.clear_server_data)
    return _msg;
}
inline void ClientToServerMessage::set_allocated_clear_server_data(::sync_pb::ClearServerDataMessage* clear_server_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.clear_server_data_;
    }
    if (clear_server_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clear_server_data);
        if (message_arena != submessage_arena) {
            clear_server_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, clear_server_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000200u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000200u;
    }
    _impl_.clear_server_data_ = clear_server_data;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.clear_server_data)
}

// -------------------------------------------------------------------

// CommitResponse_EntryResponse_DatatypeSpecificError

// .sync_pb.SharingMessageCommitError sharing_message_error = 1;
inline bool CommitResponse_EntryResponse_DatatypeSpecificError::_internal_has_sharing_message_error() const
{
    return datatype_error_case() == kSharingMessageError;
}
inline bool CommitResponse_EntryResponse_DatatypeSpecificError::has_sharing_message_error() const
{
    return _internal_has_sharing_message_error();
}
inline void CommitResponse_EntryResponse_DatatypeSpecificError::set_has_sharing_message_error()
{
    _impl_._oneof_case_[0] = kSharingMessageError;
}
inline ::sync_pb::SharingMessageCommitError* CommitResponse_EntryResponse_DatatypeSpecificError::release_sharing_message_error()
{
    // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
    if (_internal_has_sharing_message_error()) {
        clear_has_datatype_error();
        ::sync_pb::SharingMessageCommitError* temp = _impl_.datatype_error_.sharing_message_error_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.datatype_error_.sharing_message_error_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::sync_pb::SharingMessageCommitError& CommitResponse_EntryResponse_DatatypeSpecificError::_internal_sharing_message_error() const
{
    return _internal_has_sharing_message_error()
        ? *_impl_.datatype_error_.sharing_message_error_
        : reinterpret_cast<::sync_pb::SharingMessageCommitError&>(::sync_pb::_SharingMessageCommitError_default_instance_);
}
inline const ::sync_pb::SharingMessageCommitError& CommitResponse_EntryResponse_DatatypeSpecificError::sharing_message_error() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
    return _internal_sharing_message_error();
}
inline ::sync_pb::SharingMessageCommitError* CommitResponse_EntryResponse_DatatypeSpecificError::unsafe_arena_release_sharing_message_error()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
    if (_internal_has_sharing_message_error()) {
        clear_has_datatype_error();
        ::sync_pb::SharingMessageCommitError* temp = _impl_.datatype_error_.sharing_message_error_;
        _impl_.datatype_error_.sharing_message_error_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void CommitResponse_EntryResponse_DatatypeSpecificError::unsafe_arena_set_allocated_sharing_message_error(
    ::sync_pb::SharingMessageCommitError* sharing_message_error)
{
    clear_datatype_error();
    if (sharing_message_error) {
        set_has_sharing_message_error();
        _impl_.datatype_error_.sharing_message_error_ = sharing_message_error;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
}
inline ::sync_pb::SharingMessageCommitError* CommitResponse_EntryResponse_DatatypeSpecificError::_internal_mutable_sharing_message_error()
{
    if (!_internal_has_sharing_message_error()) {
        clear_datatype_error();
        set_has_sharing_message_error();
        _impl_.datatype_error_.sharing_message_error_ = CreateMaybeMessage<::sync_pb::SharingMessageCommitError>(GetArenaForAllocation());
    }
    return _impl_.datatype_error_.sharing_message_error_;
}
inline ::sync_pb::SharingMessageCommitError* CommitResponse_EntryResponse_DatatypeSpecificError::mutable_sharing_message_error()
{
    ::sync_pb::SharingMessageCommitError* _msg = _internal_mutable_sharing_message_error();
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
    return _msg;
}

// .sync_pb.OutgoingPasswordSharingInvitationCommitError outgoing_password_sharing_invitation_error = 2;
inline bool CommitResponse_EntryResponse_DatatypeSpecificError::_internal_has_outgoing_password_sharing_invitation_error() const
{
    return datatype_error_case() == kOutgoingPasswordSharingInvitationError;
}
inline bool CommitResponse_EntryResponse_DatatypeSpecificError::has_outgoing_password_sharing_invitation_error() const
{
    return _internal_has_outgoing_password_sharing_invitation_error();
}
inline void CommitResponse_EntryResponse_DatatypeSpecificError::set_has_outgoing_password_sharing_invitation_error()
{
    _impl_._oneof_case_[0] = kOutgoingPasswordSharingInvitationError;
}
inline ::sync_pb::OutgoingPasswordSharingInvitationCommitError*
CommitResponse_EntryResponse_DatatypeSpecificError::release_outgoing_password_sharing_invitation_error()
{
    // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.outgoing_password_sharing_invitation_error)
    if (_internal_has_outgoing_password_sharing_invitation_error()) {
        clear_has_datatype_error();
        ::sync_pb::OutgoingPasswordSharingInvitationCommitError* temp = _impl_.datatype_error_.outgoing_password_sharing_invitation_error_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.datatype_error_.outgoing_password_sharing_invitation_error_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::sync_pb::OutgoingPasswordSharingInvitationCommitError&
CommitResponse_EntryResponse_DatatypeSpecificError::_internal_outgoing_password_sharing_invitation_error() const
{
    return _internal_has_outgoing_password_sharing_invitation_error() ? *_impl_.datatype_error_.outgoing_password_sharing_invitation_error_
                                                                      : reinterpret_cast<::sync_pb::OutgoingPasswordSharingInvitationCommitError&>(
                                                                          ::sync_pb::_OutgoingPasswordSharingInvitationCommitError_default_instance_);
}
inline const ::sync_pb::OutgoingPasswordSharingInvitationCommitError&
CommitResponse_EntryResponse_DatatypeSpecificError::outgoing_password_sharing_invitation_error() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.outgoing_password_sharing_invitation_error)
    return _internal_outgoing_password_sharing_invitation_error();
}
inline ::sync_pb::OutgoingPasswordSharingInvitationCommitError*
CommitResponse_EntryResponse_DatatypeSpecificError::unsafe_arena_release_outgoing_password_sharing_invitation_error()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.outgoing_password_sharing_invitation_error)
    if (_internal_has_outgoing_password_sharing_invitation_error()) {
        clear_has_datatype_error();
        ::sync_pb::OutgoingPasswordSharingInvitationCommitError* temp = _impl_.datatype_error_.outgoing_password_sharing_invitation_error_;
        _impl_.datatype_error_.outgoing_password_sharing_invitation_error_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void CommitResponse_EntryResponse_DatatypeSpecificError::unsafe_arena_set_allocated_outgoing_password_sharing_invitation_error(
    ::sync_pb::OutgoingPasswordSharingInvitationCommitError* outgoing_password_sharing_invitation_error)
{
    clear_datatype_error();
    if (outgoing_password_sharing_invitation_error) {
        set_has_outgoing_password_sharing_invitation_error();
        _impl_.datatype_error_.outgoing_password_sharing_invitation_error_ = outgoing_password_sharing_invitation_error;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.outgoing_password_sharing_invitation_error)
}
inline ::sync_pb::OutgoingPasswordSharingInvitationCommitError*
CommitResponse_EntryResponse_DatatypeSpecificError::_internal_mutable_outgoing_password_sharing_invitation_error()
{
    if (!_internal_has_outgoing_password_sharing_invitation_error()) {
        clear_datatype_error();
        set_has_outgoing_password_sharing_invitation_error();
        _impl_.datatype_error_.outgoing_password_sharing_invitation_error_
            = CreateMaybeMessage<::sync_pb::OutgoingPasswordSharingInvitationCommitError>(GetArenaForAllocation());
    }
    return _impl_.datatype_error_.outgoing_password_sharing_invitation_error_;
}
inline ::sync_pb::OutgoingPasswordSharingInvitationCommitError*
CommitResponse_EntryResponse_DatatypeSpecificError::mutable_outgoing_password_sharing_invitation_error()
{
    ::sync_pb::OutgoingPasswordSharingInvitationCommitError* _msg = _internal_mutable_outgoing_password_sharing_invitation_error();
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.outgoing_password_sharing_invitation_error)
    return _msg;
}

inline bool CommitResponse_EntryResponse_DatatypeSpecificError::has_datatype_error() const
{
    return datatype_error_case() != DATATYPE_ERROR_NOT_SET;
}
inline void CommitResponse_EntryResponse_DatatypeSpecificError::clear_has_datatype_error()
{
    _impl_._oneof_case_[0] = DATATYPE_ERROR_NOT_SET;
}
inline CommitResponse_EntryResponse_DatatypeSpecificError::DatatypeErrorCase CommitResponse_EntryResponse_DatatypeSpecificError::datatype_error_case() const
{
    return CommitResponse_EntryResponse_DatatypeSpecificError::DatatypeErrorCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CommitResponse_EntryResponse

// required .sync_pb.CommitResponse.ResponseType response_type = 2;
inline bool CommitResponse_EntryResponse::_internal_has_response_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool CommitResponse_EntryResponse::has_response_type() const
{
    return _internal_has_response_type();
}
inline void CommitResponse_EntryResponse::clear_response_type()
{
    _impl_.response_type_ = 1;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::sync_pb::CommitResponse_ResponseType CommitResponse_EntryResponse::_internal_response_type() const
{
    return static_cast<::sync_pb::CommitResponse_ResponseType>(_impl_.response_type_);
}
inline ::sync_pb::CommitResponse_ResponseType CommitResponse_EntryResponse::response_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.response_type)
    return _internal_response_type();
}
inline void CommitResponse_EntryResponse::_internal_set_response_type(::sync_pb::CommitResponse_ResponseType value)
{
    assert(::sync_pb::CommitResponse_ResponseType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.response_type_ = value;
}
inline void CommitResponse_EntryResponse::set_response_type(::sync_pb::CommitResponse_ResponseType value)
{
    _internal_set_response_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.response_type)
}

// optional string id_string = 3;
inline bool CommitResponse_EntryResponse::_internal_has_id_string() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CommitResponse_EntryResponse::has_id_string() const
{
    return _internal_has_id_string();
}
inline void CommitResponse_EntryResponse::clear_id_string()
{
    _impl_.id_string_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommitResponse_EntryResponse::id_string() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.id_string)
    return _internal_id_string();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CommitResponse_EntryResponse::set_id_string(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.id_string_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.id_string)
}
inline std::string* CommitResponse_EntryResponse::mutable_id_string()
{
    std::string* _s = _internal_mutable_id_string();
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.id_string)
    return _s;
}
inline const std::string& CommitResponse_EntryResponse::_internal_id_string() const
{
    return _impl_.id_string_.Get();
}
inline void CommitResponse_EntryResponse::_internal_set_id_string(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.id_string_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitResponse_EntryResponse::_internal_mutable_id_string()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.id_string_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitResponse_EntryResponse::release_id_string()
{
    // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.id_string)
    if (!_internal_has_id_string()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.id_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_string_.IsDefault()) {
        _impl_.id_string_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CommitResponse_EntryResponse::set_allocated_id_string(std::string* id_string)
{
    if (id_string != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.id_string_.SetAllocated(id_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_string_.IsDefault()) {
        _impl_.id_string_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.id_string)
}

// optional int64 version = 6;
inline bool CommitResponse_EntryResponse::_internal_has_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool CommitResponse_EntryResponse::has_version() const
{
    return _internal_has_version();
}
inline void CommitResponse_EntryResponse::clear_version()
{
    _impl_.version_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t CommitResponse_EntryResponse::_internal_version() const
{
    return _impl_.version_;
}
inline int64_t CommitResponse_EntryResponse::version() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.version)
    return _internal_version();
}
inline void CommitResponse_EntryResponse::_internal_set_version(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.version_ = value;
}
inline void CommitResponse_EntryResponse::set_version(int64_t value)
{
    _internal_set_version(value);
    // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.version)
}

// optional string error_message = 9;
inline bool CommitResponse_EntryResponse::_internal_has_error_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CommitResponse_EntryResponse::has_error_message() const
{
    return _internal_has_error_message();
}
inline void CommitResponse_EntryResponse::clear_error_message()
{
    _impl_.error_message_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommitResponse_EntryResponse::error_message() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.error_message)
    return _internal_error_message();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CommitResponse_EntryResponse::set_error_message(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.error_message_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.error_message)
}
inline std::string* CommitResponse_EntryResponse::mutable_error_message()
{
    std::string* _s = _internal_mutable_error_message();
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.error_message)
    return _s;
}
inline const std::string& CommitResponse_EntryResponse::_internal_error_message() const
{
    return _impl_.error_message_.Get();
}
inline void CommitResponse_EntryResponse::_internal_set_error_message(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitResponse_EntryResponse::_internal_mutable_error_message()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitResponse_EntryResponse::release_error_message()
{
    // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.error_message)
    if (!_internal_has_error_message()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.error_message_.IsDefault()) {
        _impl_.error_message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CommitResponse_EntryResponse::set_allocated_error_message(std::string* error_message)
{
    if (error_message != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.error_message_.IsDefault()) {
        _impl_.error_message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.error_message)
}

// optional int64 mtime = 10 [deprecated = true];
inline bool CommitResponse_EntryResponse::_internal_has_mtime() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool CommitResponse_EntryResponse::has_mtime() const
{
    return _internal_has_mtime();
}
inline void CommitResponse_EntryResponse::clear_mtime()
{
    _impl_.mtime_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t CommitResponse_EntryResponse::_internal_mtime() const
{
    return _impl_.mtime_;
}
inline int64_t CommitResponse_EntryResponse::mtime() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.mtime)
    return _internal_mtime();
}
inline void CommitResponse_EntryResponse::_internal_set_mtime(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.mtime_ = value;
}
inline void CommitResponse_EntryResponse::set_mtime(int64_t value)
{
    _internal_set_mtime(value);
    // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.mtime)
}

// optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
inline bool CommitResponse_EntryResponse::_internal_has_datatype_specific_error() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.datatype_specific_error_ != nullptr);
    return value;
}
inline bool CommitResponse_EntryResponse::has_datatype_specific_error() const
{
    return _internal_has_datatype_specific_error();
}
inline void CommitResponse_EntryResponse::clear_datatype_specific_error()
{
    if (_impl_.datatype_specific_error_ != nullptr)
        _impl_.datatype_specific_error_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& CommitResponse_EntryResponse::_internal_datatype_specific_error() const
{
    const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* p = _impl_.datatype_specific_error_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError&>(
                            ::sync_pb::_CommitResponse_EntryResponse_DatatypeSpecificError_default_instance_);
}
inline const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& CommitResponse_EntryResponse::datatype_specific_error() const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
    return _internal_datatype_specific_error();
}
inline void CommitResponse_EntryResponse::unsafe_arena_set_allocated_datatype_specific_error(
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.datatype_specific_error_);
    }
    _impl_.datatype_specific_error_ = datatype_specific_error;
    if (datatype_specific_error) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
}
inline ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* CommitResponse_EntryResponse::release_datatype_specific_error()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* temp = _impl_.datatype_specific_error_;
    _impl_.datatype_specific_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* CommitResponse_EntryResponse::unsafe_arena_release_datatype_specific_error()
{
    // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* temp = _impl_.datatype_specific_error_;
    _impl_.datatype_specific_error_ = nullptr;
    return temp;
}
inline ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* CommitResponse_EntryResponse::_internal_mutable_datatype_specific_error()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.datatype_specific_error_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError>(GetArenaForAllocation());
        _impl_.datatype_specific_error_ = p;
    }
    return _impl_.datatype_specific_error_;
}
inline ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* CommitResponse_EntryResponse::mutable_datatype_specific_error()
{
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* _msg = _internal_mutable_datatype_specific_error();
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
    return _msg;
}
inline void CommitResponse_EntryResponse::set_allocated_datatype_specific_error(
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.datatype_specific_error_;
    }
    if (datatype_specific_error) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(datatype_specific_error);
        if (message_arena != submessage_arena) {
            datatype_specific_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, datatype_specific_error, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.datatype_specific_error_ = datatype_specific_error;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
}

// -------------------------------------------------------------------

// CommitResponse

// repeated group EntryResponse = 1 { ... };
inline int CommitResponse::_internal_entryresponse_size() const
{
    return _impl_.entryresponse_.size();
}
inline int CommitResponse::entryresponse_size() const
{
    return _internal_entryresponse_size();
}
inline void CommitResponse::clear_entryresponse()
{
    _impl_.entryresponse_.Clear();
}
inline ::sync_pb::CommitResponse_EntryResponse* CommitResponse::mutable_entryresponse(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.entryresponse)
    return _impl_.entryresponse_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CommitResponse_EntryResponse>* CommitResponse::mutable_entryresponse()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.CommitResponse.entryresponse)
    return &_impl_.entryresponse_;
}
inline const ::sync_pb::CommitResponse_EntryResponse& CommitResponse::_internal_entryresponse(int index) const
{
    return _impl_.entryresponse_.Get(index);
}
inline const ::sync_pb::CommitResponse_EntryResponse& CommitResponse::entryresponse(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.entryresponse)
    return _internal_entryresponse(index);
}
inline ::sync_pb::CommitResponse_EntryResponse* CommitResponse::_internal_add_entryresponse()
{
    return _impl_.entryresponse_.Add();
}
inline ::sync_pb::CommitResponse_EntryResponse* CommitResponse::add_entryresponse()
{
    ::sync_pb::CommitResponse_EntryResponse* _add = _internal_add_entryresponse();
    // @@protoc_insertion_point(field_add:sync_pb.CommitResponse.entryresponse)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::CommitResponse_EntryResponse>& CommitResponse::entryresponse() const
{
    // @@protoc_insertion_point(field_list:sync_pb.CommitResponse.entryresponse)
    return _impl_.entryresponse_;
}

// -------------------------------------------------------------------

// GetUpdatesResponse

// repeated .sync_pb.SyncEntity entries = 1;
inline int GetUpdatesResponse::_internal_entries_size() const
{
    return _impl_.entries_.size();
}
inline int GetUpdatesResponse::entries_size() const
{
    return _internal_entries_size();
}
inline ::sync_pb::SyncEntity* GetUpdatesResponse::mutable_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesResponse.entries)
    return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity>* GetUpdatesResponse::mutable_entries()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesResponse.entries)
    return &_impl_.entries_;
}
inline const ::sync_pb::SyncEntity& GetUpdatesResponse::_internal_entries(int index) const
{
    return _impl_.entries_.Get(index);
}
inline const ::sync_pb::SyncEntity& GetUpdatesResponse::entries(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.entries)
    return _internal_entries(index);
}
inline ::sync_pb::SyncEntity* GetUpdatesResponse::_internal_add_entries()
{
    return _impl_.entries_.Add();
}
inline ::sync_pb::SyncEntity* GetUpdatesResponse::add_entries()
{
    ::sync_pb::SyncEntity* _add = _internal_add_entries();
    // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.entries)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SyncEntity>& GetUpdatesResponse::entries() const
{
    // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesResponse.entries)
    return _impl_.entries_;
}

// optional int64 changes_remaining = 4;
inline bool GetUpdatesResponse::_internal_has_changes_remaining() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool GetUpdatesResponse::has_changes_remaining() const
{
    return _internal_has_changes_remaining();
}
inline void GetUpdatesResponse::clear_changes_remaining()
{
    _impl_.changes_remaining_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t GetUpdatesResponse::_internal_changes_remaining() const
{
    return _impl_.changes_remaining_;
}
inline int64_t GetUpdatesResponse::changes_remaining() const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.changes_remaining)
    return _internal_changes_remaining();
}
inline void GetUpdatesResponse::_internal_set_changes_remaining(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.changes_remaining_ = value;
}
inline void GetUpdatesResponse::set_changes_remaining(int64_t value)
{
    _internal_set_changes_remaining(value);
    // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesResponse.changes_remaining)
}

// repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
inline int GetUpdatesResponse::_internal_new_progress_marker_size() const
{
    return _impl_.new_progress_marker_.size();
}
inline int GetUpdatesResponse::new_progress_marker_size() const
{
    return _internal_new_progress_marker_size();
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesResponse::mutable_new_progress_marker(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesResponse.new_progress_marker)
    return _impl_.new_progress_marker_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker>* GetUpdatesResponse::mutable_new_progress_marker()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesResponse.new_progress_marker)
    return &_impl_.new_progress_marker_;
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesResponse::_internal_new_progress_marker(int index) const
{
    return _impl_.new_progress_marker_.Get(index);
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesResponse::new_progress_marker(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.new_progress_marker)
    return _internal_new_progress_marker(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesResponse::_internal_add_new_progress_marker()
{
    return _impl_.new_progress_marker_.Add();
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesResponse::add_new_progress_marker()
{
    ::sync_pb::DataTypeProgressMarker* _add = _internal_add_new_progress_marker();
    // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.new_progress_marker)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeProgressMarker>& GetUpdatesResponse::new_progress_marker() const
{
    // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesResponse.new_progress_marker)
    return _impl_.new_progress_marker_;
}

// repeated bytes encryption_keys = 6;
inline int GetUpdatesResponse::_internal_encryption_keys_size() const
{
    return _impl_.encryption_keys_.size();
}
inline int GetUpdatesResponse::encryption_keys_size() const
{
    return _internal_encryption_keys_size();
}
inline void GetUpdatesResponse::clear_encryption_keys()
{
    _impl_.encryption_keys_.Clear();
}
inline std::string* GetUpdatesResponse::add_encryption_keys()
{
    std::string* _s = _internal_add_encryption_keys();
    // @@protoc_insertion_point(field_add_mutable:sync_pb.GetUpdatesResponse.encryption_keys)
    return _s;
}
inline const std::string& GetUpdatesResponse::_internal_encryption_keys(int index) const
{
    return _impl_.encryption_keys_.Get(index);
}
inline const std::string& GetUpdatesResponse::encryption_keys(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.encryption_keys)
    return _internal_encryption_keys(index);
}
inline std::string* GetUpdatesResponse::mutable_encryption_keys(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesResponse.encryption_keys)
    return _impl_.encryption_keys_.Mutable(index);
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const std::string& value)
{
    _impl_.encryption_keys_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::set_encryption_keys(int index, std::string&& value)
{
    _impl_.encryption_keys_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.encryption_keys_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const void* value, size_t size)
{
    _impl_.encryption_keys_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline std::string* GetUpdatesResponse::_internal_add_encryption_keys()
{
    return _impl_.encryption_keys_.Add();
}
inline void GetUpdatesResponse::add_encryption_keys(const std::string& value)
{
    _impl_.encryption_keys_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::add_encryption_keys(std::string&& value)
{
    _impl_.encryption_keys_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::add_encryption_keys(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.encryption_keys_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::add_encryption_keys(const void* value, size_t size)
{
    _impl_.encryption_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& GetUpdatesResponse::encryption_keys() const
{
    // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesResponse.encryption_keys)
    return _impl_.encryption_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* GetUpdatesResponse::mutable_encryption_keys()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesResponse.encryption_keys)
    return &_impl_.encryption_keys_;
}

// repeated .sync_pb.DataTypeContext context_mutations = 7;
inline int GetUpdatesResponse::_internal_context_mutations_size() const
{
    return _impl_.context_mutations_.size();
}
inline int GetUpdatesResponse::context_mutations_size() const
{
    return _internal_context_mutations_size();
}
inline ::sync_pb::DataTypeContext* GetUpdatesResponse::mutable_context_mutations(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesResponse.context_mutations)
    return _impl_.context_mutations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>* GetUpdatesResponse::mutable_context_mutations()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesResponse.context_mutations)
    return &_impl_.context_mutations_;
}
inline const ::sync_pb::DataTypeContext& GetUpdatesResponse::_internal_context_mutations(int index) const
{
    return _impl_.context_mutations_.Get(index);
}
inline const ::sync_pb::DataTypeContext& GetUpdatesResponse::context_mutations(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.context_mutations)
    return _internal_context_mutations(index);
}
inline ::sync_pb::DataTypeContext* GetUpdatesResponse::_internal_add_context_mutations()
{
    return _impl_.context_mutations_.Add();
}
inline ::sync_pb::DataTypeContext* GetUpdatesResponse::add_context_mutations()
{
    ::sync_pb::DataTypeContext* _add = _internal_add_context_mutations();
    // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.context_mutations)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::DataTypeContext>& GetUpdatesResponse::context_mutations() const
{
    // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesResponse.context_mutations)
    return _impl_.context_mutations_;
}

// -------------------------------------------------------------------

// ClientToServerResponse_Error

// optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
inline bool ClientToServerResponse_Error::_internal_has_error_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientToServerResponse_Error::has_error_type() const
{
    return _internal_has_error_type();
}
inline void ClientToServerResponse_Error::clear_error_type()
{
    _impl_.error_type_ = 100;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse_Error::_internal_error_type() const
{
    return static_cast<::sync_pb::SyncEnums_ErrorType>(_impl_.error_type_);
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse_Error::error_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.Error.error_type)
    return _internal_error_type();
}
inline void ClientToServerResponse_Error::_internal_set_error_type(::sync_pb::SyncEnums_ErrorType value)
{
    assert(::sync_pb::SyncEnums_ErrorType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.error_type_ = value;
}
inline void ClientToServerResponse_Error::set_error_type(::sync_pb::SyncEnums_ErrorType value)
{
    _internal_set_error_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.Error.error_type)
}

// optional string error_description = 2;
inline bool ClientToServerResponse_Error::_internal_has_error_description() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClientToServerResponse_Error::has_error_description() const
{
    return _internal_has_error_description();
}
inline void ClientToServerResponse_Error::clear_error_description()
{
    _impl_.error_description_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientToServerResponse_Error::error_description() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.Error.error_description)
    return _internal_error_description();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientToServerResponse_Error::set_error_description(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.error_description_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.Error.error_description)
}
inline std::string* ClientToServerResponse_Error::mutable_error_description()
{
    std::string* _s = _internal_mutable_error_description();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.Error.error_description)
    return _s;
}
inline const std::string& ClientToServerResponse_Error::_internal_error_description() const
{
    return _impl_.error_description_.Get();
}
inline void ClientToServerResponse_Error::_internal_set_error_description(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.error_description_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerResponse_Error::_internal_mutable_error_description()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.error_description_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerResponse_Error::release_error_description()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.Error.error_description)
    if (!_internal_has_error_description()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.error_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.error_description_.IsDefault()) {
        _impl_.error_description_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientToServerResponse_Error::set_allocated_error_description(std::string* error_description)
{
    if (error_description != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.error_description_.SetAllocated(error_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.error_description_.IsDefault()) {
        _impl_.error_description_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.Error.error_description)
}

// optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
inline bool ClientToServerResponse_Error::_internal_has_action() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ClientToServerResponse_Error::has_action() const
{
    return _internal_has_action();
}
inline void ClientToServerResponse_Error::clear_action()
{
    _impl_.action_ = 5;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::sync_pb::SyncEnums_Action ClientToServerResponse_Error::_internal_action() const
{
    return static_cast<::sync_pb::SyncEnums_Action>(_impl_.action_);
}
inline ::sync_pb::SyncEnums_Action ClientToServerResponse_Error::action() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.Error.action)
    return _internal_action();
}
inline void ClientToServerResponse_Error::_internal_set_action(::sync_pb::SyncEnums_Action value)
{
    assert(::sync_pb::SyncEnums_Action_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.action_ = value;
}
inline void ClientToServerResponse_Error::set_action(::sync_pb::SyncEnums_Action value)
{
    _internal_set_action(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.Error.action)
}

// repeated int32 error_data_type_ids = 5;
inline int ClientToServerResponse_Error::_internal_error_data_type_ids_size() const
{
    return _impl_.error_data_type_ids_.size();
}
inline int ClientToServerResponse_Error::error_data_type_ids_size() const
{
    return _internal_error_data_type_ids_size();
}
inline void ClientToServerResponse_Error::clear_error_data_type_ids()
{
    _impl_.error_data_type_ids_.Clear();
}
inline int32_t ClientToServerResponse_Error::_internal_error_data_type_ids(int index) const
{
    return _impl_.error_data_type_ids_.Get(index);
}
inline int32_t ClientToServerResponse_Error::error_data_type_ids(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
    return _internal_error_data_type_ids(index);
}
inline void ClientToServerResponse_Error::set_error_data_type_ids(int index, int32_t value)
{
    _impl_.error_data_type_ids_.Set(index, value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
}
inline void ClientToServerResponse_Error::_internal_add_error_data_type_ids(int32_t value)
{
    _impl_.error_data_type_ids_.Add(value);
}
inline void ClientToServerResponse_Error::add_error_data_type_ids(int32_t value)
{
    _internal_add_error_data_type_ids(value);
    // @@protoc_insertion_point(field_add:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& ClientToServerResponse_Error::_internal_error_data_type_ids() const
{
    return _impl_.error_data_type_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& ClientToServerResponse_Error::error_data_type_ids() const
{
    // @@protoc_insertion_point(field_list:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
    return _internal_error_data_type_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* ClientToServerResponse_Error::_internal_mutable_error_data_type_ids()
{
    return &_impl_.error_data_type_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* ClientToServerResponse_Error::mutable_error_data_type_ids()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
    return _internal_mutable_error_data_type_ids();
}

// -------------------------------------------------------------------

// ClientToServerResponse

// optional .sync_pb.CommitResponse commit = 1;
inline bool ClientToServerResponse::_internal_has_commit() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.commit_ != nullptr);
    return value;
}
inline bool ClientToServerResponse::has_commit() const
{
    return _internal_has_commit();
}
inline void ClientToServerResponse::clear_commit()
{
    if (_impl_.commit_ != nullptr)
        _impl_.commit_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sync_pb::CommitResponse& ClientToServerResponse::_internal_commit() const
{
    const ::sync_pb::CommitResponse* p = _impl_.commit_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::CommitResponse&>(::sync_pb::_CommitResponse_default_instance_);
}
inline const ::sync_pb::CommitResponse& ClientToServerResponse::commit() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.commit)
    return _internal_commit();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_commit(::sync_pb::CommitResponse* commit)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.commit_);
    }
    _impl_.commit_ = commit;
    if (commit) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.commit)
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::release_commit()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::CommitResponse* temp = _impl_.commit_;
    _impl_.commit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::unsafe_arena_release_commit()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.commit)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::CommitResponse* temp = _impl_.commit_;
    _impl_.commit_ = nullptr;
    return temp;
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::_internal_mutable_commit()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.commit_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::CommitResponse>(GetArenaForAllocation());
        _impl_.commit_ = p;
    }
    return _impl_.commit_;
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::mutable_commit()
{
    ::sync_pb::CommitResponse* _msg = _internal_mutable_commit();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.commit)
    return _msg;
}
inline void ClientToServerResponse::set_allocated_commit(::sync_pb::CommitResponse* commit)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.commit_;
    }
    if (commit) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commit);
        if (message_arena != submessage_arena) {
            commit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, commit, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.commit_ = commit;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.commit)
}

// optional .sync_pb.GetUpdatesResponse get_updates = 2;
inline bool ClientToServerResponse::_internal_has_get_updates() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.get_updates_ != nullptr);
    return value;
}
inline bool ClientToServerResponse::has_get_updates() const
{
    return _internal_has_get_updates();
}
inline void ClientToServerResponse::clear_get_updates()
{
    if (_impl_.get_updates_ != nullptr)
        _impl_.get_updates_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sync_pb::GetUpdatesResponse& ClientToServerResponse::_internal_get_updates() const
{
    const ::sync_pb::GetUpdatesResponse* p = _impl_.get_updates_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::GetUpdatesResponse&>(::sync_pb::_GetUpdatesResponse_default_instance_);
}
inline const ::sync_pb::GetUpdatesResponse& ClientToServerResponse::get_updates() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.get_updates)
    return _internal_get_updates();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_get_updates(::sync_pb::GetUpdatesResponse* get_updates)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.get_updates_);
    }
    _impl_.get_updates_ = get_updates;
    if (get_updates) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.get_updates)
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::release_get_updates()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::sync_pb::GetUpdatesResponse* temp = _impl_.get_updates_;
    _impl_.get_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::unsafe_arena_release_get_updates()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.get_updates)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::sync_pb::GetUpdatesResponse* temp = _impl_.get_updates_;
    _impl_.get_updates_ = nullptr;
    return temp;
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::_internal_mutable_get_updates()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.get_updates_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::GetUpdatesResponse>(GetArenaForAllocation());
        _impl_.get_updates_ = p;
    }
    return _impl_.get_updates_;
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::mutable_get_updates()
{
    ::sync_pb::GetUpdatesResponse* _msg = _internal_mutable_get_updates();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.get_updates)
    return _msg;
}
inline void ClientToServerResponse::set_allocated_get_updates(::sync_pb::GetUpdatesResponse* get_updates)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.get_updates_;
    }
    if (get_updates) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_updates);
        if (message_arena != submessage_arena) {
            get_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, get_updates, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.get_updates_ = get_updates;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.get_updates)
}

// optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
inline bool ClientToServerResponse::_internal_has_error_code() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool ClientToServerResponse::has_error_code() const
{
    return _internal_has_error_code();
}
inline void ClientToServerResponse::clear_error_code()
{
    _impl_.error_code_ = 100;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse::_internal_error_code() const
{
    return static_cast<::sync_pb::SyncEnums_ErrorType>(_impl_.error_code_);
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse::error_code() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.error_code)
    return _internal_error_code();
}
inline void ClientToServerResponse::_internal_set_error_code(::sync_pb::SyncEnums_ErrorType value)
{
    assert(::sync_pb::SyncEnums_ErrorType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.error_code_ = value;
}
inline void ClientToServerResponse::set_error_code(::sync_pb::SyncEnums_ErrorType value)
{
    _internal_set_error_code(value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.error_code)
}

// optional string error_message = 5;
inline bool ClientToServerResponse::_internal_has_error_message() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ClientToServerResponse::has_error_message() const
{
    return _internal_has_error_message();
}
inline void ClientToServerResponse::clear_error_message()
{
    _impl_.error_message_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientToServerResponse::error_message() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.error_message)
    return _internal_error_message();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientToServerResponse::set_error_message(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.error_message_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.error_message)
}
inline std::string* ClientToServerResponse::mutable_error_message()
{
    std::string* _s = _internal_mutable_error_message();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.error_message)
    return _s;
}
inline const std::string& ClientToServerResponse::_internal_error_message() const
{
    return _impl_.error_message_.Get();
}
inline void ClientToServerResponse::_internal_set_error_message(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerResponse::_internal_mutable_error_message()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerResponse::release_error_message()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.error_message)
    if (!_internal_has_error_message()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.error_message_.IsDefault()) {
        _impl_.error_message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientToServerResponse::set_allocated_error_message(std::string* error_message)
{
    if (error_message != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.error_message_.IsDefault()) {
        _impl_.error_message_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.error_message)
}

// optional string store_birthday = 6;
inline bool ClientToServerResponse::_internal_has_store_birthday() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ClientToServerResponse::has_store_birthday() const
{
    return _internal_has_store_birthday();
}
inline void ClientToServerResponse::clear_store_birthday()
{
    _impl_.store_birthday_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientToServerResponse::store_birthday() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.store_birthday)
    return _internal_store_birthday();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ClientToServerResponse::set_store_birthday(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.store_birthday_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.store_birthday)
}
inline std::string* ClientToServerResponse::mutable_store_birthday()
{
    std::string* _s = _internal_mutable_store_birthday();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.store_birthday)
    return _s;
}
inline const std::string& ClientToServerResponse::_internal_store_birthday() const
{
    return _impl_.store_birthday_.Get();
}
inline void ClientToServerResponse::_internal_set_store_birthday(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.store_birthday_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerResponse::_internal_mutable_store_birthday()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.store_birthday_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerResponse::release_store_birthday()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.store_birthday)
    if (!_internal_has_store_birthday()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.store_birthday_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.store_birthday_.IsDefault()) {
        _impl_.store_birthday_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ClientToServerResponse::set_allocated_store_birthday(std::string* store_birthday)
{
    if (store_birthday != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.store_birthday_.SetAllocated(store_birthday, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.store_birthday_.IsDefault()) {
        _impl_.store_birthday_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.store_birthday)
}

// optional .sync_pb.ClientCommand client_command = 7;
inline bool ClientToServerResponse::_internal_has_client_command() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.client_command_ != nullptr);
    return value;
}
inline bool ClientToServerResponse::has_client_command() const
{
    return _internal_has_client_command();
}
inline const ::sync_pb::ClientCommand& ClientToServerResponse::_internal_client_command() const
{
    const ::sync_pb::ClientCommand* p = _impl_.client_command_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClientCommand&>(::sync_pb::_ClientCommand_default_instance_);
}
inline const ::sync_pb::ClientCommand& ClientToServerResponse::client_command() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.client_command)
    return _internal_client_command();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_client_command(::sync_pb::ClientCommand* client_command)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_command_);
    }
    _impl_.client_command_ = client_command;
    if (client_command) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.client_command)
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::release_client_command()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::sync_pb::ClientCommand* temp = _impl_.client_command_;
    _impl_.client_command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::unsafe_arena_release_client_command()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.client_command)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::sync_pb::ClientCommand* temp = _impl_.client_command_;
    _impl_.client_command_ = nullptr;
    return temp;
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::_internal_mutable_client_command()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.client_command_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ClientCommand>(GetArenaForAllocation());
        _impl_.client_command_ = p;
    }
    return _impl_.client_command_;
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::mutable_client_command()
{
    ::sync_pb::ClientCommand* _msg = _internal_mutable_client_command();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.client_command)
    return _msg;
}
inline void ClientToServerResponse::set_allocated_client_command(::sync_pb::ClientCommand* client_command)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.client_command_);
    }
    if (client_command) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_command));
        if (message_arena != submessage_arena) {
            client_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, client_command, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.client_command_ = client_command;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.client_command)
}

// repeated int32 migrated_data_type_id = 12;
inline int ClientToServerResponse::_internal_migrated_data_type_id_size() const
{
    return _impl_.migrated_data_type_id_.size();
}
inline int ClientToServerResponse::migrated_data_type_id_size() const
{
    return _internal_migrated_data_type_id_size();
}
inline void ClientToServerResponse::clear_migrated_data_type_id()
{
    _impl_.migrated_data_type_id_.Clear();
}
inline int32_t ClientToServerResponse::_internal_migrated_data_type_id(int index) const
{
    return _impl_.migrated_data_type_id_.Get(index);
}
inline int32_t ClientToServerResponse::migrated_data_type_id(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.migrated_data_type_id)
    return _internal_migrated_data_type_id(index);
}
inline void ClientToServerResponse::set_migrated_data_type_id(int index, int32_t value)
{
    _impl_.migrated_data_type_id_.Set(index, value);
    // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.migrated_data_type_id)
}
inline void ClientToServerResponse::_internal_add_migrated_data_type_id(int32_t value)
{
    _impl_.migrated_data_type_id_.Add(value);
}
inline void ClientToServerResponse::add_migrated_data_type_id(int32_t value)
{
    _internal_add_migrated_data_type_id(value);
    // @@protoc_insertion_point(field_add:sync_pb.ClientToServerResponse.migrated_data_type_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& ClientToServerResponse::_internal_migrated_data_type_id() const
{
    return _impl_.migrated_data_type_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& ClientToServerResponse::migrated_data_type_id() const
{
    // @@protoc_insertion_point(field_list:sync_pb.ClientToServerResponse.migrated_data_type_id)
    return _internal_migrated_data_type_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* ClientToServerResponse::_internal_mutable_migrated_data_type_id()
{
    return &_impl_.migrated_data_type_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* ClientToServerResponse::mutable_migrated_data_type_id()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientToServerResponse.migrated_data_type_id)
    return _internal_mutable_migrated_data_type_id();
}

// optional .sync_pb.ClientToServerResponse.Error error = 13;
inline bool ClientToServerResponse::_internal_has_error() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.error_ != nullptr);
    return value;
}
inline bool ClientToServerResponse::has_error() const
{
    return _internal_has_error();
}
inline void ClientToServerResponse::clear_error()
{
    if (_impl_.error_ != nullptr)
        _impl_.error_->Clear();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::sync_pb::ClientToServerResponse_Error& ClientToServerResponse::_internal_error() const
{
    const ::sync_pb::ClientToServerResponse_Error* p = _impl_.error_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClientToServerResponse_Error&>(::sync_pb::_ClientToServerResponse_Error_default_instance_);
}
inline const ::sync_pb::ClientToServerResponse_Error& ClientToServerResponse::error() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.error)
    return _internal_error();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_error(::sync_pb::ClientToServerResponse_Error* error)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
    }
    _impl_.error_ = error;
    if (error) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.error)
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::release_error()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::sync_pb::ClientToServerResponse_Error* temp = _impl_.error_;
    _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::unsafe_arena_release_error()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.error)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::sync_pb::ClientToServerResponse_Error* temp = _impl_.error_;
    _impl_.error_ = nullptr;
    return temp;
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::_internal_mutable_error()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.error_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ClientToServerResponse_Error>(GetArenaForAllocation());
        _impl_.error_ = p;
    }
    return _impl_.error_;
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::mutable_error()
{
    ::sync_pb::ClientToServerResponse_Error* _msg = _internal_mutable_error();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.error)
    return _msg;
}
inline void ClientToServerResponse::set_allocated_error(::sync_pb::ClientToServerResponse_Error* error)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.error_;
    }
    if (error) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
        if (message_arena != submessage_arena) {
            error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, error, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.error_ = error;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.error)
}

// optional .sync_pb.ChipBag new_bag_of_chips = 14;
inline bool ClientToServerResponse::_internal_has_new_bag_of_chips() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.new_bag_of_chips_ != nullptr);
    return value;
}
inline bool ClientToServerResponse::has_new_bag_of_chips() const
{
    return _internal_has_new_bag_of_chips();
}
inline void ClientToServerResponse::clear_new_bag_of_chips()
{
    if (_impl_.new_bag_of_chips_ != nullptr)
        _impl_.new_bag_of_chips_->Clear();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::sync_pb::ChipBag& ClientToServerResponse::_internal_new_bag_of_chips() const
{
    const ::sync_pb::ChipBag* p = _impl_.new_bag_of_chips_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ChipBag&>(::sync_pb::_ChipBag_default_instance_);
}
inline const ::sync_pb::ChipBag& ClientToServerResponse::new_bag_of_chips() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.new_bag_of_chips)
    return _internal_new_bag_of_chips();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_new_bag_of_chips(::sync_pb::ChipBag* new_bag_of_chips)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.new_bag_of_chips_);
    }
    _impl_.new_bag_of_chips_ = new_bag_of_chips;
    if (new_bag_of_chips) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.new_bag_of_chips)
}
inline ::sync_pb::ChipBag* ClientToServerResponse::release_new_bag_of_chips()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::sync_pb::ChipBag* temp = _impl_.new_bag_of_chips_;
    _impl_.new_bag_of_chips_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ChipBag* ClientToServerResponse::unsafe_arena_release_new_bag_of_chips()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.new_bag_of_chips)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::sync_pb::ChipBag* temp = _impl_.new_bag_of_chips_;
    _impl_.new_bag_of_chips_ = nullptr;
    return temp;
}
inline ::sync_pb::ChipBag* ClientToServerResponse::_internal_mutable_new_bag_of_chips()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.new_bag_of_chips_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ChipBag>(GetArenaForAllocation());
        _impl_.new_bag_of_chips_ = p;
    }
    return _impl_.new_bag_of_chips_;
}
inline ::sync_pb::ChipBag* ClientToServerResponse::mutable_new_bag_of_chips()
{
    ::sync_pb::ChipBag* _msg = _internal_mutable_new_bag_of_chips();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.new_bag_of_chips)
    return _msg;
}
inline void ClientToServerResponse::set_allocated_new_bag_of_chips(::sync_pb::ChipBag* new_bag_of_chips)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.new_bag_of_chips_;
    }
    if (new_bag_of_chips) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_bag_of_chips);
        if (message_arena != submessage_arena) {
            new_bag_of_chips = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, new_bag_of_chips, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.new_bag_of_chips_ = new_bag_of_chips;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.new_bag_of_chips)
}

// optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
inline bool ClientToServerResponse::_internal_has_clear_server_data() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.clear_server_data_ != nullptr);
    return value;
}
inline bool ClientToServerResponse::has_clear_server_data() const
{
    return _internal_has_clear_server_data();
}
inline void ClientToServerResponse::clear_clear_server_data()
{
    if (_impl_.clear_server_data_ != nullptr)
        _impl_.clear_server_data_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::sync_pb::ClearServerDataResponse& ClientToServerResponse::_internal_clear_server_data() const
{
    const ::sync_pb::ClearServerDataResponse* p = _impl_.clear_server_data_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClearServerDataResponse&>(::sync_pb::_ClearServerDataResponse_default_instance_);
}
inline const ::sync_pb::ClearServerDataResponse& ClientToServerResponse::clear_server_data() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.clear_server_data)
    return _internal_clear_server_data();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_clear_server_data(::sync_pb::ClearServerDataResponse* clear_server_data)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.clear_server_data_);
    }
    _impl_.clear_server_data_ = clear_server_data;
    if (clear_server_data) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.clear_server_data)
}
inline ::sync_pb::ClearServerDataResponse* ClientToServerResponse::release_clear_server_data()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::sync_pb::ClearServerDataResponse* temp = _impl_.clear_server_data_;
    _impl_.clear_server_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ClearServerDataResponse* ClientToServerResponse::unsafe_arena_release_clear_server_data()
{
    // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.clear_server_data)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::sync_pb::ClearServerDataResponse* temp = _impl_.clear_server_data_;
    _impl_.clear_server_data_ = nullptr;
    return temp;
}
inline ::sync_pb::ClearServerDataResponse* ClientToServerResponse::_internal_mutable_clear_server_data()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.clear_server_data_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ClearServerDataResponse>(GetArenaForAllocation());
        _impl_.clear_server_data_ = p;
    }
    return _impl_.clear_server_data_;
}
inline ::sync_pb::ClearServerDataResponse* ClientToServerResponse::mutable_clear_server_data()
{
    ::sync_pb::ClearServerDataResponse* _msg = _internal_mutable_clear_server_data();
    // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.clear_server_data)
    return _msg;
}
inline void ClientToServerResponse::set_allocated_clear_server_data(::sync_pb::ClearServerDataResponse* clear_server_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.clear_server_data_;
    }
    if (clear_server_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clear_server_data);
        if (message_arena != submessage_arena) {
            clear_server_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, clear_server_data, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.clear_server_data_ = clear_server_data;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.clear_server_data)
}

// -------------------------------------------------------------------

// EventRequest

// optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
inline bool EventRequest::_internal_has_sync_disabled() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.sync_disabled_ != nullptr);
    return value;
}
inline bool EventRequest::has_sync_disabled() const
{
    return _internal_has_sync_disabled();
}
inline void EventRequest::clear_sync_disabled()
{
    if (_impl_.sync_disabled_ != nullptr)
        _impl_.sync_disabled_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::sync_pb::SyncDisabledEvent& EventRequest::_internal_sync_disabled() const
{
    const ::sync_pb::SyncDisabledEvent* p = _impl_.sync_disabled_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::SyncDisabledEvent&>(::sync_pb::_SyncDisabledEvent_default_instance_);
}
inline const ::sync_pb::SyncDisabledEvent& EventRequest::sync_disabled() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EventRequest.sync_disabled)
    return _internal_sync_disabled();
}
inline void EventRequest::unsafe_arena_set_allocated_sync_disabled(::sync_pb::SyncDisabledEvent* sync_disabled)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sync_disabled_);
    }
    _impl_.sync_disabled_ = sync_disabled;
    if (sync_disabled) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.EventRequest.sync_disabled)
}
inline ::sync_pb::SyncDisabledEvent* EventRequest::release_sync_disabled()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::sync_pb::SyncDisabledEvent* temp = _impl_.sync_disabled_;
    _impl_.sync_disabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::SyncDisabledEvent* EventRequest::unsafe_arena_release_sync_disabled()
{
    // @@protoc_insertion_point(field_release:sync_pb.EventRequest.sync_disabled)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::sync_pb::SyncDisabledEvent* temp = _impl_.sync_disabled_;
    _impl_.sync_disabled_ = nullptr;
    return temp;
}
inline ::sync_pb::SyncDisabledEvent* EventRequest::_internal_mutable_sync_disabled()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.sync_disabled_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::SyncDisabledEvent>(GetArenaForAllocation());
        _impl_.sync_disabled_ = p;
    }
    return _impl_.sync_disabled_;
}
inline ::sync_pb::SyncDisabledEvent* EventRequest::mutable_sync_disabled()
{
    ::sync_pb::SyncDisabledEvent* _msg = _internal_mutable_sync_disabled();
    // @@protoc_insertion_point(field_mutable:sync_pb.EventRequest.sync_disabled)
    return _msg;
}
inline void EventRequest::set_allocated_sync_disabled(::sync_pb::SyncDisabledEvent* sync_disabled)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.sync_disabled_;
    }
    if (sync_disabled) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sync_disabled);
        if (message_arena != submessage_arena) {
            sync_disabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, sync_disabled, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.sync_disabled_ = sync_disabled;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EventRequest.sync_disabled)
}

// -------------------------------------------------------------------

// EventResponse

// -------------------------------------------------------------------

// SyncDisabledEvent

// optional string cache_guid = 1;
inline bool SyncDisabledEvent::_internal_has_cache_guid() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SyncDisabledEvent::has_cache_guid() const
{
    return _internal_has_cache_guid();
}
inline void SyncDisabledEvent::clear_cache_guid()
{
    _impl_.cache_guid_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncDisabledEvent::cache_guid() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SyncDisabledEvent.cache_guid)
    return _internal_cache_guid();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SyncDisabledEvent::set_cache_guid(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_guid_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SyncDisabledEvent.cache_guid)
}
inline std::string* SyncDisabledEvent::mutable_cache_guid()
{
    std::string* _s = _internal_mutable_cache_guid();
    // @@protoc_insertion_point(field_mutable:sync_pb.SyncDisabledEvent.cache_guid)
    return _s;
}
inline const std::string& SyncDisabledEvent::_internal_cache_guid() const
{
    return _impl_.cache_guid_.Get();
}
inline void SyncDisabledEvent::_internal_set_cache_guid(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.cache_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncDisabledEvent::_internal_mutable_cache_guid()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.cache_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncDisabledEvent::release_cache_guid()
{
    // @@protoc_insertion_point(field_release:sync_pb.SyncDisabledEvent.cache_guid)
    if (!_internal_has_cache_guid()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.cache_guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_guid_.IsDefault()) {
        _impl_.cache_guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SyncDisabledEvent::set_allocated_cache_guid(std::string* cache_guid)
{
    if (cache_guid != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.cache_guid_.SetAllocated(cache_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.cache_guid_.IsDefault()) {
        _impl_.cache_guid_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SyncDisabledEvent.cache_guid)
}

// optional string store_birthday = 2;
inline bool SyncDisabledEvent::_internal_has_store_birthday() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SyncDisabledEvent::has_store_birthday() const
{
    return _internal_has_store_birthday();
}
inline void SyncDisabledEvent::clear_store_birthday()
{
    _impl_.store_birthday_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SyncDisabledEvent::store_birthday() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SyncDisabledEvent.store_birthday)
    return _internal_store_birthday();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SyncDisabledEvent::set_store_birthday(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.store_birthday_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SyncDisabledEvent.store_birthday)
}
inline std::string* SyncDisabledEvent::mutable_store_birthday()
{
    std::string* _s = _internal_mutable_store_birthday();
    // @@protoc_insertion_point(field_mutable:sync_pb.SyncDisabledEvent.store_birthday)
    return _s;
}
inline const std::string& SyncDisabledEvent::_internal_store_birthday() const
{
    return _impl_.store_birthday_.Get();
}
inline void SyncDisabledEvent::_internal_set_store_birthday(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.store_birthday_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncDisabledEvent::_internal_mutable_store_birthday()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.store_birthday_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncDisabledEvent::release_store_birthday()
{
    // @@protoc_insertion_point(field_release:sync_pb.SyncDisabledEvent.store_birthday)
    if (!_internal_has_store_birthday()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.store_birthday_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.store_birthday_.IsDefault()) {
        _impl_.store_birthday_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SyncDisabledEvent::set_allocated_store_birthday(std::string* store_birthday)
{
    if (store_birthday != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.store_birthday_.SetAllocated(store_birthday, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.store_birthday_.IsDefault()) {
        _impl_.store_birthday_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SyncDisabledEvent.store_birthday)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace sync_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::sync_pb::ClientToServerMessage_Contents> : ::std::true_type { };
template <> struct is_proto_enum<::sync_pb::CommitResponse_ResponseType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsync_2eproto
