// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/user_consent_types.proto

#include "components/sync/protocol/user_consent_types.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR UserConsentTypes_ArcBackupAndRestoreConsent::UserConsentTypes_ArcBackupAndRestoreConsent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.description_grd_ids_)*/ {},
        /*decltype(_impl_.confirmation_grd_id_)*/ 0, /*decltype(_impl_.status_)*/ 0 }
{
}
struct UserConsentTypes_ArcBackupAndRestoreConsentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypes_ArcBackupAndRestoreConsentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypes_ArcBackupAndRestoreConsentDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes_ArcBackupAndRestoreConsent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypes_ArcBackupAndRestoreConsentDefaultTypeInternal
    _UserConsentTypes_ArcBackupAndRestoreConsent_default_instance_;
PROTOBUF_CONSTEXPR UserConsentTypes_ArcGoogleLocationServiceConsent::UserConsentTypes_ArcGoogleLocationServiceConsent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.description_grd_ids_)*/ {},
        /*decltype(_impl_.confirmation_grd_id_)*/ 0, /*decltype(_impl_.status_)*/ 0 }
{
}
struct UserConsentTypes_ArcGoogleLocationServiceConsentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypes_ArcGoogleLocationServiceConsentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypes_ArcGoogleLocationServiceConsentDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes_ArcGoogleLocationServiceConsent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypes_ArcGoogleLocationServiceConsentDefaultTypeInternal
    _UserConsentTypes_ArcGoogleLocationServiceConsent_default_instance_;
PROTOBUF_CONSTEXPR UserConsentTypes_ArcPlayTermsOfServiceConsent::UserConsentTypes_ArcPlayTermsOfServiceConsent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.description_grd_ids_)*/ {},
        /*decltype(_impl_.play_terms_of_service_hash_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.play_terms_of_service_text_length_)*/ 0, /*decltype(_impl_.confirmation_grd_id_)*/ 0, /*decltype(_impl_.status_)*/ 0,
        /*decltype(_impl_.consent_flow_)*/ 1 }
{
}
struct UserConsentTypes_ArcPlayTermsOfServiceConsentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypes_ArcPlayTermsOfServiceConsentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypes_ArcPlayTermsOfServiceConsentDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes_ArcPlayTermsOfServiceConsent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypes_ArcPlayTermsOfServiceConsentDefaultTypeInternal
    _UserConsentTypes_ArcPlayTermsOfServiceConsent_default_instance_;
PROTOBUF_CONSTEXPR UserConsentTypes_SyncConsent::UserConsentTypes_SyncConsent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.description_grd_ids_)*/ {},
        /*decltype(_impl_.confirmation_grd_id_)*/ 0, /*decltype(_impl_.status_)*/ 0 }
{
}
struct UserConsentTypes_SyncConsentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypes_SyncConsentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypes_SyncConsentDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes_SyncConsent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypes_SyncConsentDefaultTypeInternal
    _UserConsentTypes_SyncConsent_default_instance_;
PROTOBUF_CONSTEXPR UserConsentTypes_UnifiedConsent::UserConsentTypes_UnifiedConsent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.description_grd_ids_)*/ {},
        /*decltype(_impl_.confirmation_grd_id_)*/ 0, /*decltype(_impl_.status_)*/ 0 }
{
}
struct UserConsentTypes_UnifiedConsentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypes_UnifiedConsentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypes_UnifiedConsentDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes_UnifiedConsent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypes_UnifiedConsentDefaultTypeInternal
    _UserConsentTypes_UnifiedConsent_default_instance_;
PROTOBUF_CONSTEXPR UserConsentTypes_AssistantActivityControlConsent::UserConsentTypes_AssistantActivityControlConsent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.ui_audit_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.status_)*/ 0,
        /*decltype(_impl_.setting_type_)*/ 0 }
{
}
struct UserConsentTypes_AssistantActivityControlConsentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypes_AssistantActivityControlConsentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypes_AssistantActivityControlConsentDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes_AssistantActivityControlConsent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypes_AssistantActivityControlConsentDefaultTypeInternal
    _UserConsentTypes_AssistantActivityControlConsent_default_instance_;
PROTOBUF_CONSTEXPR UserConsentTypes_AccountPasswordsConsent::UserConsentTypes_AccountPasswordsConsent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.description_grd_ids_)*/ {},
        /*decltype(_impl_.confirmation_grd_id_)*/ 0, /*decltype(_impl_.status_)*/ 0 }
{
}
struct UserConsentTypes_AccountPasswordsConsentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypes_AccountPasswordsConsentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypes_AccountPasswordsConsentDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes_AccountPasswordsConsent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypes_AccountPasswordsConsentDefaultTypeInternal
    _UserConsentTypes_AccountPasswordsConsent_default_instance_;
PROTOBUF_CONSTEXPR UserConsentTypes_RecorderSpeakerLabelConsent::UserConsentTypes_RecorderSpeakerLabelConsent(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.description_grd_ids_)*/ {},
        /*decltype(_impl_.confirmation_grd_id_)*/ 0, /*decltype(_impl_.status_)*/ 0 }
{
}
struct UserConsentTypes_RecorderSpeakerLabelConsentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypes_RecorderSpeakerLabelConsentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypes_RecorderSpeakerLabelConsentDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes_RecorderSpeakerLabelConsent _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypes_RecorderSpeakerLabelConsentDefaultTypeInternal
    _UserConsentTypes_RecorderSpeakerLabelConsent_default_instance_;
PROTOBUF_CONSTEXPR UserConsentTypes::UserConsentTypes(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct UserConsentTypesDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UserConsentTypesDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UserConsentTypesDefaultTypeInternal()
    {
    }
    union {
        UserConsentTypes _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserConsentTypesDefaultTypeInternal _UserConsentTypes_default_instance_;
} // namespace sync_pb
namespace sync_pb {
bool UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_IsValid(int value)
{
    switch (value) {
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_strings[2] = {};

static const char UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_names[] = "SETTING_CHANGE"
                                                                                      "SETUP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_entries[] = {
    { { UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_names + 0, 14 }, 2 },
    { { UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_names + 14, 5 }, 1 },
};

static const int UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_entries_by_number[] = {
    1, // 1 -> SETUP
    0, // 2 -> SETTING_CHANGE
};

const std::string& UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_Name(UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_entries,
        UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_entries_by_number, 2, UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_entries,
        UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_strings[idx].get();
}
bool UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow UserConsentTypes_ArcPlayTermsOfServiceConsent::SETUP;
constexpr UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow UserConsentTypes_ArcPlayTermsOfServiceConsent::SETTING_CHANGE;
constexpr UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow UserConsentTypes_ArcPlayTermsOfServiceConsent::ConsentFlow_MIN;
constexpr UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow UserConsentTypes_ArcPlayTermsOfServiceConsent::ConsentFlow_MAX;
constexpr int UserConsentTypes_ArcPlayTermsOfServiceConsent::ConsentFlow_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UserConsentTypes_AssistantActivityControlConsent_SettingType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserConsentTypes_AssistantActivityControlConsent_SettingType_strings[4] = {};

static const char UserConsentTypes_AssistantActivityControlConsent_SettingType_names[] = "ALL"
                                                                                         "DEVICE_APPS"
                                                                                         "SETTING_TYPE_UNSPECIFIED"
                                                                                         "WEB_AND_APP_ACTIVITY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserConsentTypes_AssistantActivityControlConsent_SettingType_entries[] = {
    { { UserConsentTypes_AssistantActivityControlConsent_SettingType_names + 0, 3 }, 1 },
    { { UserConsentTypes_AssistantActivityControlConsent_SettingType_names + 3, 11 }, 3 },
    { { UserConsentTypes_AssistantActivityControlConsent_SettingType_names + 14, 24 }, 0 },
    { { UserConsentTypes_AssistantActivityControlConsent_SettingType_names + 38, 20 }, 2 },
};

static const int UserConsentTypes_AssistantActivityControlConsent_SettingType_entries_by_number[] = {
    2, // 0 -> SETTING_TYPE_UNSPECIFIED
    0, // 1 -> ALL
    3, // 2 -> WEB_AND_APP_ACTIVITY
    1, // 3 -> DEVICE_APPS
};

const std::string& UserConsentTypes_AssistantActivityControlConsent_SettingType_Name(UserConsentTypes_AssistantActivityControlConsent_SettingType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(UserConsentTypes_AssistantActivityControlConsent_SettingType_entries,
        UserConsentTypes_AssistantActivityControlConsent_SettingType_entries_by_number, 4,
        UserConsentTypes_AssistantActivityControlConsent_SettingType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(UserConsentTypes_AssistantActivityControlConsent_SettingType_entries,
        UserConsentTypes_AssistantActivityControlConsent_SettingType_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UserConsentTypes_AssistantActivityControlConsent_SettingType_strings[idx].get();
}
bool UserConsentTypes_AssistantActivityControlConsent_SettingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserConsentTypes_AssistantActivityControlConsent_SettingType* value)
{
    int int_value;
    bool success
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UserConsentTypes_AssistantActivityControlConsent_SettingType_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<UserConsentTypes_AssistantActivityControlConsent_SettingType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserConsentTypes_AssistantActivityControlConsent_SettingType UserConsentTypes_AssistantActivityControlConsent::SETTING_TYPE_UNSPECIFIED;
constexpr UserConsentTypes_AssistantActivityControlConsent_SettingType UserConsentTypes_AssistantActivityControlConsent::ALL;
constexpr UserConsentTypes_AssistantActivityControlConsent_SettingType UserConsentTypes_AssistantActivityControlConsent::WEB_AND_APP_ACTIVITY;
constexpr UserConsentTypes_AssistantActivityControlConsent_SettingType UserConsentTypes_AssistantActivityControlConsent::DEVICE_APPS;
constexpr UserConsentTypes_AssistantActivityControlConsent_SettingType UserConsentTypes_AssistantActivityControlConsent::SettingType_MIN;
constexpr UserConsentTypes_AssistantActivityControlConsent_SettingType UserConsentTypes_AssistantActivityControlConsent::SettingType_MAX;
constexpr int UserConsentTypes_AssistantActivityControlConsent::SettingType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool UserConsentTypes_ConsentStatus_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UserConsentTypes_ConsentStatus_strings[3] = {};

static const char UserConsentTypes_ConsentStatus_names[] = "CONSENT_STATUS_UNSPECIFIED"
                                                           "GIVEN"
                                                           "NOT_GIVEN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UserConsentTypes_ConsentStatus_entries[] = {
    { { UserConsentTypes_ConsentStatus_names + 0, 26 }, 0 },
    { { UserConsentTypes_ConsentStatus_names + 26, 5 }, 2 },
    { { UserConsentTypes_ConsentStatus_names + 31, 9 }, 1 },
};

static const int UserConsentTypes_ConsentStatus_entries_by_number[] = {
    0, // 0 -> CONSENT_STATUS_UNSPECIFIED
    2, // 1 -> NOT_GIVEN
    1, // 2 -> GIVEN
};

const std::string& UserConsentTypes_ConsentStatus_Name(UserConsentTypes_ConsentStatus value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        UserConsentTypes_ConsentStatus_entries, UserConsentTypes_ConsentStatus_entries_by_number, 3, UserConsentTypes_ConsentStatus_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(UserConsentTypes_ConsentStatus_entries, UserConsentTypes_ConsentStatus_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UserConsentTypes_ConsentStatus_strings[idx].get();
}
bool UserConsentTypes_ConsentStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UserConsentTypes_ConsentStatus* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UserConsentTypes_ConsentStatus_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<UserConsentTypes_ConsentStatus>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr UserConsentTypes_ConsentStatus UserConsentTypes::CONSENT_STATUS_UNSPECIFIED;
constexpr UserConsentTypes_ConsentStatus UserConsentTypes::NOT_GIVEN;
constexpr UserConsentTypes_ConsentStatus UserConsentTypes::GIVEN;
constexpr UserConsentTypes_ConsentStatus UserConsentTypes::ConsentStatus_MIN;
constexpr UserConsentTypes_ConsentStatus UserConsentTypes::ConsentStatus_MAX;
constexpr int UserConsentTypes::ConsentStatus_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class UserConsentTypes_ArcBackupAndRestoreConsent::_Internal {
public:
    using HasBits = decltype(std::declval<UserConsentTypes_ArcBackupAndRestoreConsent>()._impl_._has_bits_);
    static void set_has_confirmation_grd_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

UserConsentTypes_ArcBackupAndRestoreConsent::UserConsentTypes_ArcBackupAndRestoreConsent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
}
UserConsentTypes_ArcBackupAndRestoreConsent::UserConsentTypes_ArcBackupAndRestoreConsent(const UserConsentTypes_ArcBackupAndRestoreConsent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes_ArcBackupAndRestoreConsent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.description_grd_ids_) { from._impl_.description_grd_ids_ }, decltype(_impl_.confirmation_grd_id_) {}, decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.confirmation_grd_id_, &from._impl_.confirmation_grd_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
}

inline void UserConsentTypes_ArcBackupAndRestoreConsent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_grd_ids_) { arena },
        decltype(_impl_.confirmation_grd_id_) { 0 }, decltype(_impl_.status_) { 0 } };
}

UserConsentTypes_ArcBackupAndRestoreConsent::~UserConsentTypes_ArcBackupAndRestoreConsent()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes_ArcBackupAndRestoreConsent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.description_grd_ids_.~RepeatedField();
}

void UserConsentTypes_ArcBackupAndRestoreConsent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes_ArcBackupAndRestoreConsent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.description_grd_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.confirmation_grd_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes_ArcBackupAndRestoreConsent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 description_grd_ids = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_description_grd_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_description_grd_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 confirmation_grd_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_confirmation_grd_id(&has_bits);
                _impl_.confirmation_grd_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ConsentStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::UserConsentTypes_ConsentStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes_ArcBackupAndRestoreConsent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    for (int i = 0, n = this->_internal_description_grd_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_description_grd_ids(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 confirmation_grd_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_confirmation_grd_id(), target);
    }

    // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_status(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
    return target;
}

size_t UserConsentTypes_ArcBackupAndRestoreConsent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.description_grd_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_description_grd_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 confirmation_grd_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_confirmation_grd_id());
        }

        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes_ArcBackupAndRestoreConsent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes_ArcBackupAndRestoreConsent*>(&from));
}

void UserConsentTypes_ArcBackupAndRestoreConsent::MergeFrom(const UserConsentTypes_ArcBackupAndRestoreConsent& from)
{
    UserConsentTypes_ArcBackupAndRestoreConsent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.description_grd_ids_.MergeFrom(from._impl_.description_grd_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.confirmation_grd_id_ = from._impl_.confirmation_grd_id_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes_ArcBackupAndRestoreConsent::CopyFrom(const UserConsentTypes_ArcBackupAndRestoreConsent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes_ArcBackupAndRestoreConsent::IsInitialized() const
{
    return true;
}

void UserConsentTypes_ArcBackupAndRestoreConsent::InternalSwap(UserConsentTypes_ArcBackupAndRestoreConsent* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.description_grd_ids_.InternalSwap(&other->_impl_.description_grd_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserConsentTypes_ArcBackupAndRestoreConsent, _impl_.status_)
        + sizeof(UserConsentTypes_ArcBackupAndRestoreConsent::_impl_.status_)
        - PROTOBUF_FIELD_OFFSET(UserConsentTypes_ArcBackupAndRestoreConsent, _impl_.confirmation_grd_id_)>(
        reinterpret_cast<char*>(&_impl_.confirmation_grd_id_), reinterpret_cast<char*>(&other->_impl_.confirmation_grd_id_));
}

std::string UserConsentTypes_ArcBackupAndRestoreConsent::GetTypeName() const
{
    return "sync_pb.UserConsentTypes.ArcBackupAndRestoreConsent";
}

// ===================================================================

class UserConsentTypes_ArcGoogleLocationServiceConsent::_Internal {
public:
    using HasBits = decltype(std::declval<UserConsentTypes_ArcGoogleLocationServiceConsent>()._impl_._has_bits_);
    static void set_has_confirmation_grd_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

UserConsentTypes_ArcGoogleLocationServiceConsent::UserConsentTypes_ArcGoogleLocationServiceConsent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
}
UserConsentTypes_ArcGoogleLocationServiceConsent::UserConsentTypes_ArcGoogleLocationServiceConsent(const UserConsentTypes_ArcGoogleLocationServiceConsent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes_ArcGoogleLocationServiceConsent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.description_grd_ids_) { from._impl_.description_grd_ids_ }, decltype(_impl_.confirmation_grd_id_) {}, decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.confirmation_grd_id_, &from._impl_.confirmation_grd_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
}

inline void UserConsentTypes_ArcGoogleLocationServiceConsent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_grd_ids_) { arena },
        decltype(_impl_.confirmation_grd_id_) { 0 }, decltype(_impl_.status_) { 0 } };
}

UserConsentTypes_ArcGoogleLocationServiceConsent::~UserConsentTypes_ArcGoogleLocationServiceConsent()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes_ArcGoogleLocationServiceConsent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.description_grd_ids_.~RepeatedField();
}

void UserConsentTypes_ArcGoogleLocationServiceConsent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes_ArcGoogleLocationServiceConsent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.description_grd_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.confirmation_grd_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes_ArcGoogleLocationServiceConsent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 description_grd_ids = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_description_grd_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_description_grd_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 confirmation_grd_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_confirmation_grd_id(&has_bits);
                _impl_.confirmation_grd_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ConsentStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::UserConsentTypes_ConsentStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes_ArcGoogleLocationServiceConsent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    for (int i = 0, n = this->_internal_description_grd_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_description_grd_ids(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 confirmation_grd_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_confirmation_grd_id(), target);
    }

    // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_status(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
    return target;
}

size_t UserConsentTypes_ArcGoogleLocationServiceConsent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.description_grd_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_description_grd_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 confirmation_grd_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_confirmation_grd_id());
        }

        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes_ArcGoogleLocationServiceConsent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes_ArcGoogleLocationServiceConsent*>(&from));
}

void UserConsentTypes_ArcGoogleLocationServiceConsent::MergeFrom(const UserConsentTypes_ArcGoogleLocationServiceConsent& from)
{
    UserConsentTypes_ArcGoogleLocationServiceConsent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.description_grd_ids_.MergeFrom(from._impl_.description_grd_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.confirmation_grd_id_ = from._impl_.confirmation_grd_id_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes_ArcGoogleLocationServiceConsent::CopyFrom(const UserConsentTypes_ArcGoogleLocationServiceConsent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes_ArcGoogleLocationServiceConsent::IsInitialized() const
{
    return true;
}

void UserConsentTypes_ArcGoogleLocationServiceConsent::InternalSwap(UserConsentTypes_ArcGoogleLocationServiceConsent* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.description_grd_ids_.InternalSwap(&other->_impl_.description_grd_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserConsentTypes_ArcGoogleLocationServiceConsent, _impl_.status_)
        + sizeof(UserConsentTypes_ArcGoogleLocationServiceConsent::_impl_.status_)
        - PROTOBUF_FIELD_OFFSET(UserConsentTypes_ArcGoogleLocationServiceConsent, _impl_.confirmation_grd_id_)>(
        reinterpret_cast<char*>(&_impl_.confirmation_grd_id_), reinterpret_cast<char*>(&other->_impl_.confirmation_grd_id_));
}

std::string UserConsentTypes_ArcGoogleLocationServiceConsent::GetTypeName() const
{
    return "sync_pb.UserConsentTypes.ArcGoogleLocationServiceConsent";
}

// ===================================================================

class UserConsentTypes_ArcPlayTermsOfServiceConsent::_Internal {
public:
    using HasBits = decltype(std::declval<UserConsentTypes_ArcPlayTermsOfServiceConsent>()._impl_._has_bits_);
    static void set_has_play_terms_of_service_text_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_play_terms_of_service_hash(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_confirmation_grd_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_consent_flow(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

UserConsentTypes_ArcPlayTermsOfServiceConsent::UserConsentTypes_ArcPlayTermsOfServiceConsent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
}
UserConsentTypes_ArcPlayTermsOfServiceConsent::UserConsentTypes_ArcPlayTermsOfServiceConsent(const UserConsentTypes_ArcPlayTermsOfServiceConsent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes_ArcPlayTermsOfServiceConsent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.description_grd_ids_) { from._impl_.description_grd_ids_ }, decltype(_impl_.play_terms_of_service_hash_) {},
        decltype(_impl_.play_terms_of_service_text_length_) {}, decltype(_impl_.confirmation_grd_id_) {}, decltype(_impl_.status_) {},
        decltype(_impl_.consent_flow_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.play_terms_of_service_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.play_terms_of_service_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_play_terms_of_service_hash()) {
        _this->_impl_.play_terms_of_service_hash_.Set(from._internal_play_terms_of_service_hash(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.play_terms_of_service_text_length_, &from._impl_.play_terms_of_service_text_length_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.consent_flow_) - reinterpret_cast<char*>(&_impl_.play_terms_of_service_text_length_))
            + sizeof(_impl_.consent_flow_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
}

inline void UserConsentTypes_ArcPlayTermsOfServiceConsent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_grd_ids_) { arena },
        decltype(_impl_.play_terms_of_service_hash_) {}, decltype(_impl_.play_terms_of_service_text_length_) { 0 }, decltype(_impl_.confirmation_grd_id_) { 0 },
        decltype(_impl_.status_) { 0 }, decltype(_impl_.consent_flow_) { 1 } };
    _impl_.play_terms_of_service_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.play_terms_of_service_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserConsentTypes_ArcPlayTermsOfServiceConsent::~UserConsentTypes_ArcPlayTermsOfServiceConsent()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes_ArcPlayTermsOfServiceConsent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.description_grd_ids_.~RepeatedField();
    _impl_.play_terms_of_service_hash_.Destroy();
}

void UserConsentTypes_ArcPlayTermsOfServiceConsent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes_ArcPlayTermsOfServiceConsent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.description_grd_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.play_terms_of_service_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000001eu) {
        ::memset(&_impl_.play_terms_of_service_text_length_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.play_terms_of_service_text_length_))
                + sizeof(_impl_.status_));
        _impl_.consent_flow_ = 1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes_ArcPlayTermsOfServiceConsent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 play_terms_of_service_text_length = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_play_terms_of_service_text_length(&has_bits);
                _impl_.play_terms_of_service_text_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bytes play_terms_of_service_hash = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_play_terms_of_service_hash();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 confirmation_grd_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_confirmation_grd_id(&has_bits);
                _impl_.confirmation_grd_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ConsentStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::UserConsentTypes_ConsentStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated int32 description_grd_ids = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_description_grd_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
            } else if (static_cast<uint8_t>(tag) == 42) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_description_grd_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent.ConsentFlow consent_flow = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow_IsValid(val))) {
                    _internal_set_consent_flow(static_cast<::sync_pb::UserConsentTypes_ArcPlayTermsOfServiceConsent_ConsentFlow>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes_ArcPlayTermsOfServiceConsent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 play_terms_of_service_text_length = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_play_terms_of_service_text_length(), target);
    }

    // optional bytes play_terms_of_service_hash = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_play_terms_of_service_hash(), target);
    }

    // optional int32 confirmation_grd_id = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_confirmation_grd_id(), target);
    }

    // optional .sync_pb.UserConsentTypes.ConsentStatus status = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_status(), target);
    }

    // repeated int32 description_grd_ids = 5;
    for (int i = 0, n = this->_internal_description_grd_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_description_grd_ids(i), target);
    }

    // optional .sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent.ConsentFlow consent_flow = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_consent_flow(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
    return target;
}

size_t UserConsentTypes_ArcPlayTermsOfServiceConsent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 5;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.description_grd_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_description_grd_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional bytes play_terms_of_service_hash = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_play_terms_of_service_hash());
        }

        // optional int32 play_terms_of_service_text_length = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_play_terms_of_service_text_length());
        }

        // optional int32 confirmation_grd_id = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_confirmation_grd_id());
        }

        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }

        // optional .sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent.ConsentFlow consent_flow = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_consent_flow());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes_ArcPlayTermsOfServiceConsent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes_ArcPlayTermsOfServiceConsent*>(&from));
}

void UserConsentTypes_ArcPlayTermsOfServiceConsent::MergeFrom(const UserConsentTypes_ArcPlayTermsOfServiceConsent& from)
{
    UserConsentTypes_ArcPlayTermsOfServiceConsent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.description_grd_ids_.MergeFrom(from._impl_.description_grd_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_play_terms_of_service_hash(from._internal_play_terms_of_service_hash());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.play_terms_of_service_text_length_ = from._impl_.play_terms_of_service_text_length_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.confirmation_grd_id_ = from._impl_.confirmation_grd_id_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.consent_flow_ = from._impl_.consent_flow_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes_ArcPlayTermsOfServiceConsent::CopyFrom(const UserConsentTypes_ArcPlayTermsOfServiceConsent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes_ArcPlayTermsOfServiceConsent::IsInitialized() const
{
    return true;
}

void UserConsentTypes_ArcPlayTermsOfServiceConsent::InternalSwap(UserConsentTypes_ArcPlayTermsOfServiceConsent* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.description_grd_ids_.InternalSwap(&other->_impl_.description_grd_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.play_terms_of_service_hash_, lhs_arena, &other->_impl_.play_terms_of_service_hash_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserConsentTypes_ArcPlayTermsOfServiceConsent, _impl_.status_)
        + sizeof(UserConsentTypes_ArcPlayTermsOfServiceConsent::_impl_.status_)
        - PROTOBUF_FIELD_OFFSET(UserConsentTypes_ArcPlayTermsOfServiceConsent, _impl_.play_terms_of_service_text_length_)>(
        reinterpret_cast<char*>(&_impl_.play_terms_of_service_text_length_), reinterpret_cast<char*>(&other->_impl_.play_terms_of_service_text_length_));
    swap(_impl_.consent_flow_, other->_impl_.consent_flow_);
}

std::string UserConsentTypes_ArcPlayTermsOfServiceConsent::GetTypeName() const
{
    return "sync_pb.UserConsentTypes.ArcPlayTermsOfServiceConsent";
}

// ===================================================================

class UserConsentTypes_SyncConsent::_Internal {
public:
    using HasBits = decltype(std::declval<UserConsentTypes_SyncConsent>()._impl_._has_bits_);
    static void set_has_confirmation_grd_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

UserConsentTypes_SyncConsent::UserConsentTypes_SyncConsent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes.SyncConsent)
}
UserConsentTypes_SyncConsent::UserConsentTypes_SyncConsent(const UserConsentTypes_SyncConsent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes_SyncConsent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.description_grd_ids_) { from._impl_.description_grd_ids_ }, decltype(_impl_.confirmation_grd_id_) {}, decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.confirmation_grd_id_, &from._impl_.confirmation_grd_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes.SyncConsent)
}

inline void UserConsentTypes_SyncConsent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_grd_ids_) { arena },
        decltype(_impl_.confirmation_grd_id_) { 0 }, decltype(_impl_.status_) { 0 } };
}

UserConsentTypes_SyncConsent::~UserConsentTypes_SyncConsent()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes.SyncConsent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes_SyncConsent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.description_grd_ids_.~RepeatedField();
}

void UserConsentTypes_SyncConsent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes_SyncConsent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes.SyncConsent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.description_grd_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.confirmation_grd_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes_SyncConsent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 description_grd_ids = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_description_grd_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_description_grd_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 confirmation_grd_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_confirmation_grd_id(&has_bits);
                _impl_.confirmation_grd_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ConsentStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::UserConsentTypes_ConsentStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes_SyncConsent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes.SyncConsent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    for (int i = 0, n = this->_internal_description_grd_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_description_grd_ids(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 confirmation_grd_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_confirmation_grd_id(), target);
    }

    // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_status(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes.SyncConsent)
    return target;
}

size_t UserConsentTypes_SyncConsent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes.SyncConsent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.description_grd_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_description_grd_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 confirmation_grd_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_confirmation_grd_id());
        }

        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes_SyncConsent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes_SyncConsent*>(&from));
}

void UserConsentTypes_SyncConsent::MergeFrom(const UserConsentTypes_SyncConsent& from)
{
    UserConsentTypes_SyncConsent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes.SyncConsent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.description_grd_ids_.MergeFrom(from._impl_.description_grd_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.confirmation_grd_id_ = from._impl_.confirmation_grd_id_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes_SyncConsent::CopyFrom(const UserConsentTypes_SyncConsent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes.SyncConsent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes_SyncConsent::IsInitialized() const
{
    return true;
}

void UserConsentTypes_SyncConsent::InternalSwap(UserConsentTypes_SyncConsent* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.description_grd_ids_.InternalSwap(&other->_impl_.description_grd_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserConsentTypes_SyncConsent, _impl_.status_)
        + sizeof(UserConsentTypes_SyncConsent::_impl_.status_) - PROTOBUF_FIELD_OFFSET(UserConsentTypes_SyncConsent, _impl_.confirmation_grd_id_)>(
        reinterpret_cast<char*>(&_impl_.confirmation_grd_id_), reinterpret_cast<char*>(&other->_impl_.confirmation_grd_id_));
}

std::string UserConsentTypes_SyncConsent::GetTypeName() const
{
    return "sync_pb.UserConsentTypes.SyncConsent";
}

// ===================================================================

class UserConsentTypes_UnifiedConsent::_Internal {
public:
    using HasBits = decltype(std::declval<UserConsentTypes_UnifiedConsent>()._impl_._has_bits_);
    static void set_has_confirmation_grd_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

UserConsentTypes_UnifiedConsent::UserConsentTypes_UnifiedConsent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes.UnifiedConsent)
}
UserConsentTypes_UnifiedConsent::UserConsentTypes_UnifiedConsent(const UserConsentTypes_UnifiedConsent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes_UnifiedConsent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.description_grd_ids_) { from._impl_.description_grd_ids_ }, decltype(_impl_.confirmation_grd_id_) {}, decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.confirmation_grd_id_, &from._impl_.confirmation_grd_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes.UnifiedConsent)
}

inline void UserConsentTypes_UnifiedConsent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_grd_ids_) { arena },
        decltype(_impl_.confirmation_grd_id_) { 0 }, decltype(_impl_.status_) { 0 } };
}

UserConsentTypes_UnifiedConsent::~UserConsentTypes_UnifiedConsent()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes.UnifiedConsent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes_UnifiedConsent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.description_grd_ids_.~RepeatedField();
}

void UserConsentTypes_UnifiedConsent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes_UnifiedConsent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes.UnifiedConsent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.description_grd_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.confirmation_grd_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes_UnifiedConsent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 description_grd_ids = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_description_grd_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_description_grd_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 confirmation_grd_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_confirmation_grd_id(&has_bits);
                _impl_.confirmation_grd_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ConsentStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::UserConsentTypes_ConsentStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes_UnifiedConsent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes.UnifiedConsent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    for (int i = 0, n = this->_internal_description_grd_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_description_grd_ids(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 confirmation_grd_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_confirmation_grd_id(), target);
    }

    // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_status(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes.UnifiedConsent)
    return target;
}

size_t UserConsentTypes_UnifiedConsent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes.UnifiedConsent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.description_grd_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_description_grd_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 confirmation_grd_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_confirmation_grd_id());
        }

        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes_UnifiedConsent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes_UnifiedConsent*>(&from));
}

void UserConsentTypes_UnifiedConsent::MergeFrom(const UserConsentTypes_UnifiedConsent& from)
{
    UserConsentTypes_UnifiedConsent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes.UnifiedConsent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.description_grd_ids_.MergeFrom(from._impl_.description_grd_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.confirmation_grd_id_ = from._impl_.confirmation_grd_id_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes_UnifiedConsent::CopyFrom(const UserConsentTypes_UnifiedConsent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes.UnifiedConsent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes_UnifiedConsent::IsInitialized() const
{
    return true;
}

void UserConsentTypes_UnifiedConsent::InternalSwap(UserConsentTypes_UnifiedConsent* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.description_grd_ids_.InternalSwap(&other->_impl_.description_grd_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserConsentTypes_UnifiedConsent, _impl_.status_)
        + sizeof(UserConsentTypes_UnifiedConsent::_impl_.status_) - PROTOBUF_FIELD_OFFSET(UserConsentTypes_UnifiedConsent, _impl_.confirmation_grd_id_)>(
        reinterpret_cast<char*>(&_impl_.confirmation_grd_id_), reinterpret_cast<char*>(&other->_impl_.confirmation_grd_id_));
}

std::string UserConsentTypes_UnifiedConsent::GetTypeName() const
{
    return "sync_pb.UserConsentTypes.UnifiedConsent";
}

// ===================================================================

class UserConsentTypes_AssistantActivityControlConsent::_Internal {
public:
    using HasBits = decltype(std::declval<UserConsentTypes_AssistantActivityControlConsent>()._impl_._has_bits_);
    static void set_has_ui_audit_key(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_setting_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

UserConsentTypes_AssistantActivityControlConsent::UserConsentTypes_AssistantActivityControlConsent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
}
UserConsentTypes_AssistantActivityControlConsent::UserConsentTypes_AssistantActivityControlConsent(const UserConsentTypes_AssistantActivityControlConsent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes_AssistantActivityControlConsent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.ui_audit_key_) {},
        decltype(_impl_.status_) {}, decltype(_impl_.setting_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.ui_audit_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ui_audit_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_ui_audit_key()) {
        _this->_impl_.ui_audit_key_.Set(from._internal_ui_audit_key(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.status_, &from._impl_.status_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.setting_type_) - reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.setting_type_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
}

inline void UserConsentTypes_AssistantActivityControlConsent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.ui_audit_key_) {},
        decltype(_impl_.status_) { 0 }, decltype(_impl_.setting_type_) { 0 } };
    _impl_.ui_audit_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ui_audit_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserConsentTypes_AssistantActivityControlConsent::~UserConsentTypes_AssistantActivityControlConsent()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes_AssistantActivityControlConsent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.ui_audit_key_.Destroy();
}

void UserConsentTypes_AssistantActivityControlConsent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes_AssistantActivityControlConsent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.ui_audit_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.status_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.setting_type_) - reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.setting_type_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes_AssistantActivityControlConsent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bytes ui_audit_key = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_ui_audit_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ConsentStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::UserConsentTypes_ConsentStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.AssistantActivityControlConsent.SettingType setting_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_AssistantActivityControlConsent_SettingType_IsValid(val))) {
                    _internal_set_setting_type(static_cast<::sync_pb::UserConsentTypes_AssistantActivityControlConsent_SettingType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes_AssistantActivityControlConsent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bytes ui_audit_key = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_ui_audit_key(), target);
    }

    // optional .sync_pb.UserConsentTypes.ConsentStatus status = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_status(), target);
    }

    // optional .sync_pb.UserConsentTypes.AssistantActivityControlConsent.SettingType setting_type = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_setting_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
    return target;
}

size_t UserConsentTypes_AssistantActivityControlConsent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional bytes ui_audit_key = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_ui_audit_key());
        }

        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }

        // optional .sync_pb.UserConsentTypes.AssistantActivityControlConsent.SettingType setting_type = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_setting_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes_AssistantActivityControlConsent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes_AssistantActivityControlConsent*>(&from));
}

void UserConsentTypes_AssistantActivityControlConsent::MergeFrom(const UserConsentTypes_AssistantActivityControlConsent& from)
{
    UserConsentTypes_AssistantActivityControlConsent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_ui_audit_key(from._internal_ui_audit_key());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.setting_type_ = from._impl_.setting_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes_AssistantActivityControlConsent::CopyFrom(const UserConsentTypes_AssistantActivityControlConsent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes.AssistantActivityControlConsent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes_AssistantActivityControlConsent::IsInitialized() const
{
    return true;
}

void UserConsentTypes_AssistantActivityControlConsent::InternalSwap(UserConsentTypes_AssistantActivityControlConsent* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.ui_audit_key_, lhs_arena, &other->_impl_.ui_audit_key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserConsentTypes_AssistantActivityControlConsent, _impl_.setting_type_)
        + sizeof(UserConsentTypes_AssistantActivityControlConsent::_impl_.setting_type_)
        - PROTOBUF_FIELD_OFFSET(UserConsentTypes_AssistantActivityControlConsent, _impl_.status_)>(
        reinterpret_cast<char*>(&_impl_.status_), reinterpret_cast<char*>(&other->_impl_.status_));
}

std::string UserConsentTypes_AssistantActivityControlConsent::GetTypeName() const
{
    return "sync_pb.UserConsentTypes.AssistantActivityControlConsent";
}

// ===================================================================

class UserConsentTypes_AccountPasswordsConsent::_Internal {
public:
    using HasBits = decltype(std::declval<UserConsentTypes_AccountPasswordsConsent>()._impl_._has_bits_);
    static void set_has_confirmation_grd_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

UserConsentTypes_AccountPasswordsConsent::UserConsentTypes_AccountPasswordsConsent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes.AccountPasswordsConsent)
}
UserConsentTypes_AccountPasswordsConsent::UserConsentTypes_AccountPasswordsConsent(const UserConsentTypes_AccountPasswordsConsent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes_AccountPasswordsConsent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.description_grd_ids_) { from._impl_.description_grd_ids_ }, decltype(_impl_.confirmation_grd_id_) {}, decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.confirmation_grd_id_, &from._impl_.confirmation_grd_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes.AccountPasswordsConsent)
}

inline void UserConsentTypes_AccountPasswordsConsent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_grd_ids_) { arena },
        decltype(_impl_.confirmation_grd_id_) { 0 }, decltype(_impl_.status_) { 0 } };
}

UserConsentTypes_AccountPasswordsConsent::~UserConsentTypes_AccountPasswordsConsent()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes.AccountPasswordsConsent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes_AccountPasswordsConsent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.description_grd_ids_.~RepeatedField();
}

void UserConsentTypes_AccountPasswordsConsent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes_AccountPasswordsConsent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes.AccountPasswordsConsent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.description_grd_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.confirmation_grd_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes_AccountPasswordsConsent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 description_grd_ids = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_description_grd_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_description_grd_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 confirmation_grd_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_confirmation_grd_id(&has_bits);
                _impl_.confirmation_grd_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ConsentStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::UserConsentTypes_ConsentStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes_AccountPasswordsConsent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes.AccountPasswordsConsent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    for (int i = 0, n = this->_internal_description_grd_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_description_grd_ids(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 confirmation_grd_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_confirmation_grd_id(), target);
    }

    // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_status(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes.AccountPasswordsConsent)
    return target;
}

size_t UserConsentTypes_AccountPasswordsConsent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes.AccountPasswordsConsent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.description_grd_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_description_grd_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 confirmation_grd_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_confirmation_grd_id());
        }

        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes_AccountPasswordsConsent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes_AccountPasswordsConsent*>(&from));
}

void UserConsentTypes_AccountPasswordsConsent::MergeFrom(const UserConsentTypes_AccountPasswordsConsent& from)
{
    UserConsentTypes_AccountPasswordsConsent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes.AccountPasswordsConsent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.description_grd_ids_.MergeFrom(from._impl_.description_grd_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.confirmation_grd_id_ = from._impl_.confirmation_grd_id_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes_AccountPasswordsConsent::CopyFrom(const UserConsentTypes_AccountPasswordsConsent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes.AccountPasswordsConsent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes_AccountPasswordsConsent::IsInitialized() const
{
    return true;
}

void UserConsentTypes_AccountPasswordsConsent::InternalSwap(UserConsentTypes_AccountPasswordsConsent* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.description_grd_ids_.InternalSwap(&other->_impl_.description_grd_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserConsentTypes_AccountPasswordsConsent, _impl_.status_)
        + sizeof(UserConsentTypes_AccountPasswordsConsent::_impl_.status_)
        - PROTOBUF_FIELD_OFFSET(UserConsentTypes_AccountPasswordsConsent, _impl_.confirmation_grd_id_)>(
        reinterpret_cast<char*>(&_impl_.confirmation_grd_id_), reinterpret_cast<char*>(&other->_impl_.confirmation_grd_id_));
}

std::string UserConsentTypes_AccountPasswordsConsent::GetTypeName() const
{
    return "sync_pb.UserConsentTypes.AccountPasswordsConsent";
}

// ===================================================================

class UserConsentTypes_RecorderSpeakerLabelConsent::_Internal {
public:
    using HasBits = decltype(std::declval<UserConsentTypes_RecorderSpeakerLabelConsent>()._impl_._has_bits_);
    static void set_has_confirmation_grd_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

UserConsentTypes_RecorderSpeakerLabelConsent::UserConsentTypes_RecorderSpeakerLabelConsent(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
}
UserConsentTypes_RecorderSpeakerLabelConsent::UserConsentTypes_RecorderSpeakerLabelConsent(const UserConsentTypes_RecorderSpeakerLabelConsent& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes_RecorderSpeakerLabelConsent* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.description_grd_ids_) { from._impl_.description_grd_ids_ }, decltype(_impl_.confirmation_grd_id_) {}, decltype(_impl_.status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.confirmation_grd_id_, &from._impl_.confirmation_grd_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
}

inline void UserConsentTypes_RecorderSpeakerLabelConsent::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.description_grd_ids_) { arena },
        decltype(_impl_.confirmation_grd_id_) { 0 }, decltype(_impl_.status_) { 0 } };
}

UserConsentTypes_RecorderSpeakerLabelConsent::~UserConsentTypes_RecorderSpeakerLabelConsent()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes_RecorderSpeakerLabelConsent::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.description_grd_ids_.~RepeatedField();
}

void UserConsentTypes_RecorderSpeakerLabelConsent::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes_RecorderSpeakerLabelConsent::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.description_grd_ids_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        ::memset(&_impl_.confirmation_grd_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_) - reinterpret_cast<char*>(&_impl_.confirmation_grd_id_)) + sizeof(_impl_.status_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes_RecorderSpeakerLabelConsent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 description_grd_ids = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_description_grd_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_description_grd_ids(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 confirmation_grd_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_confirmation_grd_id(&has_bits);
                _impl_.confirmation_grd_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::UserConsentTypes_ConsentStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::UserConsentTypes_ConsentStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes_RecorderSpeakerLabelConsent::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    for (int i = 0, n = this->_internal_description_grd_ids_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_description_grd_ids(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 confirmation_grd_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_confirmation_grd_id(), target);
    }

    // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_status(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
    return target;
}

size_t UserConsentTypes_RecorderSpeakerLabelConsent::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 description_grd_ids = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.description_grd_ids_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_description_grd_ids_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional int32 confirmation_grd_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_confirmation_grd_id());
        }

        // optional .sync_pb.UserConsentTypes.ConsentStatus status = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes_RecorderSpeakerLabelConsent::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes_RecorderSpeakerLabelConsent*>(&from));
}

void UserConsentTypes_RecorderSpeakerLabelConsent::MergeFrom(const UserConsentTypes_RecorderSpeakerLabelConsent& from)
{
    UserConsentTypes_RecorderSpeakerLabelConsent* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.description_grd_ids_.MergeFrom(from._impl_.description_grd_ids_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.confirmation_grd_id_ = from._impl_.confirmation_grd_id_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes_RecorderSpeakerLabelConsent::CopyFrom(const UserConsentTypes_RecorderSpeakerLabelConsent& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes_RecorderSpeakerLabelConsent::IsInitialized() const
{
    return true;
}

void UserConsentTypes_RecorderSpeakerLabelConsent::InternalSwap(UserConsentTypes_RecorderSpeakerLabelConsent* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.description_grd_ids_.InternalSwap(&other->_impl_.description_grd_ids_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UserConsentTypes_RecorderSpeakerLabelConsent, _impl_.status_)
        + sizeof(UserConsentTypes_RecorderSpeakerLabelConsent::_impl_.status_)
        - PROTOBUF_FIELD_OFFSET(UserConsentTypes_RecorderSpeakerLabelConsent, _impl_.confirmation_grd_id_)>(
        reinterpret_cast<char*>(&_impl_.confirmation_grd_id_), reinterpret_cast<char*>(&other->_impl_.confirmation_grd_id_));
}

std::string UserConsentTypes_RecorderSpeakerLabelConsent::GetTypeName() const
{
    return "sync_pb.UserConsentTypes.RecorderSpeakerLabelConsent";
}

// ===================================================================

class UserConsentTypes::_Internal {
public:
};

UserConsentTypes::UserConsentTypes(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.UserConsentTypes)
}
UserConsentTypes::UserConsentTypes(const UserConsentTypes& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UserConsentTypes* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.UserConsentTypes)
}

inline void UserConsentTypes::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

UserConsentTypes::~UserConsentTypes()
{
    // @@protoc_insertion_point(destructor:sync_pb.UserConsentTypes)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UserConsentTypes::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserConsentTypes::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UserConsentTypes::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.UserConsentTypes)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* UserConsentTypes::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UserConsentTypes::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.UserConsentTypes)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.UserConsentTypes)
    return target;
}

size_t UserConsentTypes::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.UserConsentTypes)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UserConsentTypes::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UserConsentTypes*>(&from));
}

void UserConsentTypes::MergeFrom(const UserConsentTypes& from)
{
    UserConsentTypes* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.UserConsentTypes)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UserConsentTypes::CopyFrom(const UserConsentTypes& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.UserConsentTypes)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UserConsentTypes::IsInitialized() const
{
    return true;
}

void UserConsentTypes::InternalSwap(UserConsentTypes* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string UserConsentTypes::GetTypeName() const
{
    return "sync_pb.UserConsentTypes";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes_ArcBackupAndRestoreConsent* Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes_ArcBackupAndRestoreConsent>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes_ArcBackupAndRestoreConsent>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes_ArcGoogleLocationServiceConsent*
Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes_ArcGoogleLocationServiceConsent>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes_ArcGoogleLocationServiceConsent>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes_ArcPlayTermsOfServiceConsent* Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes_ArcPlayTermsOfServiceConsent>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes_ArcPlayTermsOfServiceConsent>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes_SyncConsent* Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes_SyncConsent>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes_SyncConsent>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes_UnifiedConsent* Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes_UnifiedConsent>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes_UnifiedConsent>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes_AssistantActivityControlConsent*
Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes_AssistantActivityControlConsent>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes_AssistantActivityControlConsent>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes_AccountPasswordsConsent* Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes_AccountPasswordsConsent>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes_AccountPasswordsConsent>(arena);
}
template <>
PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes_RecorderSpeakerLabelConsent* Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes_RecorderSpeakerLabelConsent>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes_RecorderSpeakerLabelConsent>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::UserConsentTypes* Arena::CreateMaybeMessage<::sync_pb::UserConsentTypes>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::UserConsentTypes>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
