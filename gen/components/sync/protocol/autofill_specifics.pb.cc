// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/autofill_specifics.proto

#include "components/sync/protocol/autofill_specifics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR AutofillProfileSpecifics::AutofillProfileSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.name_first_)*/ {},
        /*decltype(_impl_.name_middle_)*/ {}, /*decltype(_impl_.name_last_)*/ {}, /*decltype(_impl_.email_address_)*/ {},
        /*decltype(_impl_.phone_home_whole_number_)*/ {}, /*decltype(_impl_.name_full_)*/ {}, /*decltype(_impl_.name_last_first_)*/ {},
        /*decltype(_impl_.name_last_conjunction_)*/ {}, /*decltype(_impl_.name_last_second_)*/ {}, /*decltype(_impl_.name_first_status_)*/ {},
        /*decltype(_impl_.name_middle_status_)*/ {}, /*decltype(_impl_.name_last_status_)*/ {}, /*decltype(_impl_.name_last_first_status_)*/ {},
        /*decltype(_impl_.name_last_conjunction_status_)*/ {}, /*decltype(_impl_.name_last_second_status_)*/ {}, /*decltype(_impl_.name_full_status_)*/ {},
        /*decltype(_impl_.deprecated_label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.company_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_line1_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_line2_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_city_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_state_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_zip_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_country_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.phone_fax_whole_number_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.guid_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.deprecated_origin_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_street_address_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_sorting_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_dependent_locality_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_language_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_thoroughfare_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_thoroughfare_number_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_subpremise_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_apt_num_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_floor_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.profile_label_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_landmark_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_between_streets_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_admin_level_2_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_street_location_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_overflow_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_between_streets_1_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_between_streets_2_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_between_streets_or_landmark_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_overflow_and_landmark_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_apt_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_apt_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_street_location_and_locality_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_home_thoroughfare_number_and_apt_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.alternative_full_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.alternative_given_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.alternative_family_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.use_count_)*/ int64_t { 0 }, /*decltype(_impl_.use_date_)*/ int64_t { 0 },
        /*decltype(_impl_.validity_state_bitfield_)*/ int64_t { 0 }, /*decltype(_impl_.is_client_validity_states_updated_)*/ false,
        /*decltype(_impl_.address_home_city_status_)*/ 0, /*decltype(_impl_.address_home_state_status_)*/ 0, /*decltype(_impl_.address_home_zip_status_)*/ 0,
        /*decltype(_impl_.address_home_country_status_)*/ 0, /*decltype(_impl_.address_home_street_address_status_)*/ 0,
        /*decltype(_impl_.address_home_sorting_code_status_)*/ 0, /*decltype(_impl_.address_home_dependent_locality_status_)*/ 0,
        /*decltype(_impl_.address_home_language_code_status_)*/ 0, /*decltype(_impl_.address_home_thoroughfare_name_status_)*/ 0,
        /*decltype(_impl_.address_home_thoroughfare_number_status_)*/ 0, /*decltype(_impl_.address_home_subpremise_name_status_)*/ 0,
        /*decltype(_impl_.address_home_apt_num_status_)*/ 0, /*decltype(_impl_.address_home_floor_status_)*/ 0,
        /*decltype(_impl_.address_home_landmark_status_)*/ 0, /*decltype(_impl_.address_home_between_streets_status_)*/ 0,
        /*decltype(_impl_.address_home_admin_level_2_status_)*/ 0, /*decltype(_impl_.address_home_street_location_status_)*/ 0,
        /*decltype(_impl_.address_home_overflow_status_)*/ 0, /*decltype(_impl_.address_home_between_streets_1_status_)*/ 0,
        /*decltype(_impl_.address_home_between_streets_2_status_)*/ 0, /*decltype(_impl_.address_home_between_streets_or_landmark_status_)*/ 0,
        /*decltype(_impl_.address_home_overflow_and_landmark_status_)*/ 0, /*decltype(_impl_.address_home_apt_status_)*/ 0,
        /*decltype(_impl_.address_home_apt_type_status_)*/ 0, /*decltype(_impl_.address_home_street_location_and_locality_status_)*/ 0,
        /*decltype(_impl_.address_home_thoroughfare_number_and_apt_status_)*/ 0, /*decltype(_impl_.alternative_full_name_status_)*/ 0,
        /*decltype(_impl_.alternative_given_name_status_)*/ 0, /*decltype(_impl_.alternative_family_name_status_)*/ 0 }
{
}
struct AutofillProfileSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillProfileSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillProfileSpecificsDefaultTypeInternal()
    {
    }
    union {
        AutofillProfileSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillProfileSpecificsDefaultTypeInternal
    _AutofillProfileSpecifics_default_instance_;
PROTOBUF_CONSTEXPR AutofillSpecifics::AutofillSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.usage_timestamp_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.value_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.profile_)*/ nullptr }
{
}
struct AutofillSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillSpecificsDefaultTypeInternal()
    {
    }
    union {
        AutofillSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillSpecificsDefaultTypeInternal _AutofillSpecifics_default_instance_;
PROTOBUF_CONSTEXPR CloudTokenData::CloudTokenData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.suffix_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.art_fife_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.instrument_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.exp_month_)*/ 0,
        /*decltype(_impl_.exp_year_)*/ 0 }
{
}
struct CloudTokenDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CloudTokenDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CloudTokenDataDefaultTypeInternal()
    {
    }
    union {
        CloudTokenData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CloudTokenDataDefaultTypeInternal _CloudTokenData_default_instance_;
PROTOBUF_CONSTEXPR CardBenefit_FlatRateBenefit::CardBenefit_FlatRateBenefit(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CardBenefit_FlatRateBenefitDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CardBenefit_FlatRateBenefitDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CardBenefit_FlatRateBenefitDefaultTypeInternal()
    {
    }
    union {
        CardBenefit_FlatRateBenefit _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CardBenefit_FlatRateBenefitDefaultTypeInternal
    _CardBenefit_FlatRateBenefit_default_instance_;
PROTOBUF_CONSTEXPR CardBenefit_CategoryBenefit::CardBenefit_CategoryBenefit(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.category_benefit_type_)*/ 0 }
{
}
struct CardBenefit_CategoryBenefitDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CardBenefit_CategoryBenefitDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CardBenefit_CategoryBenefitDefaultTypeInternal()
    {
    }
    union {
        CardBenefit_CategoryBenefit _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CardBenefit_CategoryBenefitDefaultTypeInternal
    _CardBenefit_CategoryBenefit_default_instance_;
PROTOBUF_CONSTEXPR CardBenefit_MerchantBenefit::CardBenefit_MerchantBenefit(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.merchant_domain_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CardBenefit_MerchantBenefitDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CardBenefit_MerchantBenefitDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CardBenefit_MerchantBenefitDefaultTypeInternal()
    {
    }
    union {
        CardBenefit_MerchantBenefit _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CardBenefit_MerchantBenefitDefaultTypeInternal
    _CardBenefit_MerchantBenefit_default_instance_;
PROTOBUF_CONSTEXPR CardBenefit::CardBenefit(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.benefit_description_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.benefit_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.start_time_unix_epoch_milliseconds_)*/ int64_t { 0 }, /*decltype(_impl_.end_time_unix_epoch_milliseconds_)*/ int64_t { 0 },
        /*decltype(_impl_.DomainSpecificBenefit_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct CardBenefitDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CardBenefitDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CardBenefitDefaultTypeInternal()
    {
    }
    union {
        CardBenefit _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CardBenefitDefaultTypeInternal _CardBenefit_default_instance_;
PROTOBUF_CONSTEXPR CardIssuer::CardIssuer(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.issuer_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.issuer_)*/ 0 }
{
}
struct CardIssuerDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CardIssuerDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CardIssuerDefaultTypeInternal()
    {
    }
    union {
        CardIssuer _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CardIssuerDefaultTypeInternal _CardIssuer_default_instance_;
PROTOBUF_CONSTEXPR WalletMaskedCreditCard::WalletMaskedCreditCard(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.card_benefit_)*/ {},
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.name_on_card_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.last_four_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.billing_address_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.bank_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.nickname_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.card_art_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.product_description_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.product_terms_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.cloud_token_data_)*/ nullptr, /*decltype(_impl_.card_issuer_)*/ nullptr, /*decltype(_impl_.status_)*/ 0, /*decltype(_impl_.type_)*/ 0,
        /*decltype(_impl_.exp_month_)*/ 0, /*decltype(_impl_.exp_year_)*/ 0, /*decltype(_impl_.instrument_id_)*/ int64_t { 0 },
        /*decltype(_impl_.virtual_card_enrollment_state_)*/ 0, /*decltype(_impl_.virtual_card_enrollment_type_)*/ 0,
        /*decltype(_impl_.card_info_retrieval_enrollment_state_)*/ 0 }
{
}
struct WalletMaskedCreditCardDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WalletMaskedCreditCardDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WalletMaskedCreditCardDefaultTypeInternal()
    {
    }
    union {
        WalletMaskedCreditCard _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WalletMaskedCreditCardDefaultTypeInternal
    _WalletMaskedCreditCard_default_instance_;
PROTOBUF_CONSTEXPR WalletPostalAddress::WalletPostalAddress(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.street_address_)*/ {},
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.company_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_1_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_2_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_3_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.address_4_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.postal_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sorting_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.country_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.language_code_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.recipient_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.phone_number_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct WalletPostalAddressDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WalletPostalAddressDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WalletPostalAddressDefaultTypeInternal()
    {
    }
    union {
        WalletPostalAddress _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WalletPostalAddressDefaultTypeInternal
    _WalletPostalAddress_default_instance_;
PROTOBUF_CONSTEXPR PaymentsCustomerData::PaymentsCustomerData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct PaymentsCustomerDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PaymentsCustomerDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PaymentsCustomerDataDefaultTypeInternal()
    {
    }
    union {
        PaymentsCustomerData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PaymentsCustomerDataDefaultTypeInternal
    _PaymentsCustomerData_default_instance_;
PROTOBUF_CONSTEXPR WalletCreditCardCloudTokenData::WalletCreditCardCloudTokenData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.masked_card_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.suffix_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.art_fife_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.instrument_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.exp_month_)*/ 0,
        /*decltype(_impl_.exp_year_)*/ 0 }
{
}
struct WalletCreditCardCloudTokenDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WalletCreditCardCloudTokenDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WalletCreditCardCloudTokenDataDefaultTypeInternal()
    {
    }
    union {
        WalletCreditCardCloudTokenData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WalletCreditCardCloudTokenDataDefaultTypeInternal
    _WalletCreditCardCloudTokenData_default_instance_;
PROTOBUF_CONSTEXPR PaymentInstrument::PaymentInstrument(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.supported_rails_)*/ {},
        /*decltype(_impl_.display_icon_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.nickname_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.device_details_)*/ nullptr,
        /*decltype(_impl_.instrument_id_)*/ int64_t { 0 }, /*decltype(_impl_.instrument_details_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct PaymentInstrumentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PaymentInstrumentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PaymentInstrumentDefaultTypeInternal()
    {
    }
    union {
        PaymentInstrument _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PaymentInstrumentDefaultTypeInternal _PaymentInstrument_default_instance_;
PROTOBUF_CONSTEXPR BnplIssuerDetails::BnplIssuerDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.eligible_price_range_)*/ {},
        /*decltype(_impl_.issuer_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct BnplIssuerDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BnplIssuerDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BnplIssuerDetailsDefaultTypeInternal()
    {
    }
    union {
        BnplIssuerDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BnplIssuerDetailsDefaultTypeInternal _BnplIssuerDetails_default_instance_;
PROTOBUF_CONSTEXPR PaymentInstrumentCreationOption::PaymentInstrumentCreationOption(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.creation_option_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct PaymentInstrumentCreationOptionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PaymentInstrumentCreationOptionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PaymentInstrumentCreationOptionDefaultTypeInternal()
    {
    }
    union {
        PaymentInstrumentCreationOption _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PaymentInstrumentCreationOptionDefaultTypeInternal
    _PaymentInstrumentCreationOption_default_instance_;
PROTOBUF_CONSTEXPR EligiblePriceRange::EligiblePriceRange(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.currency_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.min_price_in_micros_)*/ int64_t { 0 }, /*decltype(_impl_.max_price_in_micros_)*/ int64_t { 0 } }
{
}
struct EligiblePriceRangeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR EligiblePriceRangeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~EligiblePriceRangeDefaultTypeInternal()
    {
    }
    union {
        EligiblePriceRange _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EligiblePriceRangeDefaultTypeInternal _EligiblePriceRange_default_instance_;
PROTOBUF_CONSTEXPR WalletMaskedIban::WalletMaskedIban(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.instrument_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.prefix_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.suffix_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.nickname_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.length_)*/ 0 }
{
}
struct WalletMaskedIbanDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WalletMaskedIbanDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WalletMaskedIbanDefaultTypeInternal()
    {
    }
    union {
        WalletMaskedIban _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WalletMaskedIbanDefaultTypeInternal _WalletMaskedIban_default_instance_;
PROTOBUF_CONSTEXPR BankAccountDetails::BankAccountDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.bank_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.account_number_suffix_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.account_type_)*/ 0 }
{
}
struct BankAccountDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BankAccountDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BankAccountDetailsDefaultTypeInternal()
    {
    }
    union {
        BankAccountDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BankAccountDetailsDefaultTypeInternal _BankAccountDetails_default_instance_;
PROTOBUF_CONSTEXPR EwalletDetails::EwalletDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.supported_payment_link_uris_)*/ {},
        /*decltype(_impl_.ewallet_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.account_display_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct EwalletDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR EwalletDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~EwalletDetailsDefaultTypeInternal()
    {
    }
    union {
        EwalletDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EwalletDetailsDefaultTypeInternal _EwalletDetails_default_instance_;
PROTOBUF_CONSTEXPR DeviceDetails::DeviceDetails(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.is_fido_enrolled_)*/ false }
{
}
struct DeviceDetailsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DeviceDetailsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DeviceDetailsDefaultTypeInternal()
    {
    }
    union {
        DeviceDetails _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DeviceDetailsDefaultTypeInternal _DeviceDetails_default_instance_;
PROTOBUF_CONSTEXPR AutofillWalletSpecifics::AutofillWalletSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.masked_card_)*/ nullptr,
        /*decltype(_impl_.address_)*/ nullptr, /*decltype(_impl_.customer_data_)*/ nullptr, /*decltype(_impl_.cloud_token_data_)*/ nullptr,
        /*decltype(_impl_.payment_instrument_)*/ nullptr, /*decltype(_impl_.masked_iban_)*/ nullptr,
        /*decltype(_impl_.payment_instrument_creation_option_)*/ nullptr, /*decltype(_impl_.type_)*/ 0 }
{
}
struct AutofillWalletSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AutofillWalletSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AutofillWalletSpecificsDefaultTypeInternal()
    {
    }
    union {
        AutofillWalletSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AutofillWalletSpecificsDefaultTypeInternal
    _AutofillWalletSpecifics_default_instance_;
PROTOBUF_CONSTEXPR WalletMetadataSpecifics::WalletMetadataSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.card_billing_address_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.use_count_)*/ int64_t { 0 }, /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.address_has_converted_)*/ false,
        /*decltype(_impl_.use_date_)*/ int64_t { 0 } }
{
}
struct WalletMetadataSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WalletMetadataSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WalletMetadataSpecificsDefaultTypeInternal()
    {
    }
    union {
        WalletMetadataSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WalletMetadataSpecificsDefaultTypeInternal
    _WalletMetadataSpecifics_default_instance_;
} // namespace sync_pb
namespace sync_pb {
bool AutofillProfileSpecifics_VerificationStatus_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillProfileSpecifics_VerificationStatus_strings[6] = {};

static const char AutofillProfileSpecifics_VerificationStatus_names[] = "FORMATTED"
                                                                        "OBSERVED"
                                                                        "PARSED"
                                                                        "SERVER_PARSED"
                                                                        "USER_VERIFIED"
                                                                        "VERIFICATION_STATUS_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillProfileSpecifics_VerificationStatus_entries[] = {
    { { AutofillProfileSpecifics_VerificationStatus_names + 0, 9 }, 2 },
    { { AutofillProfileSpecifics_VerificationStatus_names + 9, 8 }, 3 },
    { { AutofillProfileSpecifics_VerificationStatus_names + 17, 6 }, 1 },
    { { AutofillProfileSpecifics_VerificationStatus_names + 23, 13 }, 5 },
    { { AutofillProfileSpecifics_VerificationStatus_names + 36, 13 }, 4 },
    { { AutofillProfileSpecifics_VerificationStatus_names + 49, 31 }, 0 },
};

static const int AutofillProfileSpecifics_VerificationStatus_entries_by_number[] = {
    5, // 0 -> VERIFICATION_STATUS_UNSPECIFIED
    2, // 1 -> PARSED
    0, // 2 -> FORMATTED
    1, // 3 -> OBSERVED
    4, // 4 -> USER_VERIFIED
    3, // 5 -> SERVER_PARSED
};

const std::string& AutofillProfileSpecifics_VerificationStatus_Name(AutofillProfileSpecifics_VerificationStatus value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AutofillProfileSpecifics_VerificationStatus_entries,
        AutofillProfileSpecifics_VerificationStatus_entries_by_number, 6, AutofillProfileSpecifics_VerificationStatus_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillProfileSpecifics_VerificationStatus_entries, AutofillProfileSpecifics_VerificationStatus_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillProfileSpecifics_VerificationStatus_strings[idx].get();
}
bool AutofillProfileSpecifics_VerificationStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillProfileSpecifics_VerificationStatus* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillProfileSpecifics_VerificationStatus_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<AutofillProfileSpecifics_VerificationStatus>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillProfileSpecifics_VerificationStatus AutofillProfileSpecifics::VERIFICATION_STATUS_UNSPECIFIED;
constexpr AutofillProfileSpecifics_VerificationStatus AutofillProfileSpecifics::PARSED;
constexpr AutofillProfileSpecifics_VerificationStatus AutofillProfileSpecifics::FORMATTED;
constexpr AutofillProfileSpecifics_VerificationStatus AutofillProfileSpecifics::OBSERVED;
constexpr AutofillProfileSpecifics_VerificationStatus AutofillProfileSpecifics::USER_VERIFIED;
constexpr AutofillProfileSpecifics_VerificationStatus AutofillProfileSpecifics::SERVER_PARSED;
constexpr AutofillProfileSpecifics_VerificationStatus AutofillProfileSpecifics::VerificationStatus_MIN;
constexpr AutofillProfileSpecifics_VerificationStatus AutofillProfileSpecifics::VerificationStatus_MAX;
constexpr int AutofillProfileSpecifics::VerificationStatus_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CardBenefit_CategoryBenefitType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CardBenefit_CategoryBenefitType_strings[7] = {};

static const char CardBenefit_CategoryBenefitType_names[] = "CATEGORY_BENEFIT_TYPE_UNKNOWN"
                                                            "DINING"
                                                            "ENTERTAINMENT"
                                                            "FLIGHTS"
                                                            "GROCERY_STORES"
                                                            "STREAMING"
                                                            "SUBSCRIPTION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CardBenefit_CategoryBenefitType_entries[] = {
    { { CardBenefit_CategoryBenefitType_names + 0, 29 }, 0 },
    { { CardBenefit_CategoryBenefitType_names + 29, 6 }, 3 },
    { { CardBenefit_CategoryBenefitType_names + 35, 13 }, 4 },
    { { CardBenefit_CategoryBenefitType_names + 48, 7 }, 2 },
    { { CardBenefit_CategoryBenefitType_names + 55, 14 }, 6 },
    { { CardBenefit_CategoryBenefitType_names + 69, 9 }, 5 },
    { { CardBenefit_CategoryBenefitType_names + 78, 12 }, 1 },
};

static const int CardBenefit_CategoryBenefitType_entries_by_number[] = {
    0, // 0 -> CATEGORY_BENEFIT_TYPE_UNKNOWN
    6, // 1 -> SUBSCRIPTION
    3, // 2 -> FLIGHTS
    1, // 3 -> DINING
    2, // 4 -> ENTERTAINMENT
    5, // 5 -> STREAMING
    4, // 6 -> GROCERY_STORES
};

const std::string& CardBenefit_CategoryBenefitType_Name(CardBenefit_CategoryBenefitType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        CardBenefit_CategoryBenefitType_entries, CardBenefit_CategoryBenefitType_entries_by_number, 7, CardBenefit_CategoryBenefitType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        CardBenefit_CategoryBenefitType_entries, CardBenefit_CategoryBenefitType_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : CardBenefit_CategoryBenefitType_strings[idx].get();
}
bool CardBenefit_CategoryBenefitType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CardBenefit_CategoryBenefitType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(CardBenefit_CategoryBenefitType_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<CardBenefit_CategoryBenefitType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CardBenefit_CategoryBenefitType CardBenefit::CATEGORY_BENEFIT_TYPE_UNKNOWN;
constexpr CardBenefit_CategoryBenefitType CardBenefit::SUBSCRIPTION;
constexpr CardBenefit_CategoryBenefitType CardBenefit::FLIGHTS;
constexpr CardBenefit_CategoryBenefitType CardBenefit::DINING;
constexpr CardBenefit_CategoryBenefitType CardBenefit::ENTERTAINMENT;
constexpr CardBenefit_CategoryBenefitType CardBenefit::STREAMING;
constexpr CardBenefit_CategoryBenefitType CardBenefit::GROCERY_STORES;
constexpr CardBenefit_CategoryBenefitType CardBenefit::CategoryBenefitType_MIN;
constexpr CardBenefit_CategoryBenefitType CardBenefit::CategoryBenefitType_MAX;
constexpr int CardBenefit::CategoryBenefitType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CardIssuer_Issuer_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CardIssuer_Issuer_strings[3] = {};

static const char CardIssuer_Issuer_names[] = "EXTERNAL_ISSUER"
                                              "GOOGLE"
                                              "ISSUER_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CardIssuer_Issuer_entries[] = {
    { { CardIssuer_Issuer_names + 0, 15 }, 2 },
    { { CardIssuer_Issuer_names + 15, 6 }, 1 },
    { { CardIssuer_Issuer_names + 21, 14 }, 0 },
};

static const int CardIssuer_Issuer_entries_by_number[] = {
    2, // 0 -> ISSUER_UNKNOWN
    1, // 1 -> GOOGLE
    0, // 2 -> EXTERNAL_ISSUER
};

const std::string& CardIssuer_Issuer_Name(CardIssuer_Issuer value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        CardIssuer_Issuer_entries, CardIssuer_Issuer_entries_by_number, 3, CardIssuer_Issuer_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(CardIssuer_Issuer_entries, CardIssuer_Issuer_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : CardIssuer_Issuer_strings[idx].get();
}
bool CardIssuer_Issuer_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CardIssuer_Issuer* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(CardIssuer_Issuer_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<CardIssuer_Issuer>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CardIssuer_Issuer CardIssuer::ISSUER_UNKNOWN;
constexpr CardIssuer_Issuer CardIssuer::GOOGLE;
constexpr CardIssuer_Issuer CardIssuer::EXTERNAL_ISSUER;
constexpr CardIssuer_Issuer CardIssuer::Issuer_MIN;
constexpr CardIssuer_Issuer CardIssuer::Issuer_MAX;
constexpr int CardIssuer::Issuer_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WalletMaskedCreditCard_WalletCardStatus_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WalletMaskedCreditCard_WalletCardStatus_strings[2] = {};

static const char WalletMaskedCreditCard_WalletCardStatus_names[] = "EXPIRED"
                                                                    "VALID";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WalletMaskedCreditCard_WalletCardStatus_entries[] = {
    { { WalletMaskedCreditCard_WalletCardStatus_names + 0, 7 }, 1 },
    { { WalletMaskedCreditCard_WalletCardStatus_names + 7, 5 }, 0 },
};

static const int WalletMaskedCreditCard_WalletCardStatus_entries_by_number[] = {
    1, // 0 -> VALID
    0, // 1 -> EXPIRED
};

const std::string& WalletMaskedCreditCard_WalletCardStatus_Name(WalletMaskedCreditCard_WalletCardStatus value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(WalletMaskedCreditCard_WalletCardStatus_entries,
        WalletMaskedCreditCard_WalletCardStatus_entries_by_number, 2, WalletMaskedCreditCard_WalletCardStatus_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        WalletMaskedCreditCard_WalletCardStatus_entries, WalletMaskedCreditCard_WalletCardStatus_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WalletMaskedCreditCard_WalletCardStatus_strings[idx].get();
}
bool WalletMaskedCreditCard_WalletCardStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WalletMaskedCreditCard_WalletCardStatus* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WalletMaskedCreditCard_WalletCardStatus_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<WalletMaskedCreditCard_WalletCardStatus>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WalletMaskedCreditCard_WalletCardStatus WalletMaskedCreditCard::VALID;
constexpr WalletMaskedCreditCard_WalletCardStatus WalletMaskedCreditCard::EXPIRED;
constexpr WalletMaskedCreditCard_WalletCardStatus WalletMaskedCreditCard::WalletCardStatus_MIN;
constexpr WalletMaskedCreditCard_WalletCardStatus WalletMaskedCreditCard::WalletCardStatus_MAX;
constexpr int WalletMaskedCreditCard::WalletCardStatus_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WalletMaskedCreditCard_WalletCardType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WalletMaskedCreditCard_WalletCardType_strings[12] = {};

static const char WalletMaskedCreditCard_WalletCardType_names[] = "AMEX"
                                                                  "DISCOVER"
                                                                  "ELO"
                                                                  "JCB"
                                                                  "MAESTRO"
                                                                  "MASTER_CARD"
                                                                  "SOLO"
                                                                  "SWITCH"
                                                                  "UNIONPAY"
                                                                  "UNKNOWN"
                                                                  "VERVE"
                                                                  "VISA";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WalletMaskedCreditCard_WalletCardType_entries[] = {
    { { WalletMaskedCreditCard_WalletCardType_names + 0, 4 }, 1 },
    { { WalletMaskedCreditCard_WalletCardType_names + 4, 8 }, 2 },
    { { WalletMaskedCreditCard_WalletCardType_names + 12, 3 }, 10 },
    { { WalletMaskedCreditCard_WalletCardType_names + 15, 3 }, 3 },
    { { WalletMaskedCreditCard_WalletCardType_names + 18, 7 }, 4 },
    { { WalletMaskedCreditCard_WalletCardType_names + 25, 11 }, 5 },
    { { WalletMaskedCreditCard_WalletCardType_names + 36, 4 }, 6 },
    { { WalletMaskedCreditCard_WalletCardType_names + 40, 6 }, 7 },
    { { WalletMaskedCreditCard_WalletCardType_names + 46, 8 }, 9 },
    { { WalletMaskedCreditCard_WalletCardType_names + 54, 7 }, 0 },
    { { WalletMaskedCreditCard_WalletCardType_names + 61, 5 }, 11 },
    { { WalletMaskedCreditCard_WalletCardType_names + 66, 4 }, 8 },
};

static const int WalletMaskedCreditCard_WalletCardType_entries_by_number[] = {
    9, // 0 -> UNKNOWN
    0, // 1 -> AMEX
    1, // 2 -> DISCOVER
    3, // 3 -> JCB
    4, // 4 -> MAESTRO
    5, // 5 -> MASTER_CARD
    6, // 6 -> SOLO
    7, // 7 -> SWITCH
    11, // 8 -> VISA
    8, // 9 -> UNIONPAY
    2, // 10 -> ELO
    10, // 11 -> VERVE
};

const std::string& WalletMaskedCreditCard_WalletCardType_Name(WalletMaskedCreditCard_WalletCardType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(WalletMaskedCreditCard_WalletCardType_entries,
        WalletMaskedCreditCard_WalletCardType_entries_by_number, 12, WalletMaskedCreditCard_WalletCardType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        WalletMaskedCreditCard_WalletCardType_entries, WalletMaskedCreditCard_WalletCardType_entries_by_number, 12, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WalletMaskedCreditCard_WalletCardType_strings[idx].get();
}
bool WalletMaskedCreditCard_WalletCardType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WalletMaskedCreditCard_WalletCardType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WalletMaskedCreditCard_WalletCardType_entries, 12, name, &int_value);
    if (success) {
        *value = static_cast<WalletMaskedCreditCard_WalletCardType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::UNKNOWN;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::AMEX;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::DISCOVER;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::JCB;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::MAESTRO;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::MASTER_CARD;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::SOLO;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::SWITCH;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::VISA;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::UNIONPAY;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::ELO;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::VERVE;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::WalletCardType_MIN;
constexpr WalletMaskedCreditCard_WalletCardType WalletMaskedCreditCard::WalletCardType_MAX;
constexpr int WalletMaskedCreditCard::WalletCardType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WalletMaskedCreditCard_VirtualCardEnrollmentState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WalletMaskedCreditCard_VirtualCardEnrollmentState_strings[5] = {};

static const char WalletMaskedCreditCard_VirtualCardEnrollmentState_names[] = "ENROLLED"
                                                                              "UNENROLLED"
                                                                              "UNENROLLED_AND_ELIGIBLE"
                                                                              "UNENROLLED_AND_NOT_ELIGIBLE"
                                                                              "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WalletMaskedCreditCard_VirtualCardEnrollmentState_entries[] = {
    { { WalletMaskedCreditCard_VirtualCardEnrollmentState_names + 0, 8 }, 2 },
    { { WalletMaskedCreditCard_VirtualCardEnrollmentState_names + 8, 10 }, 1 },
    { { WalletMaskedCreditCard_VirtualCardEnrollmentState_names + 18, 23 }, 4 },
    { { WalletMaskedCreditCard_VirtualCardEnrollmentState_names + 41, 27 }, 3 },
    { { WalletMaskedCreditCard_VirtualCardEnrollmentState_names + 68, 11 }, 0 },
};

static const int WalletMaskedCreditCard_VirtualCardEnrollmentState_entries_by_number[] = {
    4, // 0 -> UNSPECIFIED
    1, // 1 -> UNENROLLED
    0, // 2 -> ENROLLED
    3, // 3 -> UNENROLLED_AND_NOT_ELIGIBLE
    2, // 4 -> UNENROLLED_AND_ELIGIBLE
};

const std::string& WalletMaskedCreditCard_VirtualCardEnrollmentState_Name(WalletMaskedCreditCard_VirtualCardEnrollmentState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(WalletMaskedCreditCard_VirtualCardEnrollmentState_entries,
        WalletMaskedCreditCard_VirtualCardEnrollmentState_entries_by_number, 5, WalletMaskedCreditCard_VirtualCardEnrollmentState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        WalletMaskedCreditCard_VirtualCardEnrollmentState_entries, WalletMaskedCreditCard_VirtualCardEnrollmentState_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WalletMaskedCreditCard_VirtualCardEnrollmentState_strings[idx].get();
}
bool WalletMaskedCreditCard_VirtualCardEnrollmentState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WalletMaskedCreditCard_VirtualCardEnrollmentState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WalletMaskedCreditCard_VirtualCardEnrollmentState_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<WalletMaskedCreditCard_VirtualCardEnrollmentState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentState WalletMaskedCreditCard::UNSPECIFIED;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentState WalletMaskedCreditCard::UNENROLLED;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentState WalletMaskedCreditCard::ENROLLED;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentState WalletMaskedCreditCard::UNENROLLED_AND_NOT_ELIGIBLE;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentState WalletMaskedCreditCard::UNENROLLED_AND_ELIGIBLE;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentState WalletMaskedCreditCard::VirtualCardEnrollmentState_MIN;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentState WalletMaskedCreditCard::VirtualCardEnrollmentState_MAX;
constexpr int WalletMaskedCreditCard::VirtualCardEnrollmentState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WalletMaskedCreditCard_VirtualCardEnrollmentType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WalletMaskedCreditCard_VirtualCardEnrollmentType_strings[3] = {};

static const char WalletMaskedCreditCard_VirtualCardEnrollmentType_names[] = "ISSUER"
                                                                             "NETWORK"
                                                                             "TYPE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WalletMaskedCreditCard_VirtualCardEnrollmentType_entries[] = {
    { { WalletMaskedCreditCard_VirtualCardEnrollmentType_names + 0, 6 }, 1 },
    { { WalletMaskedCreditCard_VirtualCardEnrollmentType_names + 6, 7 }, 2 },
    { { WalletMaskedCreditCard_VirtualCardEnrollmentType_names + 13, 16 }, 0 },
};

static const int WalletMaskedCreditCard_VirtualCardEnrollmentType_entries_by_number[] = {
    2, // 0 -> TYPE_UNSPECIFIED
    0, // 1 -> ISSUER
    1, // 2 -> NETWORK
};

const std::string& WalletMaskedCreditCard_VirtualCardEnrollmentType_Name(WalletMaskedCreditCard_VirtualCardEnrollmentType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(WalletMaskedCreditCard_VirtualCardEnrollmentType_entries,
        WalletMaskedCreditCard_VirtualCardEnrollmentType_entries_by_number, 3, WalletMaskedCreditCard_VirtualCardEnrollmentType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        WalletMaskedCreditCard_VirtualCardEnrollmentType_entries, WalletMaskedCreditCard_VirtualCardEnrollmentType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WalletMaskedCreditCard_VirtualCardEnrollmentType_strings[idx].get();
}
bool WalletMaskedCreditCard_VirtualCardEnrollmentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WalletMaskedCreditCard_VirtualCardEnrollmentType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WalletMaskedCreditCard_VirtualCardEnrollmentType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<WalletMaskedCreditCard_VirtualCardEnrollmentType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentType WalletMaskedCreditCard::TYPE_UNSPECIFIED;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentType WalletMaskedCreditCard::ISSUER;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentType WalletMaskedCreditCard::NETWORK;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentType WalletMaskedCreditCard::VirtualCardEnrollmentType_MIN;
constexpr WalletMaskedCreditCard_VirtualCardEnrollmentType WalletMaskedCreditCard::VirtualCardEnrollmentType_MAX;
constexpr int WalletMaskedCreditCard::VirtualCardEnrollmentType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_strings[4] = {};

static const char WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_names[] = "RETRIEVAL_ENROLLED"
                                                                                    "RETRIEVAL_UNENROLLED_AND_ELIGIBLE"
                                                                                    "RETRIEVAL_UNENROLLED_AND_NOT_ELIGIBLE"
                                                                                    "RETRIEVAL_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_entries[] = {
    { { WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_names + 0, 18 }, 1 },
    { { WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_names + 18, 33 }, 3 },
    { { WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_names + 51, 37 }, 2 },
    { { WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_names + 88, 21 }, 0 },
};

static const int WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_entries_by_number[] = {
    3, // 0 -> RETRIEVAL_UNSPECIFIED
    0, // 1 -> RETRIEVAL_ENROLLED
    2, // 2 -> RETRIEVAL_UNENROLLED_AND_NOT_ELIGIBLE
    1, // 3 -> RETRIEVAL_UNENROLLED_AND_ELIGIBLE
};

const std::string& WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_Name(WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_entries,
        WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_entries_by_number, 4, WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_entries, WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_strings[idx].get();
}
bool WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState WalletMaskedCreditCard::RETRIEVAL_UNSPECIFIED;
constexpr WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState WalletMaskedCreditCard::RETRIEVAL_ENROLLED;
constexpr WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState WalletMaskedCreditCard::RETRIEVAL_UNENROLLED_AND_NOT_ELIGIBLE;
constexpr WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState WalletMaskedCreditCard::RETRIEVAL_UNENROLLED_AND_ELIGIBLE;
constexpr WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState WalletMaskedCreditCard::CardInfoRetrievalEnrollmentState_MIN;
constexpr WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState WalletMaskedCreditCard::CardInfoRetrievalEnrollmentState_MAX;
constexpr int WalletMaskedCreditCard::CardInfoRetrievalEnrollmentState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PaymentInstrument_SupportedRail_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PaymentInstrument_SupportedRail_strings[5] = {};

static const char PaymentInstrument_SupportedRail_names[] = "CARD_NUMBER"
                                                            "IBAN"
                                                            "PAYMENT_HYPERLINK"
                                                            "PIX"
                                                            "SUPPORTED_RAIL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PaymentInstrument_SupportedRail_entries[] = {
    { { PaymentInstrument_SupportedRail_names + 0, 11 }, 4 },
    { { PaymentInstrument_SupportedRail_names + 11, 4 }, 2 },
    { { PaymentInstrument_SupportedRail_names + 15, 17 }, 3 },
    { { PaymentInstrument_SupportedRail_names + 32, 3 }, 1 },
    { { PaymentInstrument_SupportedRail_names + 35, 22 }, 0 },
};

static const int PaymentInstrument_SupportedRail_entries_by_number[] = {
    4, // 0 -> SUPPORTED_RAIL_UNKNOWN
    3, // 1 -> PIX
    1, // 2 -> IBAN
    2, // 3 -> PAYMENT_HYPERLINK
    0, // 4 -> CARD_NUMBER
};

const std::string& PaymentInstrument_SupportedRail_Name(PaymentInstrument_SupportedRail value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        PaymentInstrument_SupportedRail_entries, PaymentInstrument_SupportedRail_entries_by_number, 5, PaymentInstrument_SupportedRail_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        PaymentInstrument_SupportedRail_entries, PaymentInstrument_SupportedRail_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : PaymentInstrument_SupportedRail_strings[idx].get();
}
bool PaymentInstrument_SupportedRail_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaymentInstrument_SupportedRail* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(PaymentInstrument_SupportedRail_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<PaymentInstrument_SupportedRail>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PaymentInstrument_SupportedRail PaymentInstrument::SUPPORTED_RAIL_UNKNOWN;
constexpr PaymentInstrument_SupportedRail PaymentInstrument::PIX;
constexpr PaymentInstrument_SupportedRail PaymentInstrument::IBAN;
constexpr PaymentInstrument_SupportedRail PaymentInstrument::PAYMENT_HYPERLINK;
constexpr PaymentInstrument_SupportedRail PaymentInstrument::CARD_NUMBER;
constexpr PaymentInstrument_SupportedRail PaymentInstrument::SupportedRail_MIN;
constexpr PaymentInstrument_SupportedRail PaymentInstrument::SupportedRail_MAX;
constexpr int PaymentInstrument::SupportedRail_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool BankAccountDetails_AccountType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BankAccountDetails_AccountType_strings[6] = {};

static const char BankAccountDetails_AccountType_names[] = "ACCOUNT_TYPE_UNSPECIFIED"
                                                           "CHECKING"
                                                           "CURRENT"
                                                           "SALARY"
                                                           "SAVINGS"
                                                           "TRANSACTING_ACCOUNT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BankAccountDetails_AccountType_entries[] = {
    { { BankAccountDetails_AccountType_names + 0, 24 }, 0 },
    { { BankAccountDetails_AccountType_names + 24, 8 }, 1 },
    { { BankAccountDetails_AccountType_names + 32, 7 }, 3 },
    { { BankAccountDetails_AccountType_names + 39, 6 }, 4 },
    { { BankAccountDetails_AccountType_names + 45, 7 }, 2 },
    { { BankAccountDetails_AccountType_names + 52, 19 }, 5 },
};

static const int BankAccountDetails_AccountType_entries_by_number[] = {
    0, // 0 -> ACCOUNT_TYPE_UNSPECIFIED
    1, // 1 -> CHECKING
    4, // 2 -> SAVINGS
    2, // 3 -> CURRENT
    3, // 4 -> SALARY
    5, // 5 -> TRANSACTING_ACCOUNT
};

const std::string& BankAccountDetails_AccountType_Name(BankAccountDetails_AccountType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        BankAccountDetails_AccountType_entries, BankAccountDetails_AccountType_entries_by_number, 6, BankAccountDetails_AccountType_strings);
    (void)dummy;
    int idx
        = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(BankAccountDetails_AccountType_entries, BankAccountDetails_AccountType_entries_by_number, 6, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : BankAccountDetails_AccountType_strings[idx].get();
}
bool BankAccountDetails_AccountType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BankAccountDetails_AccountType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(BankAccountDetails_AccountType_entries, 6, name, &int_value);
    if (success) {
        *value = static_cast<BankAccountDetails_AccountType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr BankAccountDetails_AccountType BankAccountDetails::ACCOUNT_TYPE_UNSPECIFIED;
constexpr BankAccountDetails_AccountType BankAccountDetails::CHECKING;
constexpr BankAccountDetails_AccountType BankAccountDetails::SAVINGS;
constexpr BankAccountDetails_AccountType BankAccountDetails::CURRENT;
constexpr BankAccountDetails_AccountType BankAccountDetails::SALARY;
constexpr BankAccountDetails_AccountType BankAccountDetails::TRANSACTING_ACCOUNT;
constexpr BankAccountDetails_AccountType BankAccountDetails::AccountType_MIN;
constexpr BankAccountDetails_AccountType BankAccountDetails::AccountType_MAX;
constexpr int BankAccountDetails::AccountType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AutofillWalletSpecifics_WalletInfoType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AutofillWalletSpecifics_WalletInfoType_strings[8] = {};

static const char AutofillWalletSpecifics_WalletInfoType_names[] = "CREDIT_CARD_CLOUD_TOKEN_DATA"
                                                                   "CUSTOMER_DATA"
                                                                   "MASKED_CREDIT_CARD"
                                                                   "MASKED_IBAN"
                                                                   "PAYMENT_INSTRUMENT"
                                                                   "PAYMENT_INSTRUMENT_CREATION_OPTION"
                                                                   "POSTAL_ADDRESS"
                                                                   "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AutofillWalletSpecifics_WalletInfoType_entries[] = {
    { { AutofillWalletSpecifics_WalletInfoType_names + 0, 28 }, 4 },
    { { AutofillWalletSpecifics_WalletInfoType_names + 28, 13 }, 3 },
    { { AutofillWalletSpecifics_WalletInfoType_names + 41, 18 }, 1 },
    { { AutofillWalletSpecifics_WalletInfoType_names + 59, 11 }, 6 },
    { { AutofillWalletSpecifics_WalletInfoType_names + 70, 18 }, 5 },
    { { AutofillWalletSpecifics_WalletInfoType_names + 88, 34 }, 7 },
    { { AutofillWalletSpecifics_WalletInfoType_names + 122, 14 }, 2 },
    { { AutofillWalletSpecifics_WalletInfoType_names + 136, 7 }, 0 },
};

static const int AutofillWalletSpecifics_WalletInfoType_entries_by_number[] = {
    7, // 0 -> UNKNOWN
    2, // 1 -> MASKED_CREDIT_CARD
    6, // 2 -> POSTAL_ADDRESS
    1, // 3 -> CUSTOMER_DATA
    0, // 4 -> CREDIT_CARD_CLOUD_TOKEN_DATA
    4, // 5 -> PAYMENT_INSTRUMENT
    3, // 6 -> MASKED_IBAN
    5, // 7 -> PAYMENT_INSTRUMENT_CREATION_OPTION
};

const std::string& AutofillWalletSpecifics_WalletInfoType_Name(AutofillWalletSpecifics_WalletInfoType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(AutofillWalletSpecifics_WalletInfoType_entries,
        AutofillWalletSpecifics_WalletInfoType_entries_by_number, 8, AutofillWalletSpecifics_WalletInfoType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        AutofillWalletSpecifics_WalletInfoType_entries, AutofillWalletSpecifics_WalletInfoType_entries_by_number, 8, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : AutofillWalletSpecifics_WalletInfoType_strings[idx].get();
}
bool AutofillWalletSpecifics_WalletInfoType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AutofillWalletSpecifics_WalletInfoType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(AutofillWalletSpecifics_WalletInfoType_entries, 8, name, &int_value);
    if (success) {
        *value = static_cast<AutofillWalletSpecifics_WalletInfoType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::UNKNOWN;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::MASKED_CREDIT_CARD;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::POSTAL_ADDRESS;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::CUSTOMER_DATA;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::CREDIT_CARD_CLOUD_TOKEN_DATA;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::PAYMENT_INSTRUMENT;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::MASKED_IBAN;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::PAYMENT_INSTRUMENT_CREATION_OPTION;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::WalletInfoType_MIN;
constexpr AutofillWalletSpecifics_WalletInfoType AutofillWalletSpecifics::WalletInfoType_MAX;
constexpr int AutofillWalletSpecifics::WalletInfoType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WalletMetadataSpecifics_Type_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WalletMetadataSpecifics_Type_strings[4] = {};

static const char WalletMetadataSpecifics_Type_names[] = "ADDRESS"
                                                         "CARD"
                                                         "IBAN"
                                                         "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WalletMetadataSpecifics_Type_entries[] = {
    { { WalletMetadataSpecifics_Type_names + 0, 7 }, 2 },
    { { WalletMetadataSpecifics_Type_names + 7, 4 }, 1 },
    { { WalletMetadataSpecifics_Type_names + 11, 4 }, 3 },
    { { WalletMetadataSpecifics_Type_names + 15, 7 }, 0 },
};

static const int WalletMetadataSpecifics_Type_entries_by_number[] = {
    3, // 0 -> UNKNOWN
    1, // 1 -> CARD
    0, // 2 -> ADDRESS
    2, // 3 -> IBAN
};

const std::string& WalletMetadataSpecifics_Type_Name(WalletMetadataSpecifics_Type value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        WalletMetadataSpecifics_Type_entries, WalletMetadataSpecifics_Type_entries_by_number, 4, WalletMetadataSpecifics_Type_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(WalletMetadataSpecifics_Type_entries, WalletMetadataSpecifics_Type_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WalletMetadataSpecifics_Type_strings[idx].get();
}
bool WalletMetadataSpecifics_Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WalletMetadataSpecifics_Type* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WalletMetadataSpecifics_Type_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<WalletMetadataSpecifics_Type>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WalletMetadataSpecifics_Type WalletMetadataSpecifics::UNKNOWN;
constexpr WalletMetadataSpecifics_Type WalletMetadataSpecifics::CARD;
constexpr WalletMetadataSpecifics_Type WalletMetadataSpecifics::ADDRESS;
constexpr WalletMetadataSpecifics_Type WalletMetadataSpecifics::IBAN;
constexpr WalletMetadataSpecifics_Type WalletMetadataSpecifics::Type_MIN;
constexpr WalletMetadataSpecifics_Type WalletMetadataSpecifics::Type_MAX;
constexpr int WalletMetadataSpecifics::Type_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class AutofillProfileSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillProfileSpecifics>()._impl_._has_bits_);
    static void set_has_guid(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_deprecated_origin(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_use_count(HasBits* has_bits)
    {
        (*has_bits)[1] |= 32u;
    }
    static void set_has_use_date(HasBits* has_bits)
    {
        (*has_bits)[1] |= 64u;
    }
    static void set_has_profile_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1048576u;
    }
    static void set_has_alternative_full_name(HasBits* has_bits)
    {
        (*has_bits)[1] |= 4u;
    }
    static void set_has_alternative_given_name(HasBits* has_bits)
    {
        (*has_bits)[1] |= 8u;
    }
    static void set_has_alternative_family_name(HasBits* has_bits)
    {
        (*has_bits)[1] |= 16u;
    }
    static void set_has_alternative_full_name_status(HasBits* has_bits)
    {
        (*has_bits)[2] |= 8u;
    }
    static void set_has_alternative_given_name_status(HasBits* has_bits)
    {
        (*has_bits)[2] |= 16u;
    }
    static void set_has_alternative_family_name_status(HasBits* has_bits)
    {
        (*has_bits)[2] |= 32u;
    }
    static void set_has_company_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_address_home_line1(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_address_home_line2(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_address_home_city(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_address_home_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_address_home_zip(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_address_home_country(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_address_home_admin_level_2(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8388608u;
    }
    static void set_has_address_home_street_address(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_address_home_sorting_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_address_home_dependent_locality(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_address_home_language_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_address_home_thoroughfare_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_address_home_thoroughfare_number(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_address_home_street_location(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16777216u;
    }
    static void set_has_address_home_subpremise_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_address_home_apt(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1073741824u;
    }
    static void set_has_address_home_apt_num(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
    static void set_has_address_home_apt_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2147483648u;
    }
    static void set_has_address_home_floor(HasBits* has_bits)
    {
        (*has_bits)[0] |= 524288u;
    }
    static void set_has_address_home_landmark(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2097152u;
    }
    static void set_has_address_home_between_streets(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4194304u;
    }
    static void set_has_address_home_between_streets_1(HasBits* has_bits)
    {
        (*has_bits)[0] |= 67108864u;
    }
    static void set_has_address_home_between_streets_2(HasBits* has_bits)
    {
        (*has_bits)[0] |= 134217728u;
    }
    static void set_has_address_home_overflow(HasBits* has_bits)
    {
        (*has_bits)[0] |= 33554432u;
    }
    static void set_has_address_home_between_streets_or_landmark(HasBits* has_bits)
    {
        (*has_bits)[0] |= 268435456u;
    }
    static void set_has_address_home_overflow_and_landmark(HasBits* has_bits)
    {
        (*has_bits)[0] |= 536870912u;
    }
    static void set_has_address_home_street_location_and_locality(HasBits* has_bits)
    {
        (*has_bits)[1] |= 1u;
    }
    static void set_has_address_home_thoroughfare_number_and_apt(HasBits* has_bits)
    {
        (*has_bits)[1] |= 2u;
    }
    static void set_has_address_home_city_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 512u;
    }
    static void set_has_address_home_state_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 1024u;
    }
    static void set_has_address_home_zip_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 2048u;
    }
    static void set_has_address_home_country_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 4096u;
    }
    static void set_has_address_home_landmark_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 4194304u;
    }
    static void set_has_address_home_between_streets_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 8388608u;
    }
    static void set_has_address_home_between_streets_1_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 134217728u;
    }
    static void set_has_address_home_between_streets_2_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 268435456u;
    }
    static void set_has_address_home_admin_level_2_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 16777216u;
    }
    static void set_has_address_home_overflow_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 67108864u;
    }
    static void set_has_address_home_between_streets_or_landmark_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 536870912u;
    }
    static void set_has_address_home_overflow_and_landmark_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 1073741824u;
    }
    static void set_has_address_home_street_location_and_locality_status(HasBits* has_bits)
    {
        (*has_bits)[2] |= 2u;
    }
    static void set_has_address_home_thoroughfare_number_and_apt_status(HasBits* has_bits)
    {
        (*has_bits)[2] |= 4u;
    }
    static void set_has_address_home_street_address_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 8192u;
    }
    static void set_has_address_home_sorting_code_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 16384u;
    }
    static void set_has_address_home_dependent_locality_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 32768u;
    }
    static void set_has_address_home_language_code_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 65536u;
    }
    static void set_has_address_home_thoroughfare_name_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 131072u;
    }
    static void set_has_address_home_thoroughfare_number_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 262144u;
    }
    static void set_has_address_home_street_location_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 33554432u;
    }
    static void set_has_address_home_subpremise_name_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 524288u;
    }
    static void set_has_address_home_apt_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 2147483648u;
    }
    static void set_has_address_home_apt_num_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 1048576u;
    }
    static void set_has_address_home_apt_type_status(HasBits* has_bits)
    {
        (*has_bits)[2] |= 1u;
    }
    static void set_has_address_home_floor_status(HasBits* has_bits)
    {
        (*has_bits)[1] |= 2097152u;
    }
    static void set_has_deprecated_label(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_phone_fax_whole_number(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_validity_state_bitfield(HasBits* has_bits)
    {
        (*has_bits)[1] |= 128u;
    }
    static void set_has_is_client_validity_states_updated(HasBits* has_bits)
    {
        (*has_bits)[1] |= 256u;
    }
};

AutofillProfileSpecifics::AutofillProfileSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.AutofillProfileSpecifics)
}
AutofillProfileSpecifics::AutofillProfileSpecifics(const AutofillProfileSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillProfileSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.name_first_) { from._impl_.name_first_ }, decltype(_impl_.name_middle_) { from._impl_.name_middle_ },
        decltype(_impl_.name_last_) { from._impl_.name_last_ }, decltype(_impl_.email_address_) { from._impl_.email_address_ },
        decltype(_impl_.phone_home_whole_number_) { from._impl_.phone_home_whole_number_ }, decltype(_impl_.name_full_) { from._impl_.name_full_ },
        decltype(_impl_.name_last_first_) { from._impl_.name_last_first_ }, decltype(_impl_.name_last_conjunction_) { from._impl_.name_last_conjunction_ },
        decltype(_impl_.name_last_second_) { from._impl_.name_last_second_ }, decltype(_impl_.name_first_status_) { from._impl_.name_first_status_ },
        decltype(_impl_.name_middle_status_) { from._impl_.name_middle_status_ }, decltype(_impl_.name_last_status_) { from._impl_.name_last_status_ },
        decltype(_impl_.name_last_first_status_) { from._impl_.name_last_first_status_ },
        decltype(_impl_.name_last_conjunction_status_) { from._impl_.name_last_conjunction_status_ },
        decltype(_impl_.name_last_second_status_) { from._impl_.name_last_second_status_ },
        decltype(_impl_.name_full_status_) { from._impl_.name_full_status_ }, decltype(_impl_.deprecated_label_) {}, decltype(_impl_.company_name_) {},
        decltype(_impl_.address_home_line1_) {}, decltype(_impl_.address_home_line2_) {}, decltype(_impl_.address_home_city_) {},
        decltype(_impl_.address_home_state_) {}, decltype(_impl_.address_home_zip_) {}, decltype(_impl_.address_home_country_) {},
        decltype(_impl_.phone_fax_whole_number_) {}, decltype(_impl_.guid_) {}, decltype(_impl_.deprecated_origin_) {},
        decltype(_impl_.address_home_street_address_) {}, decltype(_impl_.address_home_sorting_code_) {}, decltype(_impl_.address_home_dependent_locality_) {},
        decltype(_impl_.address_home_language_code_) {}, decltype(_impl_.address_home_thoroughfare_name_) {},
        decltype(_impl_.address_home_thoroughfare_number_) {}, decltype(_impl_.address_home_subpremise_name_) {}, decltype(_impl_.address_home_apt_num_) {},
        decltype(_impl_.address_home_floor_) {}, decltype(_impl_.profile_label_) {}, decltype(_impl_.address_home_landmark_) {},
        decltype(_impl_.address_home_between_streets_) {}, decltype(_impl_.address_home_admin_level_2_) {}, decltype(_impl_.address_home_street_location_) {},
        decltype(_impl_.address_home_overflow_) {}, decltype(_impl_.address_home_between_streets_1_) {}, decltype(_impl_.address_home_between_streets_2_) {},
        decltype(_impl_.address_home_between_streets_or_landmark_) {}, decltype(_impl_.address_home_overflow_and_landmark_) {},
        decltype(_impl_.address_home_apt_) {}, decltype(_impl_.address_home_apt_type_) {}, decltype(_impl_.address_home_street_location_and_locality_) {},
        decltype(_impl_.address_home_thoroughfare_number_and_apt_) {}, decltype(_impl_.alternative_full_name_) {}, decltype(_impl_.alternative_given_name_) {},
        decltype(_impl_.alternative_family_name_) {}, decltype(_impl_.use_count_) {}, decltype(_impl_.use_date_) {},
        decltype(_impl_.validity_state_bitfield_) {}, decltype(_impl_.is_client_validity_states_updated_) {}, decltype(_impl_.address_home_city_status_) {},
        decltype(_impl_.address_home_state_status_) {}, decltype(_impl_.address_home_zip_status_) {}, decltype(_impl_.address_home_country_status_) {},
        decltype(_impl_.address_home_street_address_status_) {}, decltype(_impl_.address_home_sorting_code_status_) {},
        decltype(_impl_.address_home_dependent_locality_status_) {}, decltype(_impl_.address_home_language_code_status_) {},
        decltype(_impl_.address_home_thoroughfare_name_status_) {}, decltype(_impl_.address_home_thoroughfare_number_status_) {},
        decltype(_impl_.address_home_subpremise_name_status_) {}, decltype(_impl_.address_home_apt_num_status_) {},
        decltype(_impl_.address_home_floor_status_) {}, decltype(_impl_.address_home_landmark_status_) {},
        decltype(_impl_.address_home_between_streets_status_) {}, decltype(_impl_.address_home_admin_level_2_status_) {},
        decltype(_impl_.address_home_street_location_status_) {}, decltype(_impl_.address_home_overflow_status_) {},
        decltype(_impl_.address_home_between_streets_1_status_) {}, decltype(_impl_.address_home_between_streets_2_status_) {},
        decltype(_impl_.address_home_between_streets_or_landmark_status_) {}, decltype(_impl_.address_home_overflow_and_landmark_status_) {},
        decltype(_impl_.address_home_apt_status_) {}, decltype(_impl_.address_home_apt_type_status_) {},
        decltype(_impl_.address_home_street_location_and_locality_status_) {}, decltype(_impl_.address_home_thoroughfare_number_and_apt_status_) {},
        decltype(_impl_.alternative_full_name_status_) {}, decltype(_impl_.alternative_given_name_status_) {},
        decltype(_impl_.alternative_family_name_status_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.deprecated_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_deprecated_label()) {
        _this->_impl_.deprecated_label_.Set(from._internal_deprecated_label(), _this->GetArenaForAllocation());
    }
    _impl_.company_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.company_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_company_name()) {
        _this->_impl_.company_name_.Set(from._internal_company_name(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_line1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_line1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_line1()) {
        _this->_impl_.address_home_line1_.Set(from._internal_address_home_line1(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_line2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_line2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_line2()) {
        _this->_impl_.address_home_line2_.Set(from._internal_address_home_line2(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_city_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_city_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_city()) {
        _this->_impl_.address_home_city_.Set(from._internal_address_home_city(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_state_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_state_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_state()) {
        _this->_impl_.address_home_state_.Set(from._internal_address_home_state(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_zip_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_zip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_zip()) {
        _this->_impl_.address_home_zip_.Set(from._internal_address_home_zip(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_country()) {
        _this->_impl_.address_home_country_.Set(from._internal_address_home_country(), _this->GetArenaForAllocation());
    }
    _impl_.phone_fax_whole_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_fax_whole_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_phone_fax_whole_number()) {
        _this->_impl_.phone_fax_whole_number_.Set(from._internal_phone_fax_whole_number(), _this->GetArenaForAllocation());
    }
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_guid()) {
        _this->_impl_.guid_.Set(from._internal_guid(), _this->GetArenaForAllocation());
    }
    _impl_.deprecated_origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_deprecated_origin()) {
        _this->_impl_.deprecated_origin_.Set(from._internal_deprecated_origin(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_street_address_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_address_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_street_address()) {
        _this->_impl_.address_home_street_address_.Set(from._internal_address_home_street_address(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_sorting_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_sorting_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_sorting_code()) {
        _this->_impl_.address_home_sorting_code_.Set(from._internal_address_home_sorting_code(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_dependent_locality_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_dependent_locality_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_dependent_locality()) {
        _this->_impl_.address_home_dependent_locality_.Set(from._internal_address_home_dependent_locality(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_language_code()) {
        _this->_impl_.address_home_language_code_.Set(from._internal_address_home_language_code(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_thoroughfare_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_thoroughfare_name()) {
        _this->_impl_.address_home_thoroughfare_name_.Set(from._internal_address_home_thoroughfare_name(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_thoroughfare_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_thoroughfare_number()) {
        _this->_impl_.address_home_thoroughfare_number_.Set(from._internal_address_home_thoroughfare_number(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_subpremise_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_subpremise_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_subpremise_name()) {
        _this->_impl_.address_home_subpremise_name_.Set(from._internal_address_home_subpremise_name(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_apt_num_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_num_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_apt_num()) {
        _this->_impl_.address_home_apt_num_.Set(from._internal_address_home_apt_num(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_floor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_floor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_floor()) {
        _this->_impl_.address_home_floor_.Set(from._internal_address_home_floor(), _this->GetArenaForAllocation());
    }
    _impl_.profile_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_profile_label()) {
        _this->_impl_.profile_label_.Set(from._internal_profile_label(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_landmark_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_landmark_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_landmark()) {
        _this->_impl_.address_home_landmark_.Set(from._internal_address_home_landmark(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_between_streets_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_between_streets()) {
        _this->_impl_.address_home_between_streets_.Set(from._internal_address_home_between_streets(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_admin_level_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_admin_level_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_admin_level_2()) {
        _this->_impl_.address_home_admin_level_2_.Set(from._internal_address_home_admin_level_2(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_street_location_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_location_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_street_location()) {
        _this->_impl_.address_home_street_location_.Set(from._internal_address_home_street_location(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_overflow_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_overflow_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_overflow()) {
        _this->_impl_.address_home_overflow_.Set(from._internal_address_home_overflow(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_between_streets_1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_between_streets_1()) {
        _this->_impl_.address_home_between_streets_1_.Set(from._internal_address_home_between_streets_1(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_between_streets_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_between_streets_2()) {
        _this->_impl_.address_home_between_streets_2_.Set(from._internal_address_home_between_streets_2(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_between_streets_or_landmark_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_or_landmark_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_between_streets_or_landmark()) {
        _this->_impl_.address_home_between_streets_or_landmark_.Set(from._internal_address_home_between_streets_or_landmark(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_overflow_and_landmark_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_overflow_and_landmark_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_overflow_and_landmark()) {
        _this->_impl_.address_home_overflow_and_landmark_.Set(from._internal_address_home_overflow_and_landmark(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_apt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_apt()) {
        _this->_impl_.address_home_apt_.Set(from._internal_address_home_apt(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_apt_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_apt_type()) {
        _this->_impl_.address_home_apt_type_.Set(from._internal_address_home_apt_type(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_street_location_and_locality_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_location_and_locality_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_street_location_and_locality()) {
        _this->_impl_.address_home_street_location_and_locality_.Set(
            from._internal_address_home_street_location_and_locality(), _this->GetArenaForAllocation());
    }
    _impl_.address_home_thoroughfare_number_and_apt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_number_and_apt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_home_thoroughfare_number_and_apt()) {
        _this->_impl_.address_home_thoroughfare_number_and_apt_.Set(from._internal_address_home_thoroughfare_number_and_apt(), _this->GetArenaForAllocation());
    }
    _impl_.alternative_full_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_full_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_alternative_full_name()) {
        _this->_impl_.alternative_full_name_.Set(from._internal_alternative_full_name(), _this->GetArenaForAllocation());
    }
    _impl_.alternative_given_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_given_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_alternative_given_name()) {
        _this->_impl_.alternative_given_name_.Set(from._internal_alternative_given_name(), _this->GetArenaForAllocation());
    }
    _impl_.alternative_family_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_family_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_alternative_family_name()) {
        _this->_impl_.alternative_family_name_.Set(from._internal_alternative_family_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.use_count_, &from._impl_.use_count_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.alternative_family_name_status_) - reinterpret_cast<char*>(&_impl_.use_count_))
            + sizeof(_impl_.alternative_family_name_status_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.AutofillProfileSpecifics)
}

inline void AutofillProfileSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_first_) { arena },
        decltype(_impl_.name_middle_) { arena }, decltype(_impl_.name_last_) { arena }, decltype(_impl_.email_address_) { arena },
        decltype(_impl_.phone_home_whole_number_) { arena }, decltype(_impl_.name_full_) { arena }, decltype(_impl_.name_last_first_) { arena },
        decltype(_impl_.name_last_conjunction_) { arena }, decltype(_impl_.name_last_second_) { arena }, decltype(_impl_.name_first_status_) { arena },
        decltype(_impl_.name_middle_status_) { arena }, decltype(_impl_.name_last_status_) { arena }, decltype(_impl_.name_last_first_status_) { arena },
        decltype(_impl_.name_last_conjunction_status_) { arena }, decltype(_impl_.name_last_second_status_) { arena },
        decltype(_impl_.name_full_status_) { arena }, decltype(_impl_.deprecated_label_) {}, decltype(_impl_.company_name_) {},
        decltype(_impl_.address_home_line1_) {}, decltype(_impl_.address_home_line2_) {}, decltype(_impl_.address_home_city_) {},
        decltype(_impl_.address_home_state_) {}, decltype(_impl_.address_home_zip_) {}, decltype(_impl_.address_home_country_) {},
        decltype(_impl_.phone_fax_whole_number_) {}, decltype(_impl_.guid_) {}, decltype(_impl_.deprecated_origin_) {},
        decltype(_impl_.address_home_street_address_) {}, decltype(_impl_.address_home_sorting_code_) {}, decltype(_impl_.address_home_dependent_locality_) {},
        decltype(_impl_.address_home_language_code_) {}, decltype(_impl_.address_home_thoroughfare_name_) {},
        decltype(_impl_.address_home_thoroughfare_number_) {}, decltype(_impl_.address_home_subpremise_name_) {}, decltype(_impl_.address_home_apt_num_) {},
        decltype(_impl_.address_home_floor_) {}, decltype(_impl_.profile_label_) {}, decltype(_impl_.address_home_landmark_) {},
        decltype(_impl_.address_home_between_streets_) {}, decltype(_impl_.address_home_admin_level_2_) {}, decltype(_impl_.address_home_street_location_) {},
        decltype(_impl_.address_home_overflow_) {}, decltype(_impl_.address_home_between_streets_1_) {}, decltype(_impl_.address_home_between_streets_2_) {},
        decltype(_impl_.address_home_between_streets_or_landmark_) {}, decltype(_impl_.address_home_overflow_and_landmark_) {},
        decltype(_impl_.address_home_apt_) {}, decltype(_impl_.address_home_apt_type_) {}, decltype(_impl_.address_home_street_location_and_locality_) {},
        decltype(_impl_.address_home_thoroughfare_number_and_apt_) {}, decltype(_impl_.alternative_full_name_) {}, decltype(_impl_.alternative_given_name_) {},
        decltype(_impl_.alternative_family_name_) {}, decltype(_impl_.use_count_) { int64_t { 0 } }, decltype(_impl_.use_date_) { int64_t { 0 } },
        decltype(_impl_.validity_state_bitfield_) { int64_t { 0 } }, decltype(_impl_.is_client_validity_states_updated_) { false },
        decltype(_impl_.address_home_city_status_) { 0 }, decltype(_impl_.address_home_state_status_) { 0 }, decltype(_impl_.address_home_zip_status_) { 0 },
        decltype(_impl_.address_home_country_status_) { 0 }, decltype(_impl_.address_home_street_address_status_) { 0 },
        decltype(_impl_.address_home_sorting_code_status_) { 0 }, decltype(_impl_.address_home_dependent_locality_status_) { 0 },
        decltype(_impl_.address_home_language_code_status_) { 0 }, decltype(_impl_.address_home_thoroughfare_name_status_) { 0 },
        decltype(_impl_.address_home_thoroughfare_number_status_) { 0 }, decltype(_impl_.address_home_subpremise_name_status_) { 0 },
        decltype(_impl_.address_home_apt_num_status_) { 0 }, decltype(_impl_.address_home_floor_status_) { 0 },
        decltype(_impl_.address_home_landmark_status_) { 0 }, decltype(_impl_.address_home_between_streets_status_) { 0 },
        decltype(_impl_.address_home_admin_level_2_status_) { 0 }, decltype(_impl_.address_home_street_location_status_) { 0 },
        decltype(_impl_.address_home_overflow_status_) { 0 }, decltype(_impl_.address_home_between_streets_1_status_) { 0 },
        decltype(_impl_.address_home_between_streets_2_status_) { 0 }, decltype(_impl_.address_home_between_streets_or_landmark_status_) { 0 },
        decltype(_impl_.address_home_overflow_and_landmark_status_) { 0 }, decltype(_impl_.address_home_apt_status_) { 0 },
        decltype(_impl_.address_home_apt_type_status_) { 0 }, decltype(_impl_.address_home_street_location_and_locality_status_) { 0 },
        decltype(_impl_.address_home_thoroughfare_number_and_apt_status_) { 0 }, decltype(_impl_.alternative_full_name_status_) { 0 },
        decltype(_impl_.alternative_given_name_status_) { 0 }, decltype(_impl_.alternative_family_name_status_) { 0 } };
    _impl_.deprecated_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.company_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.company_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_line1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_line1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_line2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_line2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_city_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_city_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_state_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_state_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_zip_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_zip_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_fax_whole_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_fax_whole_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_origin_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.deprecated_origin_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_address_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_address_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_sorting_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_sorting_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_dependent_locality_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_dependent_locality_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_subpremise_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_subpremise_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_num_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_num_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_floor_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_floor_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_label_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.profile_label_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_landmark_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_landmark_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_admin_level_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_admin_level_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_location_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_location_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_overflow_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_overflow_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_or_landmark_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_between_streets_or_landmark_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_overflow_and_landmark_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_overflow_and_landmark_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_apt_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_location_and_locality_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_street_location_and_locality_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_number_and_apt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_home_thoroughfare_number_and_apt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_full_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_full_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_given_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_given_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_family_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alternative_family_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutofillProfileSpecifics::~AutofillProfileSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.AutofillProfileSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillProfileSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_first_.~RepeatedPtrField();
    _impl_.name_middle_.~RepeatedPtrField();
    _impl_.name_last_.~RepeatedPtrField();
    _impl_.email_address_.~RepeatedPtrField();
    _impl_.phone_home_whole_number_.~RepeatedPtrField();
    _impl_.name_full_.~RepeatedPtrField();
    _impl_.name_last_first_.~RepeatedPtrField();
    _impl_.name_last_conjunction_.~RepeatedPtrField();
    _impl_.name_last_second_.~RepeatedPtrField();
    _impl_.name_first_status_.~RepeatedField();
    _impl_.name_middle_status_.~RepeatedField();
    _impl_.name_last_status_.~RepeatedField();
    _impl_.name_last_first_status_.~RepeatedField();
    _impl_.name_last_conjunction_status_.~RepeatedField();
    _impl_.name_last_second_status_.~RepeatedField();
    _impl_.name_full_status_.~RepeatedField();
    _impl_.deprecated_label_.Destroy();
    _impl_.company_name_.Destroy();
    _impl_.address_home_line1_.Destroy();
    _impl_.address_home_line2_.Destroy();
    _impl_.address_home_city_.Destroy();
    _impl_.address_home_state_.Destroy();
    _impl_.address_home_zip_.Destroy();
    _impl_.address_home_country_.Destroy();
    _impl_.phone_fax_whole_number_.Destroy();
    _impl_.guid_.Destroy();
    _impl_.deprecated_origin_.Destroy();
    _impl_.address_home_street_address_.Destroy();
    _impl_.address_home_sorting_code_.Destroy();
    _impl_.address_home_dependent_locality_.Destroy();
    _impl_.address_home_language_code_.Destroy();
    _impl_.address_home_thoroughfare_name_.Destroy();
    _impl_.address_home_thoroughfare_number_.Destroy();
    _impl_.address_home_subpremise_name_.Destroy();
    _impl_.address_home_apt_num_.Destroy();
    _impl_.address_home_floor_.Destroy();
    _impl_.profile_label_.Destroy();
    _impl_.address_home_landmark_.Destroy();
    _impl_.address_home_between_streets_.Destroy();
    _impl_.address_home_admin_level_2_.Destroy();
    _impl_.address_home_street_location_.Destroy();
    _impl_.address_home_overflow_.Destroy();
    _impl_.address_home_between_streets_1_.Destroy();
    _impl_.address_home_between_streets_2_.Destroy();
    _impl_.address_home_between_streets_or_landmark_.Destroy();
    _impl_.address_home_overflow_and_landmark_.Destroy();
    _impl_.address_home_apt_.Destroy();
    _impl_.address_home_apt_type_.Destroy();
    _impl_.address_home_street_location_and_locality_.Destroy();
    _impl_.address_home_thoroughfare_number_and_apt_.Destroy();
    _impl_.alternative_full_name_.Destroy();
    _impl_.alternative_given_name_.Destroy();
    _impl_.alternative_family_name_.Destroy();
}

void AutofillProfileSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillProfileSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.AutofillProfileSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.name_first_.Clear();
    _impl_.name_middle_.Clear();
    _impl_.name_last_.Clear();
    _impl_.email_address_.Clear();
    _impl_.phone_home_whole_number_.Clear();
    _impl_.name_full_.Clear();
    _impl_.name_last_first_.Clear();
    _impl_.name_last_conjunction_.Clear();
    _impl_.name_last_second_.Clear();
    _impl_.name_first_status_.Clear();
    _impl_.name_middle_status_.Clear();
    _impl_.name_last_status_.Clear();
    _impl_.name_last_first_status_.Clear();
    _impl_.name_last_conjunction_status_.Clear();
    _impl_.name_last_second_status_.Clear();
    _impl_.name_full_status_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.deprecated_label_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.company_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.address_home_line1_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.address_home_line2_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.address_home_city_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.address_home_state_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.address_home_zip_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            _impl_.address_home_country_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _impl_.phone_fax_whole_number_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000200u) {
            _impl_.guid_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000400u) {
            _impl_.deprecated_origin_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000800u) {
            _impl_.address_home_street_address_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00001000u) {
            _impl_.address_home_sorting_code_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00002000u) {
            _impl_.address_home_dependent_locality_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00004000u) {
            _impl_.address_home_language_code_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00008000u) {
            _impl_.address_home_thoroughfare_name_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00ff0000u) {
        if (cached_has_bits & 0x00010000u) {
            _impl_.address_home_thoroughfare_number_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00020000u) {
            _impl_.address_home_subpremise_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00040000u) {
            _impl_.address_home_apt_num_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00080000u) {
            _impl_.address_home_floor_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00100000u) {
            _impl_.profile_label_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00200000u) {
            _impl_.address_home_landmark_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00400000u) {
            _impl_.address_home_between_streets_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00800000u) {
            _impl_.address_home_admin_level_2_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0xff000000u) {
        if (cached_has_bits & 0x01000000u) {
            _impl_.address_home_street_location_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x02000000u) {
            _impl_.address_home_overflow_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x04000000u) {
            _impl_.address_home_between_streets_1_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x08000000u) {
            _impl_.address_home_between_streets_2_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x10000000u) {
            _impl_.address_home_between_streets_or_landmark_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x20000000u) {
            _impl_.address_home_overflow_and_landmark_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x40000000u) {
            _impl_.address_home_apt_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x80000000u) {
            _impl_.address_home_apt_type_.ClearNonDefaultToEmpty();
        }
    }
    cached_has_bits = _impl_._has_bits_[1];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.address_home_street_location_and_locality_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.address_home_thoroughfare_number_and_apt_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.alternative_full_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.alternative_given_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.alternative_family_name_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x000000e0u) {
        ::memset(&_impl_.use_count_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.validity_state_bitfield_) - reinterpret_cast<char*>(&_impl_.use_count_))
                + sizeof(_impl_.validity_state_bitfield_));
    }
    if (cached_has_bits & 0x0000ff00u) {
        ::memset(&_impl_.is_client_validity_states_updated_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.address_home_dependent_locality_status_) - reinterpret_cast<char*>(&_impl_.is_client_validity_states_updated_))
                + sizeof(_impl_.address_home_dependent_locality_status_));
    }
    if (cached_has_bits & 0x00ff0000u) {
        ::memset(&_impl_.address_home_language_code_status_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.address_home_between_streets_status_) - reinterpret_cast<char*>(&_impl_.address_home_language_code_status_))
                + sizeof(_impl_.address_home_between_streets_status_));
    }
    if (cached_has_bits & 0xff000000u) {
        ::memset(&_impl_.address_home_admin_level_2_status_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.address_home_apt_status_) - reinterpret_cast<char*>(&_impl_.address_home_admin_level_2_status_))
                + sizeof(_impl_.address_home_apt_status_));
    }
    cached_has_bits = _impl_._has_bits_[2];
    if (cached_has_bits & 0x0000003fu) {
        ::memset(&_impl_.address_home_apt_type_status_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.alternative_family_name_status_) - reinterpret_cast<char*>(&_impl_.address_home_apt_type_status_))
                + sizeof(_impl_.alternative_family_name_status_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillProfileSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string deprecated_label = 1 [deprecated = true];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_deprecated_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string name_first = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_name_first();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string name_middle = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_name_middle();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string name_last = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_name_last();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string email_address = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_email_address();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string company_name = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_company_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_line1 = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_address_home_line1();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_line2 = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_address_home_line2();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_city = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_address_home_city();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_state = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_address_home_state();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_zip = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_address_home_zip();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_country = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_address_home_country();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string phone_home_whole_number = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_phone_home_whole_number();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<106>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string phone_fax_whole_number = 14 [deprecated = true];
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_phone_fax_whole_number();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string guid = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                auto str = _internal_mutable_guid();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string deprecated_origin = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                auto str = _internal_mutable_deprecated_origin();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_street_address = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
                auto str = _internal_mutable_address_home_street_address();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_sorting_code = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
                auto str = _internal_mutable_address_home_sorting_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_dependent_locality = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
                auto str = _internal_mutable_address_home_dependent_locality();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_language_code = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
                auto str = _internal_mutable_address_home_language_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string name_full = 21;
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    auto str = _internal_add_name_full();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<170>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional int64 use_count = 22;
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
                _Internal::set_has_use_count(&_impl_._has_bits_);
                _impl_.use_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 use_date = 23;
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
                _Internal::set_has_use_date(&_impl_._has_bits_);
                _impl_.use_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 validity_state_bitfield = 24 [deprecated = true];
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
                _Internal::set_has_validity_state_bitfield(&_impl_._has_bits_);
                _impl_.validity_state_bitfield_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_client_validity_states_updated = 25 [deprecated = true];
        case 25:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
                _Internal::set_has_is_client_validity_states_updated(&_impl_._has_bits_);
                _impl_.is_client_validity_states_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string name_last_first = 27;
        case 27:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    auto str = _internal_add_name_last_first();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<218>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string name_last_conjunction = 28;
        case 28:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    auto str = _internal_add_name_last_conjunction();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<226>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string name_last_second = 29;
        case 29:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    auto str = _internal_add_name_last_second();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<234>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_first_status = 31;
        case 31:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                        _internal_add_name_first_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(31, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<248>(ptr));
            } else if (static_cast<uint8_t>(tag) == 250) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_name_first_status(), ptr, ctx, ::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid, &_internal_metadata_, 31);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_middle_status = 32;
        case 32:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                        _internal_add_name_middle_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(32, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<256>(ptr));
            } else if (static_cast<uint8_t>(tag) == 2) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_name_middle_status(), ptr, ctx, ::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid, &_internal_metadata_, 32);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_status = 33;
        case 33:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                        _internal_add_name_last_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(33, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<264>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_name_last_status(), ptr, ctx, ::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid, &_internal_metadata_, 33);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_first_status = 34;
        case 34:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                        _internal_add_name_last_first_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(34, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<272>(ptr));
            } else if (static_cast<uint8_t>(tag) == 18) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_name_last_first_status(), ptr, ctx,
                    ::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid, &_internal_metadata_, 34);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_conjunction_status = 35;
        case 35:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                        _internal_add_name_last_conjunction_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(35, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<280>(ptr));
            } else if (static_cast<uint8_t>(tag) == 26) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_name_last_conjunction_status(), ptr, ctx,
                    ::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid, &_internal_metadata_, 35);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_second_status = 36;
        case 36:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                        _internal_add_name_last_second_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(36, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<288>(ptr));
            } else if (static_cast<uint8_t>(tag) == 34) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_name_last_second_status(), ptr, ctx,
                    ::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid, &_internal_metadata_, 36);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_full_status = 37;
        case 37:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                        _internal_add_name_full_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(37, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<296>(ptr));
            } else if (static_cast<uint8_t>(tag) == 42) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_name_full_status(), ptr, ctx, ::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid, &_internal_metadata_, 37);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_thoroughfare_name = 38;
        case 38:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_address_home_thoroughfare_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_thoroughfare_number = 39;
        case 39:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_address_home_thoroughfare_number();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_subpremise_name = 42;
        case 42:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_address_home_subpremise_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_city_status = 43;
        case 43:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_city_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(43, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_state_status = 44;
        case 44:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_state_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(44, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_zip_status = 45;
        case 45:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_zip_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(45, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_country_status = 46;
        case 46:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_country_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(46, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_address_status = 47;
        case 47:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_street_address_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(47, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_sorting_code_status = 48;
        case 48:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_sorting_code_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(48, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_dependent_locality_status = 49;
        case 49:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_dependent_locality_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(49, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_language_code_status = 50;
        case 50:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_language_code_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(50, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_name_status = 51;
        case 51:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_thoroughfare_name_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(51, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_number_status = 52;
        case 52:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_thoroughfare_number_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(52, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_subpremise_name_status = 55;
        case 55:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_subpremise_name_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(55, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_apt_num = 56;
        case 56:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
                auto str = _internal_mutable_address_home_apt_num();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_floor = 57;
        case 57:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
                auto str = _internal_mutable_address_home_floor();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_num_status = 58;
        case 58:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_apt_num_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(58, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_floor_status = 59;
        case 59:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_floor_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(59, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string profile_label = 62;
        case 62:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
                auto str = _internal_mutable_profile_label();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_landmark = 67;
        case 67:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_address_home_landmark();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_landmark_status = 68;
        case 68:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_landmark_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(68, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_between_streets = 69;
        case 69:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_address_home_between_streets();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_status = 70;
        case 70:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_between_streets_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(70, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_admin_level_2 = 71;
        case 71:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_address_home_admin_level_2();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_admin_level_2_status = 72;
        case 72:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_admin_level_2_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(72, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_street_location = 73;
        case 73:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_address_home_street_location();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_location_status = 74;
        case 74:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_street_location_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(74, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_overflow = 75;
        case 75:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_address_home_overflow();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_overflow_status = 76;
        case 76:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_overflow_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(76, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_between_streets_1 = 77;
        case 77:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                auto str = _internal_mutable_address_home_between_streets_1();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_1_status = 78;
        case 78:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_between_streets_1_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(78, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_between_streets_2 = 79;
        case 79:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
                auto str = _internal_mutable_address_home_between_streets_2();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_2_status = 80;
        case 80:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_between_streets_2_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(80, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_between_streets_or_landmark = 81;
        case 81:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
                auto str = _internal_mutable_address_home_between_streets_or_landmark();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_or_landmark_status = 82;
        case 82:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_between_streets_or_landmark_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(82, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_overflow_and_landmark = 83;
        case 83:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
                auto str = _internal_mutable_address_home_overflow_and_landmark();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_overflow_and_landmark_status = 84;
        case 84:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_overflow_and_landmark_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(84, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_apt = 85;
        case 85:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
                auto str = _internal_mutable_address_home_apt();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_status = 86;
        case 86:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_apt_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(86, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_apt_type = 87;
        case 87:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
                auto str = _internal_mutable_address_home_apt_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_type_status = 88;
        case 88:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_apt_type_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(88, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_street_location_and_locality = 89;
        case 89:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
                auto str = _internal_mutable_address_home_street_location_and_locality();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_location_and_locality_status = 90;
        case 90:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_street_location_and_locality_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(90, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string address_home_thoroughfare_number_and_apt = 91;
        case 91:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
                auto str = _internal_mutable_address_home_thoroughfare_number_and_apt();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_number_and_apt_status = 92;
        case 92:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_address_home_thoroughfare_number_and_apt_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(92, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string alternative_full_name = 93;
        case 93:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
                auto str = _internal_mutable_alternative_full_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string alternative_given_name = 94;
        case 94:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
                auto str = _internal_mutable_alternative_given_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string alternative_family_name = 95;
        case 95:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
                auto str = _internal_mutable_alternative_family_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_full_name_status = 96;
        case 96:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_alternative_full_name_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(96, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_given_name_status = 97;
        case 97:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_alternative_given_name_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(97, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_family_name_status = 98;
        case 98:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillProfileSpecifics_VerificationStatus_IsValid(val))) {
                    _internal_set_alternative_family_name_status(static_cast<::sync_pb::AutofillProfileSpecifics_VerificationStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(98, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillProfileSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.AutofillProfileSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string deprecated_label = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_deprecated_label(), target);
    }

    // repeated string name_first = 2;
    for (int i = 0, n = this->_internal_name_first_size(); i < n; i++) {
        const auto& s = this->_internal_name_first(i);
        target = stream->WriteString(2, s, target);
    }

    // repeated string name_middle = 3;
    for (int i = 0, n = this->_internal_name_middle_size(); i < n; i++) {
        const auto& s = this->_internal_name_middle(i);
        target = stream->WriteString(3, s, target);
    }

    // repeated string name_last = 4;
    for (int i = 0, n = this->_internal_name_last_size(); i < n; i++) {
        const auto& s = this->_internal_name_last(i);
        target = stream->WriteString(4, s, target);
    }

    // repeated string email_address = 5;
    for (int i = 0, n = this->_internal_email_address_size(); i < n; i++) {
        const auto& s = this->_internal_email_address(i);
        target = stream->WriteString(5, s, target);
    }

    // optional string company_name = 6;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_company_name(), target);
    }

    // optional string address_home_line1 = 7;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_address_home_line1(), target);
    }

    // optional string address_home_line2 = 8;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_address_home_line2(), target);
    }

    // optional string address_home_city = 9;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_address_home_city(), target);
    }

    // optional string address_home_state = 10;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(10, this->_internal_address_home_state(), target);
    }

    // optional string address_home_zip = 11;
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(11, this->_internal_address_home_zip(), target);
    }

    // optional string address_home_country = 12;
    if (cached_has_bits & 0x00000080u) {
        target = stream->WriteStringMaybeAliased(12, this->_internal_address_home_country(), target);
    }

    // repeated string phone_home_whole_number = 13;
    for (int i = 0, n = this->_internal_phone_home_whole_number_size(); i < n; i++) {
        const auto& s = this->_internal_phone_home_whole_number(i);
        target = stream->WriteString(13, s, target);
    }

    // optional string phone_fax_whole_number = 14 [deprecated = true];
    if (cached_has_bits & 0x00000100u) {
        target = stream->WriteStringMaybeAliased(14, this->_internal_phone_fax_whole_number(), target);
    }

    // optional string guid = 15;
    if (cached_has_bits & 0x00000200u) {
        target = stream->WriteStringMaybeAliased(15, this->_internal_guid(), target);
    }

    // optional string deprecated_origin = 16;
    if (cached_has_bits & 0x00000400u) {
        target = stream->WriteStringMaybeAliased(16, this->_internal_deprecated_origin(), target);
    }

    // optional string address_home_street_address = 17;
    if (cached_has_bits & 0x00000800u) {
        target = stream->WriteStringMaybeAliased(17, this->_internal_address_home_street_address(), target);
    }

    // optional string address_home_sorting_code = 18;
    if (cached_has_bits & 0x00001000u) {
        target = stream->WriteStringMaybeAliased(18, this->_internal_address_home_sorting_code(), target);
    }

    // optional string address_home_dependent_locality = 19;
    if (cached_has_bits & 0x00002000u) {
        target = stream->WriteStringMaybeAliased(19, this->_internal_address_home_dependent_locality(), target);
    }

    // optional string address_home_language_code = 20;
    if (cached_has_bits & 0x00004000u) {
        target = stream->WriteStringMaybeAliased(20, this->_internal_address_home_language_code(), target);
    }

    // repeated string name_full = 21;
    for (int i = 0, n = this->_internal_name_full_size(); i < n; i++) {
        const auto& s = this->_internal_name_full(i);
        target = stream->WriteString(21, s, target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional int64 use_count = 22;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(22, this->_internal_use_count(), target);
    }

    // optional int64 use_date = 23;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(23, this->_internal_use_date(), target);
    }

    // optional int64 validity_state_bitfield = 24 [deprecated = true];
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(24, this->_internal_validity_state_bitfield(), target);
    }

    // optional bool is_client_validity_states_updated = 25 [deprecated = true];
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_is_client_validity_states_updated(), target);
    }

    // repeated string name_last_first = 27;
    for (int i = 0, n = this->_internal_name_last_first_size(); i < n; i++) {
        const auto& s = this->_internal_name_last_first(i);
        target = stream->WriteString(27, s, target);
    }

    // repeated string name_last_conjunction = 28;
    for (int i = 0, n = this->_internal_name_last_conjunction_size(); i < n; i++) {
        const auto& s = this->_internal_name_last_conjunction(i);
        target = stream->WriteString(28, s, target);
    }

    // repeated string name_last_second = 29;
    for (int i = 0, n = this->_internal_name_last_second_size(); i < n; i++) {
        const auto& s = this->_internal_name_last_second(i);
        target = stream->WriteString(29, s, target);
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_first_status = 31;
    for (int i = 0, n = this->_internal_name_first_status_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(31, this->_internal_name_first_status(i), target);
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_middle_status = 32;
    for (int i = 0, n = this->_internal_name_middle_status_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(32, this->_internal_name_middle_status(i), target);
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_status = 33;
    for (int i = 0, n = this->_internal_name_last_status_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(33, this->_internal_name_last_status(i), target);
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_first_status = 34;
    for (int i = 0, n = this->_internal_name_last_first_status_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(34, this->_internal_name_last_first_status(i), target);
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_conjunction_status = 35;
    for (int i = 0, n = this->_internal_name_last_conjunction_status_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(35, this->_internal_name_last_conjunction_status(i), target);
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_second_status = 36;
    for (int i = 0, n = this->_internal_name_last_second_status_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(36, this->_internal_name_last_second_status(i), target);
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_full_status = 37;
    for (int i = 0, n = this->_internal_name_full_status_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(37, this->_internal_name_full_status(i), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_thoroughfare_name = 38;
    if (cached_has_bits & 0x00008000u) {
        target = stream->WriteStringMaybeAliased(38, this->_internal_address_home_thoroughfare_name(), target);
    }

    // optional string address_home_thoroughfare_number = 39;
    if (cached_has_bits & 0x00010000u) {
        target = stream->WriteStringMaybeAliased(39, this->_internal_address_home_thoroughfare_number(), target);
    }

    // optional string address_home_subpremise_name = 42;
    if (cached_has_bits & 0x00020000u) {
        target = stream->WriteStringMaybeAliased(42, this->_internal_address_home_subpremise_name(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_city_status = 43;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(43, this->_internal_address_home_city_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_state_status = 44;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(44, this->_internal_address_home_state_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_zip_status = 45;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(45, this->_internal_address_home_zip_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_country_status = 46;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(46, this->_internal_address_home_country_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_address_status = 47;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(47, this->_internal_address_home_street_address_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_sorting_code_status = 48;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(48, this->_internal_address_home_sorting_code_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_dependent_locality_status = 49;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(49, this->_internal_address_home_dependent_locality_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_language_code_status = 50;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(50, this->_internal_address_home_language_code_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_name_status = 51;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(51, this->_internal_address_home_thoroughfare_name_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_number_status = 52;
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(52, this->_internal_address_home_thoroughfare_number_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_subpremise_name_status = 55;
    if (cached_has_bits & 0x00080000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(55, this->_internal_address_home_subpremise_name_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_apt_num = 56;
    if (cached_has_bits & 0x00040000u) {
        target = stream->WriteStringMaybeAliased(56, this->_internal_address_home_apt_num(), target);
    }

    // optional string address_home_floor = 57;
    if (cached_has_bits & 0x00080000u) {
        target = stream->WriteStringMaybeAliased(57, this->_internal_address_home_floor(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_num_status = 58;
    if (cached_has_bits & 0x00100000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(58, this->_internal_address_home_apt_num_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_floor_status = 59;
    if (cached_has_bits & 0x00200000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(59, this->_internal_address_home_floor_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string profile_label = 62;
    if (cached_has_bits & 0x00100000u) {
        target = stream->WriteStringMaybeAliased(62, this->_internal_profile_label(), target);
    }

    // optional string address_home_landmark = 67;
    if (cached_has_bits & 0x00200000u) {
        target = stream->WriteStringMaybeAliased(67, this->_internal_address_home_landmark(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_landmark_status = 68;
    if (cached_has_bits & 0x00400000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(68, this->_internal_address_home_landmark_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_between_streets = 69;
    if (cached_has_bits & 0x00400000u) {
        target = stream->WriteStringMaybeAliased(69, this->_internal_address_home_between_streets(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_status = 70;
    if (cached_has_bits & 0x00800000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(70, this->_internal_address_home_between_streets_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_admin_level_2 = 71;
    if (cached_has_bits & 0x00800000u) {
        target = stream->WriteStringMaybeAliased(71, this->_internal_address_home_admin_level_2(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_admin_level_2_status = 72;
    if (cached_has_bits & 0x01000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(72, this->_internal_address_home_admin_level_2_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_street_location = 73;
    if (cached_has_bits & 0x01000000u) {
        target = stream->WriteStringMaybeAliased(73, this->_internal_address_home_street_location(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_location_status = 74;
    if (cached_has_bits & 0x02000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(74, this->_internal_address_home_street_location_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_overflow = 75;
    if (cached_has_bits & 0x02000000u) {
        target = stream->WriteStringMaybeAliased(75, this->_internal_address_home_overflow(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_overflow_status = 76;
    if (cached_has_bits & 0x04000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(76, this->_internal_address_home_overflow_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_between_streets_1 = 77;
    if (cached_has_bits & 0x04000000u) {
        target = stream->WriteStringMaybeAliased(77, this->_internal_address_home_between_streets_1(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_1_status = 78;
    if (cached_has_bits & 0x08000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(78, this->_internal_address_home_between_streets_1_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_between_streets_2 = 79;
    if (cached_has_bits & 0x08000000u) {
        target = stream->WriteStringMaybeAliased(79, this->_internal_address_home_between_streets_2(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_2_status = 80;
    if (cached_has_bits & 0x10000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(80, this->_internal_address_home_between_streets_2_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_between_streets_or_landmark = 81;
    if (cached_has_bits & 0x10000000u) {
        target = stream->WriteStringMaybeAliased(81, this->_internal_address_home_between_streets_or_landmark(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_or_landmark_status = 82;
    if (cached_has_bits & 0x20000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(82, this->_internal_address_home_between_streets_or_landmark_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_overflow_and_landmark = 83;
    if (cached_has_bits & 0x20000000u) {
        target = stream->WriteStringMaybeAliased(83, this->_internal_address_home_overflow_and_landmark(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_overflow_and_landmark_status = 84;
    if (cached_has_bits & 0x40000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(84, this->_internal_address_home_overflow_and_landmark_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_apt = 85;
    if (cached_has_bits & 0x40000000u) {
        target = stream->WriteStringMaybeAliased(85, this->_internal_address_home_apt(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_status = 86;
    if (cached_has_bits & 0x80000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(86, this->_internal_address_home_apt_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string address_home_apt_type = 87;
    if (cached_has_bits & 0x80000000u) {
        target = stream->WriteStringMaybeAliased(87, this->_internal_address_home_apt_type(), target);
    }

    cached_has_bits = _impl_._has_bits_[2];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_type_status = 88;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(88, this->_internal_address_home_apt_type_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional string address_home_street_location_and_locality = 89;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(89, this->_internal_address_home_street_location_and_locality(), target);
    }

    cached_has_bits = _impl_._has_bits_[2];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_location_and_locality_status = 90;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(90, this->_internal_address_home_street_location_and_locality_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional string address_home_thoroughfare_number_and_apt = 91;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(91, this->_internal_address_home_thoroughfare_number_and_apt(), target);
    }

    cached_has_bits = _impl_._has_bits_[2];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_number_and_apt_status = 92;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(92, this->_internal_address_home_thoroughfare_number_and_apt_status(), target);
    }

    cached_has_bits = _impl_._has_bits_[1];
    // optional string alternative_full_name = 93;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(93, this->_internal_alternative_full_name(), target);
    }

    // optional string alternative_given_name = 94;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(94, this->_internal_alternative_given_name(), target);
    }

    // optional string alternative_family_name = 95;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(95, this->_internal_alternative_family_name(), target);
    }

    cached_has_bits = _impl_._has_bits_[2];
    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_full_name_status = 96;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(96, this->_internal_alternative_full_name_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_given_name_status = 97;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(97, this->_internal_alternative_given_name_status(), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_family_name_status = 98;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(98, this->_internal_alternative_family_name_status(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.AutofillProfileSpecifics)
    return target;
}

size_t AutofillProfileSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.AutofillProfileSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string name_first = 2;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.name_first_.size());
    for (int i = 0, n = _impl_.name_first_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.name_first_.Get(i));
    }

    // repeated string name_middle = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.name_middle_.size());
    for (int i = 0, n = _impl_.name_middle_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.name_middle_.Get(i));
    }

    // repeated string name_last = 4;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.name_last_.size());
    for (int i = 0, n = _impl_.name_last_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.name_last_.Get(i));
    }

    // repeated string email_address = 5;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.email_address_.size());
    for (int i = 0, n = _impl_.email_address_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.email_address_.Get(i));
    }

    // repeated string phone_home_whole_number = 13;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.phone_home_whole_number_.size());
    for (int i = 0, n = _impl_.phone_home_whole_number_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.phone_home_whole_number_.Get(i));
    }

    // repeated string name_full = 21;
    total_size += 2 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.name_full_.size());
    for (int i = 0, n = _impl_.name_full_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.name_full_.Get(i));
    }

    // repeated string name_last_first = 27;
    total_size += 2 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.name_last_first_.size());
    for (int i = 0, n = _impl_.name_last_first_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.name_last_first_.Get(i));
    }

    // repeated string name_last_conjunction = 28;
    total_size += 2 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.name_last_conjunction_.size());
    for (int i = 0, n = _impl_.name_last_conjunction_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.name_last_conjunction_.Get(i));
    }

    // repeated string name_last_second = 29;
    total_size += 2 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.name_last_second_.size());
    for (int i = 0, n = _impl_.name_last_second_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.name_last_second_.Get(i));
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_first_status = 31;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_name_first_status_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_name_first_status(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_middle_status = 32;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_name_middle_status_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_name_middle_status(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_status = 33;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_name_last_status_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_name_last_status(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_first_status = 34;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_name_last_first_status_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_name_last_first_status(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_conjunction_status = 35;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_name_last_conjunction_status_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_name_last_conjunction_status(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_last_second_status = 36;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_name_last_second_status_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_name_last_second_status(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    // repeated .sync_pb.AutofillProfileSpecifics.VerificationStatus name_full_status = 37;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_name_full_status_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_name_full_status(static_cast<int>(i)));
        }
        total_size += (2UL * count) + data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string deprecated_label = 1 [deprecated = true];
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_deprecated_label());
        }

        // optional string company_name = 6;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_company_name());
        }

        // optional string address_home_line1 = 7;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_line1());
        }

        // optional string address_home_line2 = 8;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_line2());
        }

        // optional string address_home_city = 9;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_city());
        }

        // optional string address_home_state = 10;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_state());
        }

        // optional string address_home_zip = 11;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_zip());
        }

        // optional string address_home_country = 12;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_country());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional string phone_fax_whole_number = 14 [deprecated = true];
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_phone_fax_whole_number());
        }

        // optional string guid = 15;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_guid());
        }

        // optional string deprecated_origin = 16;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_deprecated_origin());
        }

        // optional string address_home_street_address = 17;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_street_address());
        }

        // optional string address_home_sorting_code = 18;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_sorting_code());
        }

        // optional string address_home_dependent_locality = 19;
        if (cached_has_bits & 0x00002000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_dependent_locality());
        }

        // optional string address_home_language_code = 20;
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_language_code());
        }

        // optional string address_home_thoroughfare_name = 38;
        if (cached_has_bits & 0x00008000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_thoroughfare_name());
        }
    }
    if (cached_has_bits & 0x00ff0000u) {
        // optional string address_home_thoroughfare_number = 39;
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_thoroughfare_number());
        }

        // optional string address_home_subpremise_name = 42;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_subpremise_name());
        }

        // optional string address_home_apt_num = 56;
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_apt_num());
        }

        // optional string address_home_floor = 57;
        if (cached_has_bits & 0x00080000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_floor());
        }

        // optional string profile_label = 62;
        if (cached_has_bits & 0x00100000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_profile_label());
        }

        // optional string address_home_landmark = 67;
        if (cached_has_bits & 0x00200000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_landmark());
        }

        // optional string address_home_between_streets = 69;
        if (cached_has_bits & 0x00400000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_between_streets());
        }

        // optional string address_home_admin_level_2 = 71;
        if (cached_has_bits & 0x00800000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_admin_level_2());
        }
    }
    if (cached_has_bits & 0xff000000u) {
        // optional string address_home_street_location = 73;
        if (cached_has_bits & 0x01000000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_street_location());
        }

        // optional string address_home_overflow = 75;
        if (cached_has_bits & 0x02000000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_overflow());
        }

        // optional string address_home_between_streets_1 = 77;
        if (cached_has_bits & 0x04000000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_between_streets_1());
        }

        // optional string address_home_between_streets_2 = 79;
        if (cached_has_bits & 0x08000000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_between_streets_2());
        }

        // optional string address_home_between_streets_or_landmark = 81;
        if (cached_has_bits & 0x10000000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_between_streets_or_landmark());
        }

        // optional string address_home_overflow_and_landmark = 83;
        if (cached_has_bits & 0x20000000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_overflow_and_landmark());
        }

        // optional string address_home_apt = 85;
        if (cached_has_bits & 0x40000000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_apt());
        }

        // optional string address_home_apt_type = 87;
        if (cached_has_bits & 0x80000000u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_apt_type());
        }
    }
    cached_has_bits = _impl_._has_bits_[1];
    if (cached_has_bits & 0x000000ffu) {
        // optional string address_home_street_location_and_locality = 89;
        if (cached_has_bits & 0x00000001u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_street_location_and_locality());
        }

        // optional string address_home_thoroughfare_number_and_apt = 91;
        if (cached_has_bits & 0x00000002u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_home_thoroughfare_number_and_apt());
        }

        // optional string alternative_full_name = 93;
        if (cached_has_bits & 0x00000004u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_alternative_full_name());
        }

        // optional string alternative_given_name = 94;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_alternative_given_name());
        }

        // optional string alternative_family_name = 95;
        if (cached_has_bits & 0x00000010u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_alternative_family_name());
        }

        // optional int64 use_count = 22;
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_use_count());
        }

        // optional int64 use_date = 23;
        if (cached_has_bits & 0x00000040u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_use_date());
        }

        // optional int64 validity_state_bitfield = 24 [deprecated = true];
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_validity_state_bitfield());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional bool is_client_validity_states_updated = 25 [deprecated = true];
        if (cached_has_bits & 0x00000100u) {
            total_size += 2 + 1;
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_city_status = 43;
        if (cached_has_bits & 0x00000200u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_city_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_state_status = 44;
        if (cached_has_bits & 0x00000400u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_state_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_zip_status = 45;
        if (cached_has_bits & 0x00000800u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_zip_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_country_status = 46;
        if (cached_has_bits & 0x00001000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_country_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_address_status = 47;
        if (cached_has_bits & 0x00002000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_street_address_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_sorting_code_status = 48;
        if (cached_has_bits & 0x00004000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_sorting_code_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_dependent_locality_status = 49;
        if (cached_has_bits & 0x00008000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_dependent_locality_status());
        }
    }
    if (cached_has_bits & 0x00ff0000u) {
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_language_code_status = 50;
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_language_code_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_name_status = 51;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_thoroughfare_name_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_number_status = 52;
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_thoroughfare_number_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_subpremise_name_status = 55;
        if (cached_has_bits & 0x00080000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_subpremise_name_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_num_status = 58;
        if (cached_has_bits & 0x00100000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_apt_num_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_floor_status = 59;
        if (cached_has_bits & 0x00200000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_floor_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_landmark_status = 68;
        if (cached_has_bits & 0x00400000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_landmark_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_status = 70;
        if (cached_has_bits & 0x00800000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_between_streets_status());
        }
    }
    if (cached_has_bits & 0xff000000u) {
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_admin_level_2_status = 72;
        if (cached_has_bits & 0x01000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_admin_level_2_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_location_status = 74;
        if (cached_has_bits & 0x02000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_street_location_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_overflow_status = 76;
        if (cached_has_bits & 0x04000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_overflow_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_1_status = 78;
        if (cached_has_bits & 0x08000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_between_streets_1_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_2_status = 80;
        if (cached_has_bits & 0x10000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_between_streets_2_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_between_streets_or_landmark_status = 82;
        if (cached_has_bits & 0x20000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_between_streets_or_landmark_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_overflow_and_landmark_status = 84;
        if (cached_has_bits & 0x40000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_overflow_and_landmark_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_status = 86;
        if (cached_has_bits & 0x80000000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_apt_status());
        }
    }
    cached_has_bits = _impl_._has_bits_[2];
    if (cached_has_bits & 0x0000003fu) {
        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_apt_type_status = 88;
        if (cached_has_bits & 0x00000001u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_apt_type_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_street_location_and_locality_status = 90;
        if (cached_has_bits & 0x00000002u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_street_location_and_locality_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus address_home_thoroughfare_number_and_apt_status = 92;
        if (cached_has_bits & 0x00000004u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_address_home_thoroughfare_number_and_apt_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_full_name_status = 96;
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_alternative_full_name_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_given_name_status = 97;
        if (cached_has_bits & 0x00000010u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_alternative_given_name_status());
        }

        // optional .sync_pb.AutofillProfileSpecifics.VerificationStatus alternative_family_name_status = 98;
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_alternative_family_name_status());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillProfileSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillProfileSpecifics*>(&from));
}

void AutofillProfileSpecifics::MergeFrom(const AutofillProfileSpecifics& from)
{
    AutofillProfileSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.AutofillProfileSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.name_first_.MergeFrom(from._impl_.name_first_);
    _this->_impl_.name_middle_.MergeFrom(from._impl_.name_middle_);
    _this->_impl_.name_last_.MergeFrom(from._impl_.name_last_);
    _this->_impl_.email_address_.MergeFrom(from._impl_.email_address_);
    _this->_impl_.phone_home_whole_number_.MergeFrom(from._impl_.phone_home_whole_number_);
    _this->_impl_.name_full_.MergeFrom(from._impl_.name_full_);
    _this->_impl_.name_last_first_.MergeFrom(from._impl_.name_last_first_);
    _this->_impl_.name_last_conjunction_.MergeFrom(from._impl_.name_last_conjunction_);
    _this->_impl_.name_last_second_.MergeFrom(from._impl_.name_last_second_);
    _this->_impl_.name_first_status_.MergeFrom(from._impl_.name_first_status_);
    _this->_impl_.name_middle_status_.MergeFrom(from._impl_.name_middle_status_);
    _this->_impl_.name_last_status_.MergeFrom(from._impl_.name_last_status_);
    _this->_impl_.name_last_first_status_.MergeFrom(from._impl_.name_last_first_status_);
    _this->_impl_.name_last_conjunction_status_.MergeFrom(from._impl_.name_last_conjunction_status_);
    _this->_impl_.name_last_second_status_.MergeFrom(from._impl_.name_last_second_status_);
    _this->_impl_.name_full_status_.MergeFrom(from._impl_.name_full_status_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_deprecated_label(from._internal_deprecated_label());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_company_name(from._internal_company_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_address_home_line1(from._internal_address_home_line1());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_address_home_line2(from._internal_address_home_line2());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_address_home_city(from._internal_address_home_city());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_address_home_state(from._internal_address_home_state());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_address_home_zip(from._internal_address_home_zip());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_set_address_home_country(from._internal_address_home_country());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_set_phone_fax_whole_number(from._internal_phone_fax_whole_number());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_set_guid(from._internal_guid());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_set_deprecated_origin(from._internal_deprecated_origin());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_internal_set_address_home_street_address(from._internal_address_home_street_address());
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_internal_set_address_home_sorting_code(from._internal_address_home_sorting_code());
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_internal_set_address_home_dependent_locality(from._internal_address_home_dependent_locality());
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_internal_set_address_home_language_code(from._internal_address_home_language_code());
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_internal_set_address_home_thoroughfare_name(from._internal_address_home_thoroughfare_name());
        }
    }
    if (cached_has_bits & 0x00ff0000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_internal_set_address_home_thoroughfare_number(from._internal_address_home_thoroughfare_number());
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_internal_set_address_home_subpremise_name(from._internal_address_home_subpremise_name());
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_internal_set_address_home_apt_num(from._internal_address_home_apt_num());
        }
        if (cached_has_bits & 0x00080000u) {
            _this->_internal_set_address_home_floor(from._internal_address_home_floor());
        }
        if (cached_has_bits & 0x00100000u) {
            _this->_internal_set_profile_label(from._internal_profile_label());
        }
        if (cached_has_bits & 0x00200000u) {
            _this->_internal_set_address_home_landmark(from._internal_address_home_landmark());
        }
        if (cached_has_bits & 0x00400000u) {
            _this->_internal_set_address_home_between_streets(from._internal_address_home_between_streets());
        }
        if (cached_has_bits & 0x00800000u) {
            _this->_internal_set_address_home_admin_level_2(from._internal_address_home_admin_level_2());
        }
    }
    if (cached_has_bits & 0xff000000u) {
        if (cached_has_bits & 0x01000000u) {
            _this->_internal_set_address_home_street_location(from._internal_address_home_street_location());
        }
        if (cached_has_bits & 0x02000000u) {
            _this->_internal_set_address_home_overflow(from._internal_address_home_overflow());
        }
        if (cached_has_bits & 0x04000000u) {
            _this->_internal_set_address_home_between_streets_1(from._internal_address_home_between_streets_1());
        }
        if (cached_has_bits & 0x08000000u) {
            _this->_internal_set_address_home_between_streets_2(from._internal_address_home_between_streets_2());
        }
        if (cached_has_bits & 0x10000000u) {
            _this->_internal_set_address_home_between_streets_or_landmark(from._internal_address_home_between_streets_or_landmark());
        }
        if (cached_has_bits & 0x20000000u) {
            _this->_internal_set_address_home_overflow_and_landmark(from._internal_address_home_overflow_and_landmark());
        }
        if (cached_has_bits & 0x40000000u) {
            _this->_internal_set_address_home_apt(from._internal_address_home_apt());
        }
        if (cached_has_bits & 0x80000000u) {
            _this->_internal_set_address_home_apt_type(from._internal_address_home_apt_type());
        }
    }
    cached_has_bits = from._impl_._has_bits_[1];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_address_home_street_location_and_locality(from._internal_address_home_street_location_and_locality());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_address_home_thoroughfare_number_and_apt(from._internal_address_home_thoroughfare_number_and_apt());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_alternative_full_name(from._internal_alternative_full_name());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_alternative_given_name(from._internal_alternative_given_name());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_alternative_family_name(from._internal_alternative_family_name());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.use_count_ = from._impl_.use_count_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.use_date_ = from._impl_.use_date_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.validity_state_bitfield_ = from._impl_.validity_state_bitfield_;
        }
        _this->_impl_._has_bits_[1] |= cached_has_bits;
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.is_client_validity_states_updated_ = from._impl_.is_client_validity_states_updated_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.address_home_city_status_ = from._impl_.address_home_city_status_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.address_home_state_status_ = from._impl_.address_home_state_status_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.address_home_zip_status_ = from._impl_.address_home_zip_status_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.address_home_country_status_ = from._impl_.address_home_country_status_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.address_home_street_address_status_ = from._impl_.address_home_street_address_status_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.address_home_sorting_code_status_ = from._impl_.address_home_sorting_code_status_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.address_home_dependent_locality_status_ = from._impl_.address_home_dependent_locality_status_;
        }
        _this->_impl_._has_bits_[1] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00ff0000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.address_home_language_code_status_ = from._impl_.address_home_language_code_status_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.address_home_thoroughfare_name_status_ = from._impl_.address_home_thoroughfare_name_status_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.address_home_thoroughfare_number_status_ = from._impl_.address_home_thoroughfare_number_status_;
        }
        if (cached_has_bits & 0x00080000u) {
            _this->_impl_.address_home_subpremise_name_status_ = from._impl_.address_home_subpremise_name_status_;
        }
        if (cached_has_bits & 0x00100000u) {
            _this->_impl_.address_home_apt_num_status_ = from._impl_.address_home_apt_num_status_;
        }
        if (cached_has_bits & 0x00200000u) {
            _this->_impl_.address_home_floor_status_ = from._impl_.address_home_floor_status_;
        }
        if (cached_has_bits & 0x00400000u) {
            _this->_impl_.address_home_landmark_status_ = from._impl_.address_home_landmark_status_;
        }
        if (cached_has_bits & 0x00800000u) {
            _this->_impl_.address_home_between_streets_status_ = from._impl_.address_home_between_streets_status_;
        }
        _this->_impl_._has_bits_[1] |= cached_has_bits;
    }
    if (cached_has_bits & 0xff000000u) {
        if (cached_has_bits & 0x01000000u) {
            _this->_impl_.address_home_admin_level_2_status_ = from._impl_.address_home_admin_level_2_status_;
        }
        if (cached_has_bits & 0x02000000u) {
            _this->_impl_.address_home_street_location_status_ = from._impl_.address_home_street_location_status_;
        }
        if (cached_has_bits & 0x04000000u) {
            _this->_impl_.address_home_overflow_status_ = from._impl_.address_home_overflow_status_;
        }
        if (cached_has_bits & 0x08000000u) {
            _this->_impl_.address_home_between_streets_1_status_ = from._impl_.address_home_between_streets_1_status_;
        }
        if (cached_has_bits & 0x10000000u) {
            _this->_impl_.address_home_between_streets_2_status_ = from._impl_.address_home_between_streets_2_status_;
        }
        if (cached_has_bits & 0x20000000u) {
            _this->_impl_.address_home_between_streets_or_landmark_status_ = from._impl_.address_home_between_streets_or_landmark_status_;
        }
        if (cached_has_bits & 0x40000000u) {
            _this->_impl_.address_home_overflow_and_landmark_status_ = from._impl_.address_home_overflow_and_landmark_status_;
        }
        if (cached_has_bits & 0x80000000u) {
            _this->_impl_.address_home_apt_status_ = from._impl_.address_home_apt_status_;
        }
        _this->_impl_._has_bits_[1] |= cached_has_bits;
    }
    cached_has_bits = from._impl_._has_bits_[2];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.address_home_apt_type_status_ = from._impl_.address_home_apt_type_status_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.address_home_street_location_and_locality_status_ = from._impl_.address_home_street_location_and_locality_status_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.address_home_thoroughfare_number_and_apt_status_ = from._impl_.address_home_thoroughfare_number_and_apt_status_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.alternative_full_name_status_ = from._impl_.alternative_full_name_status_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.alternative_given_name_status_ = from._impl_.alternative_given_name_status_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.alternative_family_name_status_ = from._impl_.alternative_family_name_status_;
        }
        _this->_impl_._has_bits_[2] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillProfileSpecifics::CopyFrom(const AutofillProfileSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.AutofillProfileSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillProfileSpecifics::IsInitialized() const
{
    return true;
}

void AutofillProfileSpecifics::InternalSwap(AutofillProfileSpecifics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_._has_bits_[1], other->_impl_._has_bits_[1]);
    swap(_impl_._has_bits_[2], other->_impl_._has_bits_[2]);
    _impl_.name_first_.InternalSwap(&other->_impl_.name_first_);
    _impl_.name_middle_.InternalSwap(&other->_impl_.name_middle_);
    _impl_.name_last_.InternalSwap(&other->_impl_.name_last_);
    _impl_.email_address_.InternalSwap(&other->_impl_.email_address_);
    _impl_.phone_home_whole_number_.InternalSwap(&other->_impl_.phone_home_whole_number_);
    _impl_.name_full_.InternalSwap(&other->_impl_.name_full_);
    _impl_.name_last_first_.InternalSwap(&other->_impl_.name_last_first_);
    _impl_.name_last_conjunction_.InternalSwap(&other->_impl_.name_last_conjunction_);
    _impl_.name_last_second_.InternalSwap(&other->_impl_.name_last_second_);
    _impl_.name_first_status_.InternalSwap(&other->_impl_.name_first_status_);
    _impl_.name_middle_status_.InternalSwap(&other->_impl_.name_middle_status_);
    _impl_.name_last_status_.InternalSwap(&other->_impl_.name_last_status_);
    _impl_.name_last_first_status_.InternalSwap(&other->_impl_.name_last_first_status_);
    _impl_.name_last_conjunction_status_.InternalSwap(&other->_impl_.name_last_conjunction_status_);
    _impl_.name_last_second_status_.InternalSwap(&other->_impl_.name_last_second_status_);
    _impl_.name_full_status_.InternalSwap(&other->_impl_.name_full_status_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.deprecated_label_, lhs_arena, &other->_impl_.deprecated_label_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.company_name_, lhs_arena, &other->_impl_.company_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_line1_, lhs_arena, &other->_impl_.address_home_line1_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_line2_, lhs_arena, &other->_impl_.address_home_line2_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_city_, lhs_arena, &other->_impl_.address_home_city_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_state_, lhs_arena, &other->_impl_.address_home_state_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_zip_, lhs_arena, &other->_impl_.address_home_zip_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_country_, lhs_arena, &other->_impl_.address_home_country_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.phone_fax_whole_number_, lhs_arena, &other->_impl_.phone_fax_whole_number_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.guid_, lhs_arena, &other->_impl_.guid_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.deprecated_origin_, lhs_arena, &other->_impl_.deprecated_origin_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_street_address_, lhs_arena, &other->_impl_.address_home_street_address_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_sorting_code_, lhs_arena, &other->_impl_.address_home_sorting_code_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_dependent_locality_, lhs_arena, &other->_impl_.address_home_dependent_locality_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_language_code_, lhs_arena, &other->_impl_.address_home_language_code_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_thoroughfare_name_, lhs_arena, &other->_impl_.address_home_thoroughfare_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_thoroughfare_number_, lhs_arena, &other->_impl_.address_home_thoroughfare_number_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_subpremise_name_, lhs_arena, &other->_impl_.address_home_subpremise_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_apt_num_, lhs_arena, &other->_impl_.address_home_apt_num_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_floor_, lhs_arena, &other->_impl_.address_home_floor_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.profile_label_, lhs_arena, &other->_impl_.profile_label_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_landmark_, lhs_arena, &other->_impl_.address_home_landmark_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_between_streets_, lhs_arena, &other->_impl_.address_home_between_streets_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_admin_level_2_, lhs_arena, &other->_impl_.address_home_admin_level_2_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_street_location_, lhs_arena, &other->_impl_.address_home_street_location_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_overflow_, lhs_arena, &other->_impl_.address_home_overflow_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_between_streets_1_, lhs_arena, &other->_impl_.address_home_between_streets_1_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_between_streets_2_, lhs_arena, &other->_impl_.address_home_between_streets_2_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_between_streets_or_landmark_, lhs_arena, &other->_impl_.address_home_between_streets_or_landmark_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_overflow_and_landmark_, lhs_arena, &other->_impl_.address_home_overflow_and_landmark_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_home_apt_, lhs_arena, &other->_impl_.address_home_apt_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_apt_type_, lhs_arena, &other->_impl_.address_home_apt_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_street_location_and_locality_, lhs_arena, &other->_impl_.address_home_street_location_and_locality_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.address_home_thoroughfare_number_and_apt_, lhs_arena, &other->_impl_.address_home_thoroughfare_number_and_apt_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.alternative_full_name_, lhs_arena, &other->_impl_.alternative_full_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.alternative_given_name_, lhs_arena, &other->_impl_.alternative_given_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.alternative_family_name_, lhs_arena, &other->_impl_.alternative_family_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AutofillProfileSpecifics, _impl_.alternative_family_name_status_)
        + sizeof(AutofillProfileSpecifics::_impl_.alternative_family_name_status_) - PROTOBUF_FIELD_OFFSET(AutofillProfileSpecifics, _impl_.use_count_)>(
        reinterpret_cast<char*>(&_impl_.use_count_), reinterpret_cast<char*>(&other->_impl_.use_count_));
}

std::string AutofillProfileSpecifics::GetTypeName() const
{
    return "sync_pb.AutofillProfileSpecifics";
}

// ===================================================================

class AutofillSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillSpecifics>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_value(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::AutofillProfileSpecifics& profile(const AutofillSpecifics* msg);
    static void set_has_profile(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::sync_pb::AutofillProfileSpecifics& AutofillSpecifics::_Internal::profile(const AutofillSpecifics* msg)
{
    return *msg->_impl_.profile_;
}
AutofillSpecifics::AutofillSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.AutofillSpecifics)
}
AutofillSpecifics::AutofillSpecifics(const AutofillSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.usage_timestamp_) { from._impl_.usage_timestamp_ }, decltype(_impl_.name_) {}, decltype(_impl_.value_) {},
        decltype(_impl_.profile_) { nullptr } };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_value()) {
        _this->_impl_.value_.Set(from._internal_value(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_profile()) {
        _this->_impl_.profile_ = new ::sync_pb::AutofillProfileSpecifics(*from._impl_.profile_);
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.AutofillSpecifics)
}

inline void AutofillSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.usage_timestamp_) { arena },
        decltype(_impl_.name_) {}, decltype(_impl_.value_) {}, decltype(_impl_.profile_) { nullptr } };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AutofillSpecifics::~AutofillSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.AutofillSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.usage_timestamp_.~RepeatedField();
    _impl_.name_.Destroy();
    _impl_.value_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.profile_;
}

void AutofillSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.AutofillSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.usage_timestamp_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.value_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.profile_ != nullptr);
            _impl_.profile_->Clear();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int64 usage_timestamp = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_usage_timestamp(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
            } else if (static_cast<uint8_t>(tag) == 26) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_usage_timestamp(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.AutofillProfileSpecifics profile = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_profile(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.AutofillSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_value(), target);
    }

    // repeated int64 usage_timestamp = 3;
    for (int i = 0, n = this->_internal_usage_timestamp_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_usage_timestamp(i), target);
    }

    // optional .sync_pb.AutofillProfileSpecifics profile = 4;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::profile(this), _Internal::profile(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.AutofillSpecifics)
    return target;
}

size_t AutofillSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.AutofillSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int64 usage_timestamp = 3;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int64Size(this->_impl_.usage_timestamp_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_usage_timestamp_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
        }

        // optional string value = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_value());
        }

        // optional .sync_pb.AutofillProfileSpecifics profile = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.profile_);
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillSpecifics*>(&from));
}

void AutofillSpecifics::MergeFrom(const AutofillSpecifics& from)
{
    AutofillSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.AutofillSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.usage_timestamp_.MergeFrom(from._impl_.usage_timestamp_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_name(from._internal_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_value(from._internal_value());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_profile()->::sync_pb::AutofillProfileSpecifics::MergeFrom(from._internal_profile());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillSpecifics::CopyFrom(const AutofillSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.AutofillSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillSpecifics::IsInitialized() const
{
    return true;
}

void AutofillSpecifics::InternalSwap(AutofillSpecifics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.usage_timestamp_.InternalSwap(&other->_impl_.usage_timestamp_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.value_, lhs_arena, &other->_impl_.value_, rhs_arena);
    swap(_impl_.profile_, other->_impl_.profile_);
}

std::string AutofillSpecifics::GetTypeName() const
{
    return "sync_pb.AutofillSpecifics";
}

// ===================================================================

class CloudTokenData::_Internal {
public:
    using HasBits = decltype(std::declval<CloudTokenData>()._impl_._has_bits_);
    static void set_has_suffix(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_exp_month(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_exp_year(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_art_fife_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_instrument_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

CloudTokenData::CloudTokenData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CloudTokenData)
}
CloudTokenData::CloudTokenData(const CloudTokenData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CloudTokenData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.suffix_) {},
        decltype(_impl_.art_fife_url_) {}, decltype(_impl_.instrument_token_) {}, decltype(_impl_.exp_month_) {}, decltype(_impl_.exp_year_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_suffix()) {
        _this->_impl_.suffix_.Set(from._internal_suffix(), _this->GetArenaForAllocation());
    }
    _impl_.art_fife_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_fife_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_art_fife_url()) {
        _this->_impl_.art_fife_url_.Set(from._internal_art_fife_url(), _this->GetArenaForAllocation());
    }
    _impl_.instrument_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instrument_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_instrument_token()) {
        _this->_impl_.instrument_token_.Set(from._internal_instrument_token(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.exp_month_, &from._impl_.exp_month_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.exp_year_) - reinterpret_cast<char*>(&_impl_.exp_month_)) + sizeof(_impl_.exp_year_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.CloudTokenData)
}

inline void CloudTokenData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.suffix_) {}, decltype(_impl_.art_fife_url_) {},
        decltype(_impl_.instrument_token_) {}, decltype(_impl_.exp_month_) { 0 }, decltype(_impl_.exp_year_) { 0 } };
    _impl_.suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_fife_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_fife_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instrument_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instrument_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CloudTokenData::~CloudTokenData()
{
    // @@protoc_insertion_point(destructor:sync_pb.CloudTokenData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CloudTokenData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.suffix_.Destroy();
    _impl_.art_fife_url_.Destroy();
    _impl_.instrument_token_.Destroy();
}

void CloudTokenData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CloudTokenData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CloudTokenData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.suffix_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.art_fife_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.instrument_token_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000018u) {
        ::memset(&_impl_.exp_month_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.exp_year_) - reinterpret_cast<char*>(&_impl_.exp_month_)) + sizeof(_impl_.exp_year_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CloudTokenData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string suffix = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_suffix();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 exp_month = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_exp_month(&has_bits);
                _impl_.exp_month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 exp_year = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_exp_year(&has_bits);
                _impl_.exp_year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string art_fife_url = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_art_fife_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string instrument_token = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_instrument_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CloudTokenData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CloudTokenData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string suffix = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_suffix(), target);
    }

    // optional int32 exp_month = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_exp_month(), target);
    }

    // optional int32 exp_year = 3;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_exp_year(), target);
    }

    // optional string art_fife_url = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_art_fife_url(), target);
    }

    // optional string instrument_token = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_instrument_token(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CloudTokenData)
    return target;
}

size_t CloudTokenData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CloudTokenData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string suffix = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_suffix());
        }

        // optional string art_fife_url = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_art_fife_url());
        }

        // optional string instrument_token = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_instrument_token());
        }

        // optional int32 exp_month = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exp_month());
        }

        // optional int32 exp_year = 3;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exp_year());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CloudTokenData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CloudTokenData*>(&from));
}

void CloudTokenData::MergeFrom(const CloudTokenData& from)
{
    CloudTokenData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CloudTokenData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_suffix(from._internal_suffix());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_art_fife_url(from._internal_art_fife_url());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_instrument_token(from._internal_instrument_token());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.exp_month_ = from._impl_.exp_month_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.exp_year_ = from._impl_.exp_year_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CloudTokenData::CopyFrom(const CloudTokenData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CloudTokenData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CloudTokenData::IsInitialized() const
{
    return true;
}

void CloudTokenData::InternalSwap(CloudTokenData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.suffix_, lhs_arena, &other->_impl_.suffix_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.art_fife_url_, lhs_arena, &other->_impl_.art_fife_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.instrument_token_, lhs_arena, &other->_impl_.instrument_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CloudTokenData, _impl_.exp_year_) + sizeof(CloudTokenData::_impl_.exp_year_)
        - PROTOBUF_FIELD_OFFSET(CloudTokenData, _impl_.exp_month_)>(
        reinterpret_cast<char*>(&_impl_.exp_month_), reinterpret_cast<char*>(&other->_impl_.exp_month_));
}

std::string CloudTokenData::GetTypeName() const
{
    return "sync_pb.CloudTokenData";
}

// ===================================================================

class CardBenefit_FlatRateBenefit::_Internal {
public:
};

CardBenefit_FlatRateBenefit::CardBenefit_FlatRateBenefit(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CardBenefit.FlatRateBenefit)
}
CardBenefit_FlatRateBenefit::CardBenefit_FlatRateBenefit(const CardBenefit_FlatRateBenefit& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CardBenefit_FlatRateBenefit* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.CardBenefit.FlatRateBenefit)
}

inline void CardBenefit_FlatRateBenefit::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { /*decltype(_impl_._cached_size_)*/ {} };
}

CardBenefit_FlatRateBenefit::~CardBenefit_FlatRateBenefit()
{
    // @@protoc_insertion_point(destructor:sync_pb.CardBenefit.FlatRateBenefit)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CardBenefit_FlatRateBenefit::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CardBenefit_FlatRateBenefit::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CardBenefit_FlatRateBenefit::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CardBenefit.FlatRateBenefit)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _internal_metadata_.Clear<std::string>();
}

const char* CardBenefit_FlatRateBenefit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CardBenefit_FlatRateBenefit::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CardBenefit.FlatRateBenefit)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CardBenefit.FlatRateBenefit)
    return target;
}

size_t CardBenefit_FlatRateBenefit::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CardBenefit.FlatRateBenefit)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CardBenefit_FlatRateBenefit::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CardBenefit_FlatRateBenefit*>(&from));
}

void CardBenefit_FlatRateBenefit::MergeFrom(const CardBenefit_FlatRateBenefit& from)
{
    CardBenefit_FlatRateBenefit* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CardBenefit.FlatRateBenefit)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CardBenefit_FlatRateBenefit::CopyFrom(const CardBenefit_FlatRateBenefit& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CardBenefit.FlatRateBenefit)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CardBenefit_FlatRateBenefit::IsInitialized() const
{
    return true;
}

void CardBenefit_FlatRateBenefit::InternalSwap(CardBenefit_FlatRateBenefit* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string CardBenefit_FlatRateBenefit::GetTypeName() const
{
    return "sync_pb.CardBenefit.FlatRateBenefit";
}

// ===================================================================

class CardBenefit_CategoryBenefit::_Internal {
public:
    using HasBits = decltype(std::declval<CardBenefit_CategoryBenefit>()._impl_._has_bits_);
    static void set_has_category_benefit_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

CardBenefit_CategoryBenefit::CardBenefit_CategoryBenefit(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CardBenefit.CategoryBenefit)
}
CardBenefit_CategoryBenefit::CardBenefit_CategoryBenefit(const CardBenefit_CategoryBenefit& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CardBenefit_CategoryBenefit* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.category_benefit_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.category_benefit_type_ = from._impl_.category_benefit_type_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.CardBenefit.CategoryBenefit)
}

inline void CardBenefit_CategoryBenefit::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.category_benefit_type_) { 0 } };
}

CardBenefit_CategoryBenefit::~CardBenefit_CategoryBenefit()
{
    // @@protoc_insertion_point(destructor:sync_pb.CardBenefit.CategoryBenefit)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CardBenefit_CategoryBenefit::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CardBenefit_CategoryBenefit::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CardBenefit_CategoryBenefit::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CardBenefit.CategoryBenefit)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.category_benefit_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CardBenefit_CategoryBenefit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.CardBenefit.CategoryBenefitType category_benefit_type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::CardBenefit_CategoryBenefitType_IsValid(val))) {
                    _internal_set_category_benefit_type(static_cast<::sync_pb::CardBenefit_CategoryBenefitType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CardBenefit_CategoryBenefit::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CardBenefit.CategoryBenefit)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.CardBenefit.CategoryBenefitType category_benefit_type = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_category_benefit_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CardBenefit.CategoryBenefit)
    return target;
}

size_t CardBenefit_CategoryBenefit::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CardBenefit.CategoryBenefit)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional .sync_pb.CardBenefit.CategoryBenefitType category_benefit_type = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_category_benefit_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CardBenefit_CategoryBenefit::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CardBenefit_CategoryBenefit*>(&from));
}

void CardBenefit_CategoryBenefit::MergeFrom(const CardBenefit_CategoryBenefit& from)
{
    CardBenefit_CategoryBenefit* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CardBenefit.CategoryBenefit)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_category_benefit_type()) {
        _this->_internal_set_category_benefit_type(from._internal_category_benefit_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CardBenefit_CategoryBenefit::CopyFrom(const CardBenefit_CategoryBenefit& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CardBenefit.CategoryBenefit)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CardBenefit_CategoryBenefit::IsInitialized() const
{
    return true;
}

void CardBenefit_CategoryBenefit::InternalSwap(CardBenefit_CategoryBenefit* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.category_benefit_type_, other->_impl_.category_benefit_type_);
}

std::string CardBenefit_CategoryBenefit::GetTypeName() const
{
    return "sync_pb.CardBenefit.CategoryBenefit";
}

// ===================================================================

class CardBenefit_MerchantBenefit::_Internal {
public:
};

CardBenefit_MerchantBenefit::CardBenefit_MerchantBenefit(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CardBenefit.MerchantBenefit)
}
CardBenefit_MerchantBenefit::CardBenefit_MerchantBenefit(const CardBenefit_MerchantBenefit& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CardBenefit_MerchantBenefit* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.merchant_domain_) { from._impl_.merchant_domain_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:sync_pb.CardBenefit.MerchantBenefit)
}

inline void CardBenefit_MerchantBenefit::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.merchant_domain_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

CardBenefit_MerchantBenefit::~CardBenefit_MerchantBenefit()
{
    // @@protoc_insertion_point(destructor:sync_pb.CardBenefit.MerchantBenefit)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CardBenefit_MerchantBenefit::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.merchant_domain_.~RepeatedPtrField();
}

void CardBenefit_MerchantBenefit::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CardBenefit_MerchantBenefit::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CardBenefit.MerchantBenefit)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.merchant_domain_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CardBenefit_MerchantBenefit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string merchant_domain = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_merchant_domain();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CardBenefit_MerchantBenefit::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CardBenefit.MerchantBenefit)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string merchant_domain = 1;
    for (int i = 0, n = this->_internal_merchant_domain_size(); i < n; i++) {
        const auto& s = this->_internal_merchant_domain(i);
        target = stream->WriteString(1, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CardBenefit.MerchantBenefit)
    return target;
}

size_t CardBenefit_MerchantBenefit::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CardBenefit.MerchantBenefit)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string merchant_domain = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.merchant_domain_.size());
    for (int i = 0, n = _impl_.merchant_domain_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.merchant_domain_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CardBenefit_MerchantBenefit::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CardBenefit_MerchantBenefit*>(&from));
}

void CardBenefit_MerchantBenefit::MergeFrom(const CardBenefit_MerchantBenefit& from)
{
    CardBenefit_MerchantBenefit* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CardBenefit.MerchantBenefit)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.merchant_domain_.MergeFrom(from._impl_.merchant_domain_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CardBenefit_MerchantBenefit::CopyFrom(const CardBenefit_MerchantBenefit& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CardBenefit.MerchantBenefit)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CardBenefit_MerchantBenefit::IsInitialized() const
{
    return true;
}

void CardBenefit_MerchantBenefit::InternalSwap(CardBenefit_MerchantBenefit* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.merchant_domain_.InternalSwap(&other->_impl_.merchant_domain_);
}

std::string CardBenefit_MerchantBenefit::GetTypeName() const
{
    return "sync_pb.CardBenefit.MerchantBenefit";
}

// ===================================================================

class CardBenefit::_Internal {
public:
    using HasBits = decltype(std::declval<CardBenefit>()._impl_._has_bits_);
    static void set_has_benefit_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_benefit_description(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_start_time_unix_epoch_milliseconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_end_time_unix_epoch_milliseconds(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::sync_pb::CardBenefit_FlatRateBenefit& flat_rate_benefit(const CardBenefit* msg);
    static const ::sync_pb::CardBenefit_CategoryBenefit& category_benefit(const CardBenefit* msg);
    static const ::sync_pb::CardBenefit_MerchantBenefit& merchant_benefit(const CardBenefit* msg);
};

const ::sync_pb::CardBenefit_FlatRateBenefit& CardBenefit::_Internal::flat_rate_benefit(const CardBenefit* msg)
{
    return *msg->_impl_.DomainSpecificBenefit_.flat_rate_benefit_;
}
const ::sync_pb::CardBenefit_CategoryBenefit& CardBenefit::_Internal::category_benefit(const CardBenefit* msg)
{
    return *msg->_impl_.DomainSpecificBenefit_.category_benefit_;
}
const ::sync_pb::CardBenefit_MerchantBenefit& CardBenefit::_Internal::merchant_benefit(const CardBenefit* msg)
{
    return *msg->_impl_.DomainSpecificBenefit_.merchant_benefit_;
}
void CardBenefit::set_allocated_flat_rate_benefit(::sync_pb::CardBenefit_FlatRateBenefit* flat_rate_benefit)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_DomainSpecificBenefit();
    if (flat_rate_benefit) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(flat_rate_benefit);
        if (message_arena != submessage_arena) {
            flat_rate_benefit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, flat_rate_benefit, submessage_arena);
        }
        set_has_flat_rate_benefit();
        _impl_.DomainSpecificBenefit_.flat_rate_benefit_ = flat_rate_benefit;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CardBenefit.flat_rate_benefit)
}
void CardBenefit::set_allocated_category_benefit(::sync_pb::CardBenefit_CategoryBenefit* category_benefit)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_DomainSpecificBenefit();
    if (category_benefit) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(category_benefit);
        if (message_arena != submessage_arena) {
            category_benefit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, category_benefit, submessage_arena);
        }
        set_has_category_benefit();
        _impl_.DomainSpecificBenefit_.category_benefit_ = category_benefit;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CardBenefit.category_benefit)
}
void CardBenefit::set_allocated_merchant_benefit(::sync_pb::CardBenefit_MerchantBenefit* merchant_benefit)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_DomainSpecificBenefit();
    if (merchant_benefit) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(merchant_benefit);
        if (message_arena != submessage_arena) {
            merchant_benefit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, merchant_benefit, submessage_arena);
        }
        set_has_merchant_benefit();
        _impl_.DomainSpecificBenefit_.merchant_benefit_ = merchant_benefit;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.CardBenefit.merchant_benefit)
}
CardBenefit::CardBenefit(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CardBenefit)
}
CardBenefit::CardBenefit(const CardBenefit& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CardBenefit* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.benefit_description_) {}, decltype(_impl_.benefit_id_) {}, decltype(_impl_.start_time_unix_epoch_milliseconds_) {},
        decltype(_impl_.end_time_unix_epoch_milliseconds_) {}, decltype(_impl_.DomainSpecificBenefit_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.benefit_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.benefit_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_benefit_description()) {
        _this->_impl_.benefit_description_.Set(from._internal_benefit_description(), _this->GetArenaForAllocation());
    }
    _impl_.benefit_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.benefit_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_benefit_id()) {
        _this->_impl_.benefit_id_.Set(from._internal_benefit_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.start_time_unix_epoch_milliseconds_, &from._impl_.start_time_unix_epoch_milliseconds_,
        static_cast<size_t>(
            reinterpret_cast<char*>(&_impl_.end_time_unix_epoch_milliseconds_) - reinterpret_cast<char*>(&_impl_.start_time_unix_epoch_milliseconds_))
            + sizeof(_impl_.end_time_unix_epoch_milliseconds_));
    clear_has_DomainSpecificBenefit();
    switch (from.DomainSpecificBenefit_case()) {
    case kFlatRateBenefit: {
        _this->_internal_mutable_flat_rate_benefit()->::sync_pb::CardBenefit_FlatRateBenefit::MergeFrom(from._internal_flat_rate_benefit());
        break;
    }
    case kCategoryBenefit: {
        _this->_internal_mutable_category_benefit()->::sync_pb::CardBenefit_CategoryBenefit::MergeFrom(from._internal_category_benefit());
        break;
    }
    case kMerchantBenefit: {
        _this->_internal_mutable_merchant_benefit()->::sync_pb::CardBenefit_MerchantBenefit::MergeFrom(from._internal_merchant_benefit());
        break;
    }
    case DOMAINSPECIFICBENEFIT_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.CardBenefit)
}

inline void CardBenefit::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.benefit_description_) {},
        decltype(_impl_.benefit_id_) {}, decltype(_impl_.start_time_unix_epoch_milliseconds_) { int64_t { 0 } },
        decltype(_impl_.end_time_unix_epoch_milliseconds_) { int64_t { 0 } }, decltype(_impl_.DomainSpecificBenefit_) {},
        /*decltype(_impl_._oneof_case_)*/ {} };
    _impl_.benefit_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.benefit_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.benefit_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.benefit_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clear_has_DomainSpecificBenefit();
}

CardBenefit::~CardBenefit()
{
    // @@protoc_insertion_point(destructor:sync_pb.CardBenefit)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CardBenefit::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.benefit_description_.Destroy();
    _impl_.benefit_id_.Destroy();
    if (has_DomainSpecificBenefit()) {
        clear_DomainSpecificBenefit();
    }
}

void CardBenefit::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CardBenefit::clear_DomainSpecificBenefit()
{
    // @@protoc_insertion_point(one_of_clear_start:sync_pb.CardBenefit)
    switch (DomainSpecificBenefit_case()) {
    case kFlatRateBenefit: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.DomainSpecificBenefit_.flat_rate_benefit_;
        }
        break;
    }
    case kCategoryBenefit: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.DomainSpecificBenefit_.category_benefit_;
        }
        break;
    }
    case kMerchantBenefit: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.DomainSpecificBenefit_.merchant_benefit_;
        }
        break;
    }
    case DOMAINSPECIFICBENEFIT_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = DOMAINSPECIFICBENEFIT_NOT_SET;
}

void CardBenefit::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CardBenefit)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.benefit_description_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.benefit_id_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000000cu) {
        ::memset(&_impl_.start_time_unix_epoch_milliseconds_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.end_time_unix_epoch_milliseconds_) - reinterpret_cast<char*>(&_impl_.start_time_unix_epoch_milliseconds_))
                + sizeof(_impl_.end_time_unix_epoch_milliseconds_));
    }
    clear_DomainSpecificBenefit();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CardBenefit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string benefit_description = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_benefit_description();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 start_time_unix_epoch_milliseconds = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_start_time_unix_epoch_milliseconds(&has_bits);
                _impl_.start_time_unix_epoch_milliseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 end_time_unix_epoch_milliseconds = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_end_time_unix_epoch_milliseconds(&has_bits);
                _impl_.end_time_unix_epoch_milliseconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.CardBenefit.FlatRateBenefit flat_rate_benefit = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_flat_rate_benefit(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.CardBenefit.CategoryBenefit category_benefit = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_category_benefit(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.CardBenefit.MerchantBenefit merchant_benefit = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_merchant_benefit(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string benefit_id = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_benefit_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CardBenefit::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CardBenefit)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string benefit_description = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_benefit_description(), target);
    }

    // optional int64 start_time_unix_epoch_milliseconds = 2;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_start_time_unix_epoch_milliseconds(), target);
    }

    // optional int64 end_time_unix_epoch_milliseconds = 3;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_end_time_unix_epoch_milliseconds(), target);
    }

    switch (DomainSpecificBenefit_case()) {
    case kFlatRateBenefit: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::flat_rate_benefit(this), _Internal::flat_rate_benefit(this).GetCachedSize(), target, stream);
        break;
    }
    case kCategoryBenefit: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::category_benefit(this), _Internal::category_benefit(this).GetCachedSize(), target, stream);
        break;
    }
    case kMerchantBenefit: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::merchant_benefit(this), _Internal::merchant_benefit(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    // optional string benefit_id = 7;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_benefit_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CardBenefit)
    return target;
}

size_t CardBenefit::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CardBenefit)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string benefit_description = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_benefit_description());
        }

        // optional string benefit_id = 7;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_benefit_id());
        }

        // optional int64 start_time_unix_epoch_milliseconds = 2;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_time_unix_epoch_milliseconds());
        }

        // optional int64 end_time_unix_epoch_milliseconds = 3;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_time_unix_epoch_milliseconds());
        }
    }
    switch (DomainSpecificBenefit_case()) {
    // .sync_pb.CardBenefit.FlatRateBenefit flat_rate_benefit = 4;
    case kFlatRateBenefit: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.DomainSpecificBenefit_.flat_rate_benefit_);
        break;
    }
    // .sync_pb.CardBenefit.CategoryBenefit category_benefit = 5;
    case kCategoryBenefit: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.DomainSpecificBenefit_.category_benefit_);
        break;
    }
    // .sync_pb.CardBenefit.MerchantBenefit merchant_benefit = 6;
    case kMerchantBenefit: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.DomainSpecificBenefit_.merchant_benefit_);
        break;
    }
    case DOMAINSPECIFICBENEFIT_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CardBenefit::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CardBenefit*>(&from));
}

void CardBenefit::MergeFrom(const CardBenefit& from)
{
    CardBenefit* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CardBenefit)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_benefit_description(from._internal_benefit_description());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_benefit_id(from._internal_benefit_id());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.start_time_unix_epoch_milliseconds_ = from._impl_.start_time_unix_epoch_milliseconds_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.end_time_unix_epoch_milliseconds_ = from._impl_.end_time_unix_epoch_milliseconds_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    switch (from.DomainSpecificBenefit_case()) {
    case kFlatRateBenefit: {
        _this->_internal_mutable_flat_rate_benefit()->::sync_pb::CardBenefit_FlatRateBenefit::MergeFrom(from._internal_flat_rate_benefit());
        break;
    }
    case kCategoryBenefit: {
        _this->_internal_mutable_category_benefit()->::sync_pb::CardBenefit_CategoryBenefit::MergeFrom(from._internal_category_benefit());
        break;
    }
    case kMerchantBenefit: {
        _this->_internal_mutable_merchant_benefit()->::sync_pb::CardBenefit_MerchantBenefit::MergeFrom(from._internal_merchant_benefit());
        break;
    }
    case DOMAINSPECIFICBENEFIT_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CardBenefit::CopyFrom(const CardBenefit& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CardBenefit)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CardBenefit::IsInitialized() const
{
    return true;
}

void CardBenefit::InternalSwap(CardBenefit* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.benefit_description_, lhs_arena, &other->_impl_.benefit_description_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.benefit_id_, lhs_arena, &other->_impl_.benefit_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CardBenefit, _impl_.end_time_unix_epoch_milliseconds_)
        + sizeof(CardBenefit::_impl_.end_time_unix_epoch_milliseconds_) - PROTOBUF_FIELD_OFFSET(CardBenefit, _impl_.start_time_unix_epoch_milliseconds_)>(
        reinterpret_cast<char*>(&_impl_.start_time_unix_epoch_milliseconds_), reinterpret_cast<char*>(&other->_impl_.start_time_unix_epoch_milliseconds_));
    swap(_impl_.DomainSpecificBenefit_, other->_impl_.DomainSpecificBenefit_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string CardBenefit::GetTypeName() const
{
    return "sync_pb.CardBenefit";
}

// ===================================================================

class CardIssuer::_Internal {
public:
    using HasBits = decltype(std::declval<CardIssuer>()._impl_._has_bits_);
    static void set_has_issuer(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_issuer_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

CardIssuer::CardIssuer(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.CardIssuer)
}
CardIssuer::CardIssuer(const CardIssuer& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CardIssuer* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.issuer_id_) {},
        decltype(_impl_.issuer_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.issuer_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuer_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_issuer_id()) {
        _this->_impl_.issuer_id_.Set(from._internal_issuer_id(), _this->GetArenaForAllocation());
    }
    _this->_impl_.issuer_ = from._impl_.issuer_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.CardIssuer)
}

inline void CardIssuer::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.issuer_id_) {}, decltype(_impl_.issuer_) { 0 } };
    _impl_.issuer_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuer_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CardIssuer::~CardIssuer()
{
    // @@protoc_insertion_point(destructor:sync_pb.CardIssuer)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CardIssuer::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.issuer_id_.Destroy();
}

void CardIssuer::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CardIssuer::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.CardIssuer)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.issuer_id_.ClearNonDefaultToEmpty();
    }
    _impl_.issuer_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* CardIssuer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.CardIssuer.Issuer issuer = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::CardIssuer_Issuer_IsValid(val))) {
                    _internal_set_issuer(static_cast<::sync_pb::CardIssuer_Issuer>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string issuer_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_issuer_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CardIssuer::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CardIssuer)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.CardIssuer.Issuer issuer = 1;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_issuer(), target);
    }

    // optional string issuer_id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_issuer_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CardIssuer)
    return target;
}

size_t CardIssuer::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.CardIssuer)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string issuer_id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_issuer_id());
        }

        // optional .sync_pb.CardIssuer.Issuer issuer = 1;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_issuer());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CardIssuer::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CardIssuer*>(&from));
}

void CardIssuer::MergeFrom(const CardIssuer& from)
{
    CardIssuer* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CardIssuer)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_issuer_id(from._internal_issuer_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.issuer_ = from._impl_.issuer_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CardIssuer::CopyFrom(const CardIssuer& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CardIssuer)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CardIssuer::IsInitialized() const
{
    return true;
}

void CardIssuer::InternalSwap(CardIssuer* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.issuer_id_, lhs_arena, &other->_impl_.issuer_id_, rhs_arena);
    swap(_impl_.issuer_, other->_impl_.issuer_);
}

std::string CardIssuer::GetTypeName() const
{
    return "sync_pb.CardIssuer";
}

// ===================================================================

class WalletMaskedCreditCard::_Internal {
public:
    using HasBits = decltype(std::declval<WalletMaskedCreditCard>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_status(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_name_on_card(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_last_four(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_exp_month(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_exp_year(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_billing_address_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_bank_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::sync_pb::CloudTokenData& cloud_token_data(const WalletMaskedCreditCard* msg);
    static void set_has_cloud_token_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_nickname(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::sync_pb::CardIssuer& card_issuer(const WalletMaskedCreditCard* msg);
    static void set_has_card_issuer(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_instrument_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_virtual_card_enrollment_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_card_art_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_product_description(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_virtual_card_enrollment_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_product_terms_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_card_info_retrieval_enrollment_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
};

const ::sync_pb::CloudTokenData& WalletMaskedCreditCard::_Internal::cloud_token_data(const WalletMaskedCreditCard* msg)
{
    return *msg->_impl_.cloud_token_data_;
}
const ::sync_pb::CardIssuer& WalletMaskedCreditCard::_Internal::card_issuer(const WalletMaskedCreditCard* msg)
{
    return *msg->_impl_.card_issuer_;
}
WalletMaskedCreditCard::WalletMaskedCreditCard(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.WalletMaskedCreditCard)
}
WalletMaskedCreditCard::WalletMaskedCreditCard(const WalletMaskedCreditCard& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WalletMaskedCreditCard* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.card_benefit_) { from._impl_.card_benefit_ }, decltype(_impl_.id_) {}, decltype(_impl_.name_on_card_) {},
        decltype(_impl_.last_four_) {}, decltype(_impl_.billing_address_id_) {}, decltype(_impl_.bank_name_) {}, decltype(_impl_.nickname_) {},
        decltype(_impl_.card_art_url_) {}, decltype(_impl_.product_description_) {}, decltype(_impl_.product_terms_url_) {},
        decltype(_impl_.cloud_token_data_) { nullptr }, decltype(_impl_.card_issuer_) { nullptr }, decltype(_impl_.status_) {}, decltype(_impl_.type_) {},
        decltype(_impl_.exp_month_) {}, decltype(_impl_.exp_year_) {}, decltype(_impl_.instrument_id_) {}, decltype(_impl_.virtual_card_enrollment_state_) {},
        decltype(_impl_.virtual_card_enrollment_type_) {}, decltype(_impl_.card_info_retrieval_enrollment_state_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.name_on_card_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_on_card_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name_on_card()) {
        _this->_impl_.name_on_card_.Set(from._internal_name_on_card(), _this->GetArenaForAllocation());
    }
    _impl_.last_four_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_four_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_last_four()) {
        _this->_impl_.last_four_.Set(from._internal_last_four(), _this->GetArenaForAllocation());
    }
    _impl_.billing_address_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.billing_address_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_billing_address_id()) {
        _this->_impl_.billing_address_id_.Set(from._internal_billing_address_id(), _this->GetArenaForAllocation());
    }
    _impl_.bank_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bank_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_bank_name()) {
        _this->_impl_.bank_name_.Set(from._internal_bank_name(), _this->GetArenaForAllocation());
    }
    _impl_.nickname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_nickname()) {
        _this->_impl_.nickname_.Set(from._internal_nickname(), _this->GetArenaForAllocation());
    }
    _impl_.card_art_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.card_art_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_card_art_url()) {
        _this->_impl_.card_art_url_.Set(from._internal_card_art_url(), _this->GetArenaForAllocation());
    }
    _impl_.product_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_product_description()) {
        _this->_impl_.product_description_.Set(from._internal_product_description(), _this->GetArenaForAllocation());
    }
    _impl_.product_terms_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_terms_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_product_terms_url()) {
        _this->_impl_.product_terms_url_.Set(from._internal_product_terms_url(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_cloud_token_data()) {
        _this->_impl_.cloud_token_data_ = new ::sync_pb::CloudTokenData(*from._impl_.cloud_token_data_);
    }
    if (from._internal_has_card_issuer()) {
        _this->_impl_.card_issuer_ = new ::sync_pb::CardIssuer(*from._impl_.card_issuer_);
    }
    ::memcpy(&_impl_.status_, &from._impl_.status_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.card_info_retrieval_enrollment_state_) - reinterpret_cast<char*>(&_impl_.status_))
            + sizeof(_impl_.card_info_retrieval_enrollment_state_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.WalletMaskedCreditCard)
}

inline void WalletMaskedCreditCard::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.card_benefit_) { arena },
        decltype(_impl_.id_) {}, decltype(_impl_.name_on_card_) {}, decltype(_impl_.last_four_) {}, decltype(_impl_.billing_address_id_) {},
        decltype(_impl_.bank_name_) {}, decltype(_impl_.nickname_) {}, decltype(_impl_.card_art_url_) {}, decltype(_impl_.product_description_) {},
        decltype(_impl_.product_terms_url_) {}, decltype(_impl_.cloud_token_data_) { nullptr }, decltype(_impl_.card_issuer_) { nullptr },
        decltype(_impl_.status_) { 0 }, decltype(_impl_.type_) { 0 }, decltype(_impl_.exp_month_) { 0 }, decltype(_impl_.exp_year_) { 0 },
        decltype(_impl_.instrument_id_) { int64_t { 0 } }, decltype(_impl_.virtual_card_enrollment_state_) { 0 },
        decltype(_impl_.virtual_card_enrollment_type_) { 0 }, decltype(_impl_.card_info_retrieval_enrollment_state_) { 0 } };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_on_card_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_on_card_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_four_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_four_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.billing_address_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.billing_address_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bank_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bank_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.card_art_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.card_art_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_terms_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.product_terms_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WalletMaskedCreditCard::~WalletMaskedCreditCard()
{
    // @@protoc_insertion_point(destructor:sync_pb.WalletMaskedCreditCard)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WalletMaskedCreditCard::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.card_benefit_.~RepeatedPtrField();
    _impl_.id_.Destroy();
    _impl_.name_on_card_.Destroy();
    _impl_.last_four_.Destroy();
    _impl_.billing_address_id_.Destroy();
    _impl_.bank_name_.Destroy();
    _impl_.nickname_.Destroy();
    _impl_.card_art_url_.Destroy();
    _impl_.product_description_.Destroy();
    _impl_.product_terms_url_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.cloud_token_data_;
    if (this != internal_default_instance())
        delete _impl_.card_issuer_;
}

void WalletMaskedCreditCard::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WalletMaskedCreditCard::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.WalletMaskedCreditCard)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.card_benefit_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.name_on_card_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.last_four_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.billing_address_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.bank_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.nickname_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.card_art_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            _impl_.product_description_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000700u) {
        if (cached_has_bits & 0x00000100u) {
            _impl_.product_terms_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000200u) {
            GOOGLE_DCHECK(_impl_.cloud_token_data_ != nullptr);
            _impl_.cloud_token_data_->Clear();
        }
        if (cached_has_bits & 0x00000400u) {
            GOOGLE_DCHECK(_impl_.card_issuer_ != nullptr);
            _impl_.card_issuer_->Clear();
        }
    }
    if (cached_has_bits & 0x0000f800u) {
        ::memset(&_impl_.status_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.instrument_id_) - reinterpret_cast<char*>(&_impl_.status_)) + sizeof(_impl_.instrument_id_));
    }
    if (cached_has_bits & 0x00070000u) {
        ::memset(&_impl_.virtual_card_enrollment_state_, 0,
            static_cast<size_t>(
                reinterpret_cast<char*>(&_impl_.card_info_retrieval_enrollment_state_) - reinterpret_cast<char*>(&_impl_.virtual_card_enrollment_state_))
                + sizeof(_impl_.card_info_retrieval_enrollment_state_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WalletMaskedCreditCard::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletMaskedCreditCard.WalletCardStatus status = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::WalletMaskedCreditCard_WalletCardStatus_IsValid(val))) {
                    _internal_set_status(static_cast<::sync_pb::WalletMaskedCreditCard_WalletCardStatus>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string name_on_card = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_name_on_card();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletMaskedCreditCard.WalletCardType type = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::WalletMaskedCreditCard_WalletCardType_IsValid(val))) {
                    _internal_set_type(static_cast<::sync_pb::WalletMaskedCreditCard_WalletCardType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string last_four = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_last_four();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 exp_month = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_exp_month(&has_bits);
                _impl_.exp_month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 exp_year = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _Internal::set_has_exp_year(&has_bits);
                _impl_.exp_year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string billing_address_id = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_billing_address_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string bank_name = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_bank_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.CloudTokenData cloud_token_data = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_cloud_token_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string nickname = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_nickname();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.CardIssuer card_issuer = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                ptr = ctx->ParseMessage(_internal_mutable_card_issuer(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 instrument_id = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_instrument_id(&has_bits);
                _impl_.instrument_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletMaskedCreditCard.VirtualCardEnrollmentState virtual_card_enrollment_state = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::WalletMaskedCreditCard_VirtualCardEnrollmentState_IsValid(val))) {
                    _internal_set_virtual_card_enrollment_state(static_cast<::sync_pb::WalletMaskedCreditCard_VirtualCardEnrollmentState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string card_art_url = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
                auto str = _internal_mutable_card_art_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string product_description = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
                auto str = _internal_mutable_product_description();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletMaskedCreditCard.VirtualCardEnrollmentType virtual_card_enrollment_type = 19;
        case 19:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::WalletMaskedCreditCard_VirtualCardEnrollmentType_IsValid(val))) {
                    _internal_set_virtual_card_enrollment_type(static_cast<::sync_pb::WalletMaskedCreditCard_VirtualCardEnrollmentType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.CardBenefit card_benefit = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_card_benefit(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string product_terms_url = 21;
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
                auto str = _internal_mutable_product_terms_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletMaskedCreditCard.CardInfoRetrievalEnrollmentState card_info_retrieval_enrollment_state = 22;
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState_IsValid(val))) {
                    _internal_set_card_info_retrieval_enrollment_state(static_cast<::sync_pb::WalletMaskedCreditCard_CardInfoRetrievalEnrollmentState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(22, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WalletMaskedCreditCard::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.WalletMaskedCreditCard)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    // optional .sync_pb.WalletMaskedCreditCard.WalletCardStatus status = 2;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_status(), target);
    }

    // optional string name_on_card = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_name_on_card(), target);
    }

    // optional .sync_pb.WalletMaskedCreditCard.WalletCardType type = 4;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_type(), target);
    }

    // optional string last_four = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_last_four(), target);
    }

    // optional int32 exp_month = 6;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_exp_month(), target);
    }

    // optional int32 exp_year = 7;
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_exp_year(), target);
    }

    // optional string billing_address_id = 8;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_billing_address_id(), target);
    }

    // optional string bank_name = 10;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(10, this->_internal_bank_name(), target);
    }

    // optional .sync_pb.CloudTokenData cloud_token_data = 11;
    if (cached_has_bits & 0x00000200u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::cloud_token_data(this), _Internal::cloud_token_data(this).GetCachedSize(), target, stream);
    }

    // optional string nickname = 12;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(12, this->_internal_nickname(), target);
    }

    // optional .sync_pb.CardIssuer card_issuer = 13;
    if (cached_has_bits & 0x00000400u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            13, _Internal::card_issuer(this), _Internal::card_issuer(this).GetCachedSize(), target, stream);
    }

    // optional int64 instrument_id = 15;
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(15, this->_internal_instrument_id(), target);
    }

    // optional .sync_pb.WalletMaskedCreditCard.VirtualCardEnrollmentState virtual_card_enrollment_state = 16;
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(16, this->_internal_virtual_card_enrollment_state(), target);
    }

    // optional string card_art_url = 17;
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(17, this->_internal_card_art_url(), target);
    }

    // optional string product_description = 18;
    if (cached_has_bits & 0x00000080u) {
        target = stream->WriteStringMaybeAliased(18, this->_internal_product_description(), target);
    }

    // optional .sync_pb.WalletMaskedCreditCard.VirtualCardEnrollmentType virtual_card_enrollment_type = 19;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(19, this->_internal_virtual_card_enrollment_type(), target);
    }

    // repeated .sync_pb.CardBenefit card_benefit = 20;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_card_benefit_size()); i < n; i++) {
        const auto& repfield = this->_internal_card_benefit(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(20, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string product_terms_url = 21;
    if (cached_has_bits & 0x00000100u) {
        target = stream->WriteStringMaybeAliased(21, this->_internal_product_terms_url(), target);
    }

    // optional .sync_pb.WalletMaskedCreditCard.CardInfoRetrievalEnrollmentState card_info_retrieval_enrollment_state = 22;
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(22, this->_internal_card_info_retrieval_enrollment_state(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.WalletMaskedCreditCard)
    return target;
}

size_t WalletMaskedCreditCard::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.WalletMaskedCreditCard)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.CardBenefit card_benefit = 20;
    total_size += 2UL * this->_internal_card_benefit_size();
    for (const auto& msg : this->_impl_.card_benefit_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
        }

        // optional string name_on_card = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name_on_card());
        }

        // optional string last_four = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_last_four());
        }

        // optional string billing_address_id = 8;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_billing_address_id());
        }

        // optional string bank_name = 10;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_bank_name());
        }

        // optional string nickname = 12;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_nickname());
        }

        // optional string card_art_url = 17;
        if (cached_has_bits & 0x00000040u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_card_art_url());
        }

        // optional string product_description = 18;
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_product_description());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional string product_terms_url = 21;
        if (cached_has_bits & 0x00000100u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_product_terms_url());
        }

        // optional .sync_pb.CloudTokenData cloud_token_data = 11;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cloud_token_data_);
        }

        // optional .sync_pb.CardIssuer card_issuer = 13;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.card_issuer_);
        }

        // optional .sync_pb.WalletMaskedCreditCard.WalletCardStatus status = 2;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
        }

        // optional .sync_pb.WalletMaskedCreditCard.WalletCardType type = 4;
        if (cached_has_bits & 0x00001000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional int32 exp_month = 6;
        if (cached_has_bits & 0x00002000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exp_month());
        }

        // optional int32 exp_year = 7;
        if (cached_has_bits & 0x00004000u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exp_year());
        }

        // optional int64 instrument_id = 15;
        if (cached_has_bits & 0x00008000u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_instrument_id());
        }
    }
    if (cached_has_bits & 0x00070000u) {
        // optional .sync_pb.WalletMaskedCreditCard.VirtualCardEnrollmentState virtual_card_enrollment_state = 16;
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_virtual_card_enrollment_state());
        }

        // optional .sync_pb.WalletMaskedCreditCard.VirtualCardEnrollmentType virtual_card_enrollment_type = 19;
        if (cached_has_bits & 0x00020000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_virtual_card_enrollment_type());
        }

        // optional .sync_pb.WalletMaskedCreditCard.CardInfoRetrievalEnrollmentState card_info_retrieval_enrollment_state = 22;
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_card_info_retrieval_enrollment_state());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WalletMaskedCreditCard::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WalletMaskedCreditCard*>(&from));
}

void WalletMaskedCreditCard::MergeFrom(const WalletMaskedCreditCard& from)
{
    WalletMaskedCreditCard* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.WalletMaskedCreditCard)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.card_benefit_.MergeFrom(from._impl_.card_benefit_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_id(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_name_on_card(from._internal_name_on_card());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_last_four(from._internal_last_four());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_billing_address_id(from._internal_billing_address_id());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_bank_name(from._internal_bank_name());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_nickname(from._internal_nickname());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_card_art_url(from._internal_card_art_url());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_set_product_description(from._internal_product_description());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_set_product_terms_url(from._internal_product_terms_url());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_mutable_cloud_token_data()->::sync_pb::CloudTokenData::MergeFrom(from._internal_cloud_token_data());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_mutable_card_issuer()->::sync_pb::CardIssuer::MergeFrom(from._internal_card_issuer());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.status_ = from._impl_.status_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.exp_month_ = from._impl_.exp_month_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.exp_year_ = from._impl_.exp_year_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.instrument_id_ = from._impl_.instrument_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00070000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.virtual_card_enrollment_state_ = from._impl_.virtual_card_enrollment_state_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.virtual_card_enrollment_type_ = from._impl_.virtual_card_enrollment_type_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.card_info_retrieval_enrollment_state_ = from._impl_.card_info_retrieval_enrollment_state_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WalletMaskedCreditCard::CopyFrom(const WalletMaskedCreditCard& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.WalletMaskedCreditCard)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WalletMaskedCreditCard::IsInitialized() const
{
    return true;
}

void WalletMaskedCreditCard::InternalSwap(WalletMaskedCreditCard* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.card_benefit_.InternalSwap(&other->_impl_.card_benefit_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_on_card_, lhs_arena, &other->_impl_.name_on_card_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.last_four_, lhs_arena, &other->_impl_.last_four_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.billing_address_id_, lhs_arena, &other->_impl_.billing_address_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.bank_name_, lhs_arena, &other->_impl_.bank_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.nickname_, lhs_arena, &other->_impl_.nickname_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.card_art_url_, lhs_arena, &other->_impl_.card_art_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.product_description_, lhs_arena, &other->_impl_.product_description_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.product_terms_url_, lhs_arena, &other->_impl_.product_terms_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(WalletMaskedCreditCard, _impl_.card_info_retrieval_enrollment_state_)
        + sizeof(WalletMaskedCreditCard::_impl_.card_info_retrieval_enrollment_state_)
        - PROTOBUF_FIELD_OFFSET(WalletMaskedCreditCard, _impl_.cloud_token_data_)>(
        reinterpret_cast<char*>(&_impl_.cloud_token_data_), reinterpret_cast<char*>(&other->_impl_.cloud_token_data_));
}

std::string WalletMaskedCreditCard::GetTypeName() const
{
    return "sync_pb.WalletMaskedCreditCard";
}

// ===================================================================

class WalletPostalAddress::_Internal {
public:
    using HasBits = decltype(std::declval<WalletPostalAddress>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_recipient_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_company_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_address_1(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_address_2(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_address_3(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_address_4(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_postal_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_sorting_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_country_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_language_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_phone_number(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
};

WalletPostalAddress::WalletPostalAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.WalletPostalAddress)
}
WalletPostalAddress::WalletPostalAddress(const WalletPostalAddress& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WalletPostalAddress* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.street_address_) { from._impl_.street_address_ }, decltype(_impl_.id_) {}, decltype(_impl_.company_name_) {},
        decltype(_impl_.address_1_) {}, decltype(_impl_.address_2_) {}, decltype(_impl_.address_3_) {}, decltype(_impl_.address_4_) {},
        decltype(_impl_.postal_code_) {}, decltype(_impl_.sorting_code_) {}, decltype(_impl_.country_code_) {}, decltype(_impl_.language_code_) {},
        decltype(_impl_.recipient_name_) {}, decltype(_impl_.phone_number_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.company_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.company_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_company_name()) {
        _this->_impl_.company_name_.Set(from._internal_company_name(), _this->GetArenaForAllocation());
    }
    _impl_.address_1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_1()) {
        _this->_impl_.address_1_.Set(from._internal_address_1(), _this->GetArenaForAllocation());
    }
    _impl_.address_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_2()) {
        _this->_impl_.address_2_.Set(from._internal_address_2(), _this->GetArenaForAllocation());
    }
    _impl_.address_3_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_3_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_3()) {
        _this->_impl_.address_3_.Set(from._internal_address_3(), _this->GetArenaForAllocation());
    }
    _impl_.address_4_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_4_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_address_4()) {
        _this->_impl_.address_4_.Set(from._internal_address_4(), _this->GetArenaForAllocation());
    }
    _impl_.postal_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.postal_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_postal_code()) {
        _this->_impl_.postal_code_.Set(from._internal_postal_code(), _this->GetArenaForAllocation());
    }
    _impl_.sorting_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sorting_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_sorting_code()) {
        _this->_impl_.sorting_code_.Set(from._internal_sorting_code(), _this->GetArenaForAllocation());
    }
    _impl_.country_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_country_code()) {
        _this->_impl_.country_code_.Set(from._internal_country_code(), _this->GetArenaForAllocation());
    }
    _impl_.language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_language_code()) {
        _this->_impl_.language_code_.Set(from._internal_language_code(), _this->GetArenaForAllocation());
    }
    _impl_.recipient_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_recipient_name()) {
        _this->_impl_.recipient_name_.Set(from._internal_recipient_name(), _this->GetArenaForAllocation());
    }
    _impl_.phone_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_phone_number()) {
        _this->_impl_.phone_number_.Set(from._internal_phone_number(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.WalletPostalAddress)
}

inline void WalletPostalAddress::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.street_address_) { arena },
        decltype(_impl_.id_) {}, decltype(_impl_.company_name_) {}, decltype(_impl_.address_1_) {}, decltype(_impl_.address_2_) {},
        decltype(_impl_.address_3_) {}, decltype(_impl_.address_4_) {}, decltype(_impl_.postal_code_) {}, decltype(_impl_.sorting_code_) {},
        decltype(_impl_.country_code_) {}, decltype(_impl_.language_code_) {}, decltype(_impl_.recipient_name_) {}, decltype(_impl_.phone_number_) {} };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.company_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.company_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_1_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_1_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_2_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_2_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_3_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_3_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_4_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.address_4_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.postal_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.postal_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sorting_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sorting_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.language_code_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.recipient_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.phone_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WalletPostalAddress::~WalletPostalAddress()
{
    // @@protoc_insertion_point(destructor:sync_pb.WalletPostalAddress)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WalletPostalAddress::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.street_address_.~RepeatedPtrField();
    _impl_.id_.Destroy();
    _impl_.company_name_.Destroy();
    _impl_.address_1_.Destroy();
    _impl_.address_2_.Destroy();
    _impl_.address_3_.Destroy();
    _impl_.address_4_.Destroy();
    _impl_.postal_code_.Destroy();
    _impl_.sorting_code_.Destroy();
    _impl_.country_code_.Destroy();
    _impl_.language_code_.Destroy();
    _impl_.recipient_name_.Destroy();
    _impl_.phone_number_.Destroy();
}

void WalletPostalAddress::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WalletPostalAddress::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.WalletPostalAddress)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.street_address_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.company_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.address_1_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.address_2_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.address_3_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.address_4_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.postal_code_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            _impl_.sorting_code_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _impl_.country_code_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000200u) {
            _impl_.language_code_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000400u) {
            _impl_.recipient_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000800u) {
            _impl_.phone_number_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WalletPostalAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string company_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_company_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string street_address = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_street_address();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string address_1 = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_address_1();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_2 = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_address_2();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_3 = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_address_3();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string address_4 = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_address_4();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string postal_code = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_postal_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string sorting_code = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                auto str = _internal_mutable_sorting_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string country_code = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_country_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string language_code = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_language_code();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string recipient_name = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_recipient_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string phone_number = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                auto str = _internal_mutable_phone_number();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WalletPostalAddress::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.WalletPostalAddress)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    // optional string company_name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_company_name(), target);
    }

    // repeated string street_address = 3;
    for (int i = 0, n = this->_internal_street_address_size(); i < n; i++) {
        const auto& s = this->_internal_street_address(i);
        target = stream->WriteString(3, s, target);
    }

    // optional string address_1 = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_address_1(), target);
    }

    // optional string address_2 = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_address_2(), target);
    }

    // optional string address_3 = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_address_3(), target);
    }

    // optional string address_4 = 7;
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(7, this->_internal_address_4(), target);
    }

    // optional string postal_code = 8;
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(8, this->_internal_postal_code(), target);
    }

    // optional string sorting_code = 9;
    if (cached_has_bits & 0x00000080u) {
        target = stream->WriteStringMaybeAliased(9, this->_internal_sorting_code(), target);
    }

    // optional string country_code = 10;
    if (cached_has_bits & 0x00000100u) {
        target = stream->WriteStringMaybeAliased(10, this->_internal_country_code(), target);
    }

    // optional string language_code = 11;
    if (cached_has_bits & 0x00000200u) {
        target = stream->WriteStringMaybeAliased(11, this->_internal_language_code(), target);
    }

    // optional string recipient_name = 12;
    if (cached_has_bits & 0x00000400u) {
        target = stream->WriteStringMaybeAliased(12, this->_internal_recipient_name(), target);
    }

    // optional string phone_number = 13;
    if (cached_has_bits & 0x00000800u) {
        target = stream->WriteStringMaybeAliased(13, this->_internal_phone_number(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.WalletPostalAddress)
    return target;
}

size_t WalletPostalAddress::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.WalletPostalAddress)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string street_address = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.street_address_.size());
    for (int i = 0, n = _impl_.street_address_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.street_address_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
        }

        // optional string company_name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_company_name());
        }

        // optional string address_1 = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_1());
        }

        // optional string address_2 = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_2());
        }

        // optional string address_3 = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_3());
        }

        // optional string address_4 = 7;
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_address_4());
        }

        // optional string postal_code = 8;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_postal_code());
        }

        // optional string sorting_code = 9;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sorting_code());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        // optional string country_code = 10;
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_country_code());
        }

        // optional string language_code = 11;
        if (cached_has_bits & 0x00000200u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_language_code());
        }

        // optional string recipient_name = 12;
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_recipient_name());
        }

        // optional string phone_number = 13;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_phone_number());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WalletPostalAddress::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WalletPostalAddress*>(&from));
}

void WalletPostalAddress::MergeFrom(const WalletPostalAddress& from)
{
    WalletPostalAddress* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.WalletPostalAddress)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.street_address_.MergeFrom(from._impl_.street_address_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_id(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_company_name(from._internal_company_name());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_address_1(from._internal_address_1());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_address_2(from._internal_address_2());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_address_3(from._internal_address_3());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_address_4(from._internal_address_4());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_postal_code(from._internal_postal_code());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_set_sorting_code(from._internal_sorting_code());
        }
    }
    if (cached_has_bits & 0x00000f00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_internal_set_country_code(from._internal_country_code());
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_internal_set_language_code(from._internal_language_code());
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_internal_set_recipient_name(from._internal_recipient_name());
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_internal_set_phone_number(from._internal_phone_number());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WalletPostalAddress::CopyFrom(const WalletPostalAddress& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.WalletPostalAddress)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WalletPostalAddress::IsInitialized() const
{
    return true;
}

void WalletPostalAddress::InternalSwap(WalletPostalAddress* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.street_address_.InternalSwap(&other->_impl_.street_address_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.company_name_, lhs_arena, &other->_impl_.company_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_1_, lhs_arena, &other->_impl_.address_1_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_2_, lhs_arena, &other->_impl_.address_2_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_3_, lhs_arena, &other->_impl_.address_3_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.address_4_, lhs_arena, &other->_impl_.address_4_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.postal_code_, lhs_arena, &other->_impl_.postal_code_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sorting_code_, lhs_arena, &other->_impl_.sorting_code_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.country_code_, lhs_arena, &other->_impl_.country_code_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.language_code_, lhs_arena, &other->_impl_.language_code_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.recipient_name_, lhs_arena, &other->_impl_.recipient_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.phone_number_, lhs_arena, &other->_impl_.phone_number_, rhs_arena);
}

std::string WalletPostalAddress::GetTypeName() const
{
    return "sync_pb.WalletPostalAddress";
}

// ===================================================================

class PaymentsCustomerData::_Internal {
public:
    using HasBits = decltype(std::declval<PaymentsCustomerData>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

PaymentsCustomerData::PaymentsCustomerData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PaymentsCustomerData)
}
PaymentsCustomerData::PaymentsCustomerData(const PaymentsCustomerData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PaymentsCustomerData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.PaymentsCustomerData)
}

inline void PaymentsCustomerData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {} };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PaymentsCustomerData::~PaymentsCustomerData()
{
    // @@protoc_insertion_point(destructor:sync_pb.PaymentsCustomerData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PaymentsCustomerData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.id_.Destroy();
}

void PaymentsCustomerData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PaymentsCustomerData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PaymentsCustomerData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.id_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PaymentsCustomerData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PaymentsCustomerData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PaymentsCustomerData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PaymentsCustomerData)
    return target;
}

size_t PaymentsCustomerData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PaymentsCustomerData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PaymentsCustomerData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PaymentsCustomerData*>(&from));
}

void PaymentsCustomerData::MergeFrom(const PaymentsCustomerData& from)
{
    PaymentsCustomerData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PaymentsCustomerData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_id()) {
        _this->_internal_set_id(from._internal_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaymentsCustomerData::CopyFrom(const PaymentsCustomerData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PaymentsCustomerData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PaymentsCustomerData::IsInitialized() const
{
    return true;
}

void PaymentsCustomerData::InternalSwap(PaymentsCustomerData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
}

std::string PaymentsCustomerData::GetTypeName() const
{
    return "sync_pb.PaymentsCustomerData";
}

// ===================================================================

class WalletCreditCardCloudTokenData::_Internal {
public:
    using HasBits = decltype(std::declval<WalletCreditCardCloudTokenData>()._impl_._has_bits_);
    static void set_has_masked_card_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_suffix(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_exp_month(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_exp_year(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_art_fife_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_instrument_token(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

WalletCreditCardCloudTokenData::WalletCreditCardCloudTokenData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.WalletCreditCardCloudTokenData)
}
WalletCreditCardCloudTokenData::WalletCreditCardCloudTokenData(const WalletCreditCardCloudTokenData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WalletCreditCardCloudTokenData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.masked_card_id_) {},
        decltype(_impl_.suffix_) {}, decltype(_impl_.art_fife_url_) {}, decltype(_impl_.instrument_token_) {}, decltype(_impl_.exp_month_) {},
        decltype(_impl_.exp_year_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.masked_card_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.masked_card_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_masked_card_id()) {
        _this->_impl_.masked_card_id_.Set(from._internal_masked_card_id(), _this->GetArenaForAllocation());
    }
    _impl_.suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_suffix()) {
        _this->_impl_.suffix_.Set(from._internal_suffix(), _this->GetArenaForAllocation());
    }
    _impl_.art_fife_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_fife_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_art_fife_url()) {
        _this->_impl_.art_fife_url_.Set(from._internal_art_fife_url(), _this->GetArenaForAllocation());
    }
    _impl_.instrument_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instrument_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_instrument_token()) {
        _this->_impl_.instrument_token_.Set(from._internal_instrument_token(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.exp_month_, &from._impl_.exp_month_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.exp_year_) - reinterpret_cast<char*>(&_impl_.exp_month_)) + sizeof(_impl_.exp_year_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.WalletCreditCardCloudTokenData)
}

inline void WalletCreditCardCloudTokenData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.masked_card_id_) {}, decltype(_impl_.suffix_) {},
            decltype(_impl_.art_fife_url_) {}, decltype(_impl_.instrument_token_) {}, decltype(_impl_.exp_month_) { 0 }, decltype(_impl_.exp_year_) { 0 } };
    _impl_.masked_card_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.masked_card_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_fife_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.art_fife_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instrument_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instrument_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WalletCreditCardCloudTokenData::~WalletCreditCardCloudTokenData()
{
    // @@protoc_insertion_point(destructor:sync_pb.WalletCreditCardCloudTokenData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WalletCreditCardCloudTokenData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.masked_card_id_.Destroy();
    _impl_.suffix_.Destroy();
    _impl_.art_fife_url_.Destroy();
    _impl_.instrument_token_.Destroy();
}

void WalletCreditCardCloudTokenData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WalletCreditCardCloudTokenData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.WalletCreditCardCloudTokenData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.masked_card_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.suffix_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.art_fife_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.instrument_token_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x00000030u) {
        ::memset(&_impl_.exp_month_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.exp_year_) - reinterpret_cast<char*>(&_impl_.exp_month_)) + sizeof(_impl_.exp_year_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WalletCreditCardCloudTokenData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string masked_card_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_masked_card_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string suffix = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_suffix();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 exp_month = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_exp_month(&has_bits);
                _impl_.exp_month_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 exp_year = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_exp_year(&has_bits);
                _impl_.exp_year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string art_fife_url = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_art_fife_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string instrument_token = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_instrument_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WalletCreditCardCloudTokenData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.WalletCreditCardCloudTokenData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string masked_card_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_masked_card_id(), target);
    }

    // optional string suffix = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_suffix(), target);
    }

    // optional int32 exp_month = 3;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_exp_month(), target);
    }

    // optional int32 exp_year = 4;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_exp_year(), target);
    }

    // optional string art_fife_url = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_art_fife_url(), target);
    }

    // optional string instrument_token = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_instrument_token(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.WalletCreditCardCloudTokenData)
    return target;
}

size_t WalletCreditCardCloudTokenData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.WalletCreditCardCloudTokenData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string masked_card_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_masked_card_id());
        }

        // optional string suffix = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_suffix());
        }

        // optional string art_fife_url = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_art_fife_url());
        }

        // optional string instrument_token = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_instrument_token());
        }

        // optional int32 exp_month = 3;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exp_month());
        }

        // optional int32 exp_year = 4;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exp_year());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WalletCreditCardCloudTokenData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WalletCreditCardCloudTokenData*>(&from));
}

void WalletCreditCardCloudTokenData::MergeFrom(const WalletCreditCardCloudTokenData& from)
{
    WalletCreditCardCloudTokenData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.WalletCreditCardCloudTokenData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_masked_card_id(from._internal_masked_card_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_suffix(from._internal_suffix());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_art_fife_url(from._internal_art_fife_url());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_instrument_token(from._internal_instrument_token());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.exp_month_ = from._impl_.exp_month_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.exp_year_ = from._impl_.exp_year_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WalletCreditCardCloudTokenData::CopyFrom(const WalletCreditCardCloudTokenData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.WalletCreditCardCloudTokenData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WalletCreditCardCloudTokenData::IsInitialized() const
{
    return true;
}

void WalletCreditCardCloudTokenData::InternalSwap(WalletCreditCardCloudTokenData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.masked_card_id_, lhs_arena, &other->_impl_.masked_card_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.suffix_, lhs_arena, &other->_impl_.suffix_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.art_fife_url_, lhs_arena, &other->_impl_.art_fife_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.instrument_token_, lhs_arena, &other->_impl_.instrument_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(WalletCreditCardCloudTokenData, _impl_.exp_year_)
        + sizeof(WalletCreditCardCloudTokenData::_impl_.exp_year_) - PROTOBUF_FIELD_OFFSET(WalletCreditCardCloudTokenData, _impl_.exp_month_)>(
        reinterpret_cast<char*>(&_impl_.exp_month_), reinterpret_cast<char*>(&other->_impl_.exp_month_));
}

std::string WalletCreditCardCloudTokenData::GetTypeName() const
{
    return "sync_pb.WalletCreditCardCloudTokenData";
}

// ===================================================================

class PaymentInstrument::_Internal {
public:
    using HasBits = decltype(std::declval<PaymentInstrument>()._impl_._has_bits_);
    static void set_has_instrument_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_display_icon_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_nickname(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::BankAccountDetails& bank_account(const PaymentInstrument* msg);
    static const ::sync_pb::WalletMaskedIban& iban(const PaymentInstrument* msg);
    static const ::sync_pb::EwalletDetails& ewallet_details(const PaymentInstrument* msg);
    static const ::sync_pb::BnplIssuerDetails& bnpl_issuer_details(const PaymentInstrument* msg);
    static const ::sync_pb::DeviceDetails& device_details(const PaymentInstrument* msg);
    static void set_has_device_details(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::sync_pb::BankAccountDetails& PaymentInstrument::_Internal::bank_account(const PaymentInstrument* msg)
{
    return *msg->_impl_.instrument_details_.bank_account_;
}
const ::sync_pb::WalletMaskedIban& PaymentInstrument::_Internal::iban(const PaymentInstrument* msg)
{
    return *msg->_impl_.instrument_details_.iban_;
}
const ::sync_pb::EwalletDetails& PaymentInstrument::_Internal::ewallet_details(const PaymentInstrument* msg)
{
    return *msg->_impl_.instrument_details_.ewallet_details_;
}
const ::sync_pb::BnplIssuerDetails& PaymentInstrument::_Internal::bnpl_issuer_details(const PaymentInstrument* msg)
{
    return *msg->_impl_.instrument_details_.bnpl_issuer_details_;
}
const ::sync_pb::DeviceDetails& PaymentInstrument::_Internal::device_details(const PaymentInstrument* msg)
{
    return *msg->_impl_.device_details_;
}
void PaymentInstrument::set_allocated_bank_account(::sync_pb::BankAccountDetails* bank_account)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_instrument_details();
    if (bank_account) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bank_account);
        if (message_arena != submessage_arena) {
            bank_account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, bank_account, submessage_arena);
        }
        set_has_bank_account();
        _impl_.instrument_details_.bank_account_ = bank_account;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PaymentInstrument.bank_account)
}
void PaymentInstrument::set_allocated_iban(::sync_pb::WalletMaskedIban* iban)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_instrument_details();
    if (iban) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(iban);
        if (message_arena != submessage_arena) {
            iban = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, iban, submessage_arena);
        }
        set_has_iban();
        _impl_.instrument_details_.iban_ = iban;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PaymentInstrument.iban)
}
void PaymentInstrument::set_allocated_ewallet_details(::sync_pb::EwalletDetails* ewallet_details)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_instrument_details();
    if (ewallet_details) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ewallet_details);
        if (message_arena != submessage_arena) {
            ewallet_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, ewallet_details, submessage_arena);
        }
        set_has_ewallet_details();
        _impl_.instrument_details_.ewallet_details_ = ewallet_details;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PaymentInstrument.ewallet_details)
}
void PaymentInstrument::set_allocated_bnpl_issuer_details(::sync_pb::BnplIssuerDetails* bnpl_issuer_details)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_instrument_details();
    if (bnpl_issuer_details) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bnpl_issuer_details);
        if (message_arena != submessage_arena) {
            bnpl_issuer_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, bnpl_issuer_details, submessage_arena);
        }
        set_has_bnpl_issuer_details();
        _impl_.instrument_details_.bnpl_issuer_details_ = bnpl_issuer_details;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PaymentInstrument.bnpl_issuer_details)
}
PaymentInstrument::PaymentInstrument(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PaymentInstrument)
}
PaymentInstrument::PaymentInstrument(const PaymentInstrument& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PaymentInstrument* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.supported_rails_) { from._impl_.supported_rails_ }, decltype(_impl_.display_icon_url_) {}, decltype(_impl_.nickname_) {},
        decltype(_impl_.device_details_) { nullptr }, decltype(_impl_.instrument_id_) {}, decltype(_impl_.instrument_details_) {},
        /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.display_icon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_icon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_display_icon_url()) {
        _this->_impl_.display_icon_url_.Set(from._internal_display_icon_url(), _this->GetArenaForAllocation());
    }
    _impl_.nickname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_nickname()) {
        _this->_impl_.nickname_.Set(from._internal_nickname(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_device_details()) {
        _this->_impl_.device_details_ = new ::sync_pb::DeviceDetails(*from._impl_.device_details_);
    }
    _this->_impl_.instrument_id_ = from._impl_.instrument_id_;
    clear_has_instrument_details();
    switch (from.instrument_details_case()) {
    case kBankAccount: {
        _this->_internal_mutable_bank_account()->::sync_pb::BankAccountDetails::MergeFrom(from._internal_bank_account());
        break;
    }
    case kIban: {
        _this->_internal_mutable_iban()->::sync_pb::WalletMaskedIban::MergeFrom(from._internal_iban());
        break;
    }
    case kEwalletDetails: {
        _this->_internal_mutable_ewallet_details()->::sync_pb::EwalletDetails::MergeFrom(from._internal_ewallet_details());
        break;
    }
    case kBnplIssuerDetails: {
        _this->_internal_mutable_bnpl_issuer_details()->::sync_pb::BnplIssuerDetails::MergeFrom(from._internal_bnpl_issuer_details());
        break;
    }
    case INSTRUMENT_DETAILS_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.PaymentInstrument)
}

inline void PaymentInstrument::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.supported_rails_) { arena },
        decltype(_impl_.display_icon_url_) {}, decltype(_impl_.nickname_) {}, decltype(_impl_.device_details_) { nullptr },
        decltype(_impl_.instrument_id_) { int64_t { 0 } }, decltype(_impl_.instrument_details_) {}, /*decltype(_impl_._oneof_case_)*/ {} };
    _impl_.display_icon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.display_icon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clear_has_instrument_details();
}

PaymentInstrument::~PaymentInstrument()
{
    // @@protoc_insertion_point(destructor:sync_pb.PaymentInstrument)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PaymentInstrument::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.supported_rails_.~RepeatedField();
    _impl_.display_icon_url_.Destroy();
    _impl_.nickname_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.device_details_;
    if (has_instrument_details()) {
        clear_instrument_details();
    }
}

void PaymentInstrument::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PaymentInstrument::clear_instrument_details()
{
    // @@protoc_insertion_point(one_of_clear_start:sync_pb.PaymentInstrument)
    switch (instrument_details_case()) {
    case kBankAccount: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.instrument_details_.bank_account_;
        }
        break;
    }
    case kIban: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.instrument_details_.iban_;
        }
        break;
    }
    case kEwalletDetails: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.instrument_details_.ewallet_details_;
        }
        break;
    }
    case kBnplIssuerDetails: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.instrument_details_.bnpl_issuer_details_;
        }
        break;
    }
    case INSTRUMENT_DETAILS_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = INSTRUMENT_DETAILS_NOT_SET;
}

void PaymentInstrument::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PaymentInstrument)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.supported_rails_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.display_icon_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.nickname_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.device_details_ != nullptr);
            _impl_.device_details_->Clear();
        }
    }
    _impl_.instrument_id_ = int64_t { 0 };
    clear_instrument_details();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* PaymentInstrument::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int64 instrument_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_instrument_id(&has_bits);
                _impl_.instrument_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.PaymentInstrument.SupportedRail supported_rails = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                    if (PROTOBUF_PREDICT_TRUE(::sync_pb::PaymentInstrument_SupportedRail_IsValid(val))) {
                        _internal_add_supported_rails(static_cast<::sync_pb::PaymentInstrument_SupportedRail>(val));
                    } else {
                        ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                    }
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
            } else if (static_cast<uint8_t>(tag) == 18) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(
                    _internal_mutable_supported_rails(), ptr, ctx, ::sync_pb::PaymentInstrument_SupportedRail_IsValid, &_internal_metadata_, 2);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string display_icon_url = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_display_icon_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string nickname = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_nickname();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.BankAccountDetails bank_account = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_bank_account(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.WalletMaskedIban iban = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_iban(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.EwalletDetails ewallet_details = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_ewallet_details(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.DeviceDetails device_details = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_device_details(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sync_pb.BnplIssuerDetails bnpl_issuer_details = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_bnpl_issuer_details(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PaymentInstrument::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PaymentInstrument)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int64 instrument_id = 1;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_instrument_id(), target);
    }

    // repeated .sync_pb.PaymentInstrument.SupportedRail supported_rails = 2;
    for (int i = 0, n = this->_internal_supported_rails_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_supported_rails(i), target);
    }

    // optional string display_icon_url = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_display_icon_url(), target);
    }

    // optional string nickname = 4;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_nickname(), target);
    }

    switch (instrument_details_case()) {
    case kBankAccount: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::bank_account(this), _Internal::bank_account(this).GetCachedSize(), target, stream);
        break;
    }
    case kIban: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::iban(this), _Internal::iban(this).GetCachedSize(), target, stream);
        break;
    }
    case kEwalletDetails: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::ewallet_details(this), _Internal::ewallet_details(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    // optional .sync_pb.DeviceDetails device_details = 8;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::device_details(this), _Internal::device_details(this).GetCachedSize(), target, stream);
    }

    // .sync_pb.BnplIssuerDetails bnpl_issuer_details = 9;
    if (_internal_has_bnpl_issuer_details()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::bnpl_issuer_details(this), _Internal::bnpl_issuer_details(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PaymentInstrument)
    return target;
}

size_t PaymentInstrument::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PaymentInstrument)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.PaymentInstrument.SupportedRail supported_rails = 2;
    {
        size_t data_size = 0;
        unsigned int count = static_cast<unsigned int>(this->_internal_supported_rails_size());
        for (unsigned int i = 0; i < count; i++) {
            data_size += ::_pbi::WireFormatLite::EnumSize(this->_internal_supported_rails(static_cast<int>(i)));
        }
        total_size += (1UL * count) + data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string display_icon_url = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_display_icon_url());
        }

        // optional string nickname = 4;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_nickname());
        }

        // optional .sync_pb.DeviceDetails device_details = 8;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.device_details_);
        }

        // optional int64 instrument_id = 1;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_instrument_id());
        }
    }
    switch (instrument_details_case()) {
    // .sync_pb.BankAccountDetails bank_account = 5;
    case kBankAccount: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.instrument_details_.bank_account_);
        break;
    }
    // .sync_pb.WalletMaskedIban iban = 6;
    case kIban: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.instrument_details_.iban_);
        break;
    }
    // .sync_pb.EwalletDetails ewallet_details = 7;
    case kEwalletDetails: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.instrument_details_.ewallet_details_);
        break;
    }
    // .sync_pb.BnplIssuerDetails bnpl_issuer_details = 9;
    case kBnplIssuerDetails: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.instrument_details_.bnpl_issuer_details_);
        break;
    }
    case INSTRUMENT_DETAILS_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PaymentInstrument::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PaymentInstrument*>(&from));
}

void PaymentInstrument::MergeFrom(const PaymentInstrument& from)
{
    PaymentInstrument* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PaymentInstrument)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.supported_rails_.MergeFrom(from._impl_.supported_rails_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_display_icon_url(from._internal_display_icon_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_nickname(from._internal_nickname());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_device_details()->::sync_pb::DeviceDetails::MergeFrom(from._internal_device_details());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.instrument_id_ = from._impl_.instrument_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    switch (from.instrument_details_case()) {
    case kBankAccount: {
        _this->_internal_mutable_bank_account()->::sync_pb::BankAccountDetails::MergeFrom(from._internal_bank_account());
        break;
    }
    case kIban: {
        _this->_internal_mutable_iban()->::sync_pb::WalletMaskedIban::MergeFrom(from._internal_iban());
        break;
    }
    case kEwalletDetails: {
        _this->_internal_mutable_ewallet_details()->::sync_pb::EwalletDetails::MergeFrom(from._internal_ewallet_details());
        break;
    }
    case kBnplIssuerDetails: {
        _this->_internal_mutable_bnpl_issuer_details()->::sync_pb::BnplIssuerDetails::MergeFrom(from._internal_bnpl_issuer_details());
        break;
    }
    case INSTRUMENT_DETAILS_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaymentInstrument::CopyFrom(const PaymentInstrument& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PaymentInstrument)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PaymentInstrument::IsInitialized() const
{
    return true;
}

void PaymentInstrument::InternalSwap(PaymentInstrument* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.supported_rails_.InternalSwap(&other->_impl_.supported_rails_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.display_icon_url_, lhs_arena, &other->_impl_.display_icon_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.nickname_, lhs_arena, &other->_impl_.nickname_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PaymentInstrument, _impl_.instrument_id_)
        + sizeof(PaymentInstrument::_impl_.instrument_id_) - PROTOBUF_FIELD_OFFSET(PaymentInstrument, _impl_.device_details_)>(
        reinterpret_cast<char*>(&_impl_.device_details_), reinterpret_cast<char*>(&other->_impl_.device_details_));
    swap(_impl_.instrument_details_, other->_impl_.instrument_details_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string PaymentInstrument::GetTypeName() const
{
    return "sync_pb.PaymentInstrument";
}

// ===================================================================

class BnplIssuerDetails::_Internal {
public:
    using HasBits = decltype(std::declval<BnplIssuerDetails>()._impl_._has_bits_);
    static void set_has_issuer_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

BnplIssuerDetails::BnplIssuerDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.BnplIssuerDetails)
}
BnplIssuerDetails::BnplIssuerDetails(const BnplIssuerDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BnplIssuerDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.eligible_price_range_) { from._impl_.eligible_price_range_ }, decltype(_impl_.issuer_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.issuer_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuer_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_issuer_id()) {
        _this->_impl_.issuer_id_.Set(from._internal_issuer_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.BnplIssuerDetails)
}

inline void BnplIssuerDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.eligible_price_range_) { arena },
        decltype(_impl_.issuer_id_) {} };
    _impl_.issuer_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.issuer_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BnplIssuerDetails::~BnplIssuerDetails()
{
    // @@protoc_insertion_point(destructor:sync_pb.BnplIssuerDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BnplIssuerDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.eligible_price_range_.~RepeatedPtrField();
    _impl_.issuer_id_.Destroy();
}

void BnplIssuerDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BnplIssuerDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.BnplIssuerDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.eligible_price_range_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.issuer_id_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BnplIssuerDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string issuer_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_issuer_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.EligiblePriceRange eligible_price_range = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_eligible_price_range(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BnplIssuerDetails::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.BnplIssuerDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string issuer_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_issuer_id(), target);
    }

    // repeated .sync_pb.EligiblePriceRange eligible_price_range = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_eligible_price_range_size()); i < n; i++) {
        const auto& repfield = this->_internal_eligible_price_range(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.BnplIssuerDetails)
    return target;
}

size_t BnplIssuerDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.BnplIssuerDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.EligiblePriceRange eligible_price_range = 2;
    total_size += 1UL * this->_internal_eligible_price_range_size();
    for (const auto& msg : this->_impl_.eligible_price_range_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // optional string issuer_id = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_issuer_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BnplIssuerDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BnplIssuerDetails*>(&from));
}

void BnplIssuerDetails::MergeFrom(const BnplIssuerDetails& from)
{
    BnplIssuerDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.BnplIssuerDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.eligible_price_range_.MergeFrom(from._impl_.eligible_price_range_);
    if (from._internal_has_issuer_id()) {
        _this->_internal_set_issuer_id(from._internal_issuer_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BnplIssuerDetails::CopyFrom(const BnplIssuerDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.BnplIssuerDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BnplIssuerDetails::IsInitialized() const
{
    return true;
}

void BnplIssuerDetails::InternalSwap(BnplIssuerDetails* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.eligible_price_range_.InternalSwap(&other->_impl_.eligible_price_range_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.issuer_id_, lhs_arena, &other->_impl_.issuer_id_, rhs_arena);
}

std::string BnplIssuerDetails::GetTypeName() const
{
    return "sync_pb.BnplIssuerDetails";
}

// ===================================================================

class PaymentInstrumentCreationOption::_Internal {
public:
    static const ::sync_pb::BnplIssuerDetails& buy_now_pay_later_option(const PaymentInstrumentCreationOption* msg);
};

const ::sync_pb::BnplIssuerDetails& PaymentInstrumentCreationOption::_Internal::buy_now_pay_later_option(const PaymentInstrumentCreationOption* msg)
{
    return *msg->_impl_.creation_option_.buy_now_pay_later_option_;
}
void PaymentInstrumentCreationOption::set_allocated_buy_now_pay_later_option(::sync_pb::BnplIssuerDetails* buy_now_pay_later_option)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_creation_option();
    if (buy_now_pay_later_option) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(buy_now_pay_later_option);
        if (message_arena != submessage_arena) {
            buy_now_pay_later_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, buy_now_pay_later_option, submessage_arena);
        }
        set_has_buy_now_pay_later_option();
        _impl_.creation_option_.buy_now_pay_later_option_ = buy_now_pay_later_option;
    }
    // @@protoc_insertion_point(field_set_allocated:sync_pb.PaymentInstrumentCreationOption.buy_now_pay_later_option)
}
PaymentInstrumentCreationOption::PaymentInstrumentCreationOption(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.PaymentInstrumentCreationOption)
}
PaymentInstrumentCreationOption::PaymentInstrumentCreationOption(const PaymentInstrumentCreationOption& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PaymentInstrumentCreationOption* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.creation_option_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_creation_option();
    switch (from.creation_option_case()) {
    case kBuyNowPayLaterOption: {
        _this->_internal_mutable_buy_now_pay_later_option()->::sync_pb::BnplIssuerDetails::MergeFrom(from._internal_buy_now_pay_later_option());
        break;
    }
    case CREATION_OPTION_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.PaymentInstrumentCreationOption)
}

inline void PaymentInstrumentCreationOption::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.creation_option_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_creation_option();
}

PaymentInstrumentCreationOption::~PaymentInstrumentCreationOption()
{
    // @@protoc_insertion_point(destructor:sync_pb.PaymentInstrumentCreationOption)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PaymentInstrumentCreationOption::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_creation_option()) {
        clear_creation_option();
    }
}

void PaymentInstrumentCreationOption::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PaymentInstrumentCreationOption::clear_creation_option()
{
    // @@protoc_insertion_point(one_of_clear_start:sync_pb.PaymentInstrumentCreationOption)
    switch (creation_option_case()) {
    case kBuyNowPayLaterOption: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.creation_option_.buy_now_pay_later_option_;
        }
        break;
    }
    case CREATION_OPTION_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = CREATION_OPTION_NOT_SET;
}

void PaymentInstrumentCreationOption::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.PaymentInstrumentCreationOption)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_creation_option();
    _internal_metadata_.Clear<std::string>();
}

const char* PaymentInstrumentCreationOption::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .sync_pb.BnplIssuerDetails buy_now_pay_later_option = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_buy_now_pay_later_option(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PaymentInstrumentCreationOption::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.PaymentInstrumentCreationOption)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .sync_pb.BnplIssuerDetails buy_now_pay_later_option = 1;
    if (_internal_has_buy_now_pay_later_option()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::buy_now_pay_later_option(this), _Internal::buy_now_pay_later_option(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.PaymentInstrumentCreationOption)
    return target;
}

size_t PaymentInstrumentCreationOption::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.PaymentInstrumentCreationOption)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (creation_option_case()) {
    // .sync_pb.BnplIssuerDetails buy_now_pay_later_option = 1;
    case kBuyNowPayLaterOption: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.creation_option_.buy_now_pay_later_option_);
        break;
    }
    case CREATION_OPTION_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PaymentInstrumentCreationOption::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PaymentInstrumentCreationOption*>(&from));
}

void PaymentInstrumentCreationOption::MergeFrom(const PaymentInstrumentCreationOption& from)
{
    PaymentInstrumentCreationOption* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.PaymentInstrumentCreationOption)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.creation_option_case()) {
    case kBuyNowPayLaterOption: {
        _this->_internal_mutable_buy_now_pay_later_option()->::sync_pb::BnplIssuerDetails::MergeFrom(from._internal_buy_now_pay_later_option());
        break;
    }
    case CREATION_OPTION_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PaymentInstrumentCreationOption::CopyFrom(const PaymentInstrumentCreationOption& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.PaymentInstrumentCreationOption)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PaymentInstrumentCreationOption::IsInitialized() const
{
    return true;
}

void PaymentInstrumentCreationOption::InternalSwap(PaymentInstrumentCreationOption* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.creation_option_, other->_impl_.creation_option_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string PaymentInstrumentCreationOption::GetTypeName() const
{
    return "sync_pb.PaymentInstrumentCreationOption";
}

// ===================================================================

class EligiblePriceRange::_Internal {
public:
    using HasBits = decltype(std::declval<EligiblePriceRange>()._impl_._has_bits_);
    static void set_has_currency(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_min_price_in_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_max_price_in_micros(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

EligiblePriceRange::EligiblePriceRange(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.EligiblePriceRange)
}
EligiblePriceRange::EligiblePriceRange(const EligiblePriceRange& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    EligiblePriceRange* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.currency_) {},
        decltype(_impl_.min_price_in_micros_) {}, decltype(_impl_.max_price_in_micros_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.currency_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_currency()) {
        _this->_impl_.currency_.Set(from._internal_currency(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.min_price_in_micros_, &from._impl_.min_price_in_micros_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_price_in_micros_) - reinterpret_cast<char*>(&_impl_.min_price_in_micros_))
            + sizeof(_impl_.max_price_in_micros_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.EligiblePriceRange)
}

inline void EligiblePriceRange::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.currency_) {},
        decltype(_impl_.min_price_in_micros_) { int64_t { 0 } }, decltype(_impl_.max_price_in_micros_) { int64_t { 0 } } };
    _impl_.currency_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.currency_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EligiblePriceRange::~EligiblePriceRange()
{
    // @@protoc_insertion_point(destructor:sync_pb.EligiblePriceRange)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void EligiblePriceRange::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.currency_.Destroy();
}

void EligiblePriceRange::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void EligiblePriceRange::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.EligiblePriceRange)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.currency_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.min_price_in_micros_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.max_price_in_micros_) - reinterpret_cast<char*>(&_impl_.min_price_in_micros_))
                + sizeof(_impl_.max_price_in_micros_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* EligiblePriceRange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string currency = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_currency();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 min_price_in_micros = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_min_price_in_micros(&has_bits);
                _impl_.min_price_in_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 max_price_in_micros = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_max_price_in_micros(&has_bits);
                _impl_.max_price_in_micros_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* EligiblePriceRange::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.EligiblePriceRange)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string currency = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_currency(), target);
    }

    // optional int64 min_price_in_micros = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_min_price_in_micros(), target);
    }

    // optional int64 max_price_in_micros = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_max_price_in_micros(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.EligiblePriceRange)
    return target;
}

size_t EligiblePriceRange::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.EligiblePriceRange)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string currency = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_currency());
        }

        // optional int64 min_price_in_micros = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min_price_in_micros());
        }

        // optional int64 max_price_in_micros = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_price_in_micros());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void EligiblePriceRange::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const EligiblePriceRange*>(&from));
}

void EligiblePriceRange::MergeFrom(const EligiblePriceRange& from)
{
    EligiblePriceRange* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.EligiblePriceRange)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_currency(from._internal_currency());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.min_price_in_micros_ = from._impl_.min_price_in_micros_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.max_price_in_micros_ = from._impl_.max_price_in_micros_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EligiblePriceRange::CopyFrom(const EligiblePriceRange& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.EligiblePriceRange)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool EligiblePriceRange::IsInitialized() const
{
    return true;
}

void EligiblePriceRange::InternalSwap(EligiblePriceRange* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.currency_, lhs_arena, &other->_impl_.currency_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(EligiblePriceRange, _impl_.max_price_in_micros_)
        + sizeof(EligiblePriceRange::_impl_.max_price_in_micros_) - PROTOBUF_FIELD_OFFSET(EligiblePriceRange, _impl_.min_price_in_micros_)>(
        reinterpret_cast<char*>(&_impl_.min_price_in_micros_), reinterpret_cast<char*>(&other->_impl_.min_price_in_micros_));
}

std::string EligiblePriceRange::GetTypeName() const
{
    return "sync_pb.EligiblePriceRange";
}

// ===================================================================

class WalletMaskedIban::_Internal {
public:
    using HasBits = decltype(std::declval<WalletMaskedIban>()._impl_._has_bits_);
    static void set_has_instrument_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_prefix(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_suffix(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_length(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_nickname(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

WalletMaskedIban::WalletMaskedIban(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.WalletMaskedIban)
}
WalletMaskedIban::WalletMaskedIban(const WalletMaskedIban& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WalletMaskedIban* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.instrument_id_) {},
        decltype(_impl_.prefix_) {}, decltype(_impl_.suffix_) {}, decltype(_impl_.nickname_) {}, decltype(_impl_.length_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.instrument_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_instrument_id()) {
        _this->_impl_.instrument_id_.Set(from._internal_instrument_id(), _this->GetArenaForAllocation());
    }
    _impl_.prefix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_prefix()) {
        _this->_impl_.prefix_.Set(from._internal_prefix(), _this->GetArenaForAllocation());
    }
    _impl_.suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_suffix()) {
        _this->_impl_.suffix_.Set(from._internal_suffix(), _this->GetArenaForAllocation());
    }
    _impl_.nickname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_nickname()) {
        _this->_impl_.nickname_.Set(from._internal_nickname(), _this->GetArenaForAllocation());
    }
    _this->_impl_.length_ = from._impl_.length_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.WalletMaskedIban)
}

inline void WalletMaskedIban::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.instrument_id_) {},
        decltype(_impl_.prefix_) {}, decltype(_impl_.suffix_) {}, decltype(_impl_.nickname_) {}, decltype(_impl_.length_) { 0 } };
    _impl_.instrument_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.instrument_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.prefix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.nickname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WalletMaskedIban::~WalletMaskedIban()
{
    // @@protoc_insertion_point(destructor:sync_pb.WalletMaskedIban)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WalletMaskedIban::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.instrument_id_.Destroy();
    _impl_.prefix_.Destroy();
    _impl_.suffix_.Destroy();
    _impl_.nickname_.Destroy();
}

void WalletMaskedIban::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WalletMaskedIban::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.WalletMaskedIban)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.instrument_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.prefix_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.suffix_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.nickname_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.length_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WalletMaskedIban::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string instrument_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_instrument_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string prefix = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_prefix();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string suffix = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_suffix();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 length = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_length(&has_bits);
                _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string nickname = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_nickname();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WalletMaskedIban::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.WalletMaskedIban)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string instrument_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_instrument_id(), target);
    }

    // optional string prefix = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_prefix(), target);
    }

    // optional string suffix = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_suffix(), target);
    }

    // optional int32 length = 4;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_length(), target);
    }

    // optional string nickname = 5;
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_nickname(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.WalletMaskedIban)
    return target;
}

size_t WalletMaskedIban::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.WalletMaskedIban)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        // optional string instrument_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_instrument_id());
        }

        // optional string prefix = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_prefix());
        }

        // optional string suffix = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_suffix());
        }

        // optional string nickname = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_nickname());
        }

        // optional int32 length = 4;
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_length());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WalletMaskedIban::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WalletMaskedIban*>(&from));
}

void WalletMaskedIban::MergeFrom(const WalletMaskedIban& from)
{
    WalletMaskedIban* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.WalletMaskedIban)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000001fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_instrument_id(from._internal_instrument_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_prefix(from._internal_prefix());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_suffix(from._internal_suffix());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_nickname(from._internal_nickname());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.length_ = from._impl_.length_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WalletMaskedIban::CopyFrom(const WalletMaskedIban& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.WalletMaskedIban)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WalletMaskedIban::IsInitialized() const
{
    return true;
}

void WalletMaskedIban::InternalSwap(WalletMaskedIban* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.instrument_id_, lhs_arena, &other->_impl_.instrument_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.prefix_, lhs_arena, &other->_impl_.prefix_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.suffix_, lhs_arena, &other->_impl_.suffix_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.nickname_, lhs_arena, &other->_impl_.nickname_, rhs_arena);
    swap(_impl_.length_, other->_impl_.length_);
}

std::string WalletMaskedIban::GetTypeName() const
{
    return "sync_pb.WalletMaskedIban";
}

// ===================================================================

class BankAccountDetails::_Internal {
public:
    using HasBits = decltype(std::declval<BankAccountDetails>()._impl_._has_bits_);
    static void set_has_bank_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_account_number_suffix(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_account_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

BankAccountDetails::BankAccountDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.BankAccountDetails)
}
BankAccountDetails::BankAccountDetails(const BankAccountDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BankAccountDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.bank_name_) {},
        decltype(_impl_.account_number_suffix_) {}, decltype(_impl_.account_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.bank_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bank_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_bank_name()) {
        _this->_impl_.bank_name_.Set(from._internal_bank_name(), _this->GetArenaForAllocation());
    }
    _impl_.account_number_suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_number_suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_account_number_suffix()) {
        _this->_impl_.account_number_suffix_.Set(from._internal_account_number_suffix(), _this->GetArenaForAllocation());
    }
    _this->_impl_.account_type_ = from._impl_.account_type_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.BankAccountDetails)
}

inline void BankAccountDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.bank_name_) {},
        decltype(_impl_.account_number_suffix_) {}, decltype(_impl_.account_type_) { 0 } };
    _impl_.bank_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.bank_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_number_suffix_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_number_suffix_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BankAccountDetails::~BankAccountDetails()
{
    // @@protoc_insertion_point(destructor:sync_pb.BankAccountDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BankAccountDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.bank_name_.Destroy();
    _impl_.account_number_suffix_.Destroy();
}

void BankAccountDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BankAccountDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.BankAccountDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.bank_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.account_number_suffix_.ClearNonDefaultToEmpty();
        }
    }
    _impl_.account_type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BankAccountDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string bank_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_bank_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string account_number_suffix = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_account_number_suffix();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.BankAccountDetails.AccountType account_type = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::BankAccountDetails_AccountType_IsValid(val))) {
                    _internal_set_account_type(static_cast<::sync_pb::BankAccountDetails_AccountType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BankAccountDetails::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.BankAccountDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string bank_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_bank_name(), target);
    }

    // optional string account_number_suffix = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_account_number_suffix(), target);
    }

    // optional .sync_pb.BankAccountDetails.AccountType account_type = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_account_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.BankAccountDetails)
    return target;
}

size_t BankAccountDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.BankAccountDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string bank_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_bank_name());
        }

        // optional string account_number_suffix = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_account_number_suffix());
        }

        // optional .sync_pb.BankAccountDetails.AccountType account_type = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_account_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BankAccountDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BankAccountDetails*>(&from));
}

void BankAccountDetails::MergeFrom(const BankAccountDetails& from)
{
    BankAccountDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.BankAccountDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_bank_name(from._internal_bank_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_account_number_suffix(from._internal_account_number_suffix());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.account_type_ = from._impl_.account_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BankAccountDetails::CopyFrom(const BankAccountDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.BankAccountDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BankAccountDetails::IsInitialized() const
{
    return true;
}

void BankAccountDetails::InternalSwap(BankAccountDetails* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.bank_name_, lhs_arena, &other->_impl_.bank_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.account_number_suffix_, lhs_arena, &other->_impl_.account_number_suffix_, rhs_arena);
    swap(_impl_.account_type_, other->_impl_.account_type_);
}

std::string BankAccountDetails::GetTypeName() const
{
    return "sync_pb.BankAccountDetails";
}

// ===================================================================

class EwalletDetails::_Internal {
public:
    using HasBits = decltype(std::declval<EwalletDetails>()._impl_._has_bits_);
    static void set_has_ewallet_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_account_display_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

EwalletDetails::EwalletDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.EwalletDetails)
}
EwalletDetails::EwalletDetails(const EwalletDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    EwalletDetails* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.supported_payment_link_uris_) { from._impl_.supported_payment_link_uris_ }, decltype(_impl_.ewallet_name_) {},
        decltype(_impl_.account_display_name_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.ewallet_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ewallet_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_ewallet_name()) {
        _this->_impl_.ewallet_name_.Set(from._internal_ewallet_name(), _this->GetArenaForAllocation());
    }
    _impl_.account_display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_account_display_name()) {
        _this->_impl_.account_display_name_.Set(from._internal_account_display_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.EwalletDetails)
}

inline void EwalletDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.supported_payment_link_uris_) { arena },
        decltype(_impl_.ewallet_name_) {}, decltype(_impl_.account_display_name_) {} };
    _impl_.ewallet_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.ewallet_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_display_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.account_display_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EwalletDetails::~EwalletDetails()
{
    // @@protoc_insertion_point(destructor:sync_pb.EwalletDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void EwalletDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.supported_payment_link_uris_.~RepeatedPtrField();
    _impl_.ewallet_name_.Destroy();
    _impl_.account_display_name_.Destroy();
}

void EwalletDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void EwalletDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.EwalletDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.supported_payment_link_uris_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.ewallet_name_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.account_display_name_.ClearNonDefaultToEmpty();
        }
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* EwalletDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string ewallet_name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_ewallet_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string account_display_name = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_account_display_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated string supported_payment_link_uris = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_supported_payment_link_uris();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* EwalletDetails::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.EwalletDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string ewallet_name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_ewallet_name(), target);
    }

    // optional string account_display_name = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_account_display_name(), target);
    }

    // repeated string supported_payment_link_uris = 3;
    for (int i = 0, n = this->_internal_supported_payment_link_uris_size(); i < n; i++) {
        const auto& s = this->_internal_supported_payment_link_uris(i);
        target = stream->WriteString(3, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.EwalletDetails)
    return target;
}

size_t EwalletDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.EwalletDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string supported_payment_link_uris = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.supported_payment_link_uris_.size());
    for (int i = 0, n = _impl_.supported_payment_link_uris_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.supported_payment_link_uris_.Get(i));
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        // optional string ewallet_name = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_ewallet_name());
        }

        // optional string account_display_name = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_account_display_name());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void EwalletDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const EwalletDetails*>(&from));
}

void EwalletDetails::MergeFrom(const EwalletDetails& from)
{
    EwalletDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.EwalletDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.supported_payment_link_uris_.MergeFrom(from._impl_.supported_payment_link_uris_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_ewallet_name(from._internal_ewallet_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_account_display_name(from._internal_account_display_name());
        }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EwalletDetails::CopyFrom(const EwalletDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.EwalletDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool EwalletDetails::IsInitialized() const
{
    return true;
}

void EwalletDetails::InternalSwap(EwalletDetails* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.supported_payment_link_uris_.InternalSwap(&other->_impl_.supported_payment_link_uris_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.ewallet_name_, lhs_arena, &other->_impl_.ewallet_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.account_display_name_, lhs_arena, &other->_impl_.account_display_name_, rhs_arena);
}

std::string EwalletDetails::GetTypeName() const
{
    return "sync_pb.EwalletDetails";
}

// ===================================================================

class DeviceDetails::_Internal {
public:
    using HasBits = decltype(std::declval<DeviceDetails>()._impl_._has_bits_);
    static void set_has_is_fido_enrolled(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

DeviceDetails::DeviceDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.DeviceDetails)
}
DeviceDetails::DeviceDetails(const DeviceDetails& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DeviceDetails* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.is_fido_enrolled_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.is_fido_enrolled_ = from._impl_.is_fido_enrolled_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.DeviceDetails)
}

inline void DeviceDetails::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.is_fido_enrolled_) { false } };
}

DeviceDetails::~DeviceDetails()
{
    // @@protoc_insertion_point(destructor:sync_pb.DeviceDetails)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DeviceDetails::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DeviceDetails::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DeviceDetails::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.DeviceDetails)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.is_fido_enrolled_ = false;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* DeviceDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional bool is_fido_enrolled = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_is_fido_enrolled(&has_bits);
                _impl_.is_fido_enrolled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DeviceDetails::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.DeviceDetails)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional bool is_fido_enrolled = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_fido_enrolled(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.DeviceDetails)
    return target;
}

size_t DeviceDetails::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.DeviceDetails)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional bool is_fido_enrolled = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DeviceDetails::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DeviceDetails*>(&from));
}

void DeviceDetails::MergeFrom(const DeviceDetails& from)
{
    DeviceDetails* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.DeviceDetails)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_is_fido_enrolled()) {
        _this->_internal_set_is_fido_enrolled(from._internal_is_fido_enrolled());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DeviceDetails::CopyFrom(const DeviceDetails& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.DeviceDetails)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DeviceDetails::IsInitialized() const
{
    return true;
}

void DeviceDetails::InternalSwap(DeviceDetails* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.is_fido_enrolled_, other->_impl_.is_fido_enrolled_);
}

std::string DeviceDetails::GetTypeName() const
{
    return "sync_pb.DeviceDetails";
}

// ===================================================================

class AutofillWalletSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<AutofillWalletSpecifics>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static const ::sync_pb::WalletMaskedCreditCard& masked_card(const AutofillWalletSpecifics* msg);
    static void set_has_masked_card(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::WalletPostalAddress& address(const AutofillWalletSpecifics* msg);
    static void set_has_address(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::PaymentsCustomerData& customer_data(const AutofillWalletSpecifics* msg);
    static void set_has_customer_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static const ::sync_pb::WalletCreditCardCloudTokenData& cloud_token_data(const AutofillWalletSpecifics* msg);
    static void set_has_cloud_token_data(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static const ::sync_pb::PaymentInstrument& payment_instrument(const AutofillWalletSpecifics* msg);
    static void set_has_payment_instrument(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static const ::sync_pb::WalletMaskedIban& masked_iban(const AutofillWalletSpecifics* msg);
    static void set_has_masked_iban(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::sync_pb::PaymentInstrumentCreationOption& payment_instrument_creation_option(const AutofillWalletSpecifics* msg);
    static void set_has_payment_instrument_creation_option(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

const ::sync_pb::WalletMaskedCreditCard& AutofillWalletSpecifics::_Internal::masked_card(const AutofillWalletSpecifics* msg)
{
    return *msg->_impl_.masked_card_;
}
const ::sync_pb::WalletPostalAddress& AutofillWalletSpecifics::_Internal::address(const AutofillWalletSpecifics* msg)
{
    return *msg->_impl_.address_;
}
const ::sync_pb::PaymentsCustomerData& AutofillWalletSpecifics::_Internal::customer_data(const AutofillWalletSpecifics* msg)
{
    return *msg->_impl_.customer_data_;
}
const ::sync_pb::WalletCreditCardCloudTokenData& AutofillWalletSpecifics::_Internal::cloud_token_data(const AutofillWalletSpecifics* msg)
{
    return *msg->_impl_.cloud_token_data_;
}
const ::sync_pb::PaymentInstrument& AutofillWalletSpecifics::_Internal::payment_instrument(const AutofillWalletSpecifics* msg)
{
    return *msg->_impl_.payment_instrument_;
}
const ::sync_pb::WalletMaskedIban& AutofillWalletSpecifics::_Internal::masked_iban(const AutofillWalletSpecifics* msg)
{
    return *msg->_impl_.masked_iban_;
}
const ::sync_pb::PaymentInstrumentCreationOption& AutofillWalletSpecifics::_Internal::payment_instrument_creation_option(const AutofillWalletSpecifics* msg)
{
    return *msg->_impl_.payment_instrument_creation_option_;
}
AutofillWalletSpecifics::AutofillWalletSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.AutofillWalletSpecifics)
}
AutofillWalletSpecifics::AutofillWalletSpecifics(const AutofillWalletSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AutofillWalletSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.masked_card_) { nullptr }, decltype(_impl_.address_) { nullptr }, decltype(_impl_.customer_data_) { nullptr },
        decltype(_impl_.cloud_token_data_) { nullptr }, decltype(_impl_.payment_instrument_) { nullptr }, decltype(_impl_.masked_iban_) { nullptr },
        decltype(_impl_.payment_instrument_creation_option_) { nullptr }, decltype(_impl_.type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_masked_card()) {
        _this->_impl_.masked_card_ = new ::sync_pb::WalletMaskedCreditCard(*from._impl_.masked_card_);
    }
    if (from._internal_has_address()) {
        _this->_impl_.address_ = new ::sync_pb::WalletPostalAddress(*from._impl_.address_);
    }
    if (from._internal_has_customer_data()) {
        _this->_impl_.customer_data_ = new ::sync_pb::PaymentsCustomerData(*from._impl_.customer_data_);
    }
    if (from._internal_has_cloud_token_data()) {
        _this->_impl_.cloud_token_data_ = new ::sync_pb::WalletCreditCardCloudTokenData(*from._impl_.cloud_token_data_);
    }
    if (from._internal_has_payment_instrument()) {
        _this->_impl_.payment_instrument_ = new ::sync_pb::PaymentInstrument(*from._impl_.payment_instrument_);
    }
    if (from._internal_has_masked_iban()) {
        _this->_impl_.masked_iban_ = new ::sync_pb::WalletMaskedIban(*from._impl_.masked_iban_);
    }
    if (from._internal_has_payment_instrument_creation_option()) {
        _this->_impl_.payment_instrument_creation_option_ = new ::sync_pb::PaymentInstrumentCreationOption(*from._impl_.payment_instrument_creation_option_);
    }
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.AutofillWalletSpecifics)
}

inline void AutofillWalletSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.masked_card_) { nullptr },
        decltype(_impl_.address_) { nullptr }, decltype(_impl_.customer_data_) { nullptr }, decltype(_impl_.cloud_token_data_) { nullptr },
        decltype(_impl_.payment_instrument_) { nullptr }, decltype(_impl_.masked_iban_) { nullptr },
        decltype(_impl_.payment_instrument_creation_option_) { nullptr }, decltype(_impl_.type_) { 0 } };
}

AutofillWalletSpecifics::~AutofillWalletSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.AutofillWalletSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AutofillWalletSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.masked_card_;
    if (this != internal_default_instance())
        delete _impl_.address_;
    if (this != internal_default_instance())
        delete _impl_.customer_data_;
    if (this != internal_default_instance())
        delete _impl_.cloud_token_data_;
    if (this != internal_default_instance())
        delete _impl_.payment_instrument_;
    if (this != internal_default_instance())
        delete _impl_.masked_iban_;
    if (this != internal_default_instance())
        delete _impl_.payment_instrument_creation_option_;
}

void AutofillWalletSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AutofillWalletSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.AutofillWalletSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000007fu) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.masked_card_ != nullptr);
            _impl_.masked_card_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.address_ != nullptr);
            _impl_.address_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.customer_data_ != nullptr);
            _impl_.customer_data_->Clear();
        }
        if (cached_has_bits & 0x00000008u) {
            GOOGLE_DCHECK(_impl_.cloud_token_data_ != nullptr);
            _impl_.cloud_token_data_->Clear();
        }
        if (cached_has_bits & 0x00000010u) {
            GOOGLE_DCHECK(_impl_.payment_instrument_ != nullptr);
            _impl_.payment_instrument_->Clear();
        }
        if (cached_has_bits & 0x00000020u) {
            GOOGLE_DCHECK(_impl_.masked_iban_ != nullptr);
            _impl_.masked_iban_->Clear();
        }
        if (cached_has_bits & 0x00000040u) {
            GOOGLE_DCHECK(_impl_.payment_instrument_creation_option_ != nullptr);
            _impl_.payment_instrument_creation_option_->Clear();
        }
    }
    _impl_.type_ = 0;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* AutofillWalletSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.AutofillWalletSpecifics.WalletInfoType type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::AutofillWalletSpecifics_WalletInfoType_IsValid(val))) {
                    _internal_set_type(static_cast<::sync_pb::AutofillWalletSpecifics_WalletInfoType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletMaskedCreditCard masked_card = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_masked_card(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletPostalAddress address = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_address(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PaymentsCustomerData customer_data = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_customer_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletCreditCardCloudTokenData cloud_token_data = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_cloud_token_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PaymentInstrument payment_instrument = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_payment_instrument(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.WalletMaskedIban masked_iban = 7 [deprecated = true];
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_masked_iban(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.PaymentInstrumentCreationOption payment_instrument_creation_option = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_payment_instrument_creation_option(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AutofillWalletSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.AutofillWalletSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.AutofillWalletSpecifics.WalletInfoType type = 1;
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_type(), target);
    }

    // optional .sync_pb.WalletMaskedCreditCard masked_card = 2;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::masked_card(this), _Internal::masked_card(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.WalletPostalAddress address = 3;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::address(this), _Internal::address(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PaymentsCustomerData customer_data = 4;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::customer_data(this), _Internal::customer_data(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.WalletCreditCardCloudTokenData cloud_token_data = 5;
    if (cached_has_bits & 0x00000008u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::cloud_token_data(this), _Internal::cloud_token_data(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PaymentInstrument payment_instrument = 6;
    if (cached_has_bits & 0x00000010u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::payment_instrument(this), _Internal::payment_instrument(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.WalletMaskedIban masked_iban = 7 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::masked_iban(this), _Internal::masked_iban(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.PaymentInstrumentCreationOption payment_instrument_creation_option = 8;
    if (cached_has_bits & 0x00000040u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::payment_instrument_creation_option(this), _Internal::payment_instrument_creation_option(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.AutofillWalletSpecifics)
    return target;
}

size_t AutofillWalletSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.AutofillWalletSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional .sync_pb.WalletMaskedCreditCard masked_card = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.masked_card_);
        }

        // optional .sync_pb.WalletPostalAddress address = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.address_);
        }

        // optional .sync_pb.PaymentsCustomerData customer_data = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.customer_data_);
        }

        // optional .sync_pb.WalletCreditCardCloudTokenData cloud_token_data = 5;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.cloud_token_data_);
        }

        // optional .sync_pb.PaymentInstrument payment_instrument = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.payment_instrument_);
        }

        // optional .sync_pb.WalletMaskedIban masked_iban = 7 [deprecated = true];
        if (cached_has_bits & 0x00000020u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.masked_iban_);
        }

        // optional .sync_pb.PaymentInstrumentCreationOption payment_instrument_creation_option = 8;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.payment_instrument_creation_option_);
        }

        // optional .sync_pb.AutofillWalletSpecifics.WalletInfoType type = 1;
        if (cached_has_bits & 0x00000080u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AutofillWalletSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AutofillWalletSpecifics*>(&from));
}

void AutofillWalletSpecifics::MergeFrom(const AutofillWalletSpecifics& from)
{
    AutofillWalletSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.AutofillWalletSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_masked_card()->::sync_pb::WalletMaskedCreditCard::MergeFrom(from._internal_masked_card());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_address()->::sync_pb::WalletPostalAddress::MergeFrom(from._internal_address());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_customer_data()->::sync_pb::PaymentsCustomerData::MergeFrom(from._internal_customer_data());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_mutable_cloud_token_data()->::sync_pb::WalletCreditCardCloudTokenData::MergeFrom(from._internal_cloud_token_data());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_mutable_payment_instrument()->::sync_pb::PaymentInstrument::MergeFrom(from._internal_payment_instrument());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_mutable_masked_iban()->::sync_pb::WalletMaskedIban::MergeFrom(from._internal_masked_iban());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_mutable_payment_instrument_creation_option()->::sync_pb::PaymentInstrumentCreationOption::MergeFrom(
                from._internal_payment_instrument_creation_option());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AutofillWalletSpecifics::CopyFrom(const AutofillWalletSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.AutofillWalletSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AutofillWalletSpecifics::IsInitialized() const
{
    return true;
}

void AutofillWalletSpecifics::InternalSwap(AutofillWalletSpecifics* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AutofillWalletSpecifics, _impl_.type_) + sizeof(AutofillWalletSpecifics::_impl_.type_)
        - PROTOBUF_FIELD_OFFSET(AutofillWalletSpecifics, _impl_.masked_card_)>(
        reinterpret_cast<char*>(&_impl_.masked_card_), reinterpret_cast<char*>(&other->_impl_.masked_card_));
}

std::string AutofillWalletSpecifics::GetTypeName() const
{
    return "sync_pb.AutofillWalletSpecifics";
}

// ===================================================================

class WalletMetadataSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<WalletMetadataSpecifics>()._impl_._has_bits_);
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_use_count(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_use_date(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_card_billing_address_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_address_has_converted(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
};

WalletMetadataSpecifics::WalletMetadataSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.WalletMetadataSpecifics)
}
WalletMetadataSpecifics::WalletMetadataSpecifics(const WalletMetadataSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WalletMetadataSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {},
        decltype(_impl_.card_billing_address_id_) {}, decltype(_impl_.use_count_) {}, decltype(_impl_.type_) {}, decltype(_impl_.address_has_converted_) {},
        decltype(_impl_.use_date_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_id()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.card_billing_address_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.card_billing_address_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_card_billing_address_id()) {
        _this->_impl_.card_billing_address_id_.Set(from._internal_card_billing_address_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.use_count_, &from._impl_.use_count_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_date_) - reinterpret_cast<char*>(&_impl_.use_count_)) + sizeof(_impl_.use_date_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.WalletMetadataSpecifics)
}

inline void WalletMetadataSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.id_) {},
        decltype(_impl_.card_billing_address_id_) {}, decltype(_impl_.use_count_) { int64_t { 0 } }, decltype(_impl_.type_) { 0 },
        decltype(_impl_.address_has_converted_) { false }, decltype(_impl_.use_date_) { int64_t { 0 } } };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.card_billing_address_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.card_billing_address_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WalletMetadataSpecifics::~WalletMetadataSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.WalletMetadataSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WalletMetadataSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.id_.Destroy();
    _impl_.card_billing_address_id_.Destroy();
}

void WalletMetadataSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WalletMetadataSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.WalletMetadataSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000003u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.card_billing_address_id_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x0000003cu) {
        ::memset(&_impl_.use_count_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.use_date_) - reinterpret_cast<char*>(&_impl_.use_count_)) + sizeof(_impl_.use_date_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* WalletMetadataSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional .sync_pb.WalletMetadataSpecifics.Type type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::WalletMetadataSpecifics_Type_IsValid(val))) {
                    _internal_set_type(static_cast<::sync_pb::WalletMetadataSpecifics_Type>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 use_count = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_use_count(&has_bits);
                _impl_.use_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 use_date = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_use_date(&has_bits);
                _impl_.use_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string card_billing_address_id = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_card_billing_address_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool address_has_converted = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_address_has_converted(&has_bits);
                _impl_.address_has_converted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WalletMetadataSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.WalletMetadataSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional .sync_pb.WalletMetadataSpecifics.Type type = 1;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_type(), target);
    }

    // optional string id = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_id(), target);
    }

    // optional int64 use_count = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_use_count(), target);
    }

    // optional int64 use_date = 4;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_use_date(), target);
    }

    // optional string card_billing_address_id = 5;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(5, this->_internal_card_billing_address_id(), target);
    }

    // optional bool address_has_converted = 6;
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_address_has_converted(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.WalletMetadataSpecifics)
    return target;
}

size_t WalletMetadataSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.WalletMetadataSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional string id = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
        }

        // optional string card_billing_address_id = 5;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_card_billing_address_id());
        }

        // optional int64 use_count = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_use_count());
        }

        // optional .sync_pb.WalletMetadataSpecifics.Type type = 1;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional bool address_has_converted = 6;
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional int64 use_date = 4;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_use_date());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WalletMetadataSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WalletMetadataSpecifics*>(&from));
}

void WalletMetadataSpecifics::MergeFrom(const WalletMetadataSpecifics& from)
{
    WalletMetadataSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.WalletMetadataSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_id(from._internal_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_card_billing_address_id(from._internal_card_billing_address_id());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.use_count_ = from._impl_.use_count_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.address_has_converted_ = from._impl_.address_has_converted_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.use_date_ = from._impl_.use_date_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WalletMetadataSpecifics::CopyFrom(const WalletMetadataSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.WalletMetadataSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WalletMetadataSpecifics::IsInitialized() const
{
    return true;
}

void WalletMetadataSpecifics::InternalSwap(WalletMetadataSpecifics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.card_billing_address_id_, lhs_arena, &other->_impl_.card_billing_address_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(WalletMetadataSpecifics, _impl_.use_date_)
        + sizeof(WalletMetadataSpecifics::_impl_.use_date_) - PROTOBUF_FIELD_OFFSET(WalletMetadataSpecifics, _impl_.use_count_)>(
        reinterpret_cast<char*>(&_impl_.use_count_), reinterpret_cast<char*>(&other->_impl_.use_count_));
}

std::string WalletMetadataSpecifics::GetTypeName() const
{
    return "sync_pb.WalletMetadataSpecifics";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::sync_pb::AutofillProfileSpecifics* Arena::CreateMaybeMessage<::sync_pb::AutofillProfileSpecifics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::AutofillProfileSpecifics>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::AutofillSpecifics* Arena::CreateMaybeMessage<::sync_pb::AutofillSpecifics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::AutofillSpecifics>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CloudTokenData* Arena::CreateMaybeMessage<::sync_pb::CloudTokenData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CloudTokenData>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CardBenefit_FlatRateBenefit* Arena::CreateMaybeMessage<::sync_pb::CardBenefit_FlatRateBenefit>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CardBenefit_FlatRateBenefit>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CardBenefit_CategoryBenefit* Arena::CreateMaybeMessage<::sync_pb::CardBenefit_CategoryBenefit>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CardBenefit_CategoryBenefit>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CardBenefit_MerchantBenefit* Arena::CreateMaybeMessage<::sync_pb::CardBenefit_MerchantBenefit>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CardBenefit_MerchantBenefit>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CardBenefit* Arena::CreateMaybeMessage<::sync_pb::CardBenefit>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CardBenefit>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::CardIssuer* Arena::CreateMaybeMessage<::sync_pb::CardIssuer>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::CardIssuer>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::WalletMaskedCreditCard* Arena::CreateMaybeMessage<::sync_pb::WalletMaskedCreditCard>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::WalletMaskedCreditCard>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::WalletPostalAddress* Arena::CreateMaybeMessage<::sync_pb::WalletPostalAddress>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::WalletPostalAddress>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PaymentsCustomerData* Arena::CreateMaybeMessage<::sync_pb::PaymentsCustomerData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PaymentsCustomerData>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::WalletCreditCardCloudTokenData* Arena::CreateMaybeMessage<::sync_pb::WalletCreditCardCloudTokenData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::WalletCreditCardCloudTokenData>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PaymentInstrument* Arena::CreateMaybeMessage<::sync_pb::PaymentInstrument>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PaymentInstrument>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::BnplIssuerDetails* Arena::CreateMaybeMessage<::sync_pb::BnplIssuerDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::BnplIssuerDetails>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::PaymentInstrumentCreationOption* Arena::CreateMaybeMessage<::sync_pb::PaymentInstrumentCreationOption>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::PaymentInstrumentCreationOption>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::EligiblePriceRange* Arena::CreateMaybeMessage<::sync_pb::EligiblePriceRange>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::EligiblePriceRange>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::WalletMaskedIban* Arena::CreateMaybeMessage<::sync_pb::WalletMaskedIban>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::WalletMaskedIban>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::BankAccountDetails* Arena::CreateMaybeMessage<::sync_pb::BankAccountDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::BankAccountDetails>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::EwalletDetails* Arena::CreateMaybeMessage<::sync_pb::EwalletDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::EwalletDetails>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::DeviceDetails* Arena::CreateMaybeMessage<::sync_pb::DeviceDetails>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::DeviceDetails>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::AutofillWalletSpecifics* Arena::CreateMaybeMessage<::sync_pb::AutofillWalletSpecifics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::AutofillWalletSpecifics>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::WalletMetadataSpecifics* Arena::CreateMaybeMessage<::sync_pb::WalletMetadataSpecifics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::WalletMetadataSpecifics>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
