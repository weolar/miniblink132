// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/entity_metadata.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fentity_5fmetadata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fentity_5fmetadata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include "components/sync/protocol/deletion_origin.pb.h"
#include "components/sync/protocol/entity_specifics.pb.h"
#include "components/sync/protocol/unique_position.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fentity_5fmetadata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fentity_5fmetadata_2eproto {
    static const uint32_t offsets[];
};
namespace sync_pb {
class EntityMetadata;
struct EntityMetadataDefaultTypeInternal;
extern EntityMetadataDefaultTypeInternal _EntityMetadata_default_instance_;
class EntityMetadata_CollaborationMetadata;
struct EntityMetadata_CollaborationMetadataDefaultTypeInternal;
extern EntityMetadata_CollaborationMetadataDefaultTypeInternal _EntityMetadata_CollaborationMetadata_default_instance_;
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <>::sync_pb::EntityMetadata* Arena::CreateMaybeMessage<::sync_pb::EntityMetadata>(Arena*);
template <>::sync_pb::EntityMetadata_CollaborationMetadata* Arena::CreateMaybeMessage<::sync_pb::EntityMetadata_CollaborationMetadata>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

// ===================================================================

class EntityMetadata_CollaborationMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.EntityMetadata.CollaborationMetadata) */ {
public:
    inline EntityMetadata_CollaborationMetadata()
        : EntityMetadata_CollaborationMetadata(nullptr)
    {
    }
    ~EntityMetadata_CollaborationMetadata() override;
    explicit PROTOBUF_CONSTEXPR EntityMetadata_CollaborationMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    EntityMetadata_CollaborationMetadata(const EntityMetadata_CollaborationMetadata& from);
    EntityMetadata_CollaborationMetadata(EntityMetadata_CollaborationMetadata&& from) noexcept
        : EntityMetadata_CollaborationMetadata()
    {
        *this = ::std::move(from);
    }

    inline EntityMetadata_CollaborationMetadata& operator=(const EntityMetadata_CollaborationMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EntityMetadata_CollaborationMetadata& operator=(EntityMetadata_CollaborationMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const EntityMetadata_CollaborationMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const EntityMetadata_CollaborationMetadata* internal_default_instance()
    {
        return reinterpret_cast<const EntityMetadata_CollaborationMetadata*>(&_EntityMetadata_CollaborationMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(EntityMetadata_CollaborationMetadata& a, EntityMetadata_CollaborationMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(EntityMetadata_CollaborationMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EntityMetadata_CollaborationMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    EntityMetadata_CollaborationMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<EntityMetadata_CollaborationMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const EntityMetadata_CollaborationMetadata& from);
    void MergeFrom(const EntityMetadata_CollaborationMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(EntityMetadata_CollaborationMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.EntityMetadata.CollaborationMetadata";
    }

protected:
    explicit EntityMetadata_CollaborationMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCollaborationIdFieldNumber = 1,
    };
    // optional string collaboration_id = 1;
    bool has_collaboration_id() const;

private:
    bool _internal_has_collaboration_id() const;

public:
    void clear_collaboration_id();
    const std::string& collaboration_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_collaboration_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_collaboration_id();
    PROTOBUF_NODISCARD std::string* release_collaboration_id();
    void set_allocated_collaboration_id(std::string* collaboration_id);

private:
    const std::string& _internal_collaboration_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_collaboration_id(const std::string& value);
    std::string* _internal_mutable_collaboration_id();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.EntityMetadata.CollaborationMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collaboration_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fentity_5fmetadata_2eproto;
};
// -------------------------------------------------------------------

class EntityMetadata final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.EntityMetadata) */ {
public:
    inline EntityMetadata()
        : EntityMetadata(nullptr)
    {
    }
    ~EntityMetadata() override;
    explicit PROTOBUF_CONSTEXPR EntityMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    EntityMetadata(const EntityMetadata& from);
    EntityMetadata(EntityMetadata&& from) noexcept
        : EntityMetadata()
    {
        *this = ::std::move(from);
    }

    inline EntityMetadata& operator=(const EntityMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline EntityMetadata& operator=(EntityMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const EntityMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const EntityMetadata* internal_default_instance()
    {
        return reinterpret_cast<const EntityMetadata*>(&_EntityMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(EntityMetadata& a, EntityMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(EntityMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(EntityMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    EntityMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<EntityMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const EntityMetadata& from);
    void MergeFrom(const EntityMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(EntityMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.EntityMetadata";
    }

protected:
    explicit EntityMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef EntityMetadata_CollaborationMetadata CollaborationMetadata;

    // accessors -------------------------------------------------------

    enum : int {
        kClientTagHashFieldNumber = 1,
        kServerIdFieldNumber = 2,
        kSpecificsHashFieldNumber = 9,
        kBaseSpecificsHashFieldNumber = 10,
        kDeletedByVersionFieldNumber = 14,
        kUniquePositionFieldNumber = 11,
        kPossiblyTrimmedBaseSpecificsFieldNumber = 13,
        kCollaborationFieldNumber = 15,
        kDeletionOriginFieldNumber = 16,
        kSequenceNumberFieldNumber = 4,
        kAckedSequenceNumberFieldNumber = 5,
        kCreationTimeFieldNumber = 7,
        kIsDeletedFieldNumber = 3,
        kBookmarkFaviconHashFieldNumber = 12,
        kModificationTimeFieldNumber = 8,
        kServerVersionFieldNumber = 6,
    };
    // optional string client_tag_hash = 1;
    bool has_client_tag_hash() const;

private:
    bool _internal_has_client_tag_hash() const;

public:
    void clear_client_tag_hash();
    const std::string& client_tag_hash() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_client_tag_hash(ArgT0&& arg0, ArgT... args);
    std::string* mutable_client_tag_hash();
    PROTOBUF_NODISCARD std::string* release_client_tag_hash();
    void set_allocated_client_tag_hash(std::string* client_tag_hash);

private:
    const std::string& _internal_client_tag_hash() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_tag_hash(const std::string& value);
    std::string* _internal_mutable_client_tag_hash();

public:
    // optional string server_id = 2;
    bool has_server_id() const;

private:
    bool _internal_has_server_id() const;

public:
    void clear_server_id();
    const std::string& server_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_server_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_server_id();
    PROTOBUF_NODISCARD std::string* release_server_id();
    void set_allocated_server_id(std::string* server_id);

private:
    const std::string& _internal_server_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_id(const std::string& value);
    std::string* _internal_mutable_server_id();

public:
    // optional string specifics_hash = 9;
    bool has_specifics_hash() const;

private:
    bool _internal_has_specifics_hash() const;

public:
    void clear_specifics_hash();
    const std::string& specifics_hash() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_specifics_hash(ArgT0&& arg0, ArgT... args);
    std::string* mutable_specifics_hash();
    PROTOBUF_NODISCARD std::string* release_specifics_hash();
    void set_allocated_specifics_hash(std::string* specifics_hash);

private:
    const std::string& _internal_specifics_hash() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_specifics_hash(const std::string& value);
    std::string* _internal_mutable_specifics_hash();

public:
    // optional string base_specifics_hash = 10;
    bool has_base_specifics_hash() const;

private:
    bool _internal_has_base_specifics_hash() const;

public:
    void clear_base_specifics_hash();
    const std::string& base_specifics_hash() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_base_specifics_hash(ArgT0&& arg0, ArgT... args);
    std::string* mutable_base_specifics_hash();
    PROTOBUF_NODISCARD std::string* release_base_specifics_hash();
    void set_allocated_base_specifics_hash(std::string* base_specifics_hash);

private:
    const std::string& _internal_base_specifics_hash() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_specifics_hash(const std::string& value);
    std::string* _internal_mutable_base_specifics_hash();

public:
    // optional string deleted_by_version = 14;
    bool has_deleted_by_version() const;

private:
    bool _internal_has_deleted_by_version() const;

public:
    void clear_deleted_by_version();
    const std::string& deleted_by_version() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_deleted_by_version(ArgT0&& arg0, ArgT... args);
    std::string* mutable_deleted_by_version();
    PROTOBUF_NODISCARD std::string* release_deleted_by_version();
    void set_allocated_deleted_by_version(std::string* deleted_by_version);

private:
    const std::string& _internal_deleted_by_version() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_deleted_by_version(const std::string& value);
    std::string* _internal_mutable_deleted_by_version();

public:
    // optional .sync_pb.UniquePosition unique_position = 11;
    bool has_unique_position() const;

private:
    bool _internal_has_unique_position() const;

public:
    void clear_unique_position();
    const ::sync_pb::UniquePosition& unique_position() const;
    PROTOBUF_NODISCARD ::sync_pb::UniquePosition* release_unique_position();
    ::sync_pb::UniquePosition* mutable_unique_position();
    void set_allocated_unique_position(::sync_pb::UniquePosition* unique_position);

private:
    const ::sync_pb::UniquePosition& _internal_unique_position() const;
    ::sync_pb::UniquePosition* _internal_mutable_unique_position();

public:
    void unsafe_arena_set_allocated_unique_position(::sync_pb::UniquePosition* unique_position);
    ::sync_pb::UniquePosition* unsafe_arena_release_unique_position();

    // optional .sync_pb.EntitySpecifics possibly_trimmed_base_specifics = 13;
    bool has_possibly_trimmed_base_specifics() const;

private:
    bool _internal_has_possibly_trimmed_base_specifics() const;

public:
    void clear_possibly_trimmed_base_specifics();
    const ::sync_pb::EntitySpecifics& possibly_trimmed_base_specifics() const;
    PROTOBUF_NODISCARD ::sync_pb::EntitySpecifics* release_possibly_trimmed_base_specifics();
    ::sync_pb::EntitySpecifics* mutable_possibly_trimmed_base_specifics();
    void set_allocated_possibly_trimmed_base_specifics(::sync_pb::EntitySpecifics* possibly_trimmed_base_specifics);

private:
    const ::sync_pb::EntitySpecifics& _internal_possibly_trimmed_base_specifics() const;
    ::sync_pb::EntitySpecifics* _internal_mutable_possibly_trimmed_base_specifics();

public:
    void unsafe_arena_set_allocated_possibly_trimmed_base_specifics(::sync_pb::EntitySpecifics* possibly_trimmed_base_specifics);
    ::sync_pb::EntitySpecifics* unsafe_arena_release_possibly_trimmed_base_specifics();

    // optional .sync_pb.EntityMetadata.CollaborationMetadata collaboration = 15;
    bool has_collaboration() const;

private:
    bool _internal_has_collaboration() const;

public:
    void clear_collaboration();
    const ::sync_pb::EntityMetadata_CollaborationMetadata& collaboration() const;
    PROTOBUF_NODISCARD ::sync_pb::EntityMetadata_CollaborationMetadata* release_collaboration();
    ::sync_pb::EntityMetadata_CollaborationMetadata* mutable_collaboration();
    void set_allocated_collaboration(::sync_pb::EntityMetadata_CollaborationMetadata* collaboration);

private:
    const ::sync_pb::EntityMetadata_CollaborationMetadata& _internal_collaboration() const;
    ::sync_pb::EntityMetadata_CollaborationMetadata* _internal_mutable_collaboration();

public:
    void unsafe_arena_set_allocated_collaboration(::sync_pb::EntityMetadata_CollaborationMetadata* collaboration);
    ::sync_pb::EntityMetadata_CollaborationMetadata* unsafe_arena_release_collaboration();

    // optional .sync_pb.DeletionOrigin deletion_origin = 16;
    bool has_deletion_origin() const;

private:
    bool _internal_has_deletion_origin() const;

public:
    void clear_deletion_origin();
    const ::sync_pb::DeletionOrigin& deletion_origin() const;
    PROTOBUF_NODISCARD ::sync_pb::DeletionOrigin* release_deletion_origin();
    ::sync_pb::DeletionOrigin* mutable_deletion_origin();
    void set_allocated_deletion_origin(::sync_pb::DeletionOrigin* deletion_origin);

private:
    const ::sync_pb::DeletionOrigin& _internal_deletion_origin() const;
    ::sync_pb::DeletionOrigin* _internal_mutable_deletion_origin();

public:
    void unsafe_arena_set_allocated_deletion_origin(::sync_pb::DeletionOrigin* deletion_origin);
    ::sync_pb::DeletionOrigin* unsafe_arena_release_deletion_origin();

    // optional int64 sequence_number = 4;
    bool has_sequence_number() const;

private:
    bool _internal_has_sequence_number() const;

public:
    void clear_sequence_number();
    int64_t sequence_number() const;
    void set_sequence_number(int64_t value);

private:
    int64_t _internal_sequence_number() const;
    void _internal_set_sequence_number(int64_t value);

public:
    // optional int64 acked_sequence_number = 5;
    bool has_acked_sequence_number() const;

private:
    bool _internal_has_acked_sequence_number() const;

public:
    void clear_acked_sequence_number();
    int64_t acked_sequence_number() const;
    void set_acked_sequence_number(int64_t value);

private:
    int64_t _internal_acked_sequence_number() const;
    void _internal_set_acked_sequence_number(int64_t value);

public:
    // optional int64 creation_time = 7;
    bool has_creation_time() const;

private:
    bool _internal_has_creation_time() const;

public:
    void clear_creation_time();
    int64_t creation_time() const;
    void set_creation_time(int64_t value);

private:
    int64_t _internal_creation_time() const;
    void _internal_set_creation_time(int64_t value);

public:
    // optional bool is_deleted = 3;
    bool has_is_deleted() const;

private:
    bool _internal_has_is_deleted() const;

public:
    void clear_is_deleted();
    bool is_deleted() const;
    void set_is_deleted(bool value);

private:
    bool _internal_is_deleted() const;
    void _internal_set_is_deleted(bool value);

public:
    // optional fixed32 bookmark_favicon_hash = 12;
    bool has_bookmark_favicon_hash() const;

private:
    bool _internal_has_bookmark_favicon_hash() const;

public:
    void clear_bookmark_favicon_hash();
    uint32_t bookmark_favicon_hash() const;
    void set_bookmark_favicon_hash(uint32_t value);

private:
    uint32_t _internal_bookmark_favicon_hash() const;
    void _internal_set_bookmark_favicon_hash(uint32_t value);

public:
    // optional int64 modification_time = 8;
    bool has_modification_time() const;

private:
    bool _internal_has_modification_time() const;

public:
    void clear_modification_time();
    int64_t modification_time() const;
    void set_modification_time(int64_t value);

private:
    int64_t _internal_modification_time() const;
    void _internal_set_modification_time(int64_t value);

public:
    // optional int64 server_version = 6 [default = -1];
    bool has_server_version() const;

private:
    bool _internal_has_server_version() const;

public:
    void clear_server_version();
    int64_t server_version() const;
    void set_server_version(int64_t value);

private:
    int64_t _internal_server_version() const;
    void _internal_set_server_version(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.EntityMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_tag_hash_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr specifics_hash_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_specifics_hash_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deleted_by_version_;
        ::sync_pb::UniquePosition* unique_position_;
        ::sync_pb::EntitySpecifics* possibly_trimmed_base_specifics_;
        ::sync_pb::EntityMetadata_CollaborationMetadata* collaboration_;
        ::sync_pb::DeletionOrigin* deletion_origin_;
        int64_t sequence_number_;
        int64_t acked_sequence_number_;
        int64_t creation_time_;
        bool is_deleted_;
        uint32_t bookmark_favicon_hash_;
        int64_t modification_time_;
        int64_t server_version_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fentity_5fmetadata_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// EntityMetadata_CollaborationMetadata

// optional string collaboration_id = 1;
inline bool EntityMetadata_CollaborationMetadata::_internal_has_collaboration_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool EntityMetadata_CollaborationMetadata::has_collaboration_id() const
{
    return _internal_has_collaboration_id();
}
inline void EntityMetadata_CollaborationMetadata::clear_collaboration_id()
{
    _impl_.collaboration_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EntityMetadata_CollaborationMetadata::collaboration_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.CollaborationMetadata.collaboration_id)
    return _internal_collaboration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE void EntityMetadata_CollaborationMetadata::set_collaboration_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.collaboration_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.CollaborationMetadata.collaboration_id)
}
inline std::string* EntityMetadata_CollaborationMetadata::mutable_collaboration_id()
{
    std::string* _s = _internal_mutable_collaboration_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.CollaborationMetadata.collaboration_id)
    return _s;
}
inline const std::string& EntityMetadata_CollaborationMetadata::_internal_collaboration_id() const
{
    return _impl_.collaboration_id_.Get();
}
inline void EntityMetadata_CollaborationMetadata::_internal_set_collaboration_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.collaboration_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntityMetadata_CollaborationMetadata::_internal_mutable_collaboration_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.collaboration_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntityMetadata_CollaborationMetadata::release_collaboration_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.CollaborationMetadata.collaboration_id)
    if (!_internal_has_collaboration_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.collaboration_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.collaboration_id_.IsDefault()) {
        _impl_.collaboration_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void EntityMetadata_CollaborationMetadata::set_allocated_collaboration_id(std::string* collaboration_id)
{
    if (collaboration_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.collaboration_id_.SetAllocated(collaboration_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.collaboration_id_.IsDefault()) {
        _impl_.collaboration_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.CollaborationMetadata.collaboration_id)
}

// -------------------------------------------------------------------

// EntityMetadata

// optional string client_tag_hash = 1;
inline bool EntityMetadata::_internal_has_client_tag_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool EntityMetadata::has_client_tag_hash() const
{
    return _internal_has_client_tag_hash();
}
inline void EntityMetadata::clear_client_tag_hash()
{
    _impl_.client_tag_hash_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EntityMetadata::client_tag_hash() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.client_tag_hash)
    return _internal_client_tag_hash();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void EntityMetadata::set_client_tag_hash(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.client_tag_hash_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.client_tag_hash)
}
inline std::string* EntityMetadata::mutable_client_tag_hash()
{
    std::string* _s = _internal_mutable_client_tag_hash();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.client_tag_hash)
    return _s;
}
inline const std::string& EntityMetadata::_internal_client_tag_hash() const
{
    return _impl_.client_tag_hash_.Get();
}
inline void EntityMetadata::_internal_set_client_tag_hash(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.client_tag_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* EntityMetadata::_internal_mutable_client_tag_hash()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.client_tag_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* EntityMetadata::release_client_tag_hash()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.client_tag_hash)
    if (!_internal_has_client_tag_hash()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.client_tag_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_tag_hash_.IsDefault()) {
        _impl_.client_tag_hash_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void EntityMetadata::set_allocated_client_tag_hash(std::string* client_tag_hash)
{
    if (client_tag_hash != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.client_tag_hash_.SetAllocated(client_tag_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_tag_hash_.IsDefault()) {
        _impl_.client_tag_hash_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.client_tag_hash)
}

// optional string server_id = 2;
inline bool EntityMetadata::_internal_has_server_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool EntityMetadata::has_server_id() const
{
    return _internal_has_server_id();
}
inline void EntityMetadata::clear_server_id()
{
    _impl_.server_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& EntityMetadata::server_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.server_id)
    return _internal_server_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void EntityMetadata::set_server_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.server_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.server_id)
}
inline std::string* EntityMetadata::mutable_server_id()
{
    std::string* _s = _internal_mutable_server_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.server_id)
    return _s;
}
inline const std::string& EntityMetadata::_internal_server_id() const
{
    return _impl_.server_id_.Get();
}
inline void EntityMetadata::_internal_set_server_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.server_id_.Set(value, GetArenaForAllocation());
}
inline std::string* EntityMetadata::_internal_mutable_server_id()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.server_id_.Mutable(GetArenaForAllocation());
}
inline std::string* EntityMetadata::release_server_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.server_id)
    if (!_internal_has_server_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.server_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.server_id_.IsDefault()) {
        _impl_.server_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void EntityMetadata::set_allocated_server_id(std::string* server_id)
{
    if (server_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.server_id_.SetAllocated(server_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.server_id_.IsDefault()) {
        _impl_.server_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.server_id)
}

// optional bool is_deleted = 3;
inline bool EntityMetadata::_internal_has_is_deleted() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool EntityMetadata::has_is_deleted() const
{
    return _internal_has_is_deleted();
}
inline void EntityMetadata::clear_is_deleted()
{
    _impl_.is_deleted_ = false;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool EntityMetadata::_internal_is_deleted() const
{
    return _impl_.is_deleted_;
}
inline bool EntityMetadata::is_deleted() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.is_deleted)
    return _internal_is_deleted();
}
inline void EntityMetadata::_internal_set_is_deleted(bool value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.is_deleted_ = value;
}
inline void EntityMetadata::set_is_deleted(bool value)
{
    _internal_set_is_deleted(value);
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.is_deleted)
}

// optional int64 sequence_number = 4;
inline bool EntityMetadata::_internal_has_sequence_number() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool EntityMetadata::has_sequence_number() const
{
    return _internal_has_sequence_number();
}
inline void EntityMetadata::clear_sequence_number()
{
    _impl_.sequence_number_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int64_t EntityMetadata::_internal_sequence_number() const
{
    return _impl_.sequence_number_;
}
inline int64_t EntityMetadata::sequence_number() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.sequence_number)
    return _internal_sequence_number();
}
inline void EntityMetadata::_internal_set_sequence_number(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.sequence_number_ = value;
}
inline void EntityMetadata::set_sequence_number(int64_t value)
{
    _internal_set_sequence_number(value);
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.sequence_number)
}

// optional int64 acked_sequence_number = 5;
inline bool EntityMetadata::_internal_has_acked_sequence_number() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool EntityMetadata::has_acked_sequence_number() const
{
    return _internal_has_acked_sequence_number();
}
inline void EntityMetadata::clear_acked_sequence_number()
{
    _impl_.acked_sequence_number_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t EntityMetadata::_internal_acked_sequence_number() const
{
    return _impl_.acked_sequence_number_;
}
inline int64_t EntityMetadata::acked_sequence_number() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.acked_sequence_number)
    return _internal_acked_sequence_number();
}
inline void EntityMetadata::_internal_set_acked_sequence_number(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.acked_sequence_number_ = value;
}
inline void EntityMetadata::set_acked_sequence_number(int64_t value)
{
    _internal_set_acked_sequence_number(value);
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.acked_sequence_number)
}

// optional int64 server_version = 6 [default = -1];
inline bool EntityMetadata::_internal_has_server_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
    return value;
}
inline bool EntityMetadata::has_server_version() const
{
    return _internal_has_server_version();
}
inline void EntityMetadata::clear_server_version()
{
    _impl_.server_version_ = int64_t { -1 };
    _impl_._has_bits_[0] &= ~0x00008000u;
}
inline int64_t EntityMetadata::_internal_server_version() const
{
    return _impl_.server_version_;
}
inline int64_t EntityMetadata::server_version() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.server_version)
    return _internal_server_version();
}
inline void EntityMetadata::_internal_set_server_version(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00008000u;
    _impl_.server_version_ = value;
}
inline void EntityMetadata::set_server_version(int64_t value)
{
    _internal_set_server_version(value);
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.server_version)
}

// optional int64 creation_time = 7;
inline bool EntityMetadata::_internal_has_creation_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool EntityMetadata::has_creation_time() const
{
    return _internal_has_creation_time();
}
inline void EntityMetadata::clear_creation_time()
{
    _impl_.creation_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int64_t EntityMetadata::_internal_creation_time() const
{
    return _impl_.creation_time_;
}
inline int64_t EntityMetadata::creation_time() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.creation_time)
    return _internal_creation_time();
}
inline void EntityMetadata::_internal_set_creation_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.creation_time_ = value;
}
inline void EntityMetadata::set_creation_time(int64_t value)
{
    _internal_set_creation_time(value);
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.creation_time)
}

// optional int64 modification_time = 8;
inline bool EntityMetadata::_internal_has_modification_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
    return value;
}
inline bool EntityMetadata::has_modification_time() const
{
    return _internal_has_modification_time();
}
inline void EntityMetadata::clear_modification_time()
{
    _impl_.modification_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00004000u;
}
inline int64_t EntityMetadata::_internal_modification_time() const
{
    return _impl_.modification_time_;
}
inline int64_t EntityMetadata::modification_time() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.modification_time)
    return _internal_modification_time();
}
inline void EntityMetadata::_internal_set_modification_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00004000u;
    _impl_.modification_time_ = value;
}
inline void EntityMetadata::set_modification_time(int64_t value)
{
    _internal_set_modification_time(value);
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.modification_time)
}

// optional string specifics_hash = 9;
inline bool EntityMetadata::_internal_has_specifics_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool EntityMetadata::has_specifics_hash() const
{
    return _internal_has_specifics_hash();
}
inline void EntityMetadata::clear_specifics_hash()
{
    _impl_.specifics_hash_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& EntityMetadata::specifics_hash() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.specifics_hash)
    return _internal_specifics_hash();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void EntityMetadata::set_specifics_hash(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.specifics_hash_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.specifics_hash)
}
inline std::string* EntityMetadata::mutable_specifics_hash()
{
    std::string* _s = _internal_mutable_specifics_hash();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.specifics_hash)
    return _s;
}
inline const std::string& EntityMetadata::_internal_specifics_hash() const
{
    return _impl_.specifics_hash_.Get();
}
inline void EntityMetadata::_internal_set_specifics_hash(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.specifics_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* EntityMetadata::_internal_mutable_specifics_hash()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.specifics_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* EntityMetadata::release_specifics_hash()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.specifics_hash)
    if (!_internal_has_specifics_hash()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.specifics_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.specifics_hash_.IsDefault()) {
        _impl_.specifics_hash_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void EntityMetadata::set_allocated_specifics_hash(std::string* specifics_hash)
{
    if (specifics_hash != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.specifics_hash_.SetAllocated(specifics_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.specifics_hash_.IsDefault()) {
        _impl_.specifics_hash_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.specifics_hash)
}

// optional string base_specifics_hash = 10;
inline bool EntityMetadata::_internal_has_base_specifics_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool EntityMetadata::has_base_specifics_hash() const
{
    return _internal_has_base_specifics_hash();
}
inline void EntityMetadata::clear_base_specifics_hash()
{
    _impl_.base_specifics_hash_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& EntityMetadata::base_specifics_hash() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.base_specifics_hash)
    return _internal_base_specifics_hash();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void EntityMetadata::set_base_specifics_hash(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.base_specifics_hash_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.base_specifics_hash)
}
inline std::string* EntityMetadata::mutable_base_specifics_hash()
{
    std::string* _s = _internal_mutable_base_specifics_hash();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.base_specifics_hash)
    return _s;
}
inline const std::string& EntityMetadata::_internal_base_specifics_hash() const
{
    return _impl_.base_specifics_hash_.Get();
}
inline void EntityMetadata::_internal_set_base_specifics_hash(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.base_specifics_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* EntityMetadata::_internal_mutable_base_specifics_hash()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.base_specifics_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* EntityMetadata::release_base_specifics_hash()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.base_specifics_hash)
    if (!_internal_has_base_specifics_hash()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.base_specifics_hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.base_specifics_hash_.IsDefault()) {
        _impl_.base_specifics_hash_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void EntityMetadata::set_allocated_base_specifics_hash(std::string* base_specifics_hash)
{
    if (base_specifics_hash != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.base_specifics_hash_.SetAllocated(base_specifics_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.base_specifics_hash_.IsDefault()) {
        _impl_.base_specifics_hash_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.base_specifics_hash)
}

// optional .sync_pb.UniquePosition unique_position = 11;
inline bool EntityMetadata::_internal_has_unique_position() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.unique_position_ != nullptr);
    return value;
}
inline bool EntityMetadata::has_unique_position() const
{
    return _internal_has_unique_position();
}
inline const ::sync_pb::UniquePosition& EntityMetadata::_internal_unique_position() const
{
    const ::sync_pb::UniquePosition* p = _impl_.unique_position_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::UniquePosition&>(::sync_pb::_UniquePosition_default_instance_);
}
inline const ::sync_pb::UniquePosition& EntityMetadata::unique_position() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.unique_position)
    return _internal_unique_position();
}
inline void EntityMetadata::unsafe_arena_set_allocated_unique_position(::sync_pb::UniquePosition* unique_position)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unique_position_);
    }
    _impl_.unique_position_ = unique_position;
    if (unique_position) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.EntityMetadata.unique_position)
}
inline ::sync_pb::UniquePosition* EntityMetadata::release_unique_position()
{
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::sync_pb::UniquePosition* temp = _impl_.unique_position_;
    _impl_.unique_position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::UniquePosition* EntityMetadata::unsafe_arena_release_unique_position()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.unique_position)
    _impl_._has_bits_[0] &= ~0x00000020u;
    ::sync_pb::UniquePosition* temp = _impl_.unique_position_;
    _impl_.unique_position_ = nullptr;
    return temp;
}
inline ::sync_pb::UniquePosition* EntityMetadata::_internal_mutable_unique_position()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    if (_impl_.unique_position_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::UniquePosition>(GetArenaForAllocation());
        _impl_.unique_position_ = p;
    }
    return _impl_.unique_position_;
}
inline ::sync_pb::UniquePosition* EntityMetadata::mutable_unique_position()
{
    ::sync_pb::UniquePosition* _msg = _internal_mutable_unique_position();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.unique_position)
    return _msg;
}
inline void EntityMetadata::set_allocated_unique_position(::sync_pb::UniquePosition* unique_position)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.unique_position_);
    }
    if (unique_position) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(unique_position));
        if (message_arena != submessage_arena) {
            unique_position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, unique_position, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.unique_position_ = unique_position;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.unique_position)
}

// optional fixed32 bookmark_favicon_hash = 12;
inline bool EntityMetadata::_internal_has_bookmark_favicon_hash() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool EntityMetadata::has_bookmark_favicon_hash() const
{
    return _internal_has_bookmark_favicon_hash();
}
inline void EntityMetadata::clear_bookmark_favicon_hash()
{
    _impl_.bookmark_favicon_hash_ = 0u;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline uint32_t EntityMetadata::_internal_bookmark_favicon_hash() const
{
    return _impl_.bookmark_favicon_hash_;
}
inline uint32_t EntityMetadata::bookmark_favicon_hash() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.bookmark_favicon_hash)
    return _internal_bookmark_favicon_hash();
}
inline void EntityMetadata::_internal_set_bookmark_favicon_hash(uint32_t value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.bookmark_favicon_hash_ = value;
}
inline void EntityMetadata::set_bookmark_favicon_hash(uint32_t value)
{
    _internal_set_bookmark_favicon_hash(value);
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.bookmark_favicon_hash)
}

// optional .sync_pb.EntitySpecifics possibly_trimmed_base_specifics = 13;
inline bool EntityMetadata::_internal_has_possibly_trimmed_base_specifics() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.possibly_trimmed_base_specifics_ != nullptr);
    return value;
}
inline bool EntityMetadata::has_possibly_trimmed_base_specifics() const
{
    return _internal_has_possibly_trimmed_base_specifics();
}
inline const ::sync_pb::EntitySpecifics& EntityMetadata::_internal_possibly_trimmed_base_specifics() const
{
    const ::sync_pb::EntitySpecifics* p = _impl_.possibly_trimmed_base_specifics_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::EntitySpecifics&>(::sync_pb::_EntitySpecifics_default_instance_);
}
inline const ::sync_pb::EntitySpecifics& EntityMetadata::possibly_trimmed_base_specifics() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.possibly_trimmed_base_specifics)
    return _internal_possibly_trimmed_base_specifics();
}
inline void EntityMetadata::unsafe_arena_set_allocated_possibly_trimmed_base_specifics(::sync_pb::EntitySpecifics* possibly_trimmed_base_specifics)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.possibly_trimmed_base_specifics_);
    }
    _impl_.possibly_trimmed_base_specifics_ = possibly_trimmed_base_specifics;
    if (possibly_trimmed_base_specifics) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.EntityMetadata.possibly_trimmed_base_specifics)
}
inline ::sync_pb::EntitySpecifics* EntityMetadata::release_possibly_trimmed_base_specifics()
{
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::sync_pb::EntitySpecifics* temp = _impl_.possibly_trimmed_base_specifics_;
    _impl_.possibly_trimmed_base_specifics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::EntitySpecifics* EntityMetadata::unsafe_arena_release_possibly_trimmed_base_specifics()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.possibly_trimmed_base_specifics)
    _impl_._has_bits_[0] &= ~0x00000040u;
    ::sync_pb::EntitySpecifics* temp = _impl_.possibly_trimmed_base_specifics_;
    _impl_.possibly_trimmed_base_specifics_ = nullptr;
    return temp;
}
inline ::sync_pb::EntitySpecifics* EntityMetadata::_internal_mutable_possibly_trimmed_base_specifics()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    if (_impl_.possibly_trimmed_base_specifics_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::EntitySpecifics>(GetArenaForAllocation());
        _impl_.possibly_trimmed_base_specifics_ = p;
    }
    return _impl_.possibly_trimmed_base_specifics_;
}
inline ::sync_pb::EntitySpecifics* EntityMetadata::mutable_possibly_trimmed_base_specifics()
{
    ::sync_pb::EntitySpecifics* _msg = _internal_mutable_possibly_trimmed_base_specifics();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.possibly_trimmed_base_specifics)
    return _msg;
}
inline void EntityMetadata::set_allocated_possibly_trimmed_base_specifics(::sync_pb::EntitySpecifics* possibly_trimmed_base_specifics)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.possibly_trimmed_base_specifics_);
    }
    if (possibly_trimmed_base_specifics) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(possibly_trimmed_base_specifics));
        if (message_arena != submessage_arena) {
            possibly_trimmed_base_specifics
                = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, possibly_trimmed_base_specifics, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.possibly_trimmed_base_specifics_ = possibly_trimmed_base_specifics;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.possibly_trimmed_base_specifics)
}

// optional string deleted_by_version = 14;
inline bool EntityMetadata::_internal_has_deleted_by_version() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool EntityMetadata::has_deleted_by_version() const
{
    return _internal_has_deleted_by_version();
}
inline void EntityMetadata::clear_deleted_by_version()
{
    _impl_.deleted_by_version_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& EntityMetadata::deleted_by_version() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.deleted_by_version)
    return _internal_deleted_by_version();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void EntityMetadata::set_deleted_by_version(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.deleted_by_version_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.EntityMetadata.deleted_by_version)
}
inline std::string* EntityMetadata::mutable_deleted_by_version()
{
    std::string* _s = _internal_mutable_deleted_by_version();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.deleted_by_version)
    return _s;
}
inline const std::string& EntityMetadata::_internal_deleted_by_version() const
{
    return _impl_.deleted_by_version_.Get();
}
inline void EntityMetadata::_internal_set_deleted_by_version(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.deleted_by_version_.Set(value, GetArenaForAllocation());
}
inline std::string* EntityMetadata::_internal_mutable_deleted_by_version()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.deleted_by_version_.Mutable(GetArenaForAllocation());
}
inline std::string* EntityMetadata::release_deleted_by_version()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.deleted_by_version)
    if (!_internal_has_deleted_by_version()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.deleted_by_version_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.deleted_by_version_.IsDefault()) {
        _impl_.deleted_by_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void EntityMetadata::set_allocated_deleted_by_version(std::string* deleted_by_version)
{
    if (deleted_by_version != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.deleted_by_version_.SetAllocated(deleted_by_version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.deleted_by_version_.IsDefault()) {
        _impl_.deleted_by_version_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.deleted_by_version)
}

// optional .sync_pb.EntityMetadata.CollaborationMetadata collaboration = 15;
inline bool EntityMetadata::_internal_has_collaboration() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.collaboration_ != nullptr);
    return value;
}
inline bool EntityMetadata::has_collaboration() const
{
    return _internal_has_collaboration();
}
inline void EntityMetadata::clear_collaboration()
{
    if (_impl_.collaboration_ != nullptr)
        _impl_.collaboration_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::sync_pb::EntityMetadata_CollaborationMetadata& EntityMetadata::_internal_collaboration() const
{
    const ::sync_pb::EntityMetadata_CollaborationMetadata* p = _impl_.collaboration_;
    return p != nullptr
        ? *p
        : reinterpret_cast<const ::sync_pb::EntityMetadata_CollaborationMetadata&>(::sync_pb::_EntityMetadata_CollaborationMetadata_default_instance_);
}
inline const ::sync_pb::EntityMetadata_CollaborationMetadata& EntityMetadata::collaboration() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.collaboration)
    return _internal_collaboration();
}
inline void EntityMetadata::unsafe_arena_set_allocated_collaboration(::sync_pb::EntityMetadata_CollaborationMetadata* collaboration)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.collaboration_);
    }
    _impl_.collaboration_ = collaboration;
    if (collaboration) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.EntityMetadata.collaboration)
}
inline ::sync_pb::EntityMetadata_CollaborationMetadata* EntityMetadata::release_collaboration()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::sync_pb::EntityMetadata_CollaborationMetadata* temp = _impl_.collaboration_;
    _impl_.collaboration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::EntityMetadata_CollaborationMetadata* EntityMetadata::unsafe_arena_release_collaboration()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.collaboration)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::sync_pb::EntityMetadata_CollaborationMetadata* temp = _impl_.collaboration_;
    _impl_.collaboration_ = nullptr;
    return temp;
}
inline ::sync_pb::EntityMetadata_CollaborationMetadata* EntityMetadata::_internal_mutable_collaboration()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.collaboration_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::EntityMetadata_CollaborationMetadata>(GetArenaForAllocation());
        _impl_.collaboration_ = p;
    }
    return _impl_.collaboration_;
}
inline ::sync_pb::EntityMetadata_CollaborationMetadata* EntityMetadata::mutable_collaboration()
{
    ::sync_pb::EntityMetadata_CollaborationMetadata* _msg = _internal_mutable_collaboration();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.collaboration)
    return _msg;
}
inline void EntityMetadata::set_allocated_collaboration(::sync_pb::EntityMetadata_CollaborationMetadata* collaboration)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.collaboration_;
    }
    if (collaboration) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(collaboration);
        if (message_arena != submessage_arena) {
            collaboration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, collaboration, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.collaboration_ = collaboration;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.collaboration)
}

// optional .sync_pb.DeletionOrigin deletion_origin = 16;
inline bool EntityMetadata::_internal_has_deletion_origin() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.deletion_origin_ != nullptr);
    return value;
}
inline bool EntityMetadata::has_deletion_origin() const
{
    return _internal_has_deletion_origin();
}
inline const ::sync_pb::DeletionOrigin& EntityMetadata::_internal_deletion_origin() const
{
    const ::sync_pb::DeletionOrigin* p = _impl_.deletion_origin_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::DeletionOrigin&>(::sync_pb::_DeletionOrigin_default_instance_);
}
inline const ::sync_pb::DeletionOrigin& EntityMetadata::deletion_origin() const
{
    // @@protoc_insertion_point(field_get:sync_pb.EntityMetadata.deletion_origin)
    return _internal_deletion_origin();
}
inline void EntityMetadata::unsafe_arena_set_allocated_deletion_origin(::sync_pb::DeletionOrigin* deletion_origin)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deletion_origin_);
    }
    _impl_.deletion_origin_ = deletion_origin;
    if (deletion_origin) {
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.EntityMetadata.deletion_origin)
}
inline ::sync_pb::DeletionOrigin* EntityMetadata::release_deletion_origin()
{
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::sync_pb::DeletionOrigin* temp = _impl_.deletion_origin_;
    _impl_.deletion_origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::DeletionOrigin* EntityMetadata::unsafe_arena_release_deletion_origin()
{
    // @@protoc_insertion_point(field_release:sync_pb.EntityMetadata.deletion_origin)
    _impl_._has_bits_[0] &= ~0x00000100u;
    ::sync_pb::DeletionOrigin* temp = _impl_.deletion_origin_;
    _impl_.deletion_origin_ = nullptr;
    return temp;
}
inline ::sync_pb::DeletionOrigin* EntityMetadata::_internal_mutable_deletion_origin()
{
    _impl_._has_bits_[0] |= 0x00000100u;
    if (_impl_.deletion_origin_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::DeletionOrigin>(GetArenaForAllocation());
        _impl_.deletion_origin_ = p;
    }
    return _impl_.deletion_origin_;
}
inline ::sync_pb::DeletionOrigin* EntityMetadata::mutable_deletion_origin()
{
    ::sync_pb::DeletionOrigin* _msg = _internal_mutable_deletion_origin();
    // @@protoc_insertion_point(field_mutable:sync_pb.EntityMetadata.deletion_origin)
    return _msg;
}
inline void EntityMetadata::set_allocated_deletion_origin(::sync_pb::DeletionOrigin* deletion_origin)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.deletion_origin_);
    }
    if (deletion_origin) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(deletion_origin));
        if (message_arena != submessage_arena) {
            deletion_origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, deletion_origin, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000100u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000100u;
    }
    _impl_.deletion_origin_ = deletion_origin;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.EntityMetadata.deletion_origin)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace sync_pb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fentity_5fmetadata_2eproto
