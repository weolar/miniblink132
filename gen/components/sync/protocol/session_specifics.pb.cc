// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/session_specifics.proto

#include "components/sync/protocol/session_specifics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR SessionSpecifics::SessionSpecifics(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.session_tag_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.header_)*/ nullptr,
        /*decltype(_impl_.tab_)*/ nullptr, /*decltype(_impl_.tab_node_id_)*/ -1 }
{
}
struct SessionSpecificsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SessionSpecificsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SessionSpecificsDefaultTypeInternal()
    {
    }
    union {
        SessionSpecifics _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionSpecificsDefaultTypeInternal _SessionSpecifics_default_instance_;
PROTOBUF_CONSTEXPR SessionHeader::SessionHeader(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.window_)*/ {},
        /*decltype(_impl_.client_name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.device_type_)*/ 0,
        /*decltype(_impl_.device_form_factor_)*/ 0, /*decltype(_impl_.session_start_time_unix_epoch_millis_)*/ int64_t { 0 } }
{
}
struct SessionHeaderDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SessionHeaderDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SessionHeaderDefaultTypeInternal()
    {
    }
    union {
        SessionHeader _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionHeaderDefaultTypeInternal _SessionHeader_default_instance_;
PROTOBUF_CONSTEXPR SessionWindow::SessionWindow(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.tab_)*/ {}, /*decltype(_impl_.window_id_)*/ 0,
        /*decltype(_impl_.selected_tab_index_)*/ -1, /*decltype(_impl_.browser_type_)*/ 1 }
{
}
struct SessionWindowDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SessionWindowDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SessionWindowDefaultTypeInternal()
    {
    }
    union {
        SessionWindow _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionWindowDefaultTypeInternal _SessionWindow_default_instance_;
PROTOBUF_CONSTEXPR SessionTab::SessionTab(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.navigation_)*/ {},
        /*decltype(_impl_.variation_id_)*/ {}, /*decltype(_impl_.extension_app_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.favicon_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.favicon_source_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.window_id_)*/ 0,
        /*decltype(_impl_.pinned_)*/ false, /*decltype(_impl_.last_active_time_unix_epoch_millis_)*/ int64_t { 0 }, /*decltype(_impl_.browser_type_)*/ 0,
        /*decltype(_impl_.tab_id_)*/ -1, /*decltype(_impl_.tab_visual_index_)*/ -1, /*decltype(_impl_.current_navigation_index_)*/ -1,
        /*decltype(_impl_.favicon_type_)*/ 1 }
{
}
struct SessionTabDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SessionTabDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SessionTabDefaultTypeInternal()
    {
    }
    union {
        SessionTab _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SessionTabDefaultTypeInternal _SessionTab_default_instance_;
PROTOBUF_CONSTEXPR TabNavigation::TabNavigation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.navigation_redirect_)*/ {},
        /*decltype(_impl_.ancestor_task_id_)*/ {}, /*decltype(_impl_.virtual_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.referrer_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.title_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.search_terms_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.favicon_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.last_navigation_redirect_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.page_language_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.replaced_navigation_)*/ nullptr, /*decltype(_impl_.page_transition_)*/ 0, /*decltype(_impl_.unique_id_)*/ 0,
        /*decltype(_impl_.timestamp_msec_)*/ int64_t { 0 }, /*decltype(_impl_.navigation_forward_back_)*/ false,
        /*decltype(_impl_.navigation_from_address_bar_)*/ false, /*decltype(_impl_.navigation_home_page_)*/ false,
        /*decltype(_impl_.navigation_chain_start_)*/ false, /*decltype(_impl_.navigation_chain_end_)*/ false, /*decltype(_impl_.is_restored_)*/ false,
        /*decltype(_impl_.global_id_)*/ int64_t { 0 }, /*decltype(_impl_.http_status_code_)*/ 0, /*decltype(_impl_.obsolete_referrer_policy_)*/ 0,
        /*decltype(_impl_.task_id_)*/ int64_t { 0 }, /*decltype(_impl_.password_state_)*/ 0, /*decltype(_impl_.correct_referrer_policy_)*/ 1,
        /*decltype(_impl_.redirect_type_)*/ 1, /*decltype(_impl_.blocked_state_)*/ 1 }
{
}
struct TabNavigationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TabNavigationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TabNavigationDefaultTypeInternal()
    {
    }
    union {
        TabNavigation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TabNavigationDefaultTypeInternal _TabNavigation_default_instance_;
PROTOBUF_CONSTEXPR NavigationRedirect::NavigationRedirect(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} } }
{
}
struct NavigationRedirectDefaultTypeInternal {
    PROTOBUF_CONSTEXPR NavigationRedirectDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~NavigationRedirectDefaultTypeInternal()
    {
    }
    union {
        NavigationRedirect _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NavigationRedirectDefaultTypeInternal _NavigationRedirect_default_instance_;
PROTOBUF_CONSTEXPR ReplacedNavigation::ReplacedNavigation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.first_committed_url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.first_timestamp_msec_)*/ int64_t { 0 }, /*decltype(_impl_.first_page_transition_)*/ 0 }
{
}
struct ReplacedNavigationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ReplacedNavigationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ReplacedNavigationDefaultTypeInternal()
    {
    }
    union {
        ReplacedNavigation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReplacedNavigationDefaultTypeInternal _ReplacedNavigation_default_instance_;
} // namespace sync_pb
namespace sync_pb {
bool SessionTab_FaviconType_IsValid(int value)
{
    switch (value) {
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SessionTab_FaviconType_strings[1] = {};

static const char SessionTab_FaviconType_names[] = "TYPE_WEB_FAVICON";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SessionTab_FaviconType_entries[] = {
    { { SessionTab_FaviconType_names + 0, 16 }, 1 },
};

static const int SessionTab_FaviconType_entries_by_number[] = {
    0, // 1 -> TYPE_WEB_FAVICON
};

const std::string& SessionTab_FaviconType_Name(SessionTab_FaviconType value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        SessionTab_FaviconType_entries, SessionTab_FaviconType_entries_by_number, 1, SessionTab_FaviconType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(SessionTab_FaviconType_entries, SessionTab_FaviconType_entries_by_number, 1, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : SessionTab_FaviconType_strings[idx].get();
}
bool SessionTab_FaviconType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionTab_FaviconType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(SessionTab_FaviconType_entries, 1, name, &int_value);
    if (success) {
        *value = static_cast<SessionTab_FaviconType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SessionTab_FaviconType SessionTab::TYPE_WEB_FAVICON;
constexpr SessionTab_FaviconType SessionTab::FaviconType_MIN;
constexpr SessionTab_FaviconType SessionTab::FaviconType_MAX;
constexpr int SessionTab::FaviconType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TabNavigation_BlockedState_IsValid(int value)
{
    switch (value) {
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TabNavigation_BlockedState_strings[2] = {};

static const char TabNavigation_BlockedState_names[] = "STATE_ALLOWED"
                                                       "STATE_BLOCKED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TabNavigation_BlockedState_entries[] = {
    { { TabNavigation_BlockedState_names + 0, 13 }, 1 },
    { { TabNavigation_BlockedState_names + 13, 13 }, 2 },
};

static const int TabNavigation_BlockedState_entries_by_number[] = {
    0, // 1 -> STATE_ALLOWED
    1, // 2 -> STATE_BLOCKED
};

const std::string& TabNavigation_BlockedState_Name(TabNavigation_BlockedState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        TabNavigation_BlockedState_entries, TabNavigation_BlockedState_entries_by_number, 2, TabNavigation_BlockedState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(TabNavigation_BlockedState_entries, TabNavigation_BlockedState_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : TabNavigation_BlockedState_strings[idx].get();
}
bool TabNavigation_BlockedState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TabNavigation_BlockedState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(TabNavigation_BlockedState_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<TabNavigation_BlockedState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TabNavigation_BlockedState TabNavigation::STATE_ALLOWED;
constexpr TabNavigation_BlockedState TabNavigation::STATE_BLOCKED;
constexpr TabNavigation_BlockedState TabNavigation::BlockedState_MIN;
constexpr TabNavigation_BlockedState TabNavigation::BlockedState_MAX;
constexpr int TabNavigation::BlockedState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SessionSpecifics::_Internal {
public:
    using HasBits = decltype(std::declval<SessionSpecifics>()._impl_._has_bits_);
    static void set_has_session_tag(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::sync_pb::SessionHeader& header(const SessionSpecifics* msg);
    static void set_has_header(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::sync_pb::SessionTab& tab(const SessionSpecifics* msg);
    static void set_has_tab(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_tab_node_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

const ::sync_pb::SessionHeader& SessionSpecifics::_Internal::header(const SessionSpecifics* msg)
{
    return *msg->_impl_.header_;
}
const ::sync_pb::SessionTab& SessionSpecifics::_Internal::tab(const SessionSpecifics* msg)
{
    return *msg->_impl_.tab_;
}
SessionSpecifics::SessionSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.SessionSpecifics)
}
SessionSpecifics::SessionSpecifics(const SessionSpecifics& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SessionSpecifics* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.session_tag_) {},
        decltype(_impl_.header_) { nullptr }, decltype(_impl_.tab_) { nullptr }, decltype(_impl_.tab_node_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.session_tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_session_tag()) {
        _this->_impl_.session_tag_.Set(from._internal_session_tag(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_header()) {
        _this->_impl_.header_ = new ::sync_pb::SessionHeader(*from._impl_.header_);
    }
    if (from._internal_has_tab()) {
        _this->_impl_.tab_ = new ::sync_pb::SessionTab(*from._impl_.tab_);
    }
    _this->_impl_.tab_node_id_ = from._impl_.tab_node_id_;
    // @@protoc_insertion_point(copy_constructor:sync_pb.SessionSpecifics)
}

inline void SessionSpecifics::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.session_tag_) {},
        decltype(_impl_.header_) { nullptr }, decltype(_impl_.tab_) { nullptr }, decltype(_impl_.tab_node_id_) { -1 } };
    _impl_.session_tag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_tag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SessionSpecifics::~SessionSpecifics()
{
    // @@protoc_insertion_point(destructor:sync_pb.SessionSpecifics)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SessionSpecifics::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.session_tag_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.header_;
    if (this != internal_default_instance())
        delete _impl_.tab_;
}

void SessionSpecifics::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SessionSpecifics::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.SessionSpecifics)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.session_tag_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.header_ != nullptr);
            _impl_.header_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.tab_ != nullptr);
            _impl_.tab_->Clear();
        }
        _impl_.tab_node_id_ = -1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SessionSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string session_tag = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_session_tag();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SessionHeader header = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_header(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SessionTab tab = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_tab(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 tab_node_id = 4 [default = -1];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_tab_node_id(&has_bits);
                _impl_.tab_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SessionSpecifics::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.SessionSpecifics)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string session_tag = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_session_tag(), target);
    }

    // optional .sync_pb.SessionHeader header = 2;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::header(this), _Internal::header(this).GetCachedSize(), target, stream);
    }

    // optional .sync_pb.SessionTab tab = 3;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::tab(this), _Internal::tab(this).GetCachedSize(), target, stream);
    }

    // optional int32 tab_node_id = 4 [default = -1];
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_tab_node_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.SessionSpecifics)
    return target;
}

size_t SessionSpecifics::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.SessionSpecifics)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string session_tag = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_session_tag());
        }

        // optional .sync_pb.SessionHeader header = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.header_);
        }

        // optional .sync_pb.SessionTab tab = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.tab_);
        }

        // optional int32 tab_node_id = 4 [default = -1];
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tab_node_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SessionSpecifics::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SessionSpecifics*>(&from));
}

void SessionSpecifics::MergeFrom(const SessionSpecifics& from)
{
    SessionSpecifics* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.SessionSpecifics)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_session_tag(from._internal_session_tag());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_header()->::sync_pb::SessionHeader::MergeFrom(from._internal_header());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_tab()->::sync_pb::SessionTab::MergeFrom(from._internal_tab());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.tab_node_id_ = from._impl_.tab_node_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionSpecifics::CopyFrom(const SessionSpecifics& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.SessionSpecifics)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SessionSpecifics::IsInitialized() const
{
    return true;
}

void SessionSpecifics::InternalSwap(SessionSpecifics* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.session_tag_, lhs_arena, &other->_impl_.session_tag_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SessionSpecifics, _impl_.tab_) + sizeof(SessionSpecifics::_impl_.tab_)
        - PROTOBUF_FIELD_OFFSET(SessionSpecifics, _impl_.header_)>(reinterpret_cast<char*>(&_impl_.header_), reinterpret_cast<char*>(&other->_impl_.header_));
    swap(_impl_.tab_node_id_, other->_impl_.tab_node_id_);
}

std::string SessionSpecifics::GetTypeName() const
{
    return "sync_pb.SessionSpecifics";
}

// ===================================================================

class SessionHeader::_Internal {
public:
    using HasBits = decltype(std::declval<SessionHeader>()._impl_._has_bits_);
    static void set_has_session_start_time_unix_epoch_millis(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_client_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_device_form_factor(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_device_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
};

SessionHeader::SessionHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.SessionHeader)
}
SessionHeader::SessionHeader(const SessionHeader& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SessionHeader* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.window_) { from._impl_.window_ }, decltype(_impl_.client_name_) {}, decltype(_impl_.device_type_) {},
        decltype(_impl_.device_form_factor_) {}, decltype(_impl_.session_start_time_unix_epoch_millis_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.client_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_client_name()) {
        _this->_impl_.client_name_.Set(from._internal_client_name(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.device_type_, &from._impl_.device_type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_start_time_unix_epoch_millis_) - reinterpret_cast<char*>(&_impl_.device_type_))
            + sizeof(_impl_.session_start_time_unix_epoch_millis_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.SessionHeader)
}

inline void SessionHeader::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.window_) { arena },
        decltype(_impl_.client_name_) {}, decltype(_impl_.device_type_) { 0 }, decltype(_impl_.device_form_factor_) { 0 },
        decltype(_impl_.session_start_time_unix_epoch_millis_) { int64_t { 0 } } };
    _impl_.client_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SessionHeader::~SessionHeader()
{
    // @@protoc_insertion_point(destructor:sync_pb.SessionHeader)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SessionHeader::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.window_.~RepeatedPtrField();
    _impl_.client_name_.Destroy();
}

void SessionHeader::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SessionHeader::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.SessionHeader)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.window_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.client_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x0000000eu) {
        ::memset(&_impl_.device_type_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.session_start_time_unix_epoch_millis_) - reinterpret_cast<char*>(&_impl_.device_type_))
                + sizeof(_impl_.session_start_time_unix_epoch_millis_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SessionHeader::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .sync_pb.SessionWindow window = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_window(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string client_name = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_client_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.DeviceType device_type = 4 [deprecated = true];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_DeviceType_IsValid(val))) {
                    _internal_set_device_type(static_cast<::sync_pb::SyncEnums_DeviceType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_DeviceFormFactor_IsValid(val))) {
                    _internal_set_device_form_factor(static_cast<::sync_pb::SyncEnums_DeviceFormFactor>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 session_start_time_unix_epoch_millis = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _Internal::set_has_session_start_time_unix_epoch_millis(&has_bits);
                _impl_.session_start_time_unix_epoch_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SessionHeader::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.SessionHeader)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .sync_pb.SessionWindow window = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_window_size()); i < n; i++) {
        const auto& repfield = this->_internal_window(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    cached_has_bits = _impl_._has_bits_[0];
    // optional string client_name = 3;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_client_name(), target);
    }

    // optional .sync_pb.SyncEnums.DeviceType device_type = 4 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_device_type(), target);
    }

    // optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 5;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_device_form_factor(), target);
    }

    // optional int64 session_start_time_unix_epoch_millis = 6;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_session_start_time_unix_epoch_millis(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.SessionHeader)
    return target;
}

size_t SessionHeader::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.SessionHeader)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.SessionWindow window = 2;
    total_size += 1UL * this->_internal_window_size();
    for (const auto& msg : this->_impl_.window_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional string client_name = 3;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_name());
        }

        // optional .sync_pb.SyncEnums.DeviceType device_type = 4 [deprecated = true];
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_device_type());
        }

        // optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 5;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_device_form_factor());
        }

        // optional int64 session_start_time_unix_epoch_millis = 6;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_session_start_time_unix_epoch_millis());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SessionHeader::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SessionHeader*>(&from));
}

void SessionHeader::MergeFrom(const SessionHeader& from)
{
    SessionHeader* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.SessionHeader)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.window_.MergeFrom(from._impl_.window_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_client_name(from._internal_client_name());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.device_type_ = from._impl_.device_type_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.device_form_factor_ = from._impl_.device_form_factor_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.session_start_time_unix_epoch_millis_ = from._impl_.session_start_time_unix_epoch_millis_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionHeader::CopyFrom(const SessionHeader& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.SessionHeader)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SessionHeader::IsInitialized() const
{
    return true;
}

void SessionHeader::InternalSwap(SessionHeader* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.window_.InternalSwap(&other->_impl_.window_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.client_name_, lhs_arena, &other->_impl_.client_name_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SessionHeader, _impl_.session_start_time_unix_epoch_millis_)
        + sizeof(SessionHeader::_impl_.session_start_time_unix_epoch_millis_) - PROTOBUF_FIELD_OFFSET(SessionHeader, _impl_.device_type_)>(
        reinterpret_cast<char*>(&_impl_.device_type_), reinterpret_cast<char*>(&other->_impl_.device_type_));
}

std::string SessionHeader::GetTypeName() const
{
    return "sync_pb.SessionHeader";
}

// ===================================================================

class SessionWindow::_Internal {
public:
    using HasBits = decltype(std::declval<SessionWindow>()._impl_._has_bits_);
    static void set_has_window_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_selected_tab_index(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_browser_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

SessionWindow::SessionWindow(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.SessionWindow)
}
SessionWindow::SessionWindow(const SessionWindow& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SessionWindow* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tab_) { from._impl_.tab_ },
            decltype(_impl_.window_id_) {}, decltype(_impl_.selected_tab_index_) {}, decltype(_impl_.browser_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.window_id_, &from._impl_.window_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.browser_type_) - reinterpret_cast<char*>(&_impl_.window_id_)) + sizeof(_impl_.browser_type_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.SessionWindow)
}

inline void SessionWindow::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.tab_) { arena },
        decltype(_impl_.window_id_) { 0 }, decltype(_impl_.selected_tab_index_) { -1 }, decltype(_impl_.browser_type_) { 1 } };
}

SessionWindow::~SessionWindow()
{
    // @@protoc_insertion_point(destructor:sync_pb.SessionWindow)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SessionWindow::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.tab_.~RepeatedField();
}

void SessionWindow::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SessionWindow::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.SessionWindow)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.tab_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        _impl_.window_id_ = 0;
        _impl_.selected_tab_index_ = -1;
        _impl_.browser_type_ = 1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SessionWindow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 window_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_window_id(&has_bits);
                _impl_.window_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 selected_tab_index = 2 [default = -1];
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_selected_tab_index(&has_bits);
                _impl_.selected_tab_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.BrowserType browser_type = 3 [default = TYPE_TABBED];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_BrowserType_IsValid(val))) {
                    _internal_set_browser_type(static_cast<::sync_pb::SyncEnums_BrowserType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // repeated int32 tab = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_tab(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
            } else if (static_cast<uint8_t>(tag) == 34) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_tab(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SessionWindow::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.SessionWindow)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 window_id = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_window_id(), target);
    }

    // optional int32 selected_tab_index = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_selected_tab_index(), target);
    }

    // optional .sync_pb.SyncEnums.BrowserType browser_type = 3 [default = TYPE_TABBED];
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_browser_type(), target);
    }

    // repeated int32 tab = 4;
    for (int i = 0, n = this->_internal_tab_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_tab(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.SessionWindow)
    return target;
}

size_t SessionWindow::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.SessionWindow)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 tab = 4;
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.tab_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_tab_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional int32 window_id = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_window_id());
        }

        // optional int32 selected_tab_index = 2 [default = -1];
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_selected_tab_index());
        }

        // optional .sync_pb.SyncEnums.BrowserType browser_type = 3 [default = TYPE_TABBED];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_browser_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SessionWindow::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SessionWindow*>(&from));
}

void SessionWindow::MergeFrom(const SessionWindow& from)
{
    SessionWindow* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.SessionWindow)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.tab_.MergeFrom(from._impl_.tab_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.window_id_ = from._impl_.window_id_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.selected_tab_index_ = from._impl_.selected_tab_index_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.browser_type_ = from._impl_.browser_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionWindow::CopyFrom(const SessionWindow& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.SessionWindow)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SessionWindow::IsInitialized() const
{
    return true;
}

void SessionWindow::InternalSwap(SessionWindow* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.tab_.InternalSwap(&other->_impl_.tab_);
    swap(_impl_.window_id_, other->_impl_.window_id_);
    swap(_impl_.selected_tab_index_, other->_impl_.selected_tab_index_);
    swap(_impl_.browser_type_, other->_impl_.browser_type_);
}

std::string SessionWindow::GetTypeName() const
{
    return "sync_pb.SessionWindow";
}

// ===================================================================

class SessionTab::_Internal {
public:
    using HasBits = decltype(std::declval<SessionTab>()._impl_._has_bits_);
    static void set_has_tab_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_window_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_tab_visual_index(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_current_navigation_index(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_pinned(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_extension_app_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_browser_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
    static void set_has_last_active_time_unix_epoch_millis(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_favicon(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_favicon_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_favicon_source(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

SessionTab::SessionTab(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.SessionTab)
}
SessionTab::SessionTab(const SessionTab& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SessionTab* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.navigation_) { from._impl_.navigation_ }, decltype(_impl_.variation_id_) { from._impl_.variation_id_ },
        decltype(_impl_.extension_app_id_) {}, decltype(_impl_.favicon_) {}, decltype(_impl_.favicon_source_) {}, decltype(_impl_.window_id_) {},
        decltype(_impl_.pinned_) {}, decltype(_impl_.last_active_time_unix_epoch_millis_) {}, decltype(_impl_.browser_type_) {}, decltype(_impl_.tab_id_) {},
        decltype(_impl_.tab_visual_index_) {}, decltype(_impl_.current_navigation_index_) {}, decltype(_impl_.favicon_type_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.extension_app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_extension_app_id()) {
        _this->_impl_.extension_app_id_.Set(from._internal_extension_app_id(), _this->GetArenaForAllocation());
    }
    _impl_.favicon_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_favicon()) {
        _this->_impl_.favicon_.Set(from._internal_favicon(), _this->GetArenaForAllocation());
    }
    _impl_.favicon_source_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_source_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_favicon_source()) {
        _this->_impl_.favicon_source_.Set(from._internal_favicon_source(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.window_id_, &from._impl_.window_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.favicon_type_) - reinterpret_cast<char*>(&_impl_.window_id_)) + sizeof(_impl_.favicon_type_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.SessionTab)
}

inline void SessionTab::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.navigation_) { arena },
        decltype(_impl_.variation_id_) { arena }, decltype(_impl_.extension_app_id_) {}, decltype(_impl_.favicon_) {}, decltype(_impl_.favicon_source_) {},
        decltype(_impl_.window_id_) { 0 }, decltype(_impl_.pinned_) { false }, decltype(_impl_.last_active_time_unix_epoch_millis_) { int64_t { 0 } },
        decltype(_impl_.browser_type_) { 0 }, decltype(_impl_.tab_id_) { -1 }, decltype(_impl_.tab_visual_index_) { -1 },
        decltype(_impl_.current_navigation_index_) { -1 }, decltype(_impl_.favicon_type_) { 1 } };
    _impl_.extension_app_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.extension_app_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_source_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_source_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SessionTab::~SessionTab()
{
    // @@protoc_insertion_point(destructor:sync_pb.SessionTab)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SessionTab::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.navigation_.~RepeatedPtrField();
    _impl_.variation_id_.~RepeatedField();
    _impl_.extension_app_id_.Destroy();
    _impl_.favicon_.Destroy();
    _impl_.favicon_source_.Destroy();
}

void SessionTab::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SessionTab::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.SessionTab)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.navigation_.Clear();
    _impl_.variation_id_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.extension_app_id_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.favicon_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.favicon_source_.ClearNonDefaultToEmpty();
        }
    }
    if (cached_has_bits & 0x000000f8u) {
        ::memset(&_impl_.window_id_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.browser_type_) - reinterpret_cast<char*>(&_impl_.window_id_)) + sizeof(_impl_.browser_type_));
        _impl_.tab_id_ = -1;
    }
    if (cached_has_bits & 0x00000700u) {
        _impl_.tab_visual_index_ = -1;
        _impl_.current_navigation_index_ = -1;
        _impl_.favicon_type_ = 1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* SessionTab::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 tab_id = 1 [default = -1];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_tab_id(&has_bits);
                _impl_.tab_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 window_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_window_id(&has_bits);
                _impl_.window_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 tab_visual_index = 3 [default = -1];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_tab_visual_index(&has_bits);
                _impl_.tab_visual_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 current_navigation_index = 4 [default = -1];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_current_navigation_index(&has_bits);
                _impl_.current_navigation_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool pinned = 5 [default = false];
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _Internal::set_has_pinned(&has_bits);
                _impl_.pinned_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string extension_app_id = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_extension_app_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.TabNavigation navigation = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_navigation(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional bytes favicon = 8 [deprecated = true];
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                auto str = _internal_mutable_favicon();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SessionTab.FaviconType favicon_type = 9 [deprecated = true];
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SessionTab_FaviconType_IsValid(val))) {
                    _internal_set_favicon_type(static_cast<::sync_pb::SessionTab_FaviconType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional string favicon_source = 11 [deprecated = true];
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                auto str = _internal_mutable_favicon_source();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated uint64 variation_id = 12 [deprecated = true];
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_variation_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
            } else if (static_cast<uint8_t>(tag) == 98) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_variation_id(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.BrowserType browser_type = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_BrowserType_IsValid(val))) {
                    _internal_set_browser_type(static_cast<::sync_pb::SyncEnums_BrowserType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 last_active_time_unix_epoch_millis = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _Internal::set_has_last_active_time_unix_epoch_millis(&has_bits);
                _impl_.last_active_time_unix_epoch_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SessionTab::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.SessionTab)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 tab_id = 1 [default = -1];
    if (cached_has_bits & 0x00000080u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tab_id(), target);
    }

    // optional int32 window_id = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_window_id(), target);
    }

    // optional int32 tab_visual_index = 3 [default = -1];
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_tab_visual_index(), target);
    }

    // optional int32 current_navigation_index = 4 [default = -1];
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_current_navigation_index(), target);
    }

    // optional bool pinned = 5 [default = false];
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_pinned(), target);
    }

    // optional string extension_app_id = 6;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(6, this->_internal_extension_app_id(), target);
    }

    // repeated .sync_pb.TabNavigation navigation = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_navigation_size()); i < n; i++) {
        const auto& repfield = this->_internal_navigation(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional bytes favicon = 8 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteBytesMaybeAliased(8, this->_internal_favicon(), target);
    }

    // optional .sync_pb.SessionTab.FaviconType favicon_type = 9 [deprecated = true];
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(9, this->_internal_favicon_type(), target);
    }

    // optional string favicon_source = 11 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(11, this->_internal_favicon_source(), target);
    }

    // repeated uint64 variation_id = 12 [deprecated = true];
    for (int i = 0, n = this->_internal_variation_id_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_variation_id(i), target);
    }

    // optional .sync_pb.SyncEnums.BrowserType browser_type = 13;
    if (cached_has_bits & 0x00000040u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(13, this->_internal_browser_type(), target);
    }

    // optional int64 last_active_time_unix_epoch_millis = 14;
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(14, this->_internal_last_active_time_unix_epoch_millis(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.SessionTab)
    return target;
}

size_t SessionTab::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.SessionTab)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.TabNavigation navigation = 7;
    total_size += 1UL * this->_internal_navigation_size();
    for (const auto& msg : this->_impl_.navigation_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated uint64 variation_id = 12 [deprecated = true];
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt64Size(this->_impl_.variation_id_);
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_variation_id_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string extension_app_id = 6;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_extension_app_id());
        }

        // optional bytes favicon = 8 [deprecated = true];
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_favicon());
        }

        // optional string favicon_source = 11 [deprecated = true];
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_favicon_source());
        }

        // optional int32 window_id = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_window_id());
        }

        // optional bool pinned = 5 [default = false];
        if (cached_has_bits & 0x00000010u) {
            total_size += 1 + 1;
        }

        // optional int64 last_active_time_unix_epoch_millis = 14;
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_active_time_unix_epoch_millis());
        }

        // optional .sync_pb.SyncEnums.BrowserType browser_type = 13;
        if (cached_has_bits & 0x00000040u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_browser_type());
        }

        // optional int32 tab_id = 1 [default = -1];
        if (cached_has_bits & 0x00000080u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tab_id());
        }
    }
    if (cached_has_bits & 0x00000700u) {
        // optional int32 tab_visual_index = 3 [default = -1];
        if (cached_has_bits & 0x00000100u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tab_visual_index());
        }

        // optional int32 current_navigation_index = 4 [default = -1];
        if (cached_has_bits & 0x00000200u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_current_navigation_index());
        }

        // optional .sync_pb.SessionTab.FaviconType favicon_type = 9 [deprecated = true];
        if (cached_has_bits & 0x00000400u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_favicon_type());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SessionTab::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SessionTab*>(&from));
}

void SessionTab::MergeFrom(const SessionTab& from)
{
    SessionTab* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.SessionTab)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.navigation_.MergeFrom(from._impl_.navigation_);
    _this->_impl_.variation_id_.MergeFrom(from._impl_.variation_id_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_extension_app_id(from._internal_extension_app_id());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_favicon(from._internal_favicon());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_favicon_source(from._internal_favicon_source());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.window_id_ = from._impl_.window_id_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.pinned_ = from._impl_.pinned_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.last_active_time_unix_epoch_millis_ = from._impl_.last_active_time_unix_epoch_millis_;
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_impl_.browser_type_ = from._impl_.browser_type_;
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_impl_.tab_id_ = from._impl_.tab_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00000700u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.tab_visual_index_ = from._impl_.tab_visual_index_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.current_navigation_index_ = from._impl_.current_navigation_index_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.favicon_type_ = from._impl_.favicon_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SessionTab::CopyFrom(const SessionTab& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.SessionTab)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SessionTab::IsInitialized() const
{
    return true;
}

void SessionTab::InternalSwap(SessionTab* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.navigation_.InternalSwap(&other->_impl_.navigation_);
    _impl_.variation_id_.InternalSwap(&other->_impl_.variation_id_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.extension_app_id_, lhs_arena, &other->_impl_.extension_app_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.favicon_, lhs_arena, &other->_impl_.favicon_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.favicon_source_, lhs_arena, &other->_impl_.favicon_source_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(SessionTab, _impl_.browser_type_) + sizeof(SessionTab::_impl_.browser_type_)
        - PROTOBUF_FIELD_OFFSET(SessionTab, _impl_.window_id_)>(
        reinterpret_cast<char*>(&_impl_.window_id_), reinterpret_cast<char*>(&other->_impl_.window_id_));
    swap(_impl_.tab_id_, other->_impl_.tab_id_);
    swap(_impl_.tab_visual_index_, other->_impl_.tab_visual_index_);
    swap(_impl_.current_navigation_index_, other->_impl_.current_navigation_index_);
    swap(_impl_.favicon_type_, other->_impl_.favicon_type_);
}

std::string SessionTab::GetTypeName() const
{
    return "sync_pb.SessionTab";
}

// ===================================================================

class TabNavigation::_Internal {
public:
    using HasBits = decltype(std::declval<TabNavigation>()._impl_._has_bits_);
    static void set_has_virtual_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_referrer(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_title(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_page_transition(HasBits* has_bits)
    {
        (*has_bits)[0] |= 256u;
    }
    static void set_has_redirect_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8388608u;
    }
    static void set_has_unique_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 512u;
    }
    static void set_has_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1024u;
    }
    static void set_has_navigation_forward_back(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2048u;
    }
    static void set_has_navigation_from_address_bar(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4096u;
    }
    static void set_has_navigation_home_page(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8192u;
    }
    static void set_has_global_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 131072u;
    }
    static void set_has_favicon_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_http_status_code(HasBits* has_bits)
    {
        (*has_bits)[0] |= 262144u;
    }
    static void set_has_correct_referrer_policy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4194304u;
    }
    static void set_has_password_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2097152u;
    }
    static void set_has_navigation_chain_start(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16384u;
    }
    static void set_has_navigation_chain_end(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32768u;
    }
    static void set_has_search_terms(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_blocked_state(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16777216u;
    }
    static void set_has_obsolete_referrer_policy(HasBits* has_bits)
    {
        (*has_bits)[0] |= 524288u;
    }
    static void set_has_is_restored(HasBits* has_bits)
    {
        (*has_bits)[0] |= 65536u;
    }
    static void set_has_last_navigation_redirect_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static void set_has_task_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1048576u;
    }
    static const ::sync_pb::ReplacedNavigation& replaced_navigation(const TabNavigation* msg);
    static void set_has_replaced_navigation(HasBits* has_bits)
    {
        (*has_bits)[0] |= 128u;
    }
    static void set_has_page_language(HasBits* has_bits)
    {
        (*has_bits)[0] |= 64u;
    }
};

const ::sync_pb::ReplacedNavigation& TabNavigation::_Internal::replaced_navigation(const TabNavigation* msg)
{
    return *msg->_impl_.replaced_navigation_;
}
TabNavigation::TabNavigation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.TabNavigation)
}
TabNavigation::TabNavigation(const TabNavigation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TabNavigation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.navigation_redirect_) { from._impl_.navigation_redirect_ }, decltype(_impl_.ancestor_task_id_) { from._impl_.ancestor_task_id_ },
        decltype(_impl_.virtual_url_) {}, decltype(_impl_.referrer_) {}, decltype(_impl_.title_) {}, decltype(_impl_.search_terms_) {},
        decltype(_impl_.favicon_url_) {}, decltype(_impl_.last_navigation_redirect_url_) {}, decltype(_impl_.page_language_) {},
        decltype(_impl_.replaced_navigation_) { nullptr }, decltype(_impl_.page_transition_) {}, decltype(_impl_.unique_id_) {},
        decltype(_impl_.timestamp_msec_) {}, decltype(_impl_.navigation_forward_back_) {}, decltype(_impl_.navigation_from_address_bar_) {},
        decltype(_impl_.navigation_home_page_) {}, decltype(_impl_.navigation_chain_start_) {}, decltype(_impl_.navigation_chain_end_) {},
        decltype(_impl_.is_restored_) {}, decltype(_impl_.global_id_) {}, decltype(_impl_.http_status_code_) {}, decltype(_impl_.obsolete_referrer_policy_) {},
        decltype(_impl_.task_id_) {}, decltype(_impl_.password_state_) {}, decltype(_impl_.correct_referrer_policy_) {}, decltype(_impl_.redirect_type_) {},
        decltype(_impl_.blocked_state_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.virtual_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.virtual_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_virtual_url()) {
        _this->_impl_.virtual_url_.Set(from._internal_virtual_url(), _this->GetArenaForAllocation());
    }
    _impl_.referrer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_referrer()) {
        _this->_impl_.referrer_.Set(from._internal_referrer(), _this->GetArenaForAllocation());
    }
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_title()) {
        _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
    }
    _impl_.search_terms_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_terms_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_search_terms()) {
        _this->_impl_.search_terms_.Set(from._internal_search_terms(), _this->GetArenaForAllocation());
    }
    _impl_.favicon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_favicon_url()) {
        _this->_impl_.favicon_url_.Set(from._internal_favicon_url(), _this->GetArenaForAllocation());
    }
    _impl_.last_navigation_redirect_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_navigation_redirect_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_last_navigation_redirect_url()) {
        _this->_impl_.last_navigation_redirect_url_.Set(from._internal_last_navigation_redirect_url(), _this->GetArenaForAllocation());
    }
    _impl_.page_language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_page_language()) {
        _this->_impl_.page_language_.Set(from._internal_page_language(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_replaced_navigation()) {
        _this->_impl_.replaced_navigation_ = new ::sync_pb::ReplacedNavigation(*from._impl_.replaced_navigation_);
    }
    ::memcpy(&_impl_.page_transition_, &from._impl_.page_transition_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.blocked_state_) - reinterpret_cast<char*>(&_impl_.page_transition_))
            + sizeof(_impl_.blocked_state_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.TabNavigation)
}

inline void TabNavigation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.navigation_redirect_) { arena },
        decltype(_impl_.ancestor_task_id_) { arena }, decltype(_impl_.virtual_url_) {}, decltype(_impl_.referrer_) {}, decltype(_impl_.title_) {},
        decltype(_impl_.search_terms_) {}, decltype(_impl_.favicon_url_) {}, decltype(_impl_.last_navigation_redirect_url_) {},
        decltype(_impl_.page_language_) {}, decltype(_impl_.replaced_navigation_) { nullptr }, decltype(_impl_.page_transition_) { 0 },
        decltype(_impl_.unique_id_) { 0 }, decltype(_impl_.timestamp_msec_) { int64_t { 0 } }, decltype(_impl_.navigation_forward_back_) { false },
        decltype(_impl_.navigation_from_address_bar_) { false }, decltype(_impl_.navigation_home_page_) { false },
        decltype(_impl_.navigation_chain_start_) { false }, decltype(_impl_.navigation_chain_end_) { false }, decltype(_impl_.is_restored_) { false },
        decltype(_impl_.global_id_) { int64_t { 0 } }, decltype(_impl_.http_status_code_) { 0 }, decltype(_impl_.obsolete_referrer_policy_) { 0 },
        decltype(_impl_.task_id_) { int64_t { 0 } }, decltype(_impl_.password_state_) { 0 }, decltype(_impl_.correct_referrer_policy_) { 1 },
        decltype(_impl_.redirect_type_) { 1 }, decltype(_impl_.blocked_state_) { 1 } };
    _impl_.virtual_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.virtual_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.referrer_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_terms_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.search_terms_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.favicon_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_navigation_redirect_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.last_navigation_redirect_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_language_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.page_language_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TabNavigation::~TabNavigation()
{
    // @@protoc_insertion_point(destructor:sync_pb.TabNavigation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TabNavigation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.navigation_redirect_.~RepeatedPtrField();
    _impl_.ancestor_task_id_.~RepeatedField();
    _impl_.virtual_url_.Destroy();
    _impl_.referrer_.Destroy();
    _impl_.title_.Destroy();
    _impl_.search_terms_.Destroy();
    _impl_.favicon_url_.Destroy();
    _impl_.last_navigation_redirect_url_.Destroy();
    _impl_.page_language_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.replaced_navigation_;
}

void TabNavigation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TabNavigation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.TabNavigation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.navigation_redirect_.Clear();
    _impl_.ancestor_task_id_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _impl_.virtual_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000002u) {
            _impl_.referrer_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000004u) {
            _impl_.title_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000008u) {
            _impl_.search_terms_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000010u) {
            _impl_.favicon_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000020u) {
            _impl_.last_navigation_redirect_url_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000040u) {
            _impl_.page_language_.ClearNonDefaultToEmpty();
        }
        if (cached_has_bits & 0x00000080u) {
            GOOGLE_DCHECK(_impl_.replaced_navigation_ != nullptr);
            _impl_.replaced_navigation_->Clear();
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        ::memset(&_impl_.page_transition_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.navigation_chain_end_) - reinterpret_cast<char*>(&_impl_.page_transition_))
                + sizeof(_impl_.navigation_chain_end_));
    }
    if (cached_has_bits & 0x00ff0000u) {
        ::memset(&_impl_.is_restored_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.password_state_) - reinterpret_cast<char*>(&_impl_.is_restored_))
                + sizeof(_impl_.password_state_));
        _impl_.correct_referrer_policy_ = 1;
        _impl_.redirect_type_ = 1;
    }
    _impl_.blocked_state_ = 1;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* TabNavigation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string virtual_url = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_virtual_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string referrer = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_referrer();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string title = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_title();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_PageTransition_IsValid(val))) {
                    _internal_set_page_transition(static_cast<::sync_pb::SyncEnums_PageTransition>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_PageTransitionRedirectType_IsValid(val))) {
                    _internal_set_redirect_type(static_cast<::sync_pb::SyncEnums_PageTransitionRedirectType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 unique_id = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _Internal::set_has_unique_id(&has_bits);
                _impl_.unique_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 timestamp_msec = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _Internal::set_has_timestamp_msec(&has_bits);
                _impl_.timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool navigation_forward_back = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                _Internal::set_has_navigation_forward_back(&has_bits);
                _impl_.navigation_forward_back_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool navigation_from_address_bar = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
                _Internal::set_has_navigation_from_address_bar(&has_bits);
                _impl_.navigation_from_address_bar_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool navigation_home_page = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _Internal::set_has_navigation_home_page(&has_bits);
                _impl_.navigation_home_page_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool navigation_chain_start = 13 [deprecated = true];
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
                _Internal::set_has_navigation_chain_start(&has_bits);
                _impl_.navigation_chain_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool navigation_chain_end = 14 [deprecated = true];
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
                _Internal::set_has_navigation_chain_end(&has_bits);
                _impl_.navigation_chain_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 global_id = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _Internal::set_has_global_id(&has_bits);
                _impl_.global_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string search_terms = 16 [deprecated = true];
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                auto str = _internal_mutable_search_terms();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string favicon_url = 17;
        case 17:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
                auto str = _internal_mutable_favicon_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED, deprecated = true];
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::TabNavigation_BlockedState_IsValid(val))) {
                    _internal_set_blocked_state(static_cast<::sync_pb::TabNavigation_BlockedState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(18, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 http_status_code = 20;
        case 20:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
                _Internal::set_has_http_status_code(&has_bits);
                _impl_.http_status_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 obsolete_referrer_policy = 21 [deprecated = true];
        case 21:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
                _Internal::set_has_obsolete_referrer_policy(&has_bits);
                _impl_.obsolete_referrer_policy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional bool is_restored = 22 [deprecated = true];
        case 22:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
                _Internal::set_has_is_restored(&has_bits);
                _impl_.is_restored_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sync_pb.NavigationRedirect navigation_redirect = 23 [deprecated = true];
        case 23:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    ptr = ctx->ParseMessage(_internal_add_navigation_redirect(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<186>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional string last_navigation_redirect_url = 24 [deprecated = true];
        case 24:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
                auto str = _internal_mutable_last_navigation_redirect_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 correct_referrer_policy = 25 [default = 1];
        case 25:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
                _Internal::set_has_correct_referrer_policy(&has_bits);
                _impl_.correct_referrer_policy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.PasswordState password_state = 26;
        case 26:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_PasswordState_IsValid(val))) {
                    _internal_set_password_state(static_cast<::sync_pb::SyncEnums_PasswordState>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(26, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int64 task_id = 27 [deprecated = true];
        case 27:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
                _Internal::set_has_task_id(&has_bits);
                _impl_.task_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int64 ancestor_task_id = 28 [deprecated = true];
        case 28:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
                ptr -= 2;
                do {
                    ptr += 2;
                    _internal_add_ancestor_task_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<224>(ptr));
            } else if (static_cast<uint8_t>(tag) == 226) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ancestor_task_id(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.ReplacedNavigation replaced_navigation = 29 [deprecated = true];
        case 29:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
                ptr = ctx->ParseMessage(_internal_mutable_replaced_navigation(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional string page_language = 30 [deprecated = true];
        case 30:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
                auto str = _internal_mutable_page_language();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TabNavigation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.TabNavigation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string virtual_url = 2;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(2, this->_internal_virtual_url(), target);
    }

    // optional string referrer = 3;
    if (cached_has_bits & 0x00000002u) {
        target = stream->WriteStringMaybeAliased(3, this->_internal_referrer(), target);
    }

    // optional string title = 4;
    if (cached_has_bits & 0x00000004u) {
        target = stream->WriteStringMaybeAliased(4, this->_internal_title(), target);
    }

    // optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];
    if (cached_has_bits & 0x00000100u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(6, this->_internal_page_transition(), target);
    }

    // optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
    if (cached_has_bits & 0x00800000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(7, this->_internal_redirect_type(), target);
    }

    // optional int32 unique_id = 8;
    if (cached_has_bits & 0x00000200u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_unique_id(), target);
    }

    // optional int64 timestamp_msec = 9;
    if (cached_has_bits & 0x00000400u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(9, this->_internal_timestamp_msec(), target);
    }

    // optional bool navigation_forward_back = 10;
    if (cached_has_bits & 0x00000800u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_navigation_forward_back(), target);
    }

    // optional bool navigation_from_address_bar = 11;
    if (cached_has_bits & 0x00001000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_navigation_from_address_bar(), target);
    }

    // optional bool navigation_home_page = 12;
    if (cached_has_bits & 0x00002000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_navigation_home_page(), target);
    }

    // optional bool navigation_chain_start = 13 [deprecated = true];
    if (cached_has_bits & 0x00004000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_navigation_chain_start(), target);
    }

    // optional bool navigation_chain_end = 14 [deprecated = true];
    if (cached_has_bits & 0x00008000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_navigation_chain_end(), target);
    }

    // optional int64 global_id = 15;
    if (cached_has_bits & 0x00020000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(15, this->_internal_global_id(), target);
    }

    // optional string search_terms = 16 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
        target = stream->WriteStringMaybeAliased(16, this->_internal_search_terms(), target);
    }

    // optional string favicon_url = 17;
    if (cached_has_bits & 0x00000010u) {
        target = stream->WriteStringMaybeAliased(17, this->_internal_favicon_url(), target);
    }

    // optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED, deprecated = true];
    if (cached_has_bits & 0x01000000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(18, this->_internal_blocked_state(), target);
    }

    // optional int32 http_status_code = 20;
    if (cached_has_bits & 0x00040000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(20, this->_internal_http_status_code(), target);
    }

    // optional int32 obsolete_referrer_policy = 21 [deprecated = true];
    if (cached_has_bits & 0x00080000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(21, this->_internal_obsolete_referrer_policy(), target);
    }

    // optional bool is_restored = 22 [deprecated = true];
    if (cached_has_bits & 0x00010000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_is_restored(), target);
    }

    // repeated .sync_pb.NavigationRedirect navigation_redirect = 23 [deprecated = true];
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_navigation_redirect_size()); i < n; i++) {
        const auto& repfield = this->_internal_navigation_redirect(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(23, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional string last_navigation_redirect_url = 24 [deprecated = true];
    if (cached_has_bits & 0x00000020u) {
        target = stream->WriteStringMaybeAliased(24, this->_internal_last_navigation_redirect_url(), target);
    }

    // optional int32 correct_referrer_policy = 25 [default = 1];
    if (cached_has_bits & 0x00400000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_correct_referrer_policy(), target);
    }

    // optional .sync_pb.SyncEnums.PasswordState password_state = 26;
    if (cached_has_bits & 0x00200000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(26, this->_internal_password_state(), target);
    }

    // optional int64 task_id = 27 [deprecated = true];
    if (cached_has_bits & 0x00100000u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(27, this->_internal_task_id(), target);
    }

    // repeated int64 ancestor_task_id = 28 [deprecated = true];
    for (int i = 0, n = this->_internal_ancestor_task_id_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(28, this->_internal_ancestor_task_id(i), target);
    }

    // optional .sync_pb.ReplacedNavigation replaced_navigation = 29 [deprecated = true];
    if (cached_has_bits & 0x00000080u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            29, _Internal::replaced_navigation(this), _Internal::replaced_navigation(this).GetCachedSize(), target, stream);
    }

    // optional string page_language = 30 [deprecated = true];
    if (cached_has_bits & 0x00000040u) {
        target = stream->WriteStringMaybeAliased(30, this->_internal_page_language(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.TabNavigation)
    return target;
}

size_t TabNavigation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.TabNavigation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sync_pb.NavigationRedirect navigation_redirect = 23 [deprecated = true];
    total_size += 2UL * this->_internal_navigation_redirect_size();
    for (const auto& msg : this->_impl_.navigation_redirect_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated int64 ancestor_task_id = 28 [deprecated = true];
    {
        size_t data_size = ::_pbi::WireFormatLite::Int64Size(this->_impl_.ancestor_task_id_);
        total_size += 2 * ::_pbi::FromIntSize(this->_internal_ancestor_task_id_size());
        total_size += data_size;
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        // optional string virtual_url = 2;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_virtual_url());
        }

        // optional string referrer = 3;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_referrer());
        }

        // optional string title = 4;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_title());
        }

        // optional string search_terms = 16 [deprecated = true];
        if (cached_has_bits & 0x00000008u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_search_terms());
        }

        // optional string favicon_url = 17;
        if (cached_has_bits & 0x00000010u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_favicon_url());
        }

        // optional string last_navigation_redirect_url = 24 [deprecated = true];
        if (cached_has_bits & 0x00000020u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_last_navigation_redirect_url());
        }

        // optional string page_language = 30 [deprecated = true];
        if (cached_has_bits & 0x00000040u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_page_language());
        }

        // optional .sync_pb.ReplacedNavigation replaced_navigation = 29 [deprecated = true];
        if (cached_has_bits & 0x00000080u) {
            total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.replaced_navigation_);
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        // optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];
        if (cached_has_bits & 0x00000100u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_page_transition());
        }

        // optional int32 unique_id = 8;
        if (cached_has_bits & 0x00000200u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_unique_id());
        }

        // optional int64 timestamp_msec = 9;
        if (cached_has_bits & 0x00000400u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_msec());
        }

        // optional bool navigation_forward_back = 10;
        if (cached_has_bits & 0x00000800u) {
            total_size += 1 + 1;
        }

        // optional bool navigation_from_address_bar = 11;
        if (cached_has_bits & 0x00001000u) {
            total_size += 1 + 1;
        }

        // optional bool navigation_home_page = 12;
        if (cached_has_bits & 0x00002000u) {
            total_size += 1 + 1;
        }

        // optional bool navigation_chain_start = 13 [deprecated = true];
        if (cached_has_bits & 0x00004000u) {
            total_size += 1 + 1;
        }

        // optional bool navigation_chain_end = 14 [deprecated = true];
        if (cached_has_bits & 0x00008000u) {
            total_size += 1 + 1;
        }
    }
    if (cached_has_bits & 0x00ff0000u) {
        // optional bool is_restored = 22 [deprecated = true];
        if (cached_has_bits & 0x00010000u) {
            total_size += 2 + 1;
        }

        // optional int64 global_id = 15;
        if (cached_has_bits & 0x00020000u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_global_id());
        }

        // optional int32 http_status_code = 20;
        if (cached_has_bits & 0x00040000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(this->_internal_http_status_code());
        }

        // optional int32 obsolete_referrer_policy = 21 [deprecated = true];
        if (cached_has_bits & 0x00080000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(this->_internal_obsolete_referrer_policy());
        }

        // optional int64 task_id = 27 [deprecated = true];
        if (cached_has_bits & 0x00100000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int64Size(this->_internal_task_id());
        }

        // optional .sync_pb.SyncEnums.PasswordState password_state = 26;
        if (cached_has_bits & 0x00200000u) {
            total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_password_state());
        }

        // optional int32 correct_referrer_policy = 25 [default = 1];
        if (cached_has_bits & 0x00400000u) {
            total_size += 2 + ::_pbi::WireFormatLite::Int32Size(this->_internal_correct_referrer_policy());
        }

        // optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
        if (cached_has_bits & 0x00800000u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_redirect_type());
        }
    }
    // optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED, deprecated = true];
    if (cached_has_bits & 0x01000000u) {
        total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_blocked_state());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TabNavigation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TabNavigation*>(&from));
}

void TabNavigation::MergeFrom(const TabNavigation& from)
{
    TabNavigation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.TabNavigation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.navigation_redirect_.MergeFrom(from._impl_.navigation_redirect_);
    _this->_impl_.ancestor_task_id_.MergeFrom(from._impl_.ancestor_task_id_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x000000ffu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_virtual_url(from._internal_virtual_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_set_referrer(from._internal_referrer());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_set_title(from._internal_title());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_internal_set_search_terms(from._internal_search_terms());
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_internal_set_favicon_url(from._internal_favicon_url());
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_internal_set_last_navigation_redirect_url(from._internal_last_navigation_redirect_url());
        }
        if (cached_has_bits & 0x00000040u) {
            _this->_internal_set_page_language(from._internal_page_language());
        }
        if (cached_has_bits & 0x00000080u) {
            _this->_internal_mutable_replaced_navigation()->::sync_pb::ReplacedNavigation::MergeFrom(from._internal_replaced_navigation());
        }
    }
    if (cached_has_bits & 0x0000ff00u) {
        if (cached_has_bits & 0x00000100u) {
            _this->_impl_.page_transition_ = from._impl_.page_transition_;
        }
        if (cached_has_bits & 0x00000200u) {
            _this->_impl_.unique_id_ = from._impl_.unique_id_;
        }
        if (cached_has_bits & 0x00000400u) {
            _this->_impl_.timestamp_msec_ = from._impl_.timestamp_msec_;
        }
        if (cached_has_bits & 0x00000800u) {
            _this->_impl_.navigation_forward_back_ = from._impl_.navigation_forward_back_;
        }
        if (cached_has_bits & 0x00001000u) {
            _this->_impl_.navigation_from_address_bar_ = from._impl_.navigation_from_address_bar_;
        }
        if (cached_has_bits & 0x00002000u) {
            _this->_impl_.navigation_home_page_ = from._impl_.navigation_home_page_;
        }
        if (cached_has_bits & 0x00004000u) {
            _this->_impl_.navigation_chain_start_ = from._impl_.navigation_chain_start_;
        }
        if (cached_has_bits & 0x00008000u) {
            _this->_impl_.navigation_chain_end_ = from._impl_.navigation_chain_end_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x00ff0000u) {
        if (cached_has_bits & 0x00010000u) {
            _this->_impl_.is_restored_ = from._impl_.is_restored_;
        }
        if (cached_has_bits & 0x00020000u) {
            _this->_impl_.global_id_ = from._impl_.global_id_;
        }
        if (cached_has_bits & 0x00040000u) {
            _this->_impl_.http_status_code_ = from._impl_.http_status_code_;
        }
        if (cached_has_bits & 0x00080000u) {
            _this->_impl_.obsolete_referrer_policy_ = from._impl_.obsolete_referrer_policy_;
        }
        if (cached_has_bits & 0x00100000u) {
            _this->_impl_.task_id_ = from._impl_.task_id_;
        }
        if (cached_has_bits & 0x00200000u) {
            _this->_impl_.password_state_ = from._impl_.password_state_;
        }
        if (cached_has_bits & 0x00400000u) {
            _this->_impl_.correct_referrer_policy_ = from._impl_.correct_referrer_policy_;
        }
        if (cached_has_bits & 0x00800000u) {
            _this->_impl_.redirect_type_ = from._impl_.redirect_type_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    if (cached_has_bits & 0x01000000u) {
        _this->_internal_set_blocked_state(from._internal_blocked_state());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TabNavigation::CopyFrom(const TabNavigation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.TabNavigation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TabNavigation::IsInitialized() const
{
    return true;
}

void TabNavigation::InternalSwap(TabNavigation* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.navigation_redirect_.InternalSwap(&other->_impl_.navigation_redirect_);
    _impl_.ancestor_task_id_.InternalSwap(&other->_impl_.ancestor_task_id_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.virtual_url_, lhs_arena, &other->_impl_.virtual_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.referrer_, lhs_arena, &other->_impl_.referrer_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena, &other->_impl_.title_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.search_terms_, lhs_arena, &other->_impl_.search_terms_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.favicon_url_, lhs_arena, &other->_impl_.favicon_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.last_navigation_redirect_url_, lhs_arena, &other->_impl_.last_navigation_redirect_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.page_language_, lhs_arena, &other->_impl_.page_language_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(TabNavigation, _impl_.password_state_) + sizeof(TabNavigation::_impl_.password_state_)
        - PROTOBUF_FIELD_OFFSET(TabNavigation, _impl_.replaced_navigation_)>(
        reinterpret_cast<char*>(&_impl_.replaced_navigation_), reinterpret_cast<char*>(&other->_impl_.replaced_navigation_));
    swap(_impl_.correct_referrer_policy_, other->_impl_.correct_referrer_policy_);
    swap(_impl_.redirect_type_, other->_impl_.redirect_type_);
    swap(_impl_.blocked_state_, other->_impl_.blocked_state_);
}

std::string TabNavigation::GetTypeName() const
{
    return "sync_pb.TabNavigation";
}

// ===================================================================

class NavigationRedirect::_Internal {
public:
    using HasBits = decltype(std::declval<NavigationRedirect>()._impl_._has_bits_);
    static void set_has_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

NavigationRedirect::NavigationRedirect(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.NavigationRedirect)
}
NavigationRedirect::NavigationRedirect(const NavigationRedirect& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    NavigationRedirect* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_url()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sync_pb.NavigationRedirect)
}

inline void NavigationRedirect::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.url_) {} };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NavigationRedirect::~NavigationRedirect()
{
    // @@protoc_insertion_point(destructor:sync_pb.NavigationRedirect)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void NavigationRedirect::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void NavigationRedirect::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void NavigationRedirect::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.NavigationRedirect)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.url_.ClearNonDefaultToEmpty();
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* NavigationRedirect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* NavigationRedirect::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.NavigationRedirect)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.NavigationRedirect)
    return target;
}

size_t NavigationRedirect::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.NavigationRedirect)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string url = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void NavigationRedirect::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const NavigationRedirect*>(&from));
}

void NavigationRedirect::MergeFrom(const NavigationRedirect& from)
{
    NavigationRedirect* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.NavigationRedirect)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_url()) {
        _this->_internal_set_url(from._internal_url());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NavigationRedirect::CopyFrom(const NavigationRedirect& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.NavigationRedirect)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool NavigationRedirect::IsInitialized() const
{
    return true;
}

void NavigationRedirect::InternalSwap(NavigationRedirect* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
}

std::string NavigationRedirect::GetTypeName() const
{
    return "sync_pb.NavigationRedirect";
}

// ===================================================================

class ReplacedNavigation::_Internal {
public:
    using HasBits = decltype(std::declval<ReplacedNavigation>()._impl_._has_bits_);
    static void set_has_first_committed_url(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_first_timestamp_msec(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_first_page_transition(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

ReplacedNavigation::ReplacedNavigation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sync_pb.ReplacedNavigation)
}
ReplacedNavigation::ReplacedNavigation(const ReplacedNavigation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ReplacedNavigation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.first_committed_url_) {}, decltype(_impl_.first_timestamp_msec_) {}, decltype(_impl_.first_page_transition_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.first_committed_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_committed_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_first_committed_url()) {
        _this->_impl_.first_committed_url_.Set(from._internal_first_committed_url(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.first_timestamp_msec_, &from._impl_.first_timestamp_msec_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.first_page_transition_) - reinterpret_cast<char*>(&_impl_.first_timestamp_msec_))
            + sizeof(_impl_.first_page_transition_));
    // @@protoc_insertion_point(copy_constructor:sync_pb.ReplacedNavigation)
}

inline void ReplacedNavigation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.first_committed_url_) {},
        decltype(_impl_.first_timestamp_msec_) { int64_t { 0 } }, decltype(_impl_.first_page_transition_) { 0 } };
    _impl_.first_committed_url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.first_committed_url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReplacedNavigation::~ReplacedNavigation()
{
    // @@protoc_insertion_point(destructor:sync_pb.ReplacedNavigation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ReplacedNavigation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.first_committed_url_.Destroy();
}

void ReplacedNavigation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ReplacedNavigation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sync_pb.ReplacedNavigation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.first_committed_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000006u) {
        ::memset(&_impl_.first_timestamp_msec_, 0,
            static_cast<size_t>(reinterpret_cast<char*>(&_impl_.first_page_transition_) - reinterpret_cast<char*>(&_impl_.first_timestamp_msec_))
                + sizeof(_impl_.first_page_transition_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ReplacedNavigation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string first_committed_url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_first_committed_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int64 first_timestamp_msec = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_first_timestamp_msec(&has_bits);
                _impl_.first_timestamp_msec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .sync_pb.SyncEnums.PageTransition first_page_transition = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_PageTransition_IsValid(val))) {
                    _internal_set_first_page_transition(static_cast<::sync_pb::SyncEnums_PageTransition>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ReplacedNavigation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ReplacedNavigation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string first_committed_url = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_first_committed_url(), target);
    }

    // optional int64 first_timestamp_msec = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_first_timestamp_msec(), target);
    }

    // optional .sync_pb.SyncEnums.PageTransition first_page_transition = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_first_page_transition(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ReplacedNavigation)
    return target;
}

size_t ReplacedNavigation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sync_pb.ReplacedNavigation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        // optional string first_committed_url = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_first_committed_url());
        }

        // optional int64 first_timestamp_msec = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_first_timestamp_msec());
        }

        // optional .sync_pb.SyncEnums.PageTransition first_page_transition = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_first_page_transition());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ReplacedNavigation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ReplacedNavigation*>(&from));
}

void ReplacedNavigation::MergeFrom(const ReplacedNavigation& from)
{
    ReplacedNavigation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ReplacedNavigation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_set_first_committed_url(from._internal_first_committed_url());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.first_timestamp_msec_ = from._impl_.first_timestamp_msec_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.first_page_transition_ = from._impl_.first_page_transition_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ReplacedNavigation::CopyFrom(const ReplacedNavigation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ReplacedNavigation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ReplacedNavigation::IsInitialized() const
{
    return true;
}

void ReplacedNavigation::InternalSwap(ReplacedNavigation* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.first_committed_url_, lhs_arena, &other->_impl_.first_committed_url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ReplacedNavigation, _impl_.first_page_transition_)
        + sizeof(ReplacedNavigation::_impl_.first_page_transition_) - PROTOBUF_FIELD_OFFSET(ReplacedNavigation, _impl_.first_timestamp_msec_)>(
        reinterpret_cast<char*>(&_impl_.first_timestamp_msec_), reinterpret_cast<char*>(&other->_impl_.first_timestamp_msec_));
}

std::string ReplacedNavigation::GetTypeName() const
{
    return "sync_pb.ReplacedNavigation";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::sync_pb::SessionSpecifics* Arena::CreateMaybeMessage<::sync_pb::SessionSpecifics>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::SessionSpecifics>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::SessionHeader* Arena::CreateMaybeMessage<::sync_pb::SessionHeader>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::SessionHeader>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::SessionWindow* Arena::CreateMaybeMessage<::sync_pb::SessionWindow>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::SessionWindow>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::SessionTab* Arena::CreateMaybeMessage<::sync_pb::SessionTab>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::SessionTab>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::TabNavigation* Arena::CreateMaybeMessage<::sync_pb::TabNavigation>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::TabNavigation>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::NavigationRedirect* Arena::CreateMaybeMessage<::sync_pb::NavigationRedirect>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::NavigationRedirect>(arena);
}
template <> PROTOBUF_NOINLINE ::sync_pb::ReplacedNavigation* Arena::CreateMaybeMessage<::sync_pb::ReplacedNavigation>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sync_pb::ReplacedNavigation>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
