// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/session_specifics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/sync/protocol/sync_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto {
    static const uint32_t offsets[];
};
namespace sync_pb {
class NavigationRedirect;
struct NavigationRedirectDefaultTypeInternal;
extern NavigationRedirectDefaultTypeInternal _NavigationRedirect_default_instance_;
class ReplacedNavigation;
struct ReplacedNavigationDefaultTypeInternal;
extern ReplacedNavigationDefaultTypeInternal _ReplacedNavigation_default_instance_;
class SessionHeader;
struct SessionHeaderDefaultTypeInternal;
extern SessionHeaderDefaultTypeInternal _SessionHeader_default_instance_;
class SessionSpecifics;
struct SessionSpecificsDefaultTypeInternal;
extern SessionSpecificsDefaultTypeInternal _SessionSpecifics_default_instance_;
class SessionTab;
struct SessionTabDefaultTypeInternal;
extern SessionTabDefaultTypeInternal _SessionTab_default_instance_;
class SessionWindow;
struct SessionWindowDefaultTypeInternal;
extern SessionWindowDefaultTypeInternal _SessionWindow_default_instance_;
class TabNavigation;
struct TabNavigationDefaultTypeInternal;
extern TabNavigationDefaultTypeInternal _TabNavigation_default_instance_;
} // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template <>::sync_pb::NavigationRedirect* Arena::CreateMaybeMessage<::sync_pb::NavigationRedirect>(Arena*);
template <>::sync_pb::ReplacedNavigation* Arena::CreateMaybeMessage<::sync_pb::ReplacedNavigation>(Arena*);
template <>::sync_pb::SessionHeader* Arena::CreateMaybeMessage<::sync_pb::SessionHeader>(Arena*);
template <>::sync_pb::SessionSpecifics* Arena::CreateMaybeMessage<::sync_pb::SessionSpecifics>(Arena*);
template <>::sync_pb::SessionTab* Arena::CreateMaybeMessage<::sync_pb::SessionTab>(Arena*);
template <>::sync_pb::SessionWindow* Arena::CreateMaybeMessage<::sync_pb::SessionWindow>(Arena*);
template <>::sync_pb::TabNavigation* Arena::CreateMaybeMessage<::sync_pb::TabNavigation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

enum SessionTab_FaviconType : int { SessionTab_FaviconType_TYPE_WEB_FAVICON = 1 };
bool SessionTab_FaviconType_IsValid(int value);
constexpr SessionTab_FaviconType SessionTab_FaviconType_FaviconType_MIN = SessionTab_FaviconType_TYPE_WEB_FAVICON;
constexpr SessionTab_FaviconType SessionTab_FaviconType_FaviconType_MAX = SessionTab_FaviconType_TYPE_WEB_FAVICON;
constexpr int SessionTab_FaviconType_FaviconType_ARRAYSIZE = SessionTab_FaviconType_FaviconType_MAX + 1;

const std::string& SessionTab_FaviconType_Name(SessionTab_FaviconType value);
template <typename T> inline const std::string& SessionTab_FaviconType_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, SessionTab_FaviconType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function SessionTab_FaviconType_Name.");
    return SessionTab_FaviconType_Name(static_cast<SessionTab_FaviconType>(enum_t_value));
}
bool SessionTab_FaviconType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionTab_FaviconType* value);
enum TabNavigation_BlockedState : int { TabNavigation_BlockedState_STATE_ALLOWED = 1, TabNavigation_BlockedState_STATE_BLOCKED = 2 };
bool TabNavigation_BlockedState_IsValid(int value);
constexpr TabNavigation_BlockedState TabNavigation_BlockedState_BlockedState_MIN = TabNavigation_BlockedState_STATE_ALLOWED;
constexpr TabNavigation_BlockedState TabNavigation_BlockedState_BlockedState_MAX = TabNavigation_BlockedState_STATE_BLOCKED;
constexpr int TabNavigation_BlockedState_BlockedState_ARRAYSIZE = TabNavigation_BlockedState_BlockedState_MAX + 1;

const std::string& TabNavigation_BlockedState_Name(TabNavigation_BlockedState value);
template <typename T> inline const std::string& TabNavigation_BlockedState_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, TabNavigation_BlockedState>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function TabNavigation_BlockedState_Name.");
    return TabNavigation_BlockedState_Name(static_cast<TabNavigation_BlockedState>(enum_t_value));
}
bool TabNavigation_BlockedState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TabNavigation_BlockedState* value);
// ===================================================================

class SessionSpecifics final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SessionSpecifics) */ {
public:
    inline SessionSpecifics()
        : SessionSpecifics(nullptr)
    {
    }
    ~SessionSpecifics() override;
    explicit PROTOBUF_CONSTEXPR SessionSpecifics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SessionSpecifics(const SessionSpecifics& from);
    SessionSpecifics(SessionSpecifics&& from) noexcept
        : SessionSpecifics()
    {
        *this = ::std::move(from);
    }

    inline SessionSpecifics& operator=(const SessionSpecifics& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SessionSpecifics& operator=(SessionSpecifics&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SessionSpecifics& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SessionSpecifics* internal_default_instance()
    {
        return reinterpret_cast<const SessionSpecifics*>(&_SessionSpecifics_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(SessionSpecifics& a, SessionSpecifics& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SessionSpecifics* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SessionSpecifics* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SessionSpecifics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SessionSpecifics>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SessionSpecifics& from);
    void MergeFrom(const SessionSpecifics& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SessionSpecifics* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.SessionSpecifics";
    }

protected:
    explicit SessionSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSessionTagFieldNumber = 1,
        kHeaderFieldNumber = 2,
        kTabFieldNumber = 3,
        kTabNodeIdFieldNumber = 4,
    };
    // optional string session_tag = 1;
    bool has_session_tag() const;

private:
    bool _internal_has_session_tag() const;

public:
    void clear_session_tag();
    const std::string& session_tag() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_session_tag(ArgT0&& arg0, ArgT... args);
    std::string* mutable_session_tag();
    PROTOBUF_NODISCARD std::string* release_session_tag();
    void set_allocated_session_tag(std::string* session_tag);

private:
    const std::string& _internal_session_tag() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_tag(const std::string& value);
    std::string* _internal_mutable_session_tag();

public:
    // optional .sync_pb.SessionHeader header = 2;
    bool has_header() const;

private:
    bool _internal_has_header() const;

public:
    void clear_header();
    const ::sync_pb::SessionHeader& header() const;
    PROTOBUF_NODISCARD ::sync_pb::SessionHeader* release_header();
    ::sync_pb::SessionHeader* mutable_header();
    void set_allocated_header(::sync_pb::SessionHeader* header);

private:
    const ::sync_pb::SessionHeader& _internal_header() const;
    ::sync_pb::SessionHeader* _internal_mutable_header();

public:
    void unsafe_arena_set_allocated_header(::sync_pb::SessionHeader* header);
    ::sync_pb::SessionHeader* unsafe_arena_release_header();

    // optional .sync_pb.SessionTab tab = 3;
    bool has_tab() const;

private:
    bool _internal_has_tab() const;

public:
    void clear_tab();
    const ::sync_pb::SessionTab& tab() const;
    PROTOBUF_NODISCARD ::sync_pb::SessionTab* release_tab();
    ::sync_pb::SessionTab* mutable_tab();
    void set_allocated_tab(::sync_pb::SessionTab* tab);

private:
    const ::sync_pb::SessionTab& _internal_tab() const;
    ::sync_pb::SessionTab* _internal_mutable_tab();

public:
    void unsafe_arena_set_allocated_tab(::sync_pb::SessionTab* tab);
    ::sync_pb::SessionTab* unsafe_arena_release_tab();

    // optional int32 tab_node_id = 4 [default = -1];
    bool has_tab_node_id() const;

private:
    bool _internal_has_tab_node_id() const;

public:
    void clear_tab_node_id();
    int32_t tab_node_id() const;
    void set_tab_node_id(int32_t value);

private:
    int32_t _internal_tab_node_id() const;
    void _internal_set_tab_node_id(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.SessionSpecifics)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_tag_;
        ::sync_pb::SessionHeader* header_;
        ::sync_pb::SessionTab* tab_;
        int32_t tab_node_id_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class SessionHeader final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SessionHeader) */ {
public:
    inline SessionHeader()
        : SessionHeader(nullptr)
    {
    }
    ~SessionHeader() override;
    explicit PROTOBUF_CONSTEXPR SessionHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SessionHeader(const SessionHeader& from);
    SessionHeader(SessionHeader&& from) noexcept
        : SessionHeader()
    {
        *this = ::std::move(from);
    }

    inline SessionHeader& operator=(const SessionHeader& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SessionHeader& operator=(SessionHeader&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SessionHeader& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SessionHeader* internal_default_instance()
    {
        return reinterpret_cast<const SessionHeader*>(&_SessionHeader_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(SessionHeader& a, SessionHeader& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SessionHeader* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SessionHeader* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SessionHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SessionHeader>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SessionHeader& from);
    void MergeFrom(const SessionHeader& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SessionHeader* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.SessionHeader";
    }

protected:
    explicit SessionHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kWindowFieldNumber = 2,
        kClientNameFieldNumber = 3,
        kDeviceTypeFieldNumber = 4,
        kDeviceFormFactorFieldNumber = 5,
        kSessionStartTimeUnixEpochMillisFieldNumber = 6,
    };
    // repeated .sync_pb.SessionWindow window = 2;
    int window_size() const;

private:
    int _internal_window_size() const;

public:
    void clear_window();
    ::sync_pb::SessionWindow* mutable_window(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SessionWindow>* mutable_window();

private:
    const ::sync_pb::SessionWindow& _internal_window(int index) const;
    ::sync_pb::SessionWindow* _internal_add_window();

public:
    const ::sync_pb::SessionWindow& window(int index) const;
    ::sync_pb::SessionWindow* add_window();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SessionWindow>& window() const;

    // optional string client_name = 3;
    bool has_client_name() const;

private:
    bool _internal_has_client_name() const;

public:
    void clear_client_name();
    const std::string& client_name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_client_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_client_name();
    PROTOBUF_NODISCARD std::string* release_client_name();
    void set_allocated_client_name(std::string* client_name);

private:
    const std::string& _internal_client_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
    std::string* _internal_mutable_client_name();

public:
    // optional .sync_pb.SyncEnums.DeviceType device_type = 4 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_device_type() const;

private:
    bool _internal_has_device_type() const;

public:
    PROTOBUF_DEPRECATED void clear_device_type();
    PROTOBUF_DEPRECATED ::sync_pb::SyncEnums_DeviceType device_type() const;
    PROTOBUF_DEPRECATED void set_device_type(::sync_pb::SyncEnums_DeviceType value);

private:
    ::sync_pb::SyncEnums_DeviceType _internal_device_type() const;
    void _internal_set_device_type(::sync_pb::SyncEnums_DeviceType value);

public:
    // optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 5;
    bool has_device_form_factor() const;

private:
    bool _internal_has_device_form_factor() const;

public:
    void clear_device_form_factor();
    ::sync_pb::SyncEnums_DeviceFormFactor device_form_factor() const;
    void set_device_form_factor(::sync_pb::SyncEnums_DeviceFormFactor value);

private:
    ::sync_pb::SyncEnums_DeviceFormFactor _internal_device_form_factor() const;
    void _internal_set_device_form_factor(::sync_pb::SyncEnums_DeviceFormFactor value);

public:
    // optional int64 session_start_time_unix_epoch_millis = 6;
    bool has_session_start_time_unix_epoch_millis() const;

private:
    bool _internal_has_session_start_time_unix_epoch_millis() const;

public:
    void clear_session_start_time_unix_epoch_millis();
    int64_t session_start_time_unix_epoch_millis() const;
    void set_session_start_time_unix_epoch_millis(int64_t value);

private:
    int64_t _internal_session_start_time_unix_epoch_millis() const;
    void _internal_set_session_start_time_unix_epoch_millis(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.SessionHeader)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SessionWindow> window_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
        int device_type_;
        int device_form_factor_;
        int64_t session_start_time_unix_epoch_millis_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class SessionWindow final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SessionWindow) */ {
public:
    inline SessionWindow()
        : SessionWindow(nullptr)
    {
    }
    ~SessionWindow() override;
    explicit PROTOBUF_CONSTEXPR SessionWindow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SessionWindow(const SessionWindow& from);
    SessionWindow(SessionWindow&& from) noexcept
        : SessionWindow()
    {
        *this = ::std::move(from);
    }

    inline SessionWindow& operator=(const SessionWindow& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SessionWindow& operator=(SessionWindow&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SessionWindow& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SessionWindow* internal_default_instance()
    {
        return reinterpret_cast<const SessionWindow*>(&_SessionWindow_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(SessionWindow& a, SessionWindow& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SessionWindow* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SessionWindow* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SessionWindow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SessionWindow>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SessionWindow& from);
    void MergeFrom(const SessionWindow& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SessionWindow* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.SessionWindow";
    }

protected:
    explicit SessionWindow(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTabFieldNumber = 4,
        kWindowIdFieldNumber = 1,
        kSelectedTabIndexFieldNumber = 2,
        kBrowserTypeFieldNumber = 3,
    };
    // repeated int32 tab = 4;
    int tab_size() const;

private:
    int _internal_tab_size() const;

public:
    void clear_tab();

private:
    int32_t _internal_tab(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& _internal_tab() const;
    void _internal_add_tab(int32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* _internal_mutable_tab();

public:
    int32_t tab(int index) const;
    void set_tab(int index, int32_t value);
    void add_tab(int32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& tab() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* mutable_tab();

    // optional int32 window_id = 1;
    bool has_window_id() const;

private:
    bool _internal_has_window_id() const;

public:
    void clear_window_id();
    int32_t window_id() const;
    void set_window_id(int32_t value);

private:
    int32_t _internal_window_id() const;
    void _internal_set_window_id(int32_t value);

public:
    // optional int32 selected_tab_index = 2 [default = -1];
    bool has_selected_tab_index() const;

private:
    bool _internal_has_selected_tab_index() const;

public:
    void clear_selected_tab_index();
    int32_t selected_tab_index() const;
    void set_selected_tab_index(int32_t value);

private:
    int32_t _internal_selected_tab_index() const;
    void _internal_set_selected_tab_index(int32_t value);

public:
    // optional .sync_pb.SyncEnums.BrowserType browser_type = 3 [default = TYPE_TABBED];
    bool has_browser_type() const;

private:
    bool _internal_has_browser_type() const;

public:
    void clear_browser_type();
    ::sync_pb::SyncEnums_BrowserType browser_type() const;
    void set_browser_type(::sync_pb::SyncEnums_BrowserType value);

private:
    ::sync_pb::SyncEnums_BrowserType _internal_browser_type() const;
    void _internal_set_browser_type(::sync_pb::SyncEnums_BrowserType value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.SessionWindow)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t> tab_;
        int32_t window_id_;
        int32_t selected_tab_index_;
        int browser_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class SessionTab final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SessionTab) */ {
public:
    inline SessionTab()
        : SessionTab(nullptr)
    {
    }
    ~SessionTab() override;
    explicit PROTOBUF_CONSTEXPR SessionTab(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SessionTab(const SessionTab& from);
    SessionTab(SessionTab&& from) noexcept
        : SessionTab()
    {
        *this = ::std::move(from);
    }

    inline SessionTab& operator=(const SessionTab& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SessionTab& operator=(SessionTab&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SessionTab& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SessionTab* internal_default_instance()
    {
        return reinterpret_cast<const SessionTab*>(&_SessionTab_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(SessionTab& a, SessionTab& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SessionTab* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SessionTab* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SessionTab* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SessionTab>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SessionTab& from);
    void MergeFrom(const SessionTab& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SessionTab* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.SessionTab";
    }

protected:
    explicit SessionTab(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SessionTab_FaviconType FaviconType;
    static constexpr FaviconType TYPE_WEB_FAVICON = SessionTab_FaviconType_TYPE_WEB_FAVICON;
    static inline bool FaviconType_IsValid(int value)
    {
        return SessionTab_FaviconType_IsValid(value);
    }
    static constexpr FaviconType FaviconType_MIN = SessionTab_FaviconType_FaviconType_MIN;
    static constexpr FaviconType FaviconType_MAX = SessionTab_FaviconType_FaviconType_MAX;
    static constexpr int FaviconType_ARRAYSIZE = SessionTab_FaviconType_FaviconType_ARRAYSIZE;
    template <typename T> static inline const std::string& FaviconType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, FaviconType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function FaviconType_Name.");
        return SessionTab_FaviconType_Name(enum_t_value);
    }
    static inline bool FaviconType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FaviconType* value)
    {
        return SessionTab_FaviconType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kNavigationFieldNumber = 7,
        kVariationIdFieldNumber = 12,
        kExtensionAppIdFieldNumber = 6,
        kFaviconFieldNumber = 8,
        kFaviconSourceFieldNumber = 11,
        kWindowIdFieldNumber = 2,
        kPinnedFieldNumber = 5,
        kLastActiveTimeUnixEpochMillisFieldNumber = 14,
        kBrowserTypeFieldNumber = 13,
        kTabIdFieldNumber = 1,
        kTabVisualIndexFieldNumber = 3,
        kCurrentNavigationIndexFieldNumber = 4,
        kFaviconTypeFieldNumber = 9,
    };
    // repeated .sync_pb.TabNavigation navigation = 7;
    int navigation_size() const;

private:
    int _internal_navigation_size() const;

public:
    void clear_navigation();
    ::sync_pb::TabNavigation* mutable_navigation(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::TabNavigation>* mutable_navigation();

private:
    const ::sync_pb::TabNavigation& _internal_navigation(int index) const;
    ::sync_pb::TabNavigation* _internal_add_navigation();

public:
    const ::sync_pb::TabNavigation& navigation(int index) const;
    ::sync_pb::TabNavigation* add_navigation();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::TabNavigation>& navigation() const;

    // repeated uint64 variation_id = 12 [deprecated = true];
    PROTOBUF_DEPRECATED int variation_id_size() const;

private:
    int _internal_variation_id_size() const;

public:
    PROTOBUF_DEPRECATED void clear_variation_id();

private:
    uint64_t _internal_variation_id(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& _internal_variation_id() const;
    void _internal_add_variation_id(uint64_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* _internal_mutable_variation_id();

public:
    PROTOBUF_DEPRECATED uint64_t variation_id(int index) const;
    PROTOBUF_DEPRECATED void set_variation_id(int index, uint64_t value);
    PROTOBUF_DEPRECATED void add_variation_id(uint64_t value);
    PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& variation_id() const;
    PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* mutable_variation_id();

    // optional string extension_app_id = 6;
    bool has_extension_app_id() const;

private:
    bool _internal_has_extension_app_id() const;

public:
    void clear_extension_app_id();
    const std::string& extension_app_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_extension_app_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_extension_app_id();
    PROTOBUF_NODISCARD std::string* release_extension_app_id();
    void set_allocated_extension_app_id(std::string* extension_app_id);

private:
    const std::string& _internal_extension_app_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_app_id(const std::string& value);
    std::string* _internal_mutable_extension_app_id();

public:
    // optional bytes favicon = 8 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_favicon() const;

private:
    bool _internal_has_favicon() const;

public:
    PROTOBUF_DEPRECATED void clear_favicon();
    PROTOBUF_DEPRECATED const std::string& favicon() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_favicon(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_favicon();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_favicon();
    PROTOBUF_DEPRECATED void set_allocated_favicon(std::string* favicon);

private:
    const std::string& _internal_favicon() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_favicon(const std::string& value);
    std::string* _internal_mutable_favicon();

public:
    // optional string favicon_source = 11 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_favicon_source() const;

private:
    bool _internal_has_favicon_source() const;

public:
    PROTOBUF_DEPRECATED void clear_favicon_source();
    PROTOBUF_DEPRECATED const std::string& favicon_source() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_favicon_source(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_favicon_source();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_favicon_source();
    PROTOBUF_DEPRECATED void set_allocated_favicon_source(std::string* favicon_source);

private:
    const std::string& _internal_favicon_source() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_favicon_source(const std::string& value);
    std::string* _internal_mutable_favicon_source();

public:
    // optional int32 window_id = 2;
    bool has_window_id() const;

private:
    bool _internal_has_window_id() const;

public:
    void clear_window_id();
    int32_t window_id() const;
    void set_window_id(int32_t value);

private:
    int32_t _internal_window_id() const;
    void _internal_set_window_id(int32_t value);

public:
    // optional bool pinned = 5 [default = false];
    bool has_pinned() const;

private:
    bool _internal_has_pinned() const;

public:
    void clear_pinned();
    bool pinned() const;
    void set_pinned(bool value);

private:
    bool _internal_pinned() const;
    void _internal_set_pinned(bool value);

public:
    // optional int64 last_active_time_unix_epoch_millis = 14;
    bool has_last_active_time_unix_epoch_millis() const;

private:
    bool _internal_has_last_active_time_unix_epoch_millis() const;

public:
    void clear_last_active_time_unix_epoch_millis();
    int64_t last_active_time_unix_epoch_millis() const;
    void set_last_active_time_unix_epoch_millis(int64_t value);

private:
    int64_t _internal_last_active_time_unix_epoch_millis() const;
    void _internal_set_last_active_time_unix_epoch_millis(int64_t value);

public:
    // optional .sync_pb.SyncEnums.BrowserType browser_type = 13;
    bool has_browser_type() const;

private:
    bool _internal_has_browser_type() const;

public:
    void clear_browser_type();
    ::sync_pb::SyncEnums_BrowserType browser_type() const;
    void set_browser_type(::sync_pb::SyncEnums_BrowserType value);

private:
    ::sync_pb::SyncEnums_BrowserType _internal_browser_type() const;
    void _internal_set_browser_type(::sync_pb::SyncEnums_BrowserType value);

public:
    // optional int32 tab_id = 1 [default = -1];
    bool has_tab_id() const;

private:
    bool _internal_has_tab_id() const;

public:
    void clear_tab_id();
    int32_t tab_id() const;
    void set_tab_id(int32_t value);

private:
    int32_t _internal_tab_id() const;
    void _internal_set_tab_id(int32_t value);

public:
    // optional int32 tab_visual_index = 3 [default = -1];
    bool has_tab_visual_index() const;

private:
    bool _internal_has_tab_visual_index() const;

public:
    void clear_tab_visual_index();
    int32_t tab_visual_index() const;
    void set_tab_visual_index(int32_t value);

private:
    int32_t _internal_tab_visual_index() const;
    void _internal_set_tab_visual_index(int32_t value);

public:
    // optional int32 current_navigation_index = 4 [default = -1];
    bool has_current_navigation_index() const;

private:
    bool _internal_has_current_navigation_index() const;

public:
    void clear_current_navigation_index();
    int32_t current_navigation_index() const;
    void set_current_navigation_index(int32_t value);

private:
    int32_t _internal_current_navigation_index() const;
    void _internal_set_current_navigation_index(int32_t value);

public:
    // optional .sync_pb.SessionTab.FaviconType favicon_type = 9 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_favicon_type() const;

private:
    bool _internal_has_favicon_type() const;

public:
    PROTOBUF_DEPRECATED void clear_favicon_type();
    PROTOBUF_DEPRECATED ::sync_pb::SessionTab_FaviconType favicon_type() const;
    PROTOBUF_DEPRECATED void set_favicon_type(::sync_pb::SessionTab_FaviconType value);

private:
    ::sync_pb::SessionTab_FaviconType _internal_favicon_type() const;
    void _internal_set_favicon_type(::sync_pb::SessionTab_FaviconType value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.SessionTab)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::TabNavigation> navigation_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t> variation_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_app_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr favicon_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr favicon_source_;
        int32_t window_id_;
        bool pinned_;
        int64_t last_active_time_unix_epoch_millis_;
        int browser_type_;
        int32_t tab_id_;
        int32_t tab_visual_index_;
        int32_t current_navigation_index_;
        int favicon_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class TabNavigation final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.TabNavigation) */ {
public:
    inline TabNavigation()
        : TabNavigation(nullptr)
    {
    }
    ~TabNavigation() override;
    explicit PROTOBUF_CONSTEXPR TabNavigation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TabNavigation(const TabNavigation& from);
    TabNavigation(TabNavigation&& from) noexcept
        : TabNavigation()
    {
        *this = ::std::move(from);
    }

    inline TabNavigation& operator=(const TabNavigation& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TabNavigation& operator=(TabNavigation&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const TabNavigation& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TabNavigation* internal_default_instance()
    {
        return reinterpret_cast<const TabNavigation*>(&_TabNavigation_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(TabNavigation& a, TabNavigation& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TabNavigation* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TabNavigation* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TabNavigation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TabNavigation>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TabNavigation& from);
    void MergeFrom(const TabNavigation& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TabNavigation* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.TabNavigation";
    }

protected:
    explicit TabNavigation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef TabNavigation_BlockedState BlockedState;
    static constexpr BlockedState STATE_ALLOWED = TabNavigation_BlockedState_STATE_ALLOWED;
    static constexpr BlockedState STATE_BLOCKED = TabNavigation_BlockedState_STATE_BLOCKED;
    static inline bool BlockedState_IsValid(int value)
    {
        return TabNavigation_BlockedState_IsValid(value);
    }
    static constexpr BlockedState BlockedState_MIN = TabNavigation_BlockedState_BlockedState_MIN;
    static constexpr BlockedState BlockedState_MAX = TabNavigation_BlockedState_BlockedState_MAX;
    static constexpr int BlockedState_ARRAYSIZE = TabNavigation_BlockedState_BlockedState_ARRAYSIZE;
    template <typename T> static inline const std::string& BlockedState_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, BlockedState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function BlockedState_Name.");
        return TabNavigation_BlockedState_Name(enum_t_value);
    }
    static inline bool BlockedState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BlockedState* value)
    {
        return TabNavigation_BlockedState_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kNavigationRedirectFieldNumber = 23,
        kAncestorTaskIdFieldNumber = 28,
        kVirtualUrlFieldNumber = 2,
        kReferrerFieldNumber = 3,
        kTitleFieldNumber = 4,
        kSearchTermsFieldNumber = 16,
        kFaviconUrlFieldNumber = 17,
        kLastNavigationRedirectUrlFieldNumber = 24,
        kPageLanguageFieldNumber = 30,
        kReplacedNavigationFieldNumber = 29,
        kPageTransitionFieldNumber = 6,
        kUniqueIdFieldNumber = 8,
        kTimestampMsecFieldNumber = 9,
        kNavigationForwardBackFieldNumber = 10,
        kNavigationFromAddressBarFieldNumber = 11,
        kNavigationHomePageFieldNumber = 12,
        kNavigationChainStartFieldNumber = 13,
        kNavigationChainEndFieldNumber = 14,
        kIsRestoredFieldNumber = 22,
        kGlobalIdFieldNumber = 15,
        kHttpStatusCodeFieldNumber = 20,
        kObsoleteReferrerPolicyFieldNumber = 21,
        kTaskIdFieldNumber = 27,
        kPasswordStateFieldNumber = 26,
        kCorrectReferrerPolicyFieldNumber = 25,
        kRedirectTypeFieldNumber = 7,
        kBlockedStateFieldNumber = 18,
    };
    // repeated .sync_pb.NavigationRedirect navigation_redirect = 23 [deprecated = true];
    PROTOBUF_DEPRECATED int navigation_redirect_size() const;

private:
    int _internal_navigation_redirect_size() const;

public:
    PROTOBUF_DEPRECATED void clear_navigation_redirect();
    PROTOBUF_DEPRECATED ::sync_pb::NavigationRedirect* mutable_navigation_redirect(int index);
    PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NavigationRedirect>* mutable_navigation_redirect();

private:
    const ::sync_pb::NavigationRedirect& _internal_navigation_redirect(int index) const;
    ::sync_pb::NavigationRedirect* _internal_add_navigation_redirect();

public:
    PROTOBUF_DEPRECATED const ::sync_pb::NavigationRedirect& navigation_redirect(int index) const;
    PROTOBUF_DEPRECATED ::sync_pb::NavigationRedirect* add_navigation_redirect();
    PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NavigationRedirect>& navigation_redirect() const;

    // repeated int64 ancestor_task_id = 28 [deprecated = true];
    PROTOBUF_DEPRECATED int ancestor_task_id_size() const;

private:
    int _internal_ancestor_task_id_size() const;

public:
    PROTOBUF_DEPRECATED void clear_ancestor_task_id();

private:
    int64_t _internal_ancestor_task_id(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& _internal_ancestor_task_id() const;
    void _internal_add_ancestor_task_id(int64_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* _internal_mutable_ancestor_task_id();

public:
    PROTOBUF_DEPRECATED int64_t ancestor_task_id(int index) const;
    PROTOBUF_DEPRECATED void set_ancestor_task_id(int index, int64_t value);
    PROTOBUF_DEPRECATED void add_ancestor_task_id(int64_t value);
    PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& ancestor_task_id() const;
    PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* mutable_ancestor_task_id();

    // optional string virtual_url = 2;
    bool has_virtual_url() const;

private:
    bool _internal_has_virtual_url() const;

public:
    void clear_virtual_url();
    const std::string& virtual_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_virtual_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_virtual_url();
    PROTOBUF_NODISCARD std::string* release_virtual_url();
    void set_allocated_virtual_url(std::string* virtual_url);

private:
    const std::string& _internal_virtual_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_virtual_url(const std::string& value);
    std::string* _internal_mutable_virtual_url();

public:
    // optional string referrer = 3;
    bool has_referrer() const;

private:
    bool _internal_has_referrer() const;

public:
    void clear_referrer();
    const std::string& referrer() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_referrer(ArgT0&& arg0, ArgT... args);
    std::string* mutable_referrer();
    PROTOBUF_NODISCARD std::string* release_referrer();
    void set_allocated_referrer(std::string* referrer);

private:
    const std::string& _internal_referrer() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_referrer(const std::string& value);
    std::string* _internal_mutable_referrer();

public:
    // optional string title = 4;
    bool has_title() const;

private:
    bool _internal_has_title() const;

public:
    void clear_title();
    const std::string& title() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_title(ArgT0&& arg0, ArgT... args);
    std::string* mutable_title();
    PROTOBUF_NODISCARD std::string* release_title();
    void set_allocated_title(std::string* title);

private:
    const std::string& _internal_title() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
    std::string* _internal_mutable_title();

public:
    // optional string search_terms = 16 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_search_terms() const;

private:
    bool _internal_has_search_terms() const;

public:
    PROTOBUF_DEPRECATED void clear_search_terms();
    PROTOBUF_DEPRECATED const std::string& search_terms() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_search_terms(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_search_terms();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_search_terms();
    PROTOBUF_DEPRECATED void set_allocated_search_terms(std::string* search_terms);

private:
    const std::string& _internal_search_terms() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_terms(const std::string& value);
    std::string* _internal_mutable_search_terms();

public:
    // optional string favicon_url = 17;
    bool has_favicon_url() const;

private:
    bool _internal_has_favicon_url() const;

public:
    void clear_favicon_url();
    const std::string& favicon_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_favicon_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_favicon_url();
    PROTOBUF_NODISCARD std::string* release_favicon_url();
    void set_allocated_favicon_url(std::string* favicon_url);

private:
    const std::string& _internal_favicon_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_favicon_url(const std::string& value);
    std::string* _internal_mutable_favicon_url();

public:
    // optional string last_navigation_redirect_url = 24 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_last_navigation_redirect_url() const;

private:
    bool _internal_has_last_navigation_redirect_url() const;

public:
    PROTOBUF_DEPRECATED void clear_last_navigation_redirect_url();
    PROTOBUF_DEPRECATED const std::string& last_navigation_redirect_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_last_navigation_redirect_url(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_last_navigation_redirect_url();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_last_navigation_redirect_url();
    PROTOBUF_DEPRECATED void set_allocated_last_navigation_redirect_url(std::string* last_navigation_redirect_url);

private:
    const std::string& _internal_last_navigation_redirect_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_navigation_redirect_url(const std::string& value);
    std::string* _internal_mutable_last_navigation_redirect_url();

public:
    // optional string page_language = 30 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_page_language() const;

private:
    bool _internal_has_page_language() const;

public:
    PROTOBUF_DEPRECATED void clear_page_language();
    PROTOBUF_DEPRECATED const std::string& page_language() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> PROTOBUF_DEPRECATED void set_page_language(ArgT0&& arg0, ArgT... args);
    PROTOBUF_DEPRECATED std::string* mutable_page_language();
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_page_language();
    PROTOBUF_DEPRECATED void set_allocated_page_language(std::string* page_language);

private:
    const std::string& _internal_page_language() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_language(const std::string& value);
    std::string* _internal_mutable_page_language();

public:
    // optional .sync_pb.ReplacedNavigation replaced_navigation = 29 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_replaced_navigation() const;

private:
    bool _internal_has_replaced_navigation() const;

public:
    PROTOBUF_DEPRECATED void clear_replaced_navigation();
    PROTOBUF_DEPRECATED const ::sync_pb::ReplacedNavigation& replaced_navigation() const;
    PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::sync_pb::ReplacedNavigation* release_replaced_navigation();
    PROTOBUF_DEPRECATED ::sync_pb::ReplacedNavigation* mutable_replaced_navigation();
    PROTOBUF_DEPRECATED void set_allocated_replaced_navigation(::sync_pb::ReplacedNavigation* replaced_navigation);

private:
    const ::sync_pb::ReplacedNavigation& _internal_replaced_navigation() const;
    ::sync_pb::ReplacedNavigation* _internal_mutable_replaced_navigation();

public:
    PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_replaced_navigation(::sync_pb::ReplacedNavigation* replaced_navigation);
    PROTOBUF_DEPRECATED ::sync_pb::ReplacedNavigation* unsafe_arena_release_replaced_navigation();

    // optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];
    bool has_page_transition() const;

private:
    bool _internal_has_page_transition() const;

public:
    void clear_page_transition();
    ::sync_pb::SyncEnums_PageTransition page_transition() const;
    void set_page_transition(::sync_pb::SyncEnums_PageTransition value);

private:
    ::sync_pb::SyncEnums_PageTransition _internal_page_transition() const;
    void _internal_set_page_transition(::sync_pb::SyncEnums_PageTransition value);

public:
    // optional int32 unique_id = 8;
    bool has_unique_id() const;

private:
    bool _internal_has_unique_id() const;

public:
    void clear_unique_id();
    int32_t unique_id() const;
    void set_unique_id(int32_t value);

private:
    int32_t _internal_unique_id() const;
    void _internal_set_unique_id(int32_t value);

public:
    // optional int64 timestamp_msec = 9;
    bool has_timestamp_msec() const;

private:
    bool _internal_has_timestamp_msec() const;

public:
    void clear_timestamp_msec();
    int64_t timestamp_msec() const;
    void set_timestamp_msec(int64_t value);

private:
    int64_t _internal_timestamp_msec() const;
    void _internal_set_timestamp_msec(int64_t value);

public:
    // optional bool navigation_forward_back = 10;
    bool has_navigation_forward_back() const;

private:
    bool _internal_has_navigation_forward_back() const;

public:
    void clear_navigation_forward_back();
    bool navigation_forward_back() const;
    void set_navigation_forward_back(bool value);

private:
    bool _internal_navigation_forward_back() const;
    void _internal_set_navigation_forward_back(bool value);

public:
    // optional bool navigation_from_address_bar = 11;
    bool has_navigation_from_address_bar() const;

private:
    bool _internal_has_navigation_from_address_bar() const;

public:
    void clear_navigation_from_address_bar();
    bool navigation_from_address_bar() const;
    void set_navigation_from_address_bar(bool value);

private:
    bool _internal_navigation_from_address_bar() const;
    void _internal_set_navigation_from_address_bar(bool value);

public:
    // optional bool navigation_home_page = 12;
    bool has_navigation_home_page() const;

private:
    bool _internal_has_navigation_home_page() const;

public:
    void clear_navigation_home_page();
    bool navigation_home_page() const;
    void set_navigation_home_page(bool value);

private:
    bool _internal_navigation_home_page() const;
    void _internal_set_navigation_home_page(bool value);

public:
    // optional bool navigation_chain_start = 13 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_navigation_chain_start() const;

private:
    bool _internal_has_navigation_chain_start() const;

public:
    PROTOBUF_DEPRECATED void clear_navigation_chain_start();
    PROTOBUF_DEPRECATED bool navigation_chain_start() const;
    PROTOBUF_DEPRECATED void set_navigation_chain_start(bool value);

private:
    bool _internal_navigation_chain_start() const;
    void _internal_set_navigation_chain_start(bool value);

public:
    // optional bool navigation_chain_end = 14 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_navigation_chain_end() const;

private:
    bool _internal_has_navigation_chain_end() const;

public:
    PROTOBUF_DEPRECATED void clear_navigation_chain_end();
    PROTOBUF_DEPRECATED bool navigation_chain_end() const;
    PROTOBUF_DEPRECATED void set_navigation_chain_end(bool value);

private:
    bool _internal_navigation_chain_end() const;
    void _internal_set_navigation_chain_end(bool value);

public:
    // optional bool is_restored = 22 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_is_restored() const;

private:
    bool _internal_has_is_restored() const;

public:
    PROTOBUF_DEPRECATED void clear_is_restored();
    PROTOBUF_DEPRECATED bool is_restored() const;
    PROTOBUF_DEPRECATED void set_is_restored(bool value);

private:
    bool _internal_is_restored() const;
    void _internal_set_is_restored(bool value);

public:
    // optional int64 global_id = 15;
    bool has_global_id() const;

private:
    bool _internal_has_global_id() const;

public:
    void clear_global_id();
    int64_t global_id() const;
    void set_global_id(int64_t value);

private:
    int64_t _internal_global_id() const;
    void _internal_set_global_id(int64_t value);

public:
    // optional int32 http_status_code = 20;
    bool has_http_status_code() const;

private:
    bool _internal_has_http_status_code() const;

public:
    void clear_http_status_code();
    int32_t http_status_code() const;
    void set_http_status_code(int32_t value);

private:
    int32_t _internal_http_status_code() const;
    void _internal_set_http_status_code(int32_t value);

public:
    // optional int32 obsolete_referrer_policy = 21 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_obsolete_referrer_policy() const;

private:
    bool _internal_has_obsolete_referrer_policy() const;

public:
    PROTOBUF_DEPRECATED void clear_obsolete_referrer_policy();
    PROTOBUF_DEPRECATED int32_t obsolete_referrer_policy() const;
    PROTOBUF_DEPRECATED void set_obsolete_referrer_policy(int32_t value);

private:
    int32_t _internal_obsolete_referrer_policy() const;
    void _internal_set_obsolete_referrer_policy(int32_t value);

public:
    // optional int64 task_id = 27 [deprecated = true];
    PROTOBUF_DEPRECATED bool has_task_id() const;

private:
    bool _internal_has_task_id() const;

public:
    PROTOBUF_DEPRECATED void clear_task_id();
    PROTOBUF_DEPRECATED int64_t task_id() const;
    PROTOBUF_DEPRECATED void set_task_id(int64_t value);

private:
    int64_t _internal_task_id() const;
    void _internal_set_task_id(int64_t value);

public:
    // optional .sync_pb.SyncEnums.PasswordState password_state = 26;
    bool has_password_state() const;

private:
    bool _internal_has_password_state() const;

public:
    void clear_password_state();
    ::sync_pb::SyncEnums_PasswordState password_state() const;
    void set_password_state(::sync_pb::SyncEnums_PasswordState value);

private:
    ::sync_pb::SyncEnums_PasswordState _internal_password_state() const;
    void _internal_set_password_state(::sync_pb::SyncEnums_PasswordState value);

public:
    // optional int32 correct_referrer_policy = 25 [default = 1];
    bool has_correct_referrer_policy() const;

private:
    bool _internal_has_correct_referrer_policy() const;

public:
    void clear_correct_referrer_policy();
    int32_t correct_referrer_policy() const;
    void set_correct_referrer_policy(int32_t value);

private:
    int32_t _internal_correct_referrer_policy() const;
    void _internal_set_correct_referrer_policy(int32_t value);

public:
    // optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
    bool has_redirect_type() const;

private:
    bool _internal_has_redirect_type() const;

public:
    void clear_redirect_type();
    ::sync_pb::SyncEnums_PageTransitionRedirectType redirect_type() const;
    void set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value);

private:
    ::sync_pb::SyncEnums_PageTransitionRedirectType _internal_redirect_type() const;
    void _internal_set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value);

public:
    // optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED, deprecated = true];
    PROTOBUF_DEPRECATED bool has_blocked_state() const;

private:
    bool _internal_has_blocked_state() const;

public:
    PROTOBUF_DEPRECATED void clear_blocked_state();
    PROTOBUF_DEPRECATED ::sync_pb::TabNavigation_BlockedState blocked_state() const;
    PROTOBUF_DEPRECATED void set_blocked_state(::sync_pb::TabNavigation_BlockedState value);

private:
    ::sync_pb::TabNavigation_BlockedState _internal_blocked_state() const;
    void _internal_set_blocked_state(::sync_pb::TabNavigation_BlockedState value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.TabNavigation)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NavigationRedirect> navigation_redirect_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t> ancestor_task_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr virtual_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referrer_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_terms_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr favicon_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_navigation_redirect_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_language_;
        ::sync_pb::ReplacedNavigation* replaced_navigation_;
        int page_transition_;
        int32_t unique_id_;
        int64_t timestamp_msec_;
        bool navigation_forward_back_;
        bool navigation_from_address_bar_;
        bool navigation_home_page_;
        bool navigation_chain_start_;
        bool navigation_chain_end_;
        bool is_restored_;
        int64_t global_id_;
        int32_t http_status_code_;
        int32_t obsolete_referrer_policy_;
        int64_t task_id_;
        int password_state_;
        int32_t correct_referrer_policy_;
        int redirect_type_;
        int blocked_state_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class NavigationRedirect final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NavigationRedirect) */ {
public:
    inline NavigationRedirect()
        : NavigationRedirect(nullptr)
    {
    }
    ~NavigationRedirect() override;
    explicit PROTOBUF_CONSTEXPR NavigationRedirect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    NavigationRedirect(const NavigationRedirect& from);
    NavigationRedirect(NavigationRedirect&& from) noexcept
        : NavigationRedirect()
    {
        *this = ::std::move(from);
    }

    inline NavigationRedirect& operator=(const NavigationRedirect& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline NavigationRedirect& operator=(NavigationRedirect&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const NavigationRedirect& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const NavigationRedirect* internal_default_instance()
    {
        return reinterpret_cast<const NavigationRedirect*>(&_NavigationRedirect_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(NavigationRedirect& a, NavigationRedirect& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(NavigationRedirect* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(NavigationRedirect* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    NavigationRedirect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<NavigationRedirect>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const NavigationRedirect& from);
    void MergeFrom(const NavigationRedirect& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(NavigationRedirect* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.NavigationRedirect";
    }

protected:
    explicit NavigationRedirect(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 1,
    };
    // optional string url = 1;
    bool has_url() const;

private:
    bool _internal_has_url() const;

public:
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // @@protoc_insertion_point(class_scope:sync_pb.NavigationRedirect)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class ReplacedNavigation final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ReplacedNavigation) */ {
public:
    inline ReplacedNavigation()
        : ReplacedNavigation(nullptr)
    {
    }
    ~ReplacedNavigation() override;
    explicit PROTOBUF_CONSTEXPR ReplacedNavigation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ReplacedNavigation(const ReplacedNavigation& from);
    ReplacedNavigation(ReplacedNavigation&& from) noexcept
        : ReplacedNavigation()
    {
        *this = ::std::move(from);
    }

    inline ReplacedNavigation& operator=(const ReplacedNavigation& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ReplacedNavigation& operator=(ReplacedNavigation&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const ReplacedNavigation& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ReplacedNavigation* internal_default_instance()
    {
        return reinterpret_cast<const ReplacedNavigation*>(&_ReplacedNavigation_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(ReplacedNavigation& a, ReplacedNavigation& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ReplacedNavigation* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ReplacedNavigation* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ReplacedNavigation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ReplacedNavigation>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ReplacedNavigation& from);
    void MergeFrom(const ReplacedNavigation& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ReplacedNavigation* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sync_pb.ReplacedNavigation";
    }

protected:
    explicit ReplacedNavigation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFirstCommittedUrlFieldNumber = 1,
        kFirstTimestampMsecFieldNumber = 2,
        kFirstPageTransitionFieldNumber = 3,
    };
    // optional string first_committed_url = 1;
    bool has_first_committed_url() const;

private:
    bool _internal_has_first_committed_url() const;

public:
    void clear_first_committed_url();
    const std::string& first_committed_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_first_committed_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_first_committed_url();
    PROTOBUF_NODISCARD std::string* release_first_committed_url();
    void set_allocated_first_committed_url(std::string* first_committed_url);

private:
    const std::string& _internal_first_committed_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_committed_url(const std::string& value);
    std::string* _internal_mutable_first_committed_url();

public:
    // optional int64 first_timestamp_msec = 2;
    bool has_first_timestamp_msec() const;

private:
    bool _internal_has_first_timestamp_msec() const;

public:
    void clear_first_timestamp_msec();
    int64_t first_timestamp_msec() const;
    void set_first_timestamp_msec(int64_t value);

private:
    int64_t _internal_first_timestamp_msec() const;
    void _internal_set_first_timestamp_msec(int64_t value);

public:
    // optional .sync_pb.SyncEnums.PageTransition first_page_transition = 3;
    bool has_first_page_transition() const;

private:
    bool _internal_has_first_page_transition() const;

public:
    void clear_first_page_transition();
    ::sync_pb::SyncEnums_PageTransition first_page_transition() const;
    void set_first_page_transition(::sync_pb::SyncEnums_PageTransition value);

private:
    ::sync_pb::SyncEnums_PageTransition _internal_first_page_transition() const;
    void _internal_set_first_page_transition(::sync_pb::SyncEnums_PageTransition value);

public:
    // @@protoc_insertion_point(class_scope:sync_pb.ReplacedNavigation)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_committed_url_;
        int64_t first_timestamp_msec_;
        int first_page_transition_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// SessionSpecifics

// optional string session_tag = 1;
inline bool SessionSpecifics::_internal_has_session_tag() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SessionSpecifics::has_session_tag() const
{
    return _internal_has_session_tag();
}
inline void SessionSpecifics::clear_session_tag()
{
    _impl_.session_tag_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionSpecifics::session_tag() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionSpecifics.session_tag)
    return _internal_session_tag();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SessionSpecifics::set_session_tag(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.session_tag_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SessionSpecifics.session_tag)
}
inline std::string* SessionSpecifics::mutable_session_tag()
{
    std::string* _s = _internal_mutable_session_tag();
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionSpecifics.session_tag)
    return _s;
}
inline const std::string& SessionSpecifics::_internal_session_tag() const
{
    return _impl_.session_tag_.Get();
}
inline void SessionSpecifics::_internal_set_session_tag(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.session_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionSpecifics::_internal_mutable_session_tag()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.session_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionSpecifics::release_session_tag()
{
    // @@protoc_insertion_point(field_release:sync_pb.SessionSpecifics.session_tag)
    if (!_internal_has_session_tag()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.session_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.session_tag_.IsDefault()) {
        _impl_.session_tag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SessionSpecifics::set_allocated_session_tag(std::string* session_tag)
{
    if (session_tag != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.session_tag_.SetAllocated(session_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.session_tag_.IsDefault()) {
        _impl_.session_tag_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionSpecifics.session_tag)
}

// optional .sync_pb.SessionHeader header = 2;
inline bool SessionSpecifics::_internal_has_header() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
    return value;
}
inline bool SessionSpecifics::has_header() const
{
    return _internal_has_header();
}
inline void SessionSpecifics::clear_header()
{
    if (_impl_.header_ != nullptr)
        _impl_.header_->Clear();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sync_pb::SessionHeader& SessionSpecifics::_internal_header() const
{
    const ::sync_pb::SessionHeader* p = _impl_.header_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::SessionHeader&>(::sync_pb::_SessionHeader_default_instance_);
}
inline const ::sync_pb::SessionHeader& SessionSpecifics::header() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionSpecifics.header)
    return _internal_header();
}
inline void SessionSpecifics::unsafe_arena_set_allocated_header(::sync_pb::SessionHeader* header)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.header_);
    }
    _impl_.header_ = header;
    if (header) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.SessionSpecifics.header)
}
inline ::sync_pb::SessionHeader* SessionSpecifics::release_header()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::sync_pb::SessionHeader* temp = _impl_.header_;
    _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::SessionHeader* SessionSpecifics::unsafe_arena_release_header()
{
    // @@protoc_insertion_point(field_release:sync_pb.SessionSpecifics.header)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::sync_pb::SessionHeader* temp = _impl_.header_;
    _impl_.header_ = nullptr;
    return temp;
}
inline ::sync_pb::SessionHeader* SessionSpecifics::_internal_mutable_header()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.header_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::SessionHeader>(GetArenaForAllocation());
        _impl_.header_ = p;
    }
    return _impl_.header_;
}
inline ::sync_pb::SessionHeader* SessionSpecifics::mutable_header()
{
    ::sync_pb::SessionHeader* _msg = _internal_mutable_header();
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionSpecifics.header)
    return _msg;
}
inline void SessionSpecifics::set_allocated_header(::sync_pb::SessionHeader* header)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.header_;
    }
    if (header) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
        if (message_arena != submessage_arena) {
            header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, header, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.header_ = header;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionSpecifics.header)
}

// optional .sync_pb.SessionTab tab = 3;
inline bool SessionSpecifics::_internal_has_tab() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.tab_ != nullptr);
    return value;
}
inline bool SessionSpecifics::has_tab() const
{
    return _internal_has_tab();
}
inline void SessionSpecifics::clear_tab()
{
    if (_impl_.tab_ != nullptr)
        _impl_.tab_->Clear();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sync_pb::SessionTab& SessionSpecifics::_internal_tab() const
{
    const ::sync_pb::SessionTab* p = _impl_.tab_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::SessionTab&>(::sync_pb::_SessionTab_default_instance_);
}
inline const ::sync_pb::SessionTab& SessionSpecifics::tab() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionSpecifics.tab)
    return _internal_tab();
}
inline void SessionSpecifics::unsafe_arena_set_allocated_tab(::sync_pb::SessionTab* tab)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tab_);
    }
    _impl_.tab_ = tab;
    if (tab) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.SessionSpecifics.tab)
}
inline ::sync_pb::SessionTab* SessionSpecifics::release_tab()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::SessionTab* temp = _impl_.tab_;
    _impl_.tab_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::SessionTab* SessionSpecifics::unsafe_arena_release_tab()
{
    // @@protoc_insertion_point(field_release:sync_pb.SessionSpecifics.tab)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::sync_pb::SessionTab* temp = _impl_.tab_;
    _impl_.tab_ = nullptr;
    return temp;
}
inline ::sync_pb::SessionTab* SessionSpecifics::_internal_mutable_tab()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.tab_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::SessionTab>(GetArenaForAllocation());
        _impl_.tab_ = p;
    }
    return _impl_.tab_;
}
inline ::sync_pb::SessionTab* SessionSpecifics::mutable_tab()
{
    ::sync_pb::SessionTab* _msg = _internal_mutable_tab();
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionSpecifics.tab)
    return _msg;
}
inline void SessionSpecifics::set_allocated_tab(::sync_pb::SessionTab* tab)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.tab_;
    }
    if (tab) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tab);
        if (message_arena != submessage_arena) {
            tab = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, tab, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.tab_ = tab;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionSpecifics.tab)
}

// optional int32 tab_node_id = 4 [default = -1];
inline bool SessionSpecifics::_internal_has_tab_node_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool SessionSpecifics::has_tab_node_id() const
{
    return _internal_has_tab_node_id();
}
inline void SessionSpecifics::clear_tab_node_id()
{
    _impl_.tab_node_id_ = -1;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SessionSpecifics::_internal_tab_node_id() const
{
    return _impl_.tab_node_id_;
}
inline int32_t SessionSpecifics::tab_node_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionSpecifics.tab_node_id)
    return _internal_tab_node_id();
}
inline void SessionSpecifics::_internal_set_tab_node_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.tab_node_id_ = value;
}
inline void SessionSpecifics::set_tab_node_id(int32_t value)
{
    _internal_set_tab_node_id(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionSpecifics.tab_node_id)
}

// -------------------------------------------------------------------

// SessionHeader

// optional int64 session_start_time_unix_epoch_millis = 6;
inline bool SessionHeader::_internal_has_session_start_time_unix_epoch_millis() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool SessionHeader::has_session_start_time_unix_epoch_millis() const
{
    return _internal_has_session_start_time_unix_epoch_millis();
}
inline void SessionHeader::clear_session_start_time_unix_epoch_millis()
{
    _impl_.session_start_time_unix_epoch_millis_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t SessionHeader::_internal_session_start_time_unix_epoch_millis() const
{
    return _impl_.session_start_time_unix_epoch_millis_;
}
inline int64_t SessionHeader::session_start_time_unix_epoch_millis() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionHeader.session_start_time_unix_epoch_millis)
    return _internal_session_start_time_unix_epoch_millis();
}
inline void SessionHeader::_internal_set_session_start_time_unix_epoch_millis(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.session_start_time_unix_epoch_millis_ = value;
}
inline void SessionHeader::set_session_start_time_unix_epoch_millis(int64_t value)
{
    _internal_set_session_start_time_unix_epoch_millis(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionHeader.session_start_time_unix_epoch_millis)
}

// repeated .sync_pb.SessionWindow window = 2;
inline int SessionHeader::_internal_window_size() const
{
    return _impl_.window_.size();
}
inline int SessionHeader::window_size() const
{
    return _internal_window_size();
}
inline void SessionHeader::clear_window()
{
    _impl_.window_.Clear();
}
inline ::sync_pb::SessionWindow* SessionHeader::mutable_window(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionHeader.window)
    return _impl_.window_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SessionWindow>* SessionHeader::mutable_window()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.SessionHeader.window)
    return &_impl_.window_;
}
inline const ::sync_pb::SessionWindow& SessionHeader::_internal_window(int index) const
{
    return _impl_.window_.Get(index);
}
inline const ::sync_pb::SessionWindow& SessionHeader::window(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionHeader.window)
    return _internal_window(index);
}
inline ::sync_pb::SessionWindow* SessionHeader::_internal_add_window()
{
    return _impl_.window_.Add();
}
inline ::sync_pb::SessionWindow* SessionHeader::add_window()
{
    ::sync_pb::SessionWindow* _add = _internal_add_window();
    // @@protoc_insertion_point(field_add:sync_pb.SessionHeader.window)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::SessionWindow>& SessionHeader::window() const
{
    // @@protoc_insertion_point(field_list:sync_pb.SessionHeader.window)
    return _impl_.window_;
}

// optional string client_name = 3;
inline bool SessionHeader::_internal_has_client_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SessionHeader::has_client_name() const
{
    return _internal_has_client_name();
}
inline void SessionHeader::clear_client_name()
{
    _impl_.client_name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionHeader::client_name() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionHeader.client_name)
    return _internal_client_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SessionHeader::set_client_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.client_name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SessionHeader.client_name)
}
inline std::string* SessionHeader::mutable_client_name()
{
    std::string* _s = _internal_mutable_client_name();
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionHeader.client_name)
    return _s;
}
inline const std::string& SessionHeader::_internal_client_name() const
{
    return _impl_.client_name_.Get();
}
inline void SessionHeader::_internal_set_client_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionHeader::_internal_mutable_client_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionHeader::release_client_name()
{
    // @@protoc_insertion_point(field_release:sync_pb.SessionHeader.client_name)
    if (!_internal_has_client_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.client_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_name_.IsDefault()) {
        _impl_.client_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SessionHeader::set_allocated_client_name(std::string* client_name)
{
    if (client_name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.client_name_.IsDefault()) {
        _impl_.client_name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionHeader.client_name)
}

// optional .sync_pb.SyncEnums.DeviceFormFactor device_form_factor = 5;
inline bool SessionHeader::_internal_has_device_form_factor() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool SessionHeader::has_device_form_factor() const
{
    return _internal_has_device_form_factor();
}
inline void SessionHeader::clear_device_form_factor()
{
    _impl_.device_form_factor_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::sync_pb::SyncEnums_DeviceFormFactor SessionHeader::_internal_device_form_factor() const
{
    return static_cast<::sync_pb::SyncEnums_DeviceFormFactor>(_impl_.device_form_factor_);
}
inline ::sync_pb::SyncEnums_DeviceFormFactor SessionHeader::device_form_factor() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionHeader.device_form_factor)
    return _internal_device_form_factor();
}
inline void SessionHeader::_internal_set_device_form_factor(::sync_pb::SyncEnums_DeviceFormFactor value)
{
    assert(::sync_pb::SyncEnums_DeviceFormFactor_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.device_form_factor_ = value;
}
inline void SessionHeader::set_device_form_factor(::sync_pb::SyncEnums_DeviceFormFactor value)
{
    _internal_set_device_form_factor(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionHeader.device_form_factor)
}

// optional .sync_pb.SyncEnums.DeviceType device_type = 4 [deprecated = true];
inline bool SessionHeader::_internal_has_device_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SessionHeader::has_device_type() const
{
    return _internal_has_device_type();
}
inline void SessionHeader::clear_device_type()
{
    _impl_.device_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sync_pb::SyncEnums_DeviceType SessionHeader::_internal_device_type() const
{
    return static_cast<::sync_pb::SyncEnums_DeviceType>(_impl_.device_type_);
}
inline ::sync_pb::SyncEnums_DeviceType SessionHeader::device_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionHeader.device_type)
    return _internal_device_type();
}
inline void SessionHeader::_internal_set_device_type(::sync_pb::SyncEnums_DeviceType value)
{
    assert(::sync_pb::SyncEnums_DeviceType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.device_type_ = value;
}
inline void SessionHeader::set_device_type(::sync_pb::SyncEnums_DeviceType value)
{
    _internal_set_device_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionHeader.device_type)
}

// -------------------------------------------------------------------

// SessionWindow

// optional int32 window_id = 1;
inline bool SessionWindow::_internal_has_window_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SessionWindow::has_window_id() const
{
    return _internal_has_window_id();
}
inline void SessionWindow::clear_window_id()
{
    _impl_.window_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t SessionWindow::_internal_window_id() const
{
    return _impl_.window_id_;
}
inline int32_t SessionWindow::window_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionWindow.window_id)
    return _internal_window_id();
}
inline void SessionWindow::_internal_set_window_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.window_id_ = value;
}
inline void SessionWindow::set_window_id(int32_t value)
{
    _internal_set_window_id(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionWindow.window_id)
}

// optional int32 selected_tab_index = 2 [default = -1];
inline bool SessionWindow::_internal_has_selected_tab_index() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SessionWindow::has_selected_tab_index() const
{
    return _internal_has_selected_tab_index();
}
inline void SessionWindow::clear_selected_tab_index()
{
    _impl_.selected_tab_index_ = -1;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SessionWindow::_internal_selected_tab_index() const
{
    return _impl_.selected_tab_index_;
}
inline int32_t SessionWindow::selected_tab_index() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionWindow.selected_tab_index)
    return _internal_selected_tab_index();
}
inline void SessionWindow::_internal_set_selected_tab_index(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.selected_tab_index_ = value;
}
inline void SessionWindow::set_selected_tab_index(int32_t value)
{
    _internal_set_selected_tab_index(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionWindow.selected_tab_index)
}

// optional .sync_pb.SyncEnums.BrowserType browser_type = 3 [default = TYPE_TABBED];
inline bool SessionWindow::_internal_has_browser_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool SessionWindow::has_browser_type() const
{
    return _internal_has_browser_type();
}
inline void SessionWindow::clear_browser_type()
{
    _impl_.browser_type_ = 1;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::sync_pb::SyncEnums_BrowserType SessionWindow::_internal_browser_type() const
{
    return static_cast<::sync_pb::SyncEnums_BrowserType>(_impl_.browser_type_);
}
inline ::sync_pb::SyncEnums_BrowserType SessionWindow::browser_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionWindow.browser_type)
    return _internal_browser_type();
}
inline void SessionWindow::_internal_set_browser_type(::sync_pb::SyncEnums_BrowserType value)
{
    assert(::sync_pb::SyncEnums_BrowserType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.browser_type_ = value;
}
inline void SessionWindow::set_browser_type(::sync_pb::SyncEnums_BrowserType value)
{
    _internal_set_browser_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionWindow.browser_type)
}

// repeated int32 tab = 4;
inline int SessionWindow::_internal_tab_size() const
{
    return _impl_.tab_.size();
}
inline int SessionWindow::tab_size() const
{
    return _internal_tab_size();
}
inline void SessionWindow::clear_tab()
{
    _impl_.tab_.Clear();
}
inline int32_t SessionWindow::_internal_tab(int index) const
{
    return _impl_.tab_.Get(index);
}
inline int32_t SessionWindow::tab(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionWindow.tab)
    return _internal_tab(index);
}
inline void SessionWindow::set_tab(int index, int32_t value)
{
    _impl_.tab_.Set(index, value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionWindow.tab)
}
inline void SessionWindow::_internal_add_tab(int32_t value)
{
    _impl_.tab_.Add(value);
}
inline void SessionWindow::add_tab(int32_t value)
{
    _internal_add_tab(value);
    // @@protoc_insertion_point(field_add:sync_pb.SessionWindow.tab)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& SessionWindow::_internal_tab() const
{
    return _impl_.tab_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>& SessionWindow::tab() const
{
    // @@protoc_insertion_point(field_list:sync_pb.SessionWindow.tab)
    return _internal_tab();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* SessionWindow::_internal_mutable_tab()
{
    return &_impl_.tab_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int32_t>* SessionWindow::mutable_tab()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.SessionWindow.tab)
    return _internal_mutable_tab();
}

// -------------------------------------------------------------------

// SessionTab

// optional int32 tab_id = 1 [default = -1];
inline bool SessionTab::_internal_has_tab_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool SessionTab::has_tab_id() const
{
    return _internal_has_tab_id();
}
inline void SessionTab::clear_tab_id()
{
    _impl_.tab_id_ = -1;
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t SessionTab::_internal_tab_id() const
{
    return _impl_.tab_id_;
}
inline int32_t SessionTab::tab_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.tab_id)
    return _internal_tab_id();
}
inline void SessionTab::_internal_set_tab_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.tab_id_ = value;
}
inline void SessionTab::set_tab_id(int32_t value)
{
    _internal_set_tab_id(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.tab_id)
}

// optional int32 window_id = 2;
inline bool SessionTab::_internal_has_window_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool SessionTab::has_window_id() const
{
    return _internal_has_window_id();
}
inline void SessionTab::clear_window_id()
{
    _impl_.window_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SessionTab::_internal_window_id() const
{
    return _impl_.window_id_;
}
inline int32_t SessionTab::window_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.window_id)
    return _internal_window_id();
}
inline void SessionTab::_internal_set_window_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.window_id_ = value;
}
inline void SessionTab::set_window_id(int32_t value)
{
    _internal_set_window_id(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.window_id)
}

// optional int32 tab_visual_index = 3 [default = -1];
inline bool SessionTab::_internal_has_tab_visual_index() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool SessionTab::has_tab_visual_index() const
{
    return _internal_has_tab_visual_index();
}
inline void SessionTab::clear_tab_visual_index()
{
    _impl_.tab_visual_index_ = -1;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t SessionTab::_internal_tab_visual_index() const
{
    return _impl_.tab_visual_index_;
}
inline int32_t SessionTab::tab_visual_index() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.tab_visual_index)
    return _internal_tab_visual_index();
}
inline void SessionTab::_internal_set_tab_visual_index(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.tab_visual_index_ = value;
}
inline void SessionTab::set_tab_visual_index(int32_t value)
{
    _internal_set_tab_visual_index(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.tab_visual_index)
}

// optional int32 current_navigation_index = 4 [default = -1];
inline bool SessionTab::_internal_has_current_navigation_index() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool SessionTab::has_current_navigation_index() const
{
    return _internal_has_current_navigation_index();
}
inline void SessionTab::clear_current_navigation_index()
{
    _impl_.current_navigation_index_ = -1;
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t SessionTab::_internal_current_navigation_index() const
{
    return _impl_.current_navigation_index_;
}
inline int32_t SessionTab::current_navigation_index() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.current_navigation_index)
    return _internal_current_navigation_index();
}
inline void SessionTab::_internal_set_current_navigation_index(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.current_navigation_index_ = value;
}
inline void SessionTab::set_current_navigation_index(int32_t value)
{
    _internal_set_current_navigation_index(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.current_navigation_index)
}

// optional bool pinned = 5 [default = false];
inline bool SessionTab::_internal_has_pinned() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool SessionTab::has_pinned() const
{
    return _internal_has_pinned();
}
inline void SessionTab::clear_pinned()
{
    _impl_.pinned_ = false;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool SessionTab::_internal_pinned() const
{
    return _impl_.pinned_;
}
inline bool SessionTab::pinned() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.pinned)
    return _internal_pinned();
}
inline void SessionTab::_internal_set_pinned(bool value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.pinned_ = value;
}
inline void SessionTab::set_pinned(bool value)
{
    _internal_set_pinned(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.pinned)
}

// optional string extension_app_id = 6;
inline bool SessionTab::_internal_has_extension_app_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SessionTab::has_extension_app_id() const
{
    return _internal_has_extension_app_id();
}
inline void SessionTab::clear_extension_app_id()
{
    _impl_.extension_app_id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionTab::extension_app_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.extension_app_id)
    return _internal_extension_app_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SessionTab::set_extension_app_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.extension_app_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.extension_app_id)
}
inline std::string* SessionTab::mutable_extension_app_id()
{
    std::string* _s = _internal_mutable_extension_app_id();
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionTab.extension_app_id)
    return _s;
}
inline const std::string& SessionTab::_internal_extension_app_id() const
{
    return _impl_.extension_app_id_.Get();
}
inline void SessionTab::_internal_set_extension_app_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.extension_app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionTab::_internal_mutable_extension_app_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.extension_app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionTab::release_extension_app_id()
{
    // @@protoc_insertion_point(field_release:sync_pb.SessionTab.extension_app_id)
    if (!_internal_has_extension_app_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.extension_app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.extension_app_id_.IsDefault()) {
        _impl_.extension_app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SessionTab::set_allocated_extension_app_id(std::string* extension_app_id)
{
    if (extension_app_id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.extension_app_id_.SetAllocated(extension_app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.extension_app_id_.IsDefault()) {
        _impl_.extension_app_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionTab.extension_app_id)
}

// repeated .sync_pb.TabNavigation navigation = 7;
inline int SessionTab::_internal_navigation_size() const
{
    return _impl_.navigation_.size();
}
inline int SessionTab::navigation_size() const
{
    return _internal_navigation_size();
}
inline void SessionTab::clear_navigation()
{
    _impl_.navigation_.Clear();
}
inline ::sync_pb::TabNavigation* SessionTab::mutable_navigation(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionTab.navigation)
    return _impl_.navigation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::TabNavigation>* SessionTab::mutable_navigation()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.SessionTab.navigation)
    return &_impl_.navigation_;
}
inline const ::sync_pb::TabNavigation& SessionTab::_internal_navigation(int index) const
{
    return _impl_.navigation_.Get(index);
}
inline const ::sync_pb::TabNavigation& SessionTab::navigation(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.navigation)
    return _internal_navigation(index);
}
inline ::sync_pb::TabNavigation* SessionTab::_internal_add_navigation()
{
    return _impl_.navigation_.Add();
}
inline ::sync_pb::TabNavigation* SessionTab::add_navigation()
{
    ::sync_pb::TabNavigation* _add = _internal_add_navigation();
    // @@protoc_insertion_point(field_add:sync_pb.SessionTab.navigation)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::TabNavigation>& SessionTab::navigation() const
{
    // @@protoc_insertion_point(field_list:sync_pb.SessionTab.navigation)
    return _impl_.navigation_;
}

// optional .sync_pb.SyncEnums.BrowserType browser_type = 13;
inline bool SessionTab::_internal_has_browser_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool SessionTab::has_browser_type() const
{
    return _internal_has_browser_type();
}
inline void SessionTab::clear_browser_type()
{
    _impl_.browser_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::sync_pb::SyncEnums_BrowserType SessionTab::_internal_browser_type() const
{
    return static_cast<::sync_pb::SyncEnums_BrowserType>(_impl_.browser_type_);
}
inline ::sync_pb::SyncEnums_BrowserType SessionTab::browser_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.browser_type)
    return _internal_browser_type();
}
inline void SessionTab::_internal_set_browser_type(::sync_pb::SyncEnums_BrowserType value)
{
    assert(::sync_pb::SyncEnums_BrowserType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.browser_type_ = value;
}
inline void SessionTab::set_browser_type(::sync_pb::SyncEnums_BrowserType value)
{
    _internal_set_browser_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.browser_type)
}

// optional int64 last_active_time_unix_epoch_millis = 14;
inline bool SessionTab::_internal_has_last_active_time_unix_epoch_millis() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool SessionTab::has_last_active_time_unix_epoch_millis() const
{
    return _internal_has_last_active_time_unix_epoch_millis();
}
inline void SessionTab::clear_last_active_time_unix_epoch_millis()
{
    _impl_.last_active_time_unix_epoch_millis_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int64_t SessionTab::_internal_last_active_time_unix_epoch_millis() const
{
    return _impl_.last_active_time_unix_epoch_millis_;
}
inline int64_t SessionTab::last_active_time_unix_epoch_millis() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.last_active_time_unix_epoch_millis)
    return _internal_last_active_time_unix_epoch_millis();
}
inline void SessionTab::_internal_set_last_active_time_unix_epoch_millis(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.last_active_time_unix_epoch_millis_ = value;
}
inline void SessionTab::set_last_active_time_unix_epoch_millis(int64_t value)
{
    _internal_set_last_active_time_unix_epoch_millis(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.last_active_time_unix_epoch_millis)
}

// optional bytes favicon = 8 [deprecated = true];
inline bool SessionTab::_internal_has_favicon() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SessionTab::has_favicon() const
{
    return _internal_has_favicon();
}
inline void SessionTab::clear_favicon()
{
    _impl_.favicon_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SessionTab::favicon() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.favicon)
    return _internal_favicon();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SessionTab::set_favicon(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.favicon_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.favicon)
}
inline std::string* SessionTab::mutable_favicon()
{
    std::string* _s = _internal_mutable_favicon();
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionTab.favicon)
    return _s;
}
inline const std::string& SessionTab::_internal_favicon() const
{
    return _impl_.favicon_.Get();
}
inline void SessionTab::_internal_set_favicon(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.favicon_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionTab::_internal_mutable_favicon()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.favicon_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionTab::release_favicon()
{
    // @@protoc_insertion_point(field_release:sync_pb.SessionTab.favicon)
    if (!_internal_has_favicon()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.favicon_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.favicon_.IsDefault()) {
        _impl_.favicon_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SessionTab::set_allocated_favicon(std::string* favicon)
{
    if (favicon != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.favicon_.SetAllocated(favicon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.favicon_.IsDefault()) {
        _impl_.favicon_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionTab.favicon)
}

// optional .sync_pb.SessionTab.FaviconType favicon_type = 9 [deprecated = true];
inline bool SessionTab::_internal_has_favicon_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool SessionTab::has_favicon_type() const
{
    return _internal_has_favicon_type();
}
inline void SessionTab::clear_favicon_type()
{
    _impl_.favicon_type_ = 1;
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline ::sync_pb::SessionTab_FaviconType SessionTab::_internal_favicon_type() const
{
    return static_cast<::sync_pb::SessionTab_FaviconType>(_impl_.favicon_type_);
}
inline ::sync_pb::SessionTab_FaviconType SessionTab::favicon_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.favicon_type)
    return _internal_favicon_type();
}
inline void SessionTab::_internal_set_favicon_type(::sync_pb::SessionTab_FaviconType value)
{
    assert(::sync_pb::SessionTab_FaviconType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.favicon_type_ = value;
}
inline void SessionTab::set_favicon_type(::sync_pb::SessionTab_FaviconType value)
{
    _internal_set_favicon_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.favicon_type)
}

// optional string favicon_source = 11 [deprecated = true];
inline bool SessionTab::_internal_has_favicon_source() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool SessionTab::has_favicon_source() const
{
    return _internal_has_favicon_source();
}
inline void SessionTab::clear_favicon_source()
{
    _impl_.favicon_source_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SessionTab::favicon_source() const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.favicon_source)
    return _internal_favicon_source();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SessionTab::set_favicon_source(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.favicon_source_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.favicon_source)
}
inline std::string* SessionTab::mutable_favicon_source()
{
    std::string* _s = _internal_mutable_favicon_source();
    // @@protoc_insertion_point(field_mutable:sync_pb.SessionTab.favicon_source)
    return _s;
}
inline const std::string& SessionTab::_internal_favicon_source() const
{
    return _impl_.favicon_source_.Get();
}
inline void SessionTab::_internal_set_favicon_source(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.favicon_source_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionTab::_internal_mutable_favicon_source()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.favicon_source_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionTab::release_favicon_source()
{
    // @@protoc_insertion_point(field_release:sync_pb.SessionTab.favicon_source)
    if (!_internal_has_favicon_source()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.favicon_source_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.favicon_source_.IsDefault()) {
        _impl_.favicon_source_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SessionTab::set_allocated_favicon_source(std::string* favicon_source)
{
    if (favicon_source != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.favicon_source_.SetAllocated(favicon_source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.favicon_source_.IsDefault()) {
        _impl_.favicon_source_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionTab.favicon_source)
}

// repeated uint64 variation_id = 12 [deprecated = true];
inline int SessionTab::_internal_variation_id_size() const
{
    return _impl_.variation_id_.size();
}
inline int SessionTab::variation_id_size() const
{
    return _internal_variation_id_size();
}
inline void SessionTab::clear_variation_id()
{
    _impl_.variation_id_.Clear();
}
inline uint64_t SessionTab::_internal_variation_id(int index) const
{
    return _impl_.variation_id_.Get(index);
}
inline uint64_t SessionTab::variation_id(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.SessionTab.variation_id)
    return _internal_variation_id(index);
}
inline void SessionTab::set_variation_id(int index, uint64_t value)
{
    _impl_.variation_id_.Set(index, value);
    // @@protoc_insertion_point(field_set:sync_pb.SessionTab.variation_id)
}
inline void SessionTab::_internal_add_variation_id(uint64_t value)
{
    _impl_.variation_id_.Add(value);
}
inline void SessionTab::add_variation_id(uint64_t value)
{
    _internal_add_variation_id(value);
    // @@protoc_insertion_point(field_add:sync_pb.SessionTab.variation_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& SessionTab::_internal_variation_id() const
{
    return _impl_.variation_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>& SessionTab::variation_id() const
{
    // @@protoc_insertion_point(field_list:sync_pb.SessionTab.variation_id)
    return _internal_variation_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* SessionTab::_internal_mutable_variation_id()
{
    return &_impl_.variation_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint64_t>* SessionTab::mutable_variation_id()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.SessionTab.variation_id)
    return _internal_mutable_variation_id();
}

// -------------------------------------------------------------------

// TabNavigation

// optional string virtual_url = 2;
inline bool TabNavigation::_internal_has_virtual_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool TabNavigation::has_virtual_url() const
{
    return _internal_has_virtual_url();
}
inline void TabNavigation::clear_virtual_url()
{
    _impl_.virtual_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TabNavigation::virtual_url() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.virtual_url)
    return _internal_virtual_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabNavigation::set_virtual_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.virtual_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.virtual_url)
}
inline std::string* TabNavigation::mutable_virtual_url()
{
    std::string* _s = _internal_mutable_virtual_url();
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.virtual_url)
    return _s;
}
inline const std::string& TabNavigation::_internal_virtual_url() const
{
    return _impl_.virtual_url_.Get();
}
inline void TabNavigation::_internal_set_virtual_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.virtual_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_virtual_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.virtual_url_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_virtual_url()
{
    // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.virtual_url)
    if (!_internal_has_virtual_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.virtual_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.virtual_url_.IsDefault()) {
        _impl_.virtual_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TabNavigation::set_allocated_virtual_url(std::string* virtual_url)
{
    if (virtual_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.virtual_url_.SetAllocated(virtual_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.virtual_url_.IsDefault()) {
        _impl_.virtual_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.virtual_url)
}

// optional string referrer = 3;
inline bool TabNavigation::_internal_has_referrer() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool TabNavigation::has_referrer() const
{
    return _internal_has_referrer();
}
inline void TabNavigation::clear_referrer()
{
    _impl_.referrer_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TabNavigation::referrer() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.referrer)
    return _internal_referrer();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabNavigation::set_referrer(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.referrer_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.referrer)
}
inline std::string* TabNavigation::mutable_referrer()
{
    std::string* _s = _internal_mutable_referrer();
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.referrer)
    return _s;
}
inline const std::string& TabNavigation::_internal_referrer() const
{
    return _impl_.referrer_.Get();
}
inline void TabNavigation::_internal_set_referrer(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.referrer_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_referrer()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.referrer_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_referrer()
{
    // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.referrer)
    if (!_internal_has_referrer()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.referrer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.referrer_.IsDefault()) {
        _impl_.referrer_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TabNavigation::set_allocated_referrer(std::string* referrer)
{
    if (referrer != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.referrer_.SetAllocated(referrer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.referrer_.IsDefault()) {
        _impl_.referrer_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.referrer)
}

// optional string title = 4;
inline bool TabNavigation::_internal_has_title() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool TabNavigation::has_title() const
{
    return _internal_has_title();
}
inline void TabNavigation::clear_title()
{
    _impl_.title_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TabNavigation::title() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.title)
    return _internal_title();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabNavigation::set_title(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.title_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.title)
}
inline std::string* TabNavigation::mutable_title()
{
    std::string* _s = _internal_mutable_title();
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.title)
    return _s;
}
inline const std::string& TabNavigation::_internal_title() const
{
    return _impl_.title_.Get();
}
inline void TabNavigation::_internal_set_title(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_title()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_title()
{
    // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.title)
    if (!_internal_has_title()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TabNavigation::set_allocated_title(std::string* title)
{
    if (title != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.title)
}

// optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];
inline bool TabNavigation::_internal_has_page_transition() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool TabNavigation::has_page_transition() const
{
    return _internal_has_page_transition();
}
inline void TabNavigation::clear_page_transition()
{
    _impl_.page_transition_ = 0;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::sync_pb::SyncEnums_PageTransition TabNavigation::_internal_page_transition() const
{
    return static_cast<::sync_pb::SyncEnums_PageTransition>(_impl_.page_transition_);
}
inline ::sync_pb::SyncEnums_PageTransition TabNavigation::page_transition() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.page_transition)
    return _internal_page_transition();
}
inline void TabNavigation::_internal_set_page_transition(::sync_pb::SyncEnums_PageTransition value)
{
    assert(::sync_pb::SyncEnums_PageTransition_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.page_transition_ = value;
}
inline void TabNavigation::set_page_transition(::sync_pb::SyncEnums_PageTransition value)
{
    _internal_set_page_transition(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.page_transition)
}

// optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
inline bool TabNavigation::_internal_has_redirect_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00800000u) != 0;
    return value;
}
inline bool TabNavigation::has_redirect_type() const
{
    return _internal_has_redirect_type();
}
inline void TabNavigation::clear_redirect_type()
{
    _impl_.redirect_type_ = 1;
    _impl_._has_bits_[0] &= ~0x00800000u;
}
inline ::sync_pb::SyncEnums_PageTransitionRedirectType TabNavigation::_internal_redirect_type() const
{
    return static_cast<::sync_pb::SyncEnums_PageTransitionRedirectType>(_impl_.redirect_type_);
}
inline ::sync_pb::SyncEnums_PageTransitionRedirectType TabNavigation::redirect_type() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.redirect_type)
    return _internal_redirect_type();
}
inline void TabNavigation::_internal_set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value)
{
    assert(::sync_pb::SyncEnums_PageTransitionRedirectType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00800000u;
    _impl_.redirect_type_ = value;
}
inline void TabNavigation::set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value)
{
    _internal_set_redirect_type(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.redirect_type)
}

// optional int32 unique_id = 8;
inline bool TabNavigation::_internal_has_unique_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool TabNavigation::has_unique_id() const
{
    return _internal_has_unique_id();
}
inline void TabNavigation::clear_unique_id()
{
    _impl_.unique_id_ = 0;
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline int32_t TabNavigation::_internal_unique_id() const
{
    return _impl_.unique_id_;
}
inline int32_t TabNavigation::unique_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.unique_id)
    return _internal_unique_id();
}
inline void TabNavigation::_internal_set_unique_id(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.unique_id_ = value;
}
inline void TabNavigation::set_unique_id(int32_t value)
{
    _internal_set_unique_id(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.unique_id)
}

// optional int64 timestamp_msec = 9;
inline bool TabNavigation::_internal_has_timestamp_msec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
    return value;
}
inline bool TabNavigation::has_timestamp_msec() const
{
    return _internal_has_timestamp_msec();
}
inline void TabNavigation::clear_timestamp_msec()
{
    _impl_.timestamp_msec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000400u;
}
inline int64_t TabNavigation::_internal_timestamp_msec() const
{
    return _impl_.timestamp_msec_;
}
inline int64_t TabNavigation::timestamp_msec() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.timestamp_msec)
    return _internal_timestamp_msec();
}
inline void TabNavigation::_internal_set_timestamp_msec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000400u;
    _impl_.timestamp_msec_ = value;
}
inline void TabNavigation::set_timestamp_msec(int64_t value)
{
    _internal_set_timestamp_msec(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.timestamp_msec)
}

// optional bool navigation_forward_back = 10;
inline bool TabNavigation::_internal_has_navigation_forward_back() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
    return value;
}
inline bool TabNavigation::has_navigation_forward_back() const
{
    return _internal_has_navigation_forward_back();
}
inline void TabNavigation::clear_navigation_forward_back()
{
    _impl_.navigation_forward_back_ = false;
    _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool TabNavigation::_internal_navigation_forward_back() const
{
    return _impl_.navigation_forward_back_;
}
inline bool TabNavigation::navigation_forward_back() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_forward_back)
    return _internal_navigation_forward_back();
}
inline void TabNavigation::_internal_set_navigation_forward_back(bool value)
{
    _impl_._has_bits_[0] |= 0x00000800u;
    _impl_.navigation_forward_back_ = value;
}
inline void TabNavigation::set_navigation_forward_back(bool value)
{
    _internal_set_navigation_forward_back(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_forward_back)
}

// optional bool navigation_from_address_bar = 11;
inline bool TabNavigation::_internal_has_navigation_from_address_bar() const
{
    bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
    return value;
}
inline bool TabNavigation::has_navigation_from_address_bar() const
{
    return _internal_has_navigation_from_address_bar();
}
inline void TabNavigation::clear_navigation_from_address_bar()
{
    _impl_.navigation_from_address_bar_ = false;
    _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool TabNavigation::_internal_navigation_from_address_bar() const
{
    return _impl_.navigation_from_address_bar_;
}
inline bool TabNavigation::navigation_from_address_bar() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_from_address_bar)
    return _internal_navigation_from_address_bar();
}
inline void TabNavigation::_internal_set_navigation_from_address_bar(bool value)
{
    _impl_._has_bits_[0] |= 0x00001000u;
    _impl_.navigation_from_address_bar_ = value;
}
inline void TabNavigation::set_navigation_from_address_bar(bool value)
{
    _internal_set_navigation_from_address_bar(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_from_address_bar)
}

// optional bool navigation_home_page = 12;
inline bool TabNavigation::_internal_has_navigation_home_page() const
{
    bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
    return value;
}
inline bool TabNavigation::has_navigation_home_page() const
{
    return _internal_has_navigation_home_page();
}
inline void TabNavigation::clear_navigation_home_page()
{
    _impl_.navigation_home_page_ = false;
    _impl_._has_bits_[0] &= ~0x00002000u;
}
inline bool TabNavigation::_internal_navigation_home_page() const
{
    return _impl_.navigation_home_page_;
}
inline bool TabNavigation::navigation_home_page() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_home_page)
    return _internal_navigation_home_page();
}
inline void TabNavigation::_internal_set_navigation_home_page(bool value)
{
    _impl_._has_bits_[0] |= 0x00002000u;
    _impl_.navigation_home_page_ = value;
}
inline void TabNavigation::set_navigation_home_page(bool value)
{
    _internal_set_navigation_home_page(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_home_page)
}

// optional int64 global_id = 15;
inline bool TabNavigation::_internal_has_global_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00020000u) != 0;
    return value;
}
inline bool TabNavigation::has_global_id() const
{
    return _internal_has_global_id();
}
inline void TabNavigation::clear_global_id()
{
    _impl_.global_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00020000u;
}
inline int64_t TabNavigation::_internal_global_id() const
{
    return _impl_.global_id_;
}
inline int64_t TabNavigation::global_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.global_id)
    return _internal_global_id();
}
inline void TabNavigation::_internal_set_global_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00020000u;
    _impl_.global_id_ = value;
}
inline void TabNavigation::set_global_id(int64_t value)
{
    _internal_set_global_id(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.global_id)
}

// optional string favicon_url = 17;
inline bool TabNavigation::_internal_has_favicon_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool TabNavigation::has_favicon_url() const
{
    return _internal_has_favicon_url();
}
inline void TabNavigation::clear_favicon_url()
{
    _impl_.favicon_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TabNavigation::favicon_url() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.favicon_url)
    return _internal_favicon_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabNavigation::set_favicon_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.favicon_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.favicon_url)
}
inline std::string* TabNavigation::mutable_favicon_url()
{
    std::string* _s = _internal_mutable_favicon_url();
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.favicon_url)
    return _s;
}
inline const std::string& TabNavigation::_internal_favicon_url() const
{
    return _impl_.favicon_url_.Get();
}
inline void TabNavigation::_internal_set_favicon_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.favicon_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_favicon_url()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    return _impl_.favicon_url_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_favicon_url()
{
    // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.favicon_url)
    if (!_internal_has_favicon_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000010u;
    auto* p = _impl_.favicon_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.favicon_url_.IsDefault()) {
        _impl_.favicon_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TabNavigation::set_allocated_favicon_url(std::string* favicon_url)
{
    if (favicon_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.favicon_url_.SetAllocated(favicon_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.favicon_url_.IsDefault()) {
        _impl_.favicon_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.favicon_url)
}

// optional int32 http_status_code = 20;
inline bool TabNavigation::_internal_has_http_status_code() const
{
    bool value = (_impl_._has_bits_[0] & 0x00040000u) != 0;
    return value;
}
inline bool TabNavigation::has_http_status_code() const
{
    return _internal_has_http_status_code();
}
inline void TabNavigation::clear_http_status_code()
{
    _impl_.http_status_code_ = 0;
    _impl_._has_bits_[0] &= ~0x00040000u;
}
inline int32_t TabNavigation::_internal_http_status_code() const
{
    return _impl_.http_status_code_;
}
inline int32_t TabNavigation::http_status_code() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.http_status_code)
    return _internal_http_status_code();
}
inline void TabNavigation::_internal_set_http_status_code(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00040000u;
    _impl_.http_status_code_ = value;
}
inline void TabNavigation::set_http_status_code(int32_t value)
{
    _internal_set_http_status_code(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.http_status_code)
}

// optional int32 correct_referrer_policy = 25 [default = 1];
inline bool TabNavigation::_internal_has_correct_referrer_policy() const
{
    bool value = (_impl_._has_bits_[0] & 0x00400000u) != 0;
    return value;
}
inline bool TabNavigation::has_correct_referrer_policy() const
{
    return _internal_has_correct_referrer_policy();
}
inline void TabNavigation::clear_correct_referrer_policy()
{
    _impl_.correct_referrer_policy_ = 1;
    _impl_._has_bits_[0] &= ~0x00400000u;
}
inline int32_t TabNavigation::_internal_correct_referrer_policy() const
{
    return _impl_.correct_referrer_policy_;
}
inline int32_t TabNavigation::correct_referrer_policy() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.correct_referrer_policy)
    return _internal_correct_referrer_policy();
}
inline void TabNavigation::_internal_set_correct_referrer_policy(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00400000u;
    _impl_.correct_referrer_policy_ = value;
}
inline void TabNavigation::set_correct_referrer_policy(int32_t value)
{
    _internal_set_correct_referrer_policy(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.correct_referrer_policy)
}

// optional .sync_pb.SyncEnums.PasswordState password_state = 26;
inline bool TabNavigation::_internal_has_password_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x00200000u) != 0;
    return value;
}
inline bool TabNavigation::has_password_state() const
{
    return _internal_has_password_state();
}
inline void TabNavigation::clear_password_state()
{
    _impl_.password_state_ = 0;
    _impl_._has_bits_[0] &= ~0x00200000u;
}
inline ::sync_pb::SyncEnums_PasswordState TabNavigation::_internal_password_state() const
{
    return static_cast<::sync_pb::SyncEnums_PasswordState>(_impl_.password_state_);
}
inline ::sync_pb::SyncEnums_PasswordState TabNavigation::password_state() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.password_state)
    return _internal_password_state();
}
inline void TabNavigation::_internal_set_password_state(::sync_pb::SyncEnums_PasswordState value)
{
    assert(::sync_pb::SyncEnums_PasswordState_IsValid(value));
    _impl_._has_bits_[0] |= 0x00200000u;
    _impl_.password_state_ = value;
}
inline void TabNavigation::set_password_state(::sync_pb::SyncEnums_PasswordState value)
{
    _internal_set_password_state(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.password_state)
}

// optional bool navigation_chain_start = 13 [deprecated = true];
inline bool TabNavigation::_internal_has_navigation_chain_start() const
{
    bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
    return value;
}
inline bool TabNavigation::has_navigation_chain_start() const
{
    return _internal_has_navigation_chain_start();
}
inline void TabNavigation::clear_navigation_chain_start()
{
    _impl_.navigation_chain_start_ = false;
    _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool TabNavigation::_internal_navigation_chain_start() const
{
    return _impl_.navigation_chain_start_;
}
inline bool TabNavigation::navigation_chain_start() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_chain_start)
    return _internal_navigation_chain_start();
}
inline void TabNavigation::_internal_set_navigation_chain_start(bool value)
{
    _impl_._has_bits_[0] |= 0x00004000u;
    _impl_.navigation_chain_start_ = value;
}
inline void TabNavigation::set_navigation_chain_start(bool value)
{
    _internal_set_navigation_chain_start(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_chain_start)
}

// optional bool navigation_chain_end = 14 [deprecated = true];
inline bool TabNavigation::_internal_has_navigation_chain_end() const
{
    bool value = (_impl_._has_bits_[0] & 0x00008000u) != 0;
    return value;
}
inline bool TabNavigation::has_navigation_chain_end() const
{
    return _internal_has_navigation_chain_end();
}
inline void TabNavigation::clear_navigation_chain_end()
{
    _impl_.navigation_chain_end_ = false;
    _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool TabNavigation::_internal_navigation_chain_end() const
{
    return _impl_.navigation_chain_end_;
}
inline bool TabNavigation::navigation_chain_end() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_chain_end)
    return _internal_navigation_chain_end();
}
inline void TabNavigation::_internal_set_navigation_chain_end(bool value)
{
    _impl_._has_bits_[0] |= 0x00008000u;
    _impl_.navigation_chain_end_ = value;
}
inline void TabNavigation::set_navigation_chain_end(bool value)
{
    _internal_set_navigation_chain_end(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_chain_end)
}

// optional string search_terms = 16 [deprecated = true];
inline bool TabNavigation::_internal_has_search_terms() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    return value;
}
inline bool TabNavigation::has_search_terms() const
{
    return _internal_has_search_terms();
}
inline void TabNavigation::clear_search_terms()
{
    _impl_.search_terms_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TabNavigation::search_terms() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.search_terms)
    return _internal_search_terms();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabNavigation::set_search_terms(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.search_terms_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.search_terms)
}
inline std::string* TabNavigation::mutable_search_terms()
{
    std::string* _s = _internal_mutable_search_terms();
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.search_terms)
    return _s;
}
inline const std::string& TabNavigation::_internal_search_terms() const
{
    return _impl_.search_terms_.Get();
}
inline void TabNavigation::_internal_set_search_terms(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000008u;
    _impl_.search_terms_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_search_terms()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    return _impl_.search_terms_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_search_terms()
{
    // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.search_terms)
    if (!_internal_has_search_terms()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000008u;
    auto* p = _impl_.search_terms_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.search_terms_.IsDefault()) {
        _impl_.search_terms_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TabNavigation::set_allocated_search_terms(std::string* search_terms)
{
    if (search_terms != nullptr) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.search_terms_.SetAllocated(search_terms, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.search_terms_.IsDefault()) {
        _impl_.search_terms_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.search_terms)
}

// optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED, deprecated = true];
inline bool TabNavigation::_internal_has_blocked_state() const
{
    bool value = (_impl_._has_bits_[0] & 0x01000000u) != 0;
    return value;
}
inline bool TabNavigation::has_blocked_state() const
{
    return _internal_has_blocked_state();
}
inline void TabNavigation::clear_blocked_state()
{
    _impl_.blocked_state_ = 1;
    _impl_._has_bits_[0] &= ~0x01000000u;
}
inline ::sync_pb::TabNavigation_BlockedState TabNavigation::_internal_blocked_state() const
{
    return static_cast<::sync_pb::TabNavigation_BlockedState>(_impl_.blocked_state_);
}
inline ::sync_pb::TabNavigation_BlockedState TabNavigation::blocked_state() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.blocked_state)
    return _internal_blocked_state();
}
inline void TabNavigation::_internal_set_blocked_state(::sync_pb::TabNavigation_BlockedState value)
{
    assert(::sync_pb::TabNavigation_BlockedState_IsValid(value));
    _impl_._has_bits_[0] |= 0x01000000u;
    _impl_.blocked_state_ = value;
}
inline void TabNavigation::set_blocked_state(::sync_pb::TabNavigation_BlockedState value)
{
    _internal_set_blocked_state(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.blocked_state)
}

// optional int32 obsolete_referrer_policy = 21 [deprecated = true];
inline bool TabNavigation::_internal_has_obsolete_referrer_policy() const
{
    bool value = (_impl_._has_bits_[0] & 0x00080000u) != 0;
    return value;
}
inline bool TabNavigation::has_obsolete_referrer_policy() const
{
    return _internal_has_obsolete_referrer_policy();
}
inline void TabNavigation::clear_obsolete_referrer_policy()
{
    _impl_.obsolete_referrer_policy_ = 0;
    _impl_._has_bits_[0] &= ~0x00080000u;
}
inline int32_t TabNavigation::_internal_obsolete_referrer_policy() const
{
    return _impl_.obsolete_referrer_policy_;
}
inline int32_t TabNavigation::obsolete_referrer_policy() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.obsolete_referrer_policy)
    return _internal_obsolete_referrer_policy();
}
inline void TabNavigation::_internal_set_obsolete_referrer_policy(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00080000u;
    _impl_.obsolete_referrer_policy_ = value;
}
inline void TabNavigation::set_obsolete_referrer_policy(int32_t value)
{
    _internal_set_obsolete_referrer_policy(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.obsolete_referrer_policy)
}

// optional bool is_restored = 22 [deprecated = true];
inline bool TabNavigation::_internal_has_is_restored() const
{
    bool value = (_impl_._has_bits_[0] & 0x00010000u) != 0;
    return value;
}
inline bool TabNavigation::has_is_restored() const
{
    return _internal_has_is_restored();
}
inline void TabNavigation::clear_is_restored()
{
    _impl_.is_restored_ = false;
    _impl_._has_bits_[0] &= ~0x00010000u;
}
inline bool TabNavigation::_internal_is_restored() const
{
    return _impl_.is_restored_;
}
inline bool TabNavigation::is_restored() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.is_restored)
    return _internal_is_restored();
}
inline void TabNavigation::_internal_set_is_restored(bool value)
{
    _impl_._has_bits_[0] |= 0x00010000u;
    _impl_.is_restored_ = value;
}
inline void TabNavigation::set_is_restored(bool value)
{
    _internal_set_is_restored(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.is_restored)
}

// repeated .sync_pb.NavigationRedirect navigation_redirect = 23 [deprecated = true];
inline int TabNavigation::_internal_navigation_redirect_size() const
{
    return _impl_.navigation_redirect_.size();
}
inline int TabNavigation::navigation_redirect_size() const
{
    return _internal_navigation_redirect_size();
}
inline void TabNavigation::clear_navigation_redirect()
{
    _impl_.navigation_redirect_.Clear();
}
inline ::sync_pb::NavigationRedirect* TabNavigation::mutable_navigation_redirect(int index)
{
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.navigation_redirect)
    return _impl_.navigation_redirect_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NavigationRedirect>* TabNavigation::mutable_navigation_redirect()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.TabNavigation.navigation_redirect)
    return &_impl_.navigation_redirect_;
}
inline const ::sync_pb::NavigationRedirect& TabNavigation::_internal_navigation_redirect(int index) const
{
    return _impl_.navigation_redirect_.Get(index);
}
inline const ::sync_pb::NavigationRedirect& TabNavigation::navigation_redirect(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_redirect)
    return _internal_navigation_redirect(index);
}
inline ::sync_pb::NavigationRedirect* TabNavigation::_internal_add_navigation_redirect()
{
    return _impl_.navigation_redirect_.Add();
}
inline ::sync_pb::NavigationRedirect* TabNavigation::add_navigation_redirect()
{
    ::sync_pb::NavigationRedirect* _add = _internal_add_navigation_redirect();
    // @@protoc_insertion_point(field_add:sync_pb.TabNavigation.navigation_redirect)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sync_pb::NavigationRedirect>& TabNavigation::navigation_redirect() const
{
    // @@protoc_insertion_point(field_list:sync_pb.TabNavigation.navigation_redirect)
    return _impl_.navigation_redirect_;
}

// optional string last_navigation_redirect_url = 24 [deprecated = true];
inline bool TabNavigation::_internal_has_last_navigation_redirect_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool TabNavigation::has_last_navigation_redirect_url() const
{
    return _internal_has_last_navigation_redirect_url();
}
inline void TabNavigation::clear_last_navigation_redirect_url()
{
    _impl_.last_navigation_redirect_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const std::string& TabNavigation::last_navigation_redirect_url() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.last_navigation_redirect_url)
    return _internal_last_navigation_redirect_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabNavigation::set_last_navigation_redirect_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.last_navigation_redirect_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.last_navigation_redirect_url)
}
inline std::string* TabNavigation::mutable_last_navigation_redirect_url()
{
    std::string* _s = _internal_mutable_last_navigation_redirect_url();
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.last_navigation_redirect_url)
    return _s;
}
inline const std::string& TabNavigation::_internal_last_navigation_redirect_url() const
{
    return _impl_.last_navigation_redirect_url_.Get();
}
inline void TabNavigation::_internal_set_last_navigation_redirect_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.last_navigation_redirect_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_last_navigation_redirect_url()
{
    _impl_._has_bits_[0] |= 0x00000020u;
    return _impl_.last_navigation_redirect_url_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_last_navigation_redirect_url()
{
    // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.last_navigation_redirect_url)
    if (!_internal_has_last_navigation_redirect_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000020u;
    auto* p = _impl_.last_navigation_redirect_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.last_navigation_redirect_url_.IsDefault()) {
        _impl_.last_navigation_redirect_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TabNavigation::set_allocated_last_navigation_redirect_url(std::string* last_navigation_redirect_url)
{
    if (last_navigation_redirect_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000020u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000020u;
    }
    _impl_.last_navigation_redirect_url_.SetAllocated(last_navigation_redirect_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.last_navigation_redirect_url_.IsDefault()) {
        _impl_.last_navigation_redirect_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.last_navigation_redirect_url)
}

// optional int64 task_id = 27 [deprecated = true];
inline bool TabNavigation::_internal_has_task_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00100000u) != 0;
    return value;
}
inline bool TabNavigation::has_task_id() const
{
    return _internal_has_task_id();
}
inline void TabNavigation::clear_task_id()
{
    _impl_.task_id_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00100000u;
}
inline int64_t TabNavigation::_internal_task_id() const
{
    return _impl_.task_id_;
}
inline int64_t TabNavigation::task_id() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.task_id)
    return _internal_task_id();
}
inline void TabNavigation::_internal_set_task_id(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00100000u;
    _impl_.task_id_ = value;
}
inline void TabNavigation::set_task_id(int64_t value)
{
    _internal_set_task_id(value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.task_id)
}

// repeated int64 ancestor_task_id = 28 [deprecated = true];
inline int TabNavigation::_internal_ancestor_task_id_size() const
{
    return _impl_.ancestor_task_id_.size();
}
inline int TabNavigation::ancestor_task_id_size() const
{
    return _internal_ancestor_task_id_size();
}
inline void TabNavigation::clear_ancestor_task_id()
{
    _impl_.ancestor_task_id_.Clear();
}
inline int64_t TabNavigation::_internal_ancestor_task_id(int index) const
{
    return _impl_.ancestor_task_id_.Get(index);
}
inline int64_t TabNavigation::ancestor_task_id(int index) const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.ancestor_task_id)
    return _internal_ancestor_task_id(index);
}
inline void TabNavigation::set_ancestor_task_id(int index, int64_t value)
{
    _impl_.ancestor_task_id_.Set(index, value);
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.ancestor_task_id)
}
inline void TabNavigation::_internal_add_ancestor_task_id(int64_t value)
{
    _impl_.ancestor_task_id_.Add(value);
}
inline void TabNavigation::add_ancestor_task_id(int64_t value)
{
    _internal_add_ancestor_task_id(value);
    // @@protoc_insertion_point(field_add:sync_pb.TabNavigation.ancestor_task_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& TabNavigation::_internal_ancestor_task_id() const
{
    return _impl_.ancestor_task_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>& TabNavigation::ancestor_task_id() const
{
    // @@protoc_insertion_point(field_list:sync_pb.TabNavigation.ancestor_task_id)
    return _internal_ancestor_task_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* TabNavigation::_internal_mutable_ancestor_task_id()
{
    return &_impl_.ancestor_task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int64_t>* TabNavigation::mutable_ancestor_task_id()
{
    // @@protoc_insertion_point(field_mutable_list:sync_pb.TabNavigation.ancestor_task_id)
    return _internal_mutable_ancestor_task_id();
}

// optional .sync_pb.ReplacedNavigation replaced_navigation = 29 [deprecated = true];
inline bool TabNavigation::_internal_has_replaced_navigation() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.replaced_navigation_ != nullptr);
    return value;
}
inline bool TabNavigation::has_replaced_navigation() const
{
    return _internal_has_replaced_navigation();
}
inline void TabNavigation::clear_replaced_navigation()
{
    if (_impl_.replaced_navigation_ != nullptr)
        _impl_.replaced_navigation_->Clear();
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::sync_pb::ReplacedNavigation& TabNavigation::_internal_replaced_navigation() const
{
    const ::sync_pb::ReplacedNavigation* p = _impl_.replaced_navigation_;
    return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ReplacedNavigation&>(::sync_pb::_ReplacedNavigation_default_instance_);
}
inline const ::sync_pb::ReplacedNavigation& TabNavigation::replaced_navigation() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.replaced_navigation)
    return _internal_replaced_navigation();
}
inline void TabNavigation::unsafe_arena_set_allocated_replaced_navigation(::sync_pb::ReplacedNavigation* replaced_navigation)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.replaced_navigation_);
    }
    _impl_.replaced_navigation_ = replaced_navigation;
    if (replaced_navigation) {
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.TabNavigation.replaced_navigation)
}
inline ::sync_pb::ReplacedNavigation* TabNavigation::release_replaced_navigation()
{
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::sync_pb::ReplacedNavigation* temp = _impl_.replaced_navigation_;
    _impl_.replaced_navigation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sync_pb::ReplacedNavigation* TabNavigation::unsafe_arena_release_replaced_navigation()
{
    // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.replaced_navigation)
    _impl_._has_bits_[0] &= ~0x00000080u;
    ::sync_pb::ReplacedNavigation* temp = _impl_.replaced_navigation_;
    _impl_.replaced_navigation_ = nullptr;
    return temp;
}
inline ::sync_pb::ReplacedNavigation* TabNavigation::_internal_mutable_replaced_navigation()
{
    _impl_._has_bits_[0] |= 0x00000080u;
    if (_impl_.replaced_navigation_ == nullptr) {
        auto* p = CreateMaybeMessage<::sync_pb::ReplacedNavigation>(GetArenaForAllocation());
        _impl_.replaced_navigation_ = p;
    }
    return _impl_.replaced_navigation_;
}
inline ::sync_pb::ReplacedNavigation* TabNavigation::mutable_replaced_navigation()
{
    ::sync_pb::ReplacedNavigation* _msg = _internal_mutable_replaced_navigation();
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.replaced_navigation)
    return _msg;
}
inline void TabNavigation::set_allocated_replaced_navigation(::sync_pb::ReplacedNavigation* replaced_navigation)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.replaced_navigation_;
    }
    if (replaced_navigation) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(replaced_navigation);
        if (message_arena != submessage_arena) {
            replaced_navigation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, replaced_navigation, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000080u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000080u;
    }
    _impl_.replaced_navigation_ = replaced_navigation;
    // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.replaced_navigation)
}

// optional string page_language = 30 [deprecated = true];
inline bool TabNavigation::_internal_has_page_language() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool TabNavigation::has_page_language() const
{
    return _internal_has_page_language();
}
inline void TabNavigation::clear_page_language()
{
    _impl_.page_language_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const std::string& TabNavigation::page_language() const
{
    // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.page_language)
    return _internal_page_language();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TabNavigation::set_page_language(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.page_language_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.page_language)
}
inline std::string* TabNavigation::mutable_page_language()
{
    std::string* _s = _internal_mutable_page_language();
    // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.page_language)
    return _s;
}
inline const std::string& TabNavigation::_internal_page_language() const
{
    return _impl_.page_language_.Get();
}
inline void TabNavigation::_internal_set_page_language(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.page_language_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_page_language()
{
    _impl_._has_bits_[0] |= 0x00000040u;
    return _impl_.page_language_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_page_language()
{
    // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.page_language)
    if (!_internal_has_page_language()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000040u;
    auto* p = _impl_.page_language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.page_language_.IsDefault()) {
        _impl_.page_language_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void TabNavigation::set_allocated_page_language(std::string* page_language)
{
    if (page_language != nullptr) {
        _impl_._has_bits_[0] |= 0x00000040u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000040u;
    }
    _impl_.page_language_.SetAllocated(page_language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.page_language_.IsDefault()) {
        _impl_.page_language_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.page_language)
}

// -------------------------------------------------------------------

// NavigationRedirect

// optional string url = 1;
inline bool NavigationRedirect::_internal_has_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool NavigationRedirect::has_url() const
{
    return _internal_has_url();
}
inline void NavigationRedirect::clear_url()
{
    _impl_.url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NavigationRedirect::url() const
{
    // @@protoc_insertion_point(field_get:sync_pb.NavigationRedirect.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void NavigationRedirect::set_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.NavigationRedirect.url)
}
inline std::string* NavigationRedirect::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:sync_pb.NavigationRedirect.url)
    return _s;
}
inline const std::string& NavigationRedirect::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void NavigationRedirect::_internal_set_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigationRedirect::_internal_mutable_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* NavigationRedirect::release_url()
{
    // @@protoc_insertion_point(field_release:sync_pb.NavigationRedirect.url)
    if (!_internal_has_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void NavigationRedirect::set_allocated_url(std::string* url)
{
    if (url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.NavigationRedirect.url)
}

// -------------------------------------------------------------------

// ReplacedNavigation

// optional string first_committed_url = 1;
inline bool ReplacedNavigation::_internal_has_first_committed_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool ReplacedNavigation::has_first_committed_url() const
{
    return _internal_has_first_committed_url();
}
inline void ReplacedNavigation::clear_first_committed_url()
{
    _impl_.first_committed_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplacedNavigation::first_committed_url() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ReplacedNavigation.first_committed_url)
    return _internal_first_committed_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void ReplacedNavigation::set_first_committed_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.first_committed_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sync_pb.ReplacedNavigation.first_committed_url)
}
inline std::string* ReplacedNavigation::mutable_first_committed_url()
{
    std::string* _s = _internal_mutable_first_committed_url();
    // @@protoc_insertion_point(field_mutable:sync_pb.ReplacedNavigation.first_committed_url)
    return _s;
}
inline const std::string& ReplacedNavigation::_internal_first_committed_url() const
{
    return _impl_.first_committed_url_.Get();
}
inline void ReplacedNavigation::_internal_set_first_committed_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.first_committed_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ReplacedNavigation::_internal_mutable_first_committed_url()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.first_committed_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ReplacedNavigation::release_first_committed_url()
{
    // @@protoc_insertion_point(field_release:sync_pb.ReplacedNavigation.first_committed_url)
    if (!_internal_has_first_committed_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.first_committed_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.first_committed_url_.IsDefault()) {
        _impl_.first_committed_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void ReplacedNavigation::set_allocated_first_committed_url(std::string* first_committed_url)
{
    if (first_committed_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.first_committed_url_.SetAllocated(first_committed_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.first_committed_url_.IsDefault()) {
        _impl_.first_committed_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sync_pb.ReplacedNavigation.first_committed_url)
}

// optional int64 first_timestamp_msec = 2;
inline bool ReplacedNavigation::_internal_has_first_timestamp_msec() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool ReplacedNavigation::has_first_timestamp_msec() const
{
    return _internal_has_first_timestamp_msec();
}
inline void ReplacedNavigation::clear_first_timestamp_msec()
{
    _impl_.first_timestamp_msec_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t ReplacedNavigation::_internal_first_timestamp_msec() const
{
    return _impl_.first_timestamp_msec_;
}
inline int64_t ReplacedNavigation::first_timestamp_msec() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ReplacedNavigation.first_timestamp_msec)
    return _internal_first_timestamp_msec();
}
inline void ReplacedNavigation::_internal_set_first_timestamp_msec(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.first_timestamp_msec_ = value;
}
inline void ReplacedNavigation::set_first_timestamp_msec(int64_t value)
{
    _internal_set_first_timestamp_msec(value);
    // @@protoc_insertion_point(field_set:sync_pb.ReplacedNavigation.first_timestamp_msec)
}

// optional .sync_pb.SyncEnums.PageTransition first_page_transition = 3;
inline bool ReplacedNavigation::_internal_has_first_page_transition() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool ReplacedNavigation::has_first_page_transition() const
{
    return _internal_has_first_page_transition();
}
inline void ReplacedNavigation::clear_first_page_transition()
{
    _impl_.first_page_transition_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::sync_pb::SyncEnums_PageTransition ReplacedNavigation::_internal_first_page_transition() const
{
    return static_cast<::sync_pb::SyncEnums_PageTransition>(_impl_.first_page_transition_);
}
inline ::sync_pb::SyncEnums_PageTransition ReplacedNavigation::first_page_transition() const
{
    // @@protoc_insertion_point(field_get:sync_pb.ReplacedNavigation.first_page_transition)
    return _internal_first_page_transition();
}
inline void ReplacedNavigation::_internal_set_first_page_transition(::sync_pb::SyncEnums_PageTransition value)
{
    assert(::sync_pb::SyncEnums_PageTransition_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.first_page_transition_ = value;
}
inline void ReplacedNavigation::set_first_page_transition(::sync_pb::SyncEnums_PageTransition value)
{
    _internal_set_first_page_transition(value);
    // @@protoc_insertion_point(field_set:sync_pb.ReplacedNavigation.first_page_transition)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace sync_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::sync_pb::SessionTab_FaviconType> : ::std::true_type { };
template <> struct is_proto_enum<::sync_pb::TabNavigation_BlockedState> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto
