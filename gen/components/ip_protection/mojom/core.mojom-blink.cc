// components/ip_protection/mojom/core.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "components/ip_protection/mojom/core.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "components/ip_protection/mojom/core.mojom-params-data.h"
#include "components/ip_protection/mojom/core.mojom-shared-message-ids.h"

#include "components/ip_protection/mojom/core.mojom-blink-import-headers.h"
#include "components/ip_protection/mojom/core.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"

namespace ip_protection::mojom::blink {
const char CoreControl::Name_[] = "ip_protection.mojom.CoreControl";

CoreControl::IPCStableHashFunction CoreControl::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::CoreControl>(message.name())) {
    case messages::CoreControl::kAuthTokensMayBeAvailable: {
        return &CoreControl::AuthTokensMayBeAvailable_Sym::IPCStableHash;
    }
    case messages::CoreControl::kSetIpProtectionEnabled: {
        return &CoreControl::SetIpProtectionEnabled_Sym::IPCStableHash;
    }
    case messages::CoreControl::kVerifyIpProtectionCoreHostForTesting: {
        return &CoreControl::VerifyIpProtectionCoreHostForTesting_Sym::IPCStableHash;
    }
    case messages::CoreControl::kIsIpProtectionEnabledForTesting: {
        return &CoreControl::IsIpProtectionEnabledForTesting_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* CoreControl::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::CoreControl>(message.name())) {
        case messages::CoreControl::kAuthTokensMayBeAvailable:
            return "Receive ip_protection::mojom::CoreControl::AuthTokensMayBeAvailable";
        case messages::CoreControl::kSetIpProtectionEnabled:
            return "Receive ip_protection::mojom::CoreControl::SetIpProtectionEnabled";
        case messages::CoreControl::kVerifyIpProtectionCoreHostForTesting:
            return "Receive ip_protection::mojom::CoreControl::VerifyIpProtectionCoreHostForTesting";
        case messages::CoreControl::kIsIpProtectionEnabledForTesting:
            return "Receive ip_protection::mojom::CoreControl::IsIpProtectionEnabledForTesting";
        }
    } else {
        switch (static_cast<messages::CoreControl>(message.name())) {
        case messages::CoreControl::kAuthTokensMayBeAvailable:
            return "Receive reply ip_protection::mojom::CoreControl::AuthTokensMayBeAvailable";
        case messages::CoreControl::kSetIpProtectionEnabled:
            return "Receive reply ip_protection::mojom::CoreControl::SetIpProtectionEnabled";
        case messages::CoreControl::kVerifyIpProtectionCoreHostForTesting:
            return "Receive reply ip_protection::mojom::CoreControl::VerifyIpProtectionCoreHostForTesting";
        case messages::CoreControl::kIsIpProtectionEnabledForTesting:
            return "Receive reply ip_protection::mojom::CoreControl::IsIpProtectionEnabledForTesting";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t CoreControl::AuthTokensMayBeAvailable_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)ip_protection::mojom::CoreControl::AuthTokensMayBeAvailable");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t CoreControl::SetIpProtectionEnabled_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)ip_protection::mojom::CoreControl::SetIpProtectionEnabled");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t CoreControl::VerifyIpProtectionCoreHostForTesting_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)ip_protection::mojom::CoreControl::VerifyIpProtectionCoreHostForTesting");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t CoreControl::IsIpProtectionEnabledForTesting_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)ip_protection::mojom::CoreControl::IsIpProtectionEnabledForTesting");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class CoreControl_VerifyIpProtectionCoreHostForTesting_ForwardToCallback : public mojo::MessageReceiver {
public:
    CoreControl_VerifyIpProtectionCoreHostForTesting_ForwardToCallback(CoreControl::VerifyIpProtectionCoreHostForTestingCallback callback)
        : callback_(std::move(callback))
    {
    }

    CoreControl_VerifyIpProtectionCoreHostForTesting_ForwardToCallback(const CoreControl_VerifyIpProtectionCoreHostForTesting_ForwardToCallback&) = delete;
    CoreControl_VerifyIpProtectionCoreHostForTesting_ForwardToCallback& operator=(const CoreControl_VerifyIpProtectionCoreHostForTesting_ForwardToCallback&)
        = delete;

    bool Accept(mojo::Message* message) override;

private:
    CoreControl::VerifyIpProtectionCoreHostForTestingCallback callback_;
};

class CoreControl_IsIpProtectionEnabledForTesting_ForwardToCallback : public mojo::MessageReceiver {
public:
    CoreControl_IsIpProtectionEnabledForTesting_ForwardToCallback(CoreControl::IsIpProtectionEnabledForTestingCallback callback)
        : callback_(std::move(callback))
    {
    }

    CoreControl_IsIpProtectionEnabledForTesting_ForwardToCallback(const CoreControl_IsIpProtectionEnabledForTesting_ForwardToCallback&) = delete;
    CoreControl_IsIpProtectionEnabledForTesting_ForwardToCallback& operator=(const CoreControl_IsIpProtectionEnabledForTesting_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    CoreControl::IsIpProtectionEnabledForTestingCallback callback_;
};

CoreControlProxy::CoreControlProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void CoreControlProxy::AuthTokensMayBeAvailable()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send ip_protection::mojom::CoreControl::AuthTokensMayBeAvailable");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreControl::kAuthTokensMayBeAvailable), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreControl_AuthTokensMayBeAvailable_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreControl::Name_);
    message.set_method_name("AuthTokensMayBeAvailable");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void CoreControlProxy::SetIpProtectionEnabled(bool in_value)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send ip_protection::mojom::CoreControl::SetIpProtectionEnabled", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), in_value, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreControl::kSetIpProtectionEnabled), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreControl_SetIpProtectionEnabled_Params_Data> params(message);
    params.Allocate();
    params->value = in_value;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreControl::Name_);
    message.set_method_name("SetIpProtectionEnabled");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void CoreControlProxy::VerifyIpProtectionCoreHostForTesting(VerifyIpProtectionCoreHostForTestingCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send ip_protection::mojom::CoreControl::VerifyIpProtectionCoreHostForTesting");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreControl::kVerifyIpProtectionCoreHostForTesting), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreControl_VerifyIpProtectionCoreHostForTesting_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreControl::Name_);
    message.set_method_name("VerifyIpProtectionCoreHostForTesting");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new CoreControl_VerifyIpProtectionCoreHostForTesting_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CoreControlProxy::IsIpProtectionEnabledForTesting(IsIpProtectionEnabledForTestingCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send ip_protection::mojom::CoreControl::IsIpProtectionEnabledForTesting");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreControl::kIsIpProtectionEnabledForTesting), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreControl_IsIpProtectionEnabledForTesting_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreControl::Name_);
    message.set_method_name("IsIpProtectionEnabledForTesting");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new CoreControl_IsIpProtectionEnabledForTesting_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class CoreControl_VerifyIpProtectionCoreHostForTesting_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static CoreControl::VerifyIpProtectionCoreHostForTestingCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<CoreControl_VerifyIpProtectionCoreHostForTesting_ProxyToResponder> proxy(
            new CoreControl_VerifyIpProtectionCoreHostForTesting_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&CoreControl_VerifyIpProtectionCoreHostForTesting_ProxyToResponder::Run, std::move(proxy));
    }

    ~CoreControl_VerifyIpProtectionCoreHostForTesting_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    CoreControl_VerifyIpProtectionCoreHostForTesting_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "CoreControl::VerifyIpProtectionCoreHostForTestingCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(::ip_protection::mojom::blink::BlindSignedAuthTokenPtr in_bsa_token, std::optional<::base::Time> in_try_again_after);
};

bool CoreControl_VerifyIpProtectionCoreHostForTesting_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::CoreControl_VerifyIpProtectionCoreHostForTesting_ResponseParams_Data* params
        = reinterpret_cast<internal::CoreControl_VerifyIpProtectionCoreHostForTesting_ResponseParams_Data*>(message->mutable_payload());

    // Validation for CoreControl.2
    bool success = true;
    ::ip_protection::mojom::blink::BlindSignedAuthTokenPtr p_bsa_token {};
    std::optional<::base::Time> p_try_again_after {};
    CoreControl_VerifyIpProtectionCoreHostForTesting_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadBsaToken(&p_bsa_token))
        success = false;
    if (success && !input_data_view.ReadTryAgainAfter(&p_try_again_after))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreControl::Name_, 2, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_bsa_token), std::move(p_try_again_after));
    return true;
}

void CoreControl_VerifyIpProtectionCoreHostForTesting_ProxyToResponder::Run(
    ::ip_protection::mojom::blink::BlindSignedAuthTokenPtr in_bsa_token, std::optional<::base::Time> in_try_again_after)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply ip_protection::mojom::CoreControl::VerifyIpProtectionCoreHostForTesting", "async_response_parameters",
        [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(
                dict.AddItem("bsa_token"), in_bsa_token, "<value of type ::ip_protection::mojom::blink::BlindSignedAuthTokenPtr>");
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("try_again_after"), in_try_again_after, "<value of type std::optional<::base::Time>>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreControl::kVerifyIpProtectionCoreHostForTesting), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreControl_VerifyIpProtectionCoreHostForTesting_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->bsa_token)::BaseType> bsa_token_fragment(params.message());
    mojo::internal::Serialize<::ip_protection::mojom::BlindSignedAuthTokenDataView>(in_bsa_token, bsa_token_fragment);
    params->bsa_token.Set(bsa_token_fragment.is_null() ? nullptr : bsa_token_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->try_again_after)::BaseType> try_again_after_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_try_again_after, try_again_after_fragment);
    params->try_again_after.Set(try_again_after_fragment.is_null() ? nullptr : try_again_after_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreControl::Name_);
    message.set_method_name("VerifyIpProtectionCoreHostForTesting");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class CoreControl_IsIpProtectionEnabledForTesting_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static CoreControl::IsIpProtectionEnabledForTestingCallback CreateCallback(
        ::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<CoreControl_IsIpProtectionEnabledForTesting_ProxyToResponder> proxy(
            new CoreControl_IsIpProtectionEnabledForTesting_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&CoreControl_IsIpProtectionEnabledForTesting_ProxyToResponder::Run, std::move(proxy));
    }

    ~CoreControl_IsIpProtectionEnabledForTesting_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    CoreControl_IsIpProtectionEnabledForTesting_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "CoreControl::IsIpProtectionEnabledForTestingCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(bool in_value);
};

bool CoreControl_IsIpProtectionEnabledForTesting_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::CoreControl_IsIpProtectionEnabledForTesting_ResponseParams_Data* params
        = reinterpret_cast<internal::CoreControl_IsIpProtectionEnabledForTesting_ResponseParams_Data*>(message->mutable_payload());

    // Validation for CoreControl.3
    bool success = true;
    bool p_value {};
    CoreControl_IsIpProtectionEnabledForTesting_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_value = input_data_view.value();
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreControl::Name_, 3, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_value));
    return true;
}

void CoreControl_IsIpProtectionEnabledForTesting_ProxyToResponder::Run(bool in_value)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply ip_protection::mojom::CoreControl::IsIpProtectionEnabledForTesting", "async_response_parameters",
        [&](perfetto::TracedValue context) {
            auto dict = std::move(context).WriteDictionary();
            perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), in_value, "<value of type bool>");
        });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreControl::kIsIpProtectionEnabledForTesting), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreControl_IsIpProtectionEnabledForTesting_ResponseParams_Data> params(message);
    params.Allocate();
    params->value = in_value;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreControl::Name_);
    message.set_method_name("IsIpProtectionEnabledForTesting");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool CoreControlStubDispatch::Accept(CoreControl* impl, mojo::Message* message)
{
    switch (static_cast<messages::CoreControl>(message->header()->name)) {
    case messages::CoreControl::kAuthTokensMayBeAvailable: {
        DCHECK(message->is_serialized());
        internal::CoreControl_AuthTokensMayBeAvailable_Params_Data* params
            = reinterpret_cast<internal::CoreControl_AuthTokensMayBeAvailable_Params_Data*>(message->mutable_payload());

        // Validation for CoreControl.0
        bool success = true;
        CoreControl_AuthTokensMayBeAvailable_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreControl::Name_, 0, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->AuthTokensMayBeAvailable();
        return true;
    }
    case messages::CoreControl::kSetIpProtectionEnabled: {
        DCHECK(message->is_serialized());
        internal::CoreControl_SetIpProtectionEnabled_Params_Data* params
            = reinterpret_cast<internal::CoreControl_SetIpProtectionEnabled_Params_Data*>(message->mutable_payload());

        // Validation for CoreControl.1
        bool success = true;
        bool p_value {};
        CoreControl_SetIpProtectionEnabled_ParamsDataView input_data_view(params, message);

        if (success)
            p_value = input_data_view.value();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreControl::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetIpProtectionEnabled(std::move(p_value));
        return true;
    }
    case messages::CoreControl::kVerifyIpProtectionCoreHostForTesting: {
        break;
    }
    case messages::CoreControl::kIsIpProtectionEnabledForTesting: {
        break;
    }
    }
    return false;
}

// static
bool CoreControlStubDispatch::AcceptWithResponder(CoreControl* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::CoreControl>(message->header()->name)) {
    case messages::CoreControl::kAuthTokensMayBeAvailable: {
        break;
    }
    case messages::CoreControl::kSetIpProtectionEnabled: {
        break;
    }
    case messages::CoreControl::kVerifyIpProtectionCoreHostForTesting: {
        internal::CoreControl_VerifyIpProtectionCoreHostForTesting_Params_Data* params
            = reinterpret_cast<internal::CoreControl_VerifyIpProtectionCoreHostForTesting_Params_Data*>(message->mutable_payload());

        // Validation for CoreControl.2
        bool success = true;
        CoreControl_VerifyIpProtectionCoreHostForTesting_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreControl::Name_, 2, false);
            return false;
        }
        CoreControl::VerifyIpProtectionCoreHostForTestingCallback callback
            = CoreControl_VerifyIpProtectionCoreHostForTesting_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->VerifyIpProtectionCoreHostForTesting(std::move(callback));
        return true;
    }
    case messages::CoreControl::kIsIpProtectionEnabledForTesting: {
        internal::CoreControl_IsIpProtectionEnabledForTesting_Params_Data* params
            = reinterpret_cast<internal::CoreControl_IsIpProtectionEnabledForTesting_Params_Data*>(message->mutable_payload());

        // Validation for CoreControl.3
        bool success = true;
        CoreControl_IsIpProtectionEnabledForTesting_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreControl::Name_, 3, false);
            return false;
        }
        CoreControl::IsIpProtectionEnabledForTestingCallback callback
            = CoreControl_IsIpProtectionEnabledForTesting_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->IsIpProtectionEnabledForTesting(std::move(callback));
        return true;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kCoreControlValidationInfo[] = {
    { &internal::CoreControl_AuthTokensMayBeAvailable_Params_Data::Validate, nullptr /* no response */ },
    { &internal::CoreControl_SetIpProtectionEnabled_Params_Data::Validate, nullptr /* no response */ },
    { &internal::CoreControl_VerifyIpProtectionCoreHostForTesting_Params_Data::Validate,
        &internal::CoreControl_VerifyIpProtectionCoreHostForTesting_ResponseParams_Data::Validate },
    { &internal::CoreControl_IsIpProtectionEnabledForTesting_Params_Data::Validate,
        &internal::CoreControl_IsIpProtectionEnabledForTesting_ResponseParams_Data::Validate },
};

bool CoreControlRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::ip_protection::mojom::blink::CoreControl::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kCoreControlValidationInfo);
}

bool CoreControlResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::ip_protection::mojom::blink::CoreControl::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kCoreControlValidationInfo);
}
const char CoreHost::Name_[] = "ip_protection.mojom.CoreHost";

CoreHost::IPCStableHashFunction CoreHost::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::CoreHost>(message.name())) {
    case messages::CoreHost::kTryGetAuthTokens: {
        return &CoreHost::TryGetAuthTokens_Sym::IPCStableHash;
    }
    case messages::CoreHost::kGetProxyConfig: {
        return &CoreHost::GetProxyConfig_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* CoreHost::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::CoreHost>(message.name())) {
        case messages::CoreHost::kTryGetAuthTokens:
            return "Receive ip_protection::mojom::CoreHost::TryGetAuthTokens";
        case messages::CoreHost::kGetProxyConfig:
            return "Receive ip_protection::mojom::CoreHost::GetProxyConfig";
        }
    } else {
        switch (static_cast<messages::CoreHost>(message.name())) {
        case messages::CoreHost::kTryGetAuthTokens:
            return "Receive reply ip_protection::mojom::CoreHost::TryGetAuthTokens";
        case messages::CoreHost::kGetProxyConfig:
            return "Receive reply ip_protection::mojom::CoreHost::GetProxyConfig";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t CoreHost::TryGetAuthTokens_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)ip_protection::mojom::CoreHost::TryGetAuthTokens");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t CoreHost::GetProxyConfig_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)ip_protection::mojom::CoreHost::GetProxyConfig");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class CoreHost_TryGetAuthTokens_ForwardToCallback : public mojo::MessageReceiver {
public:
    CoreHost_TryGetAuthTokens_ForwardToCallback(CoreHost::TryGetAuthTokensCallback callback)
        : callback_(std::move(callback))
    {
    }

    CoreHost_TryGetAuthTokens_ForwardToCallback(const CoreHost_TryGetAuthTokens_ForwardToCallback&) = delete;
    CoreHost_TryGetAuthTokens_ForwardToCallback& operator=(const CoreHost_TryGetAuthTokens_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    CoreHost::TryGetAuthTokensCallback callback_;
};

class CoreHost_GetProxyConfig_ForwardToCallback : public mojo::MessageReceiver {
public:
    CoreHost_GetProxyConfig_ForwardToCallback(CoreHost::GetProxyConfigCallback callback)
        : callback_(std::move(callback))
    {
    }

    CoreHost_GetProxyConfig_ForwardToCallback(const CoreHost_GetProxyConfig_ForwardToCallback&) = delete;
    CoreHost_GetProxyConfig_ForwardToCallback& operator=(const CoreHost_GetProxyConfig_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    CoreHost::GetProxyConfigCallback callback_;
};

CoreHostProxy::CoreHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void CoreHostProxy::TryGetAuthTokens(uint32_t in_batch_size, ::ip_protection::mojom::blink::ProxyLayer in_proxy_layer, TryGetAuthTokensCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send ip_protection::mojom::CoreHost::TryGetAuthTokens", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("batch_size"), in_batch_size, "<value of type uint32_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("proxy_layer"), in_proxy_layer, "<value of type ::ip_protection::mojom::blink::ProxyLayer>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreHost::kTryGetAuthTokens), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreHost_TryGetAuthTokens_Params_Data> params(message);
    params.Allocate();
    params->batch_size = in_batch_size;
    mojo::internal::Serialize<::ip_protection::mojom::ProxyLayer>(in_proxy_layer, &params->proxy_layer);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreHost::Name_);
    message.set_method_name("TryGetAuthTokens");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new CoreHost_TryGetAuthTokens_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CoreHostProxy::GetProxyConfig(GetProxyConfigCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send ip_protection::mojom::CoreHost::GetProxyConfig");
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreHost::kGetProxyConfig), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreHost_GetProxyConfig_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreHost::Name_);
    message.set_method_name("GetProxyConfig");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new CoreHost_GetProxyConfig_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class CoreHost_TryGetAuthTokens_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static CoreHost::TryGetAuthTokensCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<CoreHost_TryGetAuthTokens_ProxyToResponder> proxy(new CoreHost_TryGetAuthTokens_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&CoreHost_TryGetAuthTokens_ProxyToResponder::Run, std::move(proxy));
    }

    ~CoreHost_TryGetAuthTokens_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    CoreHost_TryGetAuthTokens_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "CoreHost::TryGetAuthTokensCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(std::optional<WTF::Vector<::ip_protection::mojom::blink::BlindSignedAuthTokenPtr>> in_bsa_tokens, std::optional<::base::Time> in_try_again_after);
};

bool CoreHost_TryGetAuthTokens_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::CoreHost_TryGetAuthTokens_ResponseParams_Data* params
        = reinterpret_cast<internal::CoreHost_TryGetAuthTokens_ResponseParams_Data*>(message->mutable_payload());

    // Validation for CoreHost.0
    bool success = true;
    std::optional<WTF::Vector<::ip_protection::mojom::blink::BlindSignedAuthTokenPtr>> p_bsa_tokens {};
    std::optional<::base::Time> p_try_again_after {};
    CoreHost_TryGetAuthTokens_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadBsaTokens(&p_bsa_tokens))
        success = false;
    if (success && !input_data_view.ReadTryAgainAfter(&p_try_again_after))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreHost::Name_, 0, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_bsa_tokens), std::move(p_try_again_after));
    return true;
}

void CoreHost_TryGetAuthTokens_ProxyToResponder::Run(
    std::optional<WTF::Vector<::ip_protection::mojom::blink::BlindSignedAuthTokenPtr>> in_bsa_tokens, std::optional<::base::Time> in_try_again_after)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply ip_protection::mojom::CoreHost::TryGetAuthTokens", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("bsa_tokens"), in_bsa_tokens, "<value of type std::optional<WTF::Vector<::ip_protection::mojom::blink::BlindSignedAuthTokenPtr>>>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("try_again_after"), in_try_again_after, "<value of type std::optional<::base::Time>>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreHost::kTryGetAuthTokens), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreHost_TryGetAuthTokens_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->bsa_tokens)::BaseType> bsa_tokens_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& bsa_tokens_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<::ip_protection::mojom::BlindSignedAuthTokenDataView>>(
        in_bsa_tokens, bsa_tokens_fragment, &bsa_tokens_validate_params);
    params->bsa_tokens.Set(bsa_tokens_fragment.is_null() ? nullptr : bsa_tokens_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->try_again_after)::BaseType> try_again_after_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_try_again_after, try_again_after_fragment);
    params->try_again_after.Set(try_again_after_fragment.is_null() ? nullptr : try_again_after_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreHost::Name_);
    message.set_method_name("TryGetAuthTokens");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class CoreHost_GetProxyConfig_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static CoreHost::GetProxyConfigCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<CoreHost_GetProxyConfig_ProxyToResponder> proxy(new CoreHost_GetProxyConfig_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&CoreHost_GetProxyConfig_ProxyToResponder::Run, std::move(proxy));
    }

    ~CoreHost_GetProxyConfig_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    CoreHost_GetProxyConfig_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "CoreHost::GetProxyConfigCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(const std::optional<WTF::Vector<::net::ProxyChain>>& in_proxy_list, ::ip_protection::mojom::blink::GeoHintPtr in_geo_hint);
};

bool CoreHost_GetProxyConfig_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::CoreHost_GetProxyConfig_ResponseParams_Data* params
        = reinterpret_cast<internal::CoreHost_GetProxyConfig_ResponseParams_Data*>(message->mutable_payload());

    // Validation for CoreHost.1
    bool success = true;
    std::optional<WTF::Vector<::net::ProxyChain>> p_proxy_list {};
    ::ip_protection::mojom::blink::GeoHintPtr p_geo_hint {};
    CoreHost_GetProxyConfig_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadProxyList(&p_proxy_list))
        success = false;
    if (success && !input_data_view.ReadGeoHint(&p_geo_hint))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreHost::Name_, 1, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_proxy_list), std::move(p_geo_hint));
    return true;
}

void CoreHost_GetProxyConfig_ProxyToResponder::Run(
    const std::optional<WTF::Vector<::net::ProxyChain>>& in_proxy_list, ::ip_protection::mojom::blink::GeoHintPtr in_geo_hint)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply ip_protection::mojom::CoreHost::GetProxyConfig", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("proxy_list"), in_proxy_list, "<value of type const std::optional<WTF::Vector<::net::ProxyChain>>&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("geo_hint"), in_geo_hint, "<value of type ::ip_protection::mojom::blink::GeoHintPtr>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::CoreHost::kGetProxyConfig), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::ip_protection::mojom::internal::CoreHost_GetProxyConfig_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->proxy_list)::BaseType> proxy_list_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& proxy_list_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
    mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::ProxyChainDataView>>(in_proxy_list, proxy_list_fragment, &proxy_list_validate_params);
    params->proxy_list.Set(proxy_list_fragment.is_null() ? nullptr : proxy_list_fragment.data());
    mojo::internal::MessageFragment<typename decltype(params->geo_hint)::BaseType> geo_hint_fragment(params.message());
    mojo::internal::Serialize<::ip_protection::mojom::GeoHintDataView>(in_geo_hint, geo_hint_fragment);
    params->geo_hint.Set(geo_hint_fragment.is_null() ? nullptr : geo_hint_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(CoreHost::Name_);
    message.set_method_name("GetProxyConfig");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool CoreHostStubDispatch::Accept(CoreHost* impl, mojo::Message* message)
{
    switch (static_cast<messages::CoreHost>(message->header()->name)) {
    case messages::CoreHost::kTryGetAuthTokens: {
        break;
    }
    case messages::CoreHost::kGetProxyConfig: {
        break;
    }
    }
    return false;
}

// static
bool CoreHostStubDispatch::AcceptWithResponder(CoreHost* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::CoreHost>(message->header()->name)) {
    case messages::CoreHost::kTryGetAuthTokens: {
        internal::CoreHost_TryGetAuthTokens_Params_Data* params
            = reinterpret_cast<internal::CoreHost_TryGetAuthTokens_Params_Data*>(message->mutable_payload());

        // Validation for CoreHost.0
        bool success = true;
        uint32_t p_batch_size {};
        ::ip_protection::mojom::blink::ProxyLayer p_proxy_layer {};
        CoreHost_TryGetAuthTokens_ParamsDataView input_data_view(params, message);

        if (success)
            p_batch_size = input_data_view.batch_size();
        if (success && !input_data_view.ReadProxyLayer(&p_proxy_layer))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreHost::Name_, 0, false);
            return false;
        }
        CoreHost::TryGetAuthTokensCallback callback = CoreHost_TryGetAuthTokens_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->TryGetAuthTokens(std::move(p_batch_size), std::move(p_proxy_layer), std::move(callback));
        return true;
    }
    case messages::CoreHost::kGetProxyConfig: {
        internal::CoreHost_GetProxyConfig_Params_Data* params = reinterpret_cast<internal::CoreHost_GetProxyConfig_Params_Data*>(message->mutable_payload());

        // Validation for CoreHost.1
        bool success = true;
        CoreHost_GetProxyConfig_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, CoreHost::Name_, 1, false);
            return false;
        }
        CoreHost::GetProxyConfigCallback callback = CoreHost_GetProxyConfig_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetProxyConfig(std::move(callback));
        return true;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kCoreHostValidationInfo[] = {
    { &internal::CoreHost_TryGetAuthTokens_Params_Data::Validate, &internal::CoreHost_TryGetAuthTokens_ResponseParams_Data::Validate },
    { &internal::CoreHost_GetProxyConfig_Params_Data::Validate, &internal::CoreHost_GetProxyConfig_ResponseParams_Data::Validate },
};

bool CoreHostRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::ip_protection::mojom::blink::CoreHost::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kCoreHostValidationInfo);
}

bool CoreHostResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::ip_protection::mojom::blink::CoreHost::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kCoreHostValidationInfo);
}

} // ip_protection::mojom::blink

namespace mojo {

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace ip_protection::mojom::blink {

void CoreControlInterceptorForTesting::AuthTokensMayBeAvailable()
{
    GetForwardingInterface()->AuthTokensMayBeAvailable();
}
void CoreControlInterceptorForTesting::SetIpProtectionEnabled(bool value)
{
    GetForwardingInterface()->SetIpProtectionEnabled(std::move(value));
}
void CoreControlInterceptorForTesting::VerifyIpProtectionCoreHostForTesting(VerifyIpProtectionCoreHostForTestingCallback callback)
{
    GetForwardingInterface()->VerifyIpProtectionCoreHostForTesting(std::move(callback));
}
void CoreControlInterceptorForTesting::IsIpProtectionEnabledForTesting(IsIpProtectionEnabledForTestingCallback callback)
{
    GetForwardingInterface()->IsIpProtectionEnabledForTesting(std::move(callback));
}
CoreControlAsyncWaiter::CoreControlAsyncWaiter(CoreControl* proxy)
    : proxy_(proxy)
{
}

CoreControlAsyncWaiter::~CoreControlAsyncWaiter() = default;

void CoreControlAsyncWaiter::VerifyIpProtectionCoreHostForTesting(
    ::ip_protection::mojom::blink::BlindSignedAuthTokenPtr* out_bsa_token, std::optional<::base::Time>* out_try_again_after)
{
    base::RunLoop loop;
    proxy_->VerifyIpProtectionCoreHostForTesting(base::BindOnce(
        [](base::RunLoop* loop, ::ip_protection::mojom::blink::BlindSignedAuthTokenPtr* out_bsa_token, std::optional<::base::Time>* out_try_again_after,
            ::ip_protection::mojom::blink::BlindSignedAuthTokenPtr bsa_token, std::optional<::base::Time> try_again_after) {
            *out_bsa_token = std::move(bsa_token);
            *out_try_again_after = std::move(try_again_after);
            loop->Quit();
        },
        &loop, out_bsa_token, out_try_again_after));
    loop.Run();
}

void CoreControlAsyncWaiter::IsIpProtectionEnabledForTesting(bool* out_value)
{
    base::RunLoop loop;
    proxy_->IsIpProtectionEnabledForTesting(base::BindOnce(
        [](base::RunLoop* loop, bool* out_value, bool value) {
            *out_value = std::move(value);
            loop->Quit();
        },
        &loop, out_value));
    loop.Run();
}

bool CoreControlAsyncWaiter::IsIpProtectionEnabledForTesting()
{
    bool async_wait_result;
    IsIpProtectionEnabledForTesting(&async_wait_result);
    return async_wait_result;
}

void CoreHostInterceptorForTesting::TryGetAuthTokens(
    uint32_t batch_size, ::ip_protection::mojom::blink::ProxyLayer proxy_layer, TryGetAuthTokensCallback callback)
{
    GetForwardingInterface()->TryGetAuthTokens(std::move(batch_size), std::move(proxy_layer), std::move(callback));
}
void CoreHostInterceptorForTesting::GetProxyConfig(GetProxyConfigCallback callback)
{
    GetForwardingInterface()->GetProxyConfig(std::move(callback));
}
CoreHostAsyncWaiter::CoreHostAsyncWaiter(CoreHost* proxy)
    : proxy_(proxy)
{
}

CoreHostAsyncWaiter::~CoreHostAsyncWaiter() = default;

void CoreHostAsyncWaiter::TryGetAuthTokens(uint32_t batch_size, ::ip_protection::mojom::blink::ProxyLayer proxy_layer,
    std::optional<WTF::Vector<::ip_protection::mojom::blink::BlindSignedAuthTokenPtr>>* out_bsa_tokens, std::optional<::base::Time>* out_try_again_after)
{
    base::RunLoop loop;
    proxy_->TryGetAuthTokens(std::move(batch_size), std::move(proxy_layer),
        base::BindOnce(
            [](base::RunLoop* loop, std::optional<WTF::Vector<::ip_protection::mojom::blink::BlindSignedAuthTokenPtr>>* out_bsa_tokens,
                std::optional<::base::Time>* out_try_again_after, std::optional<WTF::Vector<::ip_protection::mojom::blink::BlindSignedAuthTokenPtr>> bsa_tokens,
                std::optional<::base::Time> try_again_after) {
                *out_bsa_tokens = std::move(bsa_tokens);
                *out_try_again_after = std::move(try_again_after);
                loop->Quit();
            },
            &loop, out_bsa_tokens, out_try_again_after));
    loop.Run();
}

void CoreHostAsyncWaiter::GetProxyConfig(std::optional<WTF::Vector<::net::ProxyChain>>* out_proxy_list, ::ip_protection::mojom::blink::GeoHintPtr* out_geo_hint)
{
    base::RunLoop loop;
    proxy_->GetProxyConfig(base::BindOnce(
        [](base::RunLoop* loop, std::optional<WTF::Vector<::net::ProxyChain>>* out_proxy_list, ::ip_protection::mojom::blink::GeoHintPtr* out_geo_hint,
            const std::optional<WTF::Vector<::net::ProxyChain>>& proxy_list, ::ip_protection::mojom::blink::GeoHintPtr geo_hint) {
            *out_proxy_list = std::move(proxy_list);
            *out_geo_hint = std::move(geo_hint);
            loop->Quit();
        },
        &loop, out_proxy_list, out_geo_hint));
    loop.Run();
}

} // ip_protection::mojom::blink

#if defined(__clang__)
#pragma clang diagnostic pop
#endif