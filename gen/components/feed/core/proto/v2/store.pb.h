// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/feed/core/proto/v2/store.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/feed/core/proto/v2/wire/content_id.pb.h"
#include "components/feed/core/proto/v2/wire/feed_action.pb.h"
#include "components/feed/core/proto/v2/wire/stream_structure.pb.h"
#include "components/feed/core/proto/v2/wire/web_feed_matcher.pb.h"
#include "components/feed/core/proto/v2/wire/web_feeds.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto {
    static const uint32_t offsets[];
};
namespace feedstore {
class Content;
struct ContentDefaultTypeInternal;
extern ContentDefaultTypeInternal _Content_default_instance_;
class ContentInfo;
struct ContentInfoDefaultTypeInternal;
extern ContentInfoDefaultTypeInternal _ContentInfo_default_instance_;
class DataOperation;
struct DataOperationDefaultTypeInternal;
extern DataOperationDefaultTypeInternal _DataOperation_default_instance_;
class DocView;
struct DocViewDefaultTypeInternal;
extern DocViewDefaultTypeInternal _DocView_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Metadata_SessionID;
struct Metadata_SessionIDDefaultTypeInternal;
extern Metadata_SessionIDDefaultTypeInternal _Metadata_SessionID_default_instance_;
class Metadata_StreamMetadata;
struct Metadata_StreamMetadataDefaultTypeInternal;
extern Metadata_StreamMetadataDefaultTypeInternal _Metadata_StreamMetadata_default_instance_;
class Metadata_StreamMetadata_ContentLifetime;
struct Metadata_StreamMetadata_ContentLifetimeDefaultTypeInternal;
extern Metadata_StreamMetadata_ContentLifetimeDefaultTypeInternal _Metadata_StreamMetadata_ContentLifetime_default_instance_;
class PendingWebFeedOperation;
struct PendingWebFeedOperationDefaultTypeInternal;
extern PendingWebFeedOperationDefaultTypeInternal _PendingWebFeedOperation_default_instance_;
class RecommendedWebFeedIndex;
struct RecommendedWebFeedIndexDefaultTypeInternal;
extern RecommendedWebFeedIndexDefaultTypeInternal _RecommendedWebFeedIndex_default_instance_;
class RecommendedWebFeedIndex_Entry;
struct RecommendedWebFeedIndex_EntryDefaultTypeInternal;
extern RecommendedWebFeedIndex_EntryDefaultTypeInternal _RecommendedWebFeedIndex_Entry_default_instance_;
class Record;
struct RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class StoredAction;
struct StoredActionDefaultTypeInternal;
extern StoredActionDefaultTypeInternal _StoredAction_default_instance_;
class StreamContentHashList;
struct StreamContentHashListDefaultTypeInternal;
extern StreamContentHashListDefaultTypeInternal _StreamContentHashList_default_instance_;
class StreamData;
struct StreamDataDefaultTypeInternal;
extern StreamDataDefaultTypeInternal _StreamData_default_instance_;
class StreamSharedState;
struct StreamSharedStateDefaultTypeInternal;
extern StreamSharedStateDefaultTypeInternal _StreamSharedState_default_instance_;
class StreamStructure;
struct StreamStructureDefaultTypeInternal;
extern StreamStructureDefaultTypeInternal _StreamStructure_default_instance_;
class StreamStructureSet;
struct StreamStructureSetDefaultTypeInternal;
extern StreamStructureSetDefaultTypeInternal _StreamStructureSet_default_instance_;
class SubscribedWebFeeds;
struct SubscribedWebFeedsDefaultTypeInternal;
extern SubscribedWebFeedsDefaultTypeInternal _SubscribedWebFeeds_default_instance_;
class WebFeedInfo;
struct WebFeedInfoDefaultTypeInternal;
extern WebFeedInfoDefaultTypeInternal _WebFeedInfo_default_instance_;
} // namespace feedstore
PROTOBUF_NAMESPACE_OPEN
template <>::feedstore::Content* Arena::CreateMaybeMessage<::feedstore::Content>(Arena*);
template <>::feedstore::ContentInfo* Arena::CreateMaybeMessage<::feedstore::ContentInfo>(Arena*);
template <>::feedstore::DataOperation* Arena::CreateMaybeMessage<::feedstore::DataOperation>(Arena*);
template <>::feedstore::DocView* Arena::CreateMaybeMessage<::feedstore::DocView>(Arena*);
template <>::feedstore::Image* Arena::CreateMaybeMessage<::feedstore::Image>(Arena*);
template <>::feedstore::Metadata* Arena::CreateMaybeMessage<::feedstore::Metadata>(Arena*);
template <>::feedstore::Metadata_SessionID* Arena::CreateMaybeMessage<::feedstore::Metadata_SessionID>(Arena*);
template <>::feedstore::Metadata_StreamMetadata* Arena::CreateMaybeMessage<::feedstore::Metadata_StreamMetadata>(Arena*);
template <>::feedstore::Metadata_StreamMetadata_ContentLifetime* Arena::CreateMaybeMessage<::feedstore::Metadata_StreamMetadata_ContentLifetime>(Arena*);
template <>::feedstore::PendingWebFeedOperation* Arena::CreateMaybeMessage<::feedstore::PendingWebFeedOperation>(Arena*);
template <>::feedstore::RecommendedWebFeedIndex* Arena::CreateMaybeMessage<::feedstore::RecommendedWebFeedIndex>(Arena*);
template <>::feedstore::RecommendedWebFeedIndex_Entry* Arena::CreateMaybeMessage<::feedstore::RecommendedWebFeedIndex_Entry>(Arena*);
template <>::feedstore::Record* Arena::CreateMaybeMessage<::feedstore::Record>(Arena*);
template <>::feedstore::StoredAction* Arena::CreateMaybeMessage<::feedstore::StoredAction>(Arena*);
template <>::feedstore::StreamContentHashList* Arena::CreateMaybeMessage<::feedstore::StreamContentHashList>(Arena*);
template <>::feedstore::StreamData* Arena::CreateMaybeMessage<::feedstore::StreamData>(Arena*);
template <>::feedstore::StreamSharedState* Arena::CreateMaybeMessage<::feedstore::StreamSharedState>(Arena*);
template <>::feedstore::StreamStructure* Arena::CreateMaybeMessage<::feedstore::StreamStructure>(Arena*);
template <>::feedstore::StreamStructureSet* Arena::CreateMaybeMessage<::feedstore::StreamStructureSet>(Arena*);
template <>::feedstore::SubscribedWebFeeds* Arena::CreateMaybeMessage<::feedstore::SubscribedWebFeeds>(Arena*);
template <>::feedstore::WebFeedInfo* Arena::CreateMaybeMessage<::feedstore::WebFeedInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace feedstore {

enum StreamStructure_Operation : int {
    StreamStructure_Operation_UNKNOWN = 0,
    StreamStructure_Operation_CLEAR_ALL = 1,
    StreamStructure_Operation_UPDATE_OR_APPEND = 2,
    StreamStructure_Operation_REMOVE = 3,
    StreamStructure_Operation_StreamStructure_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    StreamStructure_Operation_StreamStructure_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StreamStructure_Operation_IsValid(int value);
constexpr StreamStructure_Operation StreamStructure_Operation_Operation_MIN = StreamStructure_Operation_UNKNOWN;
constexpr StreamStructure_Operation StreamStructure_Operation_Operation_MAX = StreamStructure_Operation_REMOVE;
constexpr int StreamStructure_Operation_Operation_ARRAYSIZE = StreamStructure_Operation_Operation_MAX + 1;

const std::string& StreamStructure_Operation_Name(StreamStructure_Operation value);
template <typename T> inline const std::string& StreamStructure_Operation_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, StreamStructure_Operation>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function StreamStructure_Operation_Name.");
    return StreamStructure_Operation_Name(static_cast<StreamStructure_Operation>(enum_t_value));
}
bool StreamStructure_Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamStructure_Operation* value);
enum StreamStructure_Type : int {
    StreamStructure_Type_UNKNOWN_TYPE = 0,
    StreamStructure_Type_STREAM = 1,
    StreamStructure_Type_CARD = 2,
    StreamStructure_Type_CONTENT = 3,
    StreamStructure_Type_GROUP = 4,
    StreamStructure_Type_StreamStructure_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    StreamStructure_Type_StreamStructure_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StreamStructure_Type_IsValid(int value);
constexpr StreamStructure_Type StreamStructure_Type_Type_MIN = StreamStructure_Type_UNKNOWN_TYPE;
constexpr StreamStructure_Type StreamStructure_Type_Type_MAX = StreamStructure_Type_GROUP;
constexpr int StreamStructure_Type_Type_ARRAYSIZE = StreamStructure_Type_Type_MAX + 1;

const std::string& StreamStructure_Type_Name(StreamStructure_Type value);
template <typename T> inline const std::string& StreamStructure_Type_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, StreamStructure_Type>::value || ::std::is_integral<T>::value, "Incorrect type passed to function StreamStructure_Type_Name.");
    return StreamStructure_Type_Name(static_cast<StreamStructure_Type>(enum_t_value));
}
bool StreamStructure_Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamStructure_Type* value);
enum WebFeedInfo_State : int {
    WebFeedInfo_State_STATE_UNSPECIFIED = 0,
    WebFeedInfo_State_INACTIVE = 1,
    WebFeedInfo_State_ACTIVE = 2,
    WebFeedInfo_State_WAITING_FOR_CONTENT = 4,
    WebFeedInfo_State_WebFeedInfo_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    WebFeedInfo_State_WebFeedInfo_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WebFeedInfo_State_IsValid(int value);
constexpr WebFeedInfo_State WebFeedInfo_State_State_MIN = WebFeedInfo_State_STATE_UNSPECIFIED;
constexpr WebFeedInfo_State WebFeedInfo_State_State_MAX = WebFeedInfo_State_WAITING_FOR_CONTENT;
constexpr int WebFeedInfo_State_State_ARRAYSIZE = WebFeedInfo_State_State_MAX + 1;

const std::string& WebFeedInfo_State_Name(WebFeedInfo_State value);
template <typename T> inline const std::string& WebFeedInfo_State_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, WebFeedInfo_State>::value || ::std::is_integral<T>::value, "Incorrect type passed to function WebFeedInfo_State_Name.");
    return WebFeedInfo_State_Name(static_cast<WebFeedInfo_State>(enum_t_value));
}
bool WebFeedInfo_State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebFeedInfo_State* value);
enum PendingWebFeedOperation_Kind : int {
    PendingWebFeedOperation_Kind_KIND_UNSPECIFIED = 0,
    PendingWebFeedOperation_Kind_SUBSCRIBE = 1,
    PendingWebFeedOperation_Kind_UNSUBSCRIBE = 2,
    PendingWebFeedOperation_Kind_PendingWebFeedOperation_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    PendingWebFeedOperation_Kind_PendingWebFeedOperation_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PendingWebFeedOperation_Kind_IsValid(int value);
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation_Kind_Kind_MIN = PendingWebFeedOperation_Kind_KIND_UNSPECIFIED;
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation_Kind_Kind_MAX = PendingWebFeedOperation_Kind_UNSUBSCRIBE;
constexpr int PendingWebFeedOperation_Kind_Kind_ARRAYSIZE = PendingWebFeedOperation_Kind_Kind_MAX + 1;

const std::string& PendingWebFeedOperation_Kind_Name(PendingWebFeedOperation_Kind value);
template <typename T> inline const std::string& PendingWebFeedOperation_Kind_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, PendingWebFeedOperation_Kind>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function PendingWebFeedOperation_Kind_Name.");
    return PendingWebFeedOperation_Kind_Name(static_cast<PendingWebFeedOperation_Kind>(enum_t_value));
}
bool PendingWebFeedOperation_Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PendingWebFeedOperation_Kind* value);
// ===================================================================

class Record final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Record) */ {
public:
    inline Record()
        : Record(nullptr)
    {
    }
    ~Record() override;
    explicit PROTOBUF_CONSTEXPR Record(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Record(const Record& from);
    Record(Record&& from) noexcept
        : Record()
    {
        *this = ::std::move(from);
    }

    inline Record& operator=(const Record& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Record& operator=(Record&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Record& default_instance()
    {
        return *internal_default_instance();
    }
    enum DataCase {
        kStreamData = 1,
        kStreamStructures = 2,
        kContent = 3,
        kLocalAction = 4,
        kSharedState = 5,
        kMetadata = 6,
        kSubscribedWebFeeds = 7,
        kRecommendedWebFeed = 8,
        kRecommendedWebFeedIndex = 9,
        kPendingWebFeedOperation = 10,
        kDocView = 11,
        DATA_NOT_SET = 0,
    };

    static inline const Record* internal_default_instance()
    {
        return reinterpret_cast<const Record*>(&_Record_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(Record& a, Record& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Record* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Record* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Record>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Record& from);
    void MergeFrom(const Record& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Record* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.Record";
    }

protected:
    explicit Record(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStreamDataFieldNumber = 1,
        kStreamStructuresFieldNumber = 2,
        kContentFieldNumber = 3,
        kLocalActionFieldNumber = 4,
        kSharedStateFieldNumber = 5,
        kMetadataFieldNumber = 6,
        kSubscribedWebFeedsFieldNumber = 7,
        kRecommendedWebFeedFieldNumber = 8,
        kRecommendedWebFeedIndexFieldNumber = 9,
        kPendingWebFeedOperationFieldNumber = 10,
        kDocViewFieldNumber = 11,
    };
    // .feedstore.StreamData stream_data = 1;
    bool has_stream_data() const;

private:
    bool _internal_has_stream_data() const;

public:
    void clear_stream_data();
    const ::feedstore::StreamData& stream_data() const;
    PROTOBUF_NODISCARD ::feedstore::StreamData* release_stream_data();
    ::feedstore::StreamData* mutable_stream_data();
    void set_allocated_stream_data(::feedstore::StreamData* stream_data);

private:
    const ::feedstore::StreamData& _internal_stream_data() const;
    ::feedstore::StreamData* _internal_mutable_stream_data();

public:
    void unsafe_arena_set_allocated_stream_data(::feedstore::StreamData* stream_data);
    ::feedstore::StreamData* unsafe_arena_release_stream_data();

    // .feedstore.StreamStructureSet stream_structures = 2;
    bool has_stream_structures() const;

private:
    bool _internal_has_stream_structures() const;

public:
    void clear_stream_structures();
    const ::feedstore::StreamStructureSet& stream_structures() const;
    PROTOBUF_NODISCARD ::feedstore::StreamStructureSet* release_stream_structures();
    ::feedstore::StreamStructureSet* mutable_stream_structures();
    void set_allocated_stream_structures(::feedstore::StreamStructureSet* stream_structures);

private:
    const ::feedstore::StreamStructureSet& _internal_stream_structures() const;
    ::feedstore::StreamStructureSet* _internal_mutable_stream_structures();

public:
    void unsafe_arena_set_allocated_stream_structures(::feedstore::StreamStructureSet* stream_structures);
    ::feedstore::StreamStructureSet* unsafe_arena_release_stream_structures();

    // .feedstore.Content content = 3;
    bool has_content() const;

private:
    bool _internal_has_content() const;

public:
    void clear_content();
    const ::feedstore::Content& content() const;
    PROTOBUF_NODISCARD ::feedstore::Content* release_content();
    ::feedstore::Content* mutable_content();
    void set_allocated_content(::feedstore::Content* content);

private:
    const ::feedstore::Content& _internal_content() const;
    ::feedstore::Content* _internal_mutable_content();

public:
    void unsafe_arena_set_allocated_content(::feedstore::Content* content);
    ::feedstore::Content* unsafe_arena_release_content();

    // .feedstore.StoredAction local_action = 4;
    bool has_local_action() const;

private:
    bool _internal_has_local_action() const;

public:
    void clear_local_action();
    const ::feedstore::StoredAction& local_action() const;
    PROTOBUF_NODISCARD ::feedstore::StoredAction* release_local_action();
    ::feedstore::StoredAction* mutable_local_action();
    void set_allocated_local_action(::feedstore::StoredAction* local_action);

private:
    const ::feedstore::StoredAction& _internal_local_action() const;
    ::feedstore::StoredAction* _internal_mutable_local_action();

public:
    void unsafe_arena_set_allocated_local_action(::feedstore::StoredAction* local_action);
    ::feedstore::StoredAction* unsafe_arena_release_local_action();

    // .feedstore.StreamSharedState shared_state = 5;
    bool has_shared_state() const;

private:
    bool _internal_has_shared_state() const;

public:
    void clear_shared_state();
    const ::feedstore::StreamSharedState& shared_state() const;
    PROTOBUF_NODISCARD ::feedstore::StreamSharedState* release_shared_state();
    ::feedstore::StreamSharedState* mutable_shared_state();
    void set_allocated_shared_state(::feedstore::StreamSharedState* shared_state);

private:
    const ::feedstore::StreamSharedState& _internal_shared_state() const;
    ::feedstore::StreamSharedState* _internal_mutable_shared_state();

public:
    void unsafe_arena_set_allocated_shared_state(::feedstore::StreamSharedState* shared_state);
    ::feedstore::StreamSharedState* unsafe_arena_release_shared_state();

    // .feedstore.Metadata metadata = 6;
    bool has_metadata() const;

private:
    bool _internal_has_metadata() const;

public:
    void clear_metadata();
    const ::feedstore::Metadata& metadata() const;
    PROTOBUF_NODISCARD ::feedstore::Metadata* release_metadata();
    ::feedstore::Metadata* mutable_metadata();
    void set_allocated_metadata(::feedstore::Metadata* metadata);

private:
    const ::feedstore::Metadata& _internal_metadata() const;
    ::feedstore::Metadata* _internal_mutable_metadata();

public:
    void unsafe_arena_set_allocated_metadata(::feedstore::Metadata* metadata);
    ::feedstore::Metadata* unsafe_arena_release_metadata();

    // .feedstore.SubscribedWebFeeds subscribed_web_feeds = 7;
    bool has_subscribed_web_feeds() const;

private:
    bool _internal_has_subscribed_web_feeds() const;

public:
    void clear_subscribed_web_feeds();
    const ::feedstore::SubscribedWebFeeds& subscribed_web_feeds() const;
    PROTOBUF_NODISCARD ::feedstore::SubscribedWebFeeds* release_subscribed_web_feeds();
    ::feedstore::SubscribedWebFeeds* mutable_subscribed_web_feeds();
    void set_allocated_subscribed_web_feeds(::feedstore::SubscribedWebFeeds* subscribed_web_feeds);

private:
    const ::feedstore::SubscribedWebFeeds& _internal_subscribed_web_feeds() const;
    ::feedstore::SubscribedWebFeeds* _internal_mutable_subscribed_web_feeds();

public:
    void unsafe_arena_set_allocated_subscribed_web_feeds(::feedstore::SubscribedWebFeeds* subscribed_web_feeds);
    ::feedstore::SubscribedWebFeeds* unsafe_arena_release_subscribed_web_feeds();

    // .feedstore.WebFeedInfo recommended_web_feed = 8;
    bool has_recommended_web_feed() const;

private:
    bool _internal_has_recommended_web_feed() const;

public:
    void clear_recommended_web_feed();
    const ::feedstore::WebFeedInfo& recommended_web_feed() const;
    PROTOBUF_NODISCARD ::feedstore::WebFeedInfo* release_recommended_web_feed();
    ::feedstore::WebFeedInfo* mutable_recommended_web_feed();
    void set_allocated_recommended_web_feed(::feedstore::WebFeedInfo* recommended_web_feed);

private:
    const ::feedstore::WebFeedInfo& _internal_recommended_web_feed() const;
    ::feedstore::WebFeedInfo* _internal_mutable_recommended_web_feed();

public:
    void unsafe_arena_set_allocated_recommended_web_feed(::feedstore::WebFeedInfo* recommended_web_feed);
    ::feedstore::WebFeedInfo* unsafe_arena_release_recommended_web_feed();

    // .feedstore.RecommendedWebFeedIndex recommended_web_feed_index = 9;
    bool has_recommended_web_feed_index() const;

private:
    bool _internal_has_recommended_web_feed_index() const;

public:
    void clear_recommended_web_feed_index();
    const ::feedstore::RecommendedWebFeedIndex& recommended_web_feed_index() const;
    PROTOBUF_NODISCARD ::feedstore::RecommendedWebFeedIndex* release_recommended_web_feed_index();
    ::feedstore::RecommendedWebFeedIndex* mutable_recommended_web_feed_index();
    void set_allocated_recommended_web_feed_index(::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index);

private:
    const ::feedstore::RecommendedWebFeedIndex& _internal_recommended_web_feed_index() const;
    ::feedstore::RecommendedWebFeedIndex* _internal_mutable_recommended_web_feed_index();

public:
    void unsafe_arena_set_allocated_recommended_web_feed_index(::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index);
    ::feedstore::RecommendedWebFeedIndex* unsafe_arena_release_recommended_web_feed_index();

    // .feedstore.PendingWebFeedOperation pending_web_feed_operation = 10;
    bool has_pending_web_feed_operation() const;

private:
    bool _internal_has_pending_web_feed_operation() const;

public:
    void clear_pending_web_feed_operation();
    const ::feedstore::PendingWebFeedOperation& pending_web_feed_operation() const;
    PROTOBUF_NODISCARD ::feedstore::PendingWebFeedOperation* release_pending_web_feed_operation();
    ::feedstore::PendingWebFeedOperation* mutable_pending_web_feed_operation();
    void set_allocated_pending_web_feed_operation(::feedstore::PendingWebFeedOperation* pending_web_feed_operation);

private:
    const ::feedstore::PendingWebFeedOperation& _internal_pending_web_feed_operation() const;
    ::feedstore::PendingWebFeedOperation* _internal_mutable_pending_web_feed_operation();

public:
    void unsafe_arena_set_allocated_pending_web_feed_operation(::feedstore::PendingWebFeedOperation* pending_web_feed_operation);
    ::feedstore::PendingWebFeedOperation* unsafe_arena_release_pending_web_feed_operation();

    // .feedstore.DocView doc_view = 11;
    bool has_doc_view() const;

private:
    bool _internal_has_doc_view() const;

public:
    void clear_doc_view();
    const ::feedstore::DocView& doc_view() const;
    PROTOBUF_NODISCARD ::feedstore::DocView* release_doc_view();
    ::feedstore::DocView* mutable_doc_view();
    void set_allocated_doc_view(::feedstore::DocView* doc_view);

private:
    const ::feedstore::DocView& _internal_doc_view() const;
    ::feedstore::DocView* _internal_mutable_doc_view();

public:
    void unsafe_arena_set_allocated_doc_view(::feedstore::DocView* doc_view);
    ::feedstore::DocView* unsafe_arena_release_doc_view();

    void clear_data();
    DataCase data_case() const;
    // @@protoc_insertion_point(class_scope:feedstore.Record)
private:
    class _Internal;
    void set_has_stream_data();
    void set_has_stream_structures();
    void set_has_content();
    void set_has_local_action();
    void set_has_shared_state();
    void set_has_metadata();
    void set_has_subscribed_web_feeds();
    void set_has_recommended_web_feed();
    void set_has_recommended_web_feed_index();
    void set_has_pending_web_feed_operation();
    void set_has_doc_view();

    inline bool has_data() const;
    inline void clear_has_data();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        union DataUnion {
            constexpr DataUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::feedstore::StreamData* stream_data_;
            ::feedstore::StreamStructureSet* stream_structures_;
            ::feedstore::Content* content_;
            ::feedstore::StoredAction* local_action_;
            ::feedstore::StreamSharedState* shared_state_;
            ::feedstore::Metadata* metadata_;
            ::feedstore::SubscribedWebFeeds* subscribed_web_feeds_;
            ::feedstore::WebFeedInfo* recommended_web_feed_;
            ::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index_;
            ::feedstore::PendingWebFeedOperation* pending_web_feed_operation_;
            ::feedstore::DocView* doc_view_;
        } data_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamContentHashList final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamContentHashList) */ {
public:
    inline StreamContentHashList()
        : StreamContentHashList(nullptr)
    {
    }
    ~StreamContentHashList() override;
    explicit PROTOBUF_CONSTEXPR StreamContentHashList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StreamContentHashList(const StreamContentHashList& from);
    StreamContentHashList(StreamContentHashList&& from) noexcept
        : StreamContentHashList()
    {
        *this = ::std::move(from);
    }

    inline StreamContentHashList& operator=(const StreamContentHashList& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StreamContentHashList& operator=(StreamContentHashList&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StreamContentHashList& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StreamContentHashList* internal_default_instance()
    {
        return reinterpret_cast<const StreamContentHashList*>(&_StreamContentHashList_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(StreamContentHashList& a, StreamContentHashList& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StreamContentHashList* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StreamContentHashList* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StreamContentHashList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StreamContentHashList>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StreamContentHashList& from);
    void MergeFrom(const StreamContentHashList& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StreamContentHashList* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.StreamContentHashList";
    }

protected:
    explicit StreamContentHashList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kHashesFieldNumber = 1,
    };
    // repeated uint32 hashes = 1;
    int hashes_size() const;

private:
    int _internal_hashes_size() const;

public:
    void clear_hashes();

private:
    uint32_t _internal_hashes(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& _internal_hashes() const;
    void _internal_add_hashes(uint32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* _internal_mutable_hashes();

public:
    uint32_t hashes(int index) const;
    void set_hashes(int index, uint32_t value);
    void add_hashes(uint32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& hashes() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* mutable_hashes();

    // @@protoc_insertion_point(class_scope:feedstore.StreamContentHashList)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t> hashes_;
        mutable std::atomic<int> _hashes_cached_byte_size_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamData final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamData) */ {
public:
    inline StreamData()
        : StreamData(nullptr)
    {
    }
    ~StreamData() override;
    explicit PROTOBUF_CONSTEXPR StreamData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StreamData(const StreamData& from);
    StreamData(StreamData&& from) noexcept
        : StreamData()
    {
        *this = ::std::move(from);
    }

    inline StreamData& operator=(const StreamData& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StreamData& operator=(StreamData&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StreamData& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StreamData* internal_default_instance()
    {
        return reinterpret_cast<const StreamData*>(&_StreamData_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(StreamData& a, StreamData& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StreamData* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StreamData* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StreamData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StreamData>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StreamData& from);
    void MergeFrom(const StreamData& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StreamData* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.StreamData";
    }

protected:
    explicit StreamData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSharedStateIdsFieldNumber = 6,
        kContentHashesFieldNumber = 11,
        kNextPageTokenFieldNumber = 2,
        kStreamKeyFieldNumber = 10,
        kRootEventIdFieldNumber = 12,
        kGaiaFieldNumber = 13,
        kEmailFieldNumber = 14,
        kContentIdFieldNumber = 1,
        kLastAddedTimeMillisFieldNumber = 4,
        kSignedInFieldNumber = 7,
        kLoggingEnabledFieldNumber = 8,
        kPrivacyNoticeFulfilledFieldNumber = 9,
    };
    // repeated .feedwire.ContentId shared_state_ids = 6;
    int shared_state_ids_size() const;

private:
    int _internal_shared_state_ids_size() const;

public:
    void clear_shared_state_ids();
    ::feedwire::ContentId* mutable_shared_state_ids(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::ContentId>* mutable_shared_state_ids();

private:
    const ::feedwire::ContentId& _internal_shared_state_ids(int index) const;
    ::feedwire::ContentId* _internal_add_shared_state_ids();

public:
    const ::feedwire::ContentId& shared_state_ids(int index) const;
    ::feedwire::ContentId* add_shared_state_ids();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::ContentId>& shared_state_ids() const;

    // repeated .feedstore.StreamContentHashList content_hashes = 11;
    int content_hashes_size() const;

private:
    int _internal_content_hashes_size() const;

public:
    void clear_content_hashes();
    ::feedstore::StreamContentHashList* mutable_content_hashes(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList>* mutable_content_hashes();

private:
    const ::feedstore::StreamContentHashList& _internal_content_hashes(int index) const;
    ::feedstore::StreamContentHashList* _internal_add_content_hashes();

public:
    const ::feedstore::StreamContentHashList& content_hashes(int index) const;
    ::feedstore::StreamContentHashList* add_content_hashes();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList>& content_hashes() const;

    // bytes next_page_token = 2;
    void clear_next_page_token();
    const std::string& next_page_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_next_page_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_next_page_token();
    PROTOBUF_NODISCARD std::string* release_next_page_token();
    void set_allocated_next_page_token(std::string* next_page_token);

private:
    const std::string& _internal_next_page_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
    std::string* _internal_mutable_next_page_token();

public:
    // string stream_key = 10;
    void clear_stream_key();
    const std::string& stream_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_stream_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_stream_key();
    PROTOBUF_NODISCARD std::string* release_stream_key();
    void set_allocated_stream_key(std::string* stream_key);

private:
    const std::string& _internal_stream_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_key(const std::string& value);
    std::string* _internal_mutable_stream_key();

public:
    // bytes root_event_id = 12;
    void clear_root_event_id();
    const std::string& root_event_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_root_event_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_root_event_id();
    PROTOBUF_NODISCARD std::string* release_root_event_id();
    void set_allocated_root_event_id(std::string* root_event_id);

private:
    const std::string& _internal_root_event_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_root_event_id(const std::string& value);
    std::string* _internal_mutable_root_event_id();

public:
    // string gaia = 13;
    void clear_gaia();
    const std::string& gaia() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_gaia(ArgT0&& arg0, ArgT... args);
    std::string* mutable_gaia();
    PROTOBUF_NODISCARD std::string* release_gaia();
    void set_allocated_gaia(std::string* gaia);

private:
    const std::string& _internal_gaia() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_gaia(const std::string& value);
    std::string* _internal_mutable_gaia();

public:
    // string email = 14;
    void clear_email();
    const std::string& email() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_email(ArgT0&& arg0, ArgT... args);
    std::string* mutable_email();
    PROTOBUF_NODISCARD std::string* release_email();
    void set_allocated_email(std::string* email);

private:
    const std::string& _internal_email() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
    std::string* _internal_mutable_email();

public:
    // .feedwire.ContentId content_id = 1;
    bool has_content_id() const;

private:
    bool _internal_has_content_id() const;

public:
    void clear_content_id();
    const ::feedwire::ContentId& content_id() const;
    PROTOBUF_NODISCARD ::feedwire::ContentId* release_content_id();
    ::feedwire::ContentId* mutable_content_id();
    void set_allocated_content_id(::feedwire::ContentId* content_id);

private:
    const ::feedwire::ContentId& _internal_content_id() const;
    ::feedwire::ContentId* _internal_mutable_content_id();

public:
    void unsafe_arena_set_allocated_content_id(::feedwire::ContentId* content_id);
    ::feedwire::ContentId* unsafe_arena_release_content_id();

    // int64 last_added_time_millis = 4;
    void clear_last_added_time_millis();
    int64_t last_added_time_millis() const;
    void set_last_added_time_millis(int64_t value);

private:
    int64_t _internal_last_added_time_millis() const;
    void _internal_set_last_added_time_millis(int64_t value);

public:
    // bool signed_in = 7;
    void clear_signed_in();
    bool signed_in() const;
    void set_signed_in(bool value);

private:
    bool _internal_signed_in() const;
    void _internal_set_signed_in(bool value);

public:
    // bool logging_enabled = 8;
    void clear_logging_enabled();
    bool logging_enabled() const;
    void set_logging_enabled(bool value);

private:
    bool _internal_logging_enabled() const;
    void _internal_set_logging_enabled(bool value);

public:
    // bool privacy_notice_fulfilled = 9;
    void clear_privacy_notice_fulfilled();
    bool privacy_notice_fulfilled() const;
    void set_privacy_notice_fulfilled(bool value);

private:
    bool _internal_privacy_notice_fulfilled() const;
    void _internal_set_privacy_notice_fulfilled(bool value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.StreamData)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::ContentId> shared_state_ids_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList> content_hashes_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_event_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gaia_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
        ::feedwire::ContentId* content_id_;
        int64_t last_added_time_millis_;
        bool signed_in_;
        bool logging_enabled_;
        bool privacy_notice_fulfilled_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Metadata_SessionID final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Metadata.SessionID) */ {
public:
    inline Metadata_SessionID()
        : Metadata_SessionID(nullptr)
    {
    }
    ~Metadata_SessionID() override;
    explicit PROTOBUF_CONSTEXPR Metadata_SessionID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Metadata_SessionID(const Metadata_SessionID& from);
    Metadata_SessionID(Metadata_SessionID&& from) noexcept
        : Metadata_SessionID()
    {
        *this = ::std::move(from);
    }

    inline Metadata_SessionID& operator=(const Metadata_SessionID& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Metadata_SessionID& operator=(Metadata_SessionID&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Metadata_SessionID& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Metadata_SessionID* internal_default_instance()
    {
        return reinterpret_cast<const Metadata_SessionID*>(&_Metadata_SessionID_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(Metadata_SessionID& a, Metadata_SessionID& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Metadata_SessionID* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Metadata_SessionID* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Metadata_SessionID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Metadata_SessionID>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Metadata_SessionID& from);
    void MergeFrom(const Metadata_SessionID& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Metadata_SessionID* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.Metadata.SessionID";
    }

protected:
    explicit Metadata_SessionID(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTokenFieldNumber = 1,
        kExpiryTimeMsFieldNumber = 2,
    };
    // string token = 1;
    void clear_token();
    const std::string& token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_token();
    PROTOBUF_NODISCARD std::string* release_token();
    void set_allocated_token(std::string* token);

private:
    const std::string& _internal_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
    std::string* _internal_mutable_token();

public:
    // int64 expiry_time_ms = 2;
    void clear_expiry_time_ms();
    int64_t expiry_time_ms() const;
    void set_expiry_time_ms(int64_t value);

private:
    int64_t _internal_expiry_time_ms() const;
    void _internal_set_expiry_time_ms(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.Metadata.SessionID)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
        int64_t expiry_time_ms_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Metadata_StreamMetadata_ContentLifetime final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Metadata.StreamMetadata.ContentLifetime) */ {
public:
    inline Metadata_StreamMetadata_ContentLifetime()
        : Metadata_StreamMetadata_ContentLifetime(nullptr)
    {
    }
    ~Metadata_StreamMetadata_ContentLifetime() override;
    explicit PROTOBUF_CONSTEXPR Metadata_StreamMetadata_ContentLifetime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Metadata_StreamMetadata_ContentLifetime(const Metadata_StreamMetadata_ContentLifetime& from);
    Metadata_StreamMetadata_ContentLifetime(Metadata_StreamMetadata_ContentLifetime&& from) noexcept
        : Metadata_StreamMetadata_ContentLifetime()
    {
        *this = ::std::move(from);
    }

    inline Metadata_StreamMetadata_ContentLifetime& operator=(const Metadata_StreamMetadata_ContentLifetime& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Metadata_StreamMetadata_ContentLifetime& operator=(Metadata_StreamMetadata_ContentLifetime&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Metadata_StreamMetadata_ContentLifetime& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Metadata_StreamMetadata_ContentLifetime* internal_default_instance()
    {
        return reinterpret_cast<const Metadata_StreamMetadata_ContentLifetime*>(&_Metadata_StreamMetadata_ContentLifetime_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(Metadata_StreamMetadata_ContentLifetime& a, Metadata_StreamMetadata_ContentLifetime& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Metadata_StreamMetadata_ContentLifetime* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Metadata_StreamMetadata_ContentLifetime* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Metadata_StreamMetadata_ContentLifetime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Metadata_StreamMetadata_ContentLifetime>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Metadata_StreamMetadata_ContentLifetime& from);
    void MergeFrom(const Metadata_StreamMetadata_ContentLifetime& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Metadata_StreamMetadata_ContentLifetime* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.Metadata.StreamMetadata.ContentLifetime";
    }

protected:
    explicit Metadata_StreamMetadata_ContentLifetime(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStaleAgeMsFieldNumber = 1,
        kInvalidAgeMsFieldNumber = 2,
    };
    // int64 stale_age_ms = 1;
    void clear_stale_age_ms();
    int64_t stale_age_ms() const;
    void set_stale_age_ms(int64_t value);

private:
    int64_t _internal_stale_age_ms() const;
    void _internal_set_stale_age_ms(int64_t value);

public:
    // int64 invalid_age_ms = 2;
    void clear_invalid_age_ms();
    int64_t invalid_age_ms() const;
    void set_invalid_age_ms(int64_t value);

private:
    int64_t _internal_invalid_age_ms() const;
    void _internal_set_invalid_age_ms(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.Metadata.StreamMetadata.ContentLifetime)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        int64_t stale_age_ms_;
        int64_t invalid_age_ms_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Metadata_StreamMetadata final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Metadata.StreamMetadata) */ {
public:
    inline Metadata_StreamMetadata()
        : Metadata_StreamMetadata(nullptr)
    {
    }
    ~Metadata_StreamMetadata() override;
    explicit PROTOBUF_CONSTEXPR Metadata_StreamMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Metadata_StreamMetadata(const Metadata_StreamMetadata& from);
    Metadata_StreamMetadata(Metadata_StreamMetadata&& from) noexcept
        : Metadata_StreamMetadata()
    {
        *this = ::std::move(from);
    }

    inline Metadata_StreamMetadata& operator=(const Metadata_StreamMetadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Metadata_StreamMetadata& operator=(Metadata_StreamMetadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Metadata_StreamMetadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Metadata_StreamMetadata* internal_default_instance()
    {
        return reinterpret_cast<const Metadata_StreamMetadata*>(&_Metadata_StreamMetadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(Metadata_StreamMetadata& a, Metadata_StreamMetadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Metadata_StreamMetadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Metadata_StreamMetadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Metadata_StreamMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Metadata_StreamMetadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Metadata_StreamMetadata& from);
    void MergeFrom(const Metadata_StreamMetadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Metadata_StreamMetadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.Metadata.StreamMetadata";
    }

protected:
    explicit Metadata_StreamMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Metadata_StreamMetadata_ContentLifetime ContentLifetime;

    // accessors -------------------------------------------------------

    enum : int {
        kViewContentHashesFieldNumber = 4,
        kViewedContentHashesFieldNumber = 8,
        kStreamKeyFieldNumber = 1,
        kContentLifetimeFieldNumber = 5,
        kLastFetchTimeMillisFieldNumber = 6,
        kLastServerResponseTimeMillisFieldNumber = 7,
        kIsKnownStaleFieldNumber = 3,
    };
    // repeated .feedstore.StreamContentHashList view_content_hashes = 4;
    int view_content_hashes_size() const;

private:
    int _internal_view_content_hashes_size() const;

public:
    void clear_view_content_hashes();
    ::feedstore::StreamContentHashList* mutable_view_content_hashes(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList>* mutable_view_content_hashes();

private:
    const ::feedstore::StreamContentHashList& _internal_view_content_hashes(int index) const;
    ::feedstore::StreamContentHashList* _internal_add_view_content_hashes();

public:
    const ::feedstore::StreamContentHashList& view_content_hashes(int index) const;
    ::feedstore::StreamContentHashList* add_view_content_hashes();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList>& view_content_hashes() const;

    // repeated uint32 viewed_content_hashes = 8;
    int viewed_content_hashes_size() const;

private:
    int _internal_viewed_content_hashes_size() const;

public:
    void clear_viewed_content_hashes();

private:
    uint32_t _internal_viewed_content_hashes(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& _internal_viewed_content_hashes() const;
    void _internal_add_viewed_content_hashes(uint32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* _internal_mutable_viewed_content_hashes();

public:
    uint32_t viewed_content_hashes(int index) const;
    void set_viewed_content_hashes(int index, uint32_t value);
    void add_viewed_content_hashes(uint32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& viewed_content_hashes() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* mutable_viewed_content_hashes();

    // string stream_key = 1;
    void clear_stream_key();
    const std::string& stream_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_stream_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_stream_key();
    PROTOBUF_NODISCARD std::string* release_stream_key();
    void set_allocated_stream_key(std::string* stream_key);

private:
    const std::string& _internal_stream_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_key(const std::string& value);
    std::string* _internal_mutable_stream_key();

public:
    // .feedstore.Metadata.StreamMetadata.ContentLifetime content_lifetime = 5;
    bool has_content_lifetime() const;

private:
    bool _internal_has_content_lifetime() const;

public:
    void clear_content_lifetime();
    const ::feedstore::Metadata_StreamMetadata_ContentLifetime& content_lifetime() const;
    PROTOBUF_NODISCARD ::feedstore::Metadata_StreamMetadata_ContentLifetime* release_content_lifetime();
    ::feedstore::Metadata_StreamMetadata_ContentLifetime* mutable_content_lifetime();
    void set_allocated_content_lifetime(::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime);

private:
    const ::feedstore::Metadata_StreamMetadata_ContentLifetime& _internal_content_lifetime() const;
    ::feedstore::Metadata_StreamMetadata_ContentLifetime* _internal_mutable_content_lifetime();

public:
    void unsafe_arena_set_allocated_content_lifetime(::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime);
    ::feedstore::Metadata_StreamMetadata_ContentLifetime* unsafe_arena_release_content_lifetime();

    // int64 last_fetch_time_millis = 6;
    void clear_last_fetch_time_millis();
    int64_t last_fetch_time_millis() const;
    void set_last_fetch_time_millis(int64_t value);

private:
    int64_t _internal_last_fetch_time_millis() const;
    void _internal_set_last_fetch_time_millis(int64_t value);

public:
    // int64 last_server_response_time_millis = 7;
    void clear_last_server_response_time_millis();
    int64_t last_server_response_time_millis() const;
    void set_last_server_response_time_millis(int64_t value);

private:
    int64_t _internal_last_server_response_time_millis() const;
    void _internal_set_last_server_response_time_millis(int64_t value);

public:
    // bool is_known_stale = 3;
    void clear_is_known_stale();
    bool is_known_stale() const;
    void set_is_known_stale(bool value);

private:
    bool _internal_is_known_stale() const;
    void _internal_set_is_known_stale(bool value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.Metadata.StreamMetadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList> view_content_hashes_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t> viewed_content_hashes_;
        mutable std::atomic<int> _viewed_content_hashes_cached_byte_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_key_;
        ::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime_;
        int64_t last_fetch_time_millis_;
        int64_t last_server_response_time_millis_;
        bool is_known_stale_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Metadata final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Metadata) */ {
public:
    inline Metadata()
        : Metadata(nullptr)
    {
    }
    ~Metadata() override;
    explicit PROTOBUF_CONSTEXPR Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Metadata(const Metadata& from);
    Metadata(Metadata&& from) noexcept
        : Metadata()
    {
        *this = ::std::move(from);
    }

    inline Metadata& operator=(const Metadata& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Metadata& operator=(Metadata&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Metadata& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Metadata* internal_default_instance()
    {
        return reinterpret_cast<const Metadata*>(&_Metadata_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(Metadata& a, Metadata& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Metadata* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Metadata* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Metadata>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Metadata& from);
    void MergeFrom(const Metadata& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Metadata* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.Metadata";
    }

protected:
    explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Metadata_SessionID SessionID;
    typedef Metadata_StreamMetadata StreamMetadata;

    // accessors -------------------------------------------------------

    enum : int {
        kStreamMetadataFieldNumber = 5,
        kMostRecentViewedContentHashesFieldNumber = 11,
        kConsistencyTokenFieldNumber = 1,
        kGaiaFieldNumber = 6,
        kSessionIdFieldNumber = 3,
        kNextActionIdFieldNumber = 2,
        kStreamSchemaVersionFieldNumber = 4,
        kWebAndAppActivityEnabledFieldNumber = 7,
        kDiscoverPersonalizationEnabledFieldNumber = 8,
        kFollowedFromWebPageMenuCountFieldNumber = 9,
    };
    // repeated .feedstore.Metadata.StreamMetadata stream_metadata = 5;
    int stream_metadata_size() const;

private:
    int _internal_stream_metadata_size() const;

public:
    void clear_stream_metadata();
    ::feedstore::Metadata_StreamMetadata* mutable_stream_metadata(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::Metadata_StreamMetadata>* mutable_stream_metadata();

private:
    const ::feedstore::Metadata_StreamMetadata& _internal_stream_metadata(int index) const;
    ::feedstore::Metadata_StreamMetadata* _internal_add_stream_metadata();

public:
    const ::feedstore::Metadata_StreamMetadata& stream_metadata(int index) const;
    ::feedstore::Metadata_StreamMetadata* add_stream_metadata();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::Metadata_StreamMetadata>& stream_metadata() const;

    // repeated uint32 most_recent_viewed_content_hashes = 11;
    int most_recent_viewed_content_hashes_size() const;

private:
    int _internal_most_recent_viewed_content_hashes_size() const;

public:
    void clear_most_recent_viewed_content_hashes();

private:
    uint32_t _internal_most_recent_viewed_content_hashes(int index) const;
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& _internal_most_recent_viewed_content_hashes() const;
    void _internal_add_most_recent_viewed_content_hashes(uint32_t value);
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* _internal_mutable_most_recent_viewed_content_hashes();

public:
    uint32_t most_recent_viewed_content_hashes(int index) const;
    void set_most_recent_viewed_content_hashes(int index, uint32_t value);
    void add_most_recent_viewed_content_hashes(uint32_t value);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& most_recent_viewed_content_hashes() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* mutable_most_recent_viewed_content_hashes();

    // bytes consistency_token = 1;
    void clear_consistency_token();
    const std::string& consistency_token() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_consistency_token(ArgT0&& arg0, ArgT... args);
    std::string* mutable_consistency_token();
    PROTOBUF_NODISCARD std::string* release_consistency_token();
    void set_allocated_consistency_token(std::string* consistency_token);

private:
    const std::string& _internal_consistency_token() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_consistency_token(const std::string& value);
    std::string* _internal_mutable_consistency_token();

public:
    // string gaia = 6;
    void clear_gaia();
    const std::string& gaia() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_gaia(ArgT0&& arg0, ArgT... args);
    std::string* mutable_gaia();
    PROTOBUF_NODISCARD std::string* release_gaia();
    void set_allocated_gaia(std::string* gaia);

private:
    const std::string& _internal_gaia() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_gaia(const std::string& value);
    std::string* _internal_mutable_gaia();

public:
    // .feedstore.Metadata.SessionID session_id = 3;
    bool has_session_id() const;

private:
    bool _internal_has_session_id() const;

public:
    void clear_session_id();
    const ::feedstore::Metadata_SessionID& session_id() const;
    PROTOBUF_NODISCARD ::feedstore::Metadata_SessionID* release_session_id();
    ::feedstore::Metadata_SessionID* mutable_session_id();
    void set_allocated_session_id(::feedstore::Metadata_SessionID* session_id);

private:
    const ::feedstore::Metadata_SessionID& _internal_session_id() const;
    ::feedstore::Metadata_SessionID* _internal_mutable_session_id();

public:
    void unsafe_arena_set_allocated_session_id(::feedstore::Metadata_SessionID* session_id);
    ::feedstore::Metadata_SessionID* unsafe_arena_release_session_id();

    // int32 next_action_id = 2;
    void clear_next_action_id();
    int32_t next_action_id() const;
    void set_next_action_id(int32_t value);

private:
    int32_t _internal_next_action_id() const;
    void _internal_set_next_action_id(int32_t value);

public:
    // int32 stream_schema_version = 4;
    void clear_stream_schema_version();
    int32_t stream_schema_version() const;
    void set_stream_schema_version(int32_t value);

private:
    int32_t _internal_stream_schema_version() const;
    void _internal_set_stream_schema_version(int32_t value);

public:
    // bool web_and_app_activity_enabled = 7;
    void clear_web_and_app_activity_enabled();
    bool web_and_app_activity_enabled() const;
    void set_web_and_app_activity_enabled(bool value);

private:
    bool _internal_web_and_app_activity_enabled() const;
    void _internal_set_web_and_app_activity_enabled(bool value);

public:
    // bool discover_personalization_enabled = 8;
    void clear_discover_personalization_enabled();
    bool discover_personalization_enabled() const;
    void set_discover_personalization_enabled(bool value);

private:
    bool _internal_discover_personalization_enabled() const;
    void _internal_set_discover_personalization_enabled(bool value);

public:
    // int32 followed_from_web_page_menu_count = 9;
    void clear_followed_from_web_page_menu_count();
    int32_t followed_from_web_page_menu_count() const;
    void set_followed_from_web_page_menu_count(int32_t value);

private:
    int32_t _internal_followed_from_web_page_menu_count() const;
    void _internal_set_followed_from_web_page_menu_count(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.Metadata)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::Metadata_StreamMetadata> stream_metadata_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t> most_recent_viewed_content_hashes_;
        mutable std::atomic<int> _most_recent_viewed_content_hashes_cached_byte_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consistency_token_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gaia_;
        ::feedstore::Metadata_SessionID* session_id_;
        int32_t next_action_id_;
        int32_t stream_schema_version_;
        bool web_and_app_activity_enabled_;
        bool discover_personalization_enabled_;
        int32_t followed_from_web_page_menu_count_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamStructureSet final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamStructureSet) */ {
public:
    inline StreamStructureSet()
        : StreamStructureSet(nullptr)
    {
    }
    ~StreamStructureSet() override;
    explicit PROTOBUF_CONSTEXPR StreamStructureSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StreamStructureSet(const StreamStructureSet& from);
    StreamStructureSet(StreamStructureSet&& from) noexcept
        : StreamStructureSet()
    {
        *this = ::std::move(from);
    }

    inline StreamStructureSet& operator=(const StreamStructureSet& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StreamStructureSet& operator=(StreamStructureSet&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StreamStructureSet& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StreamStructureSet* internal_default_instance()
    {
        return reinterpret_cast<const StreamStructureSet*>(&_StreamStructureSet_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 7;

    friend void swap(StreamStructureSet& a, StreamStructureSet& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StreamStructureSet* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StreamStructureSet* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StreamStructureSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StreamStructureSet>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StreamStructureSet& from);
    void MergeFrom(const StreamStructureSet& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StreamStructureSet* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.StreamStructureSet";
    }

protected:
    explicit StreamStructureSet(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStructuresFieldNumber = 3,
        kStreamKeyFieldNumber = 1,
        kSequenceNumberFieldNumber = 2,
    };
    // repeated .feedstore.StreamStructure structures = 3;
    int structures_size() const;

private:
    int _internal_structures_size() const;

public:
    void clear_structures();
    ::feedstore::StreamStructure* mutable_structures(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamStructure>* mutable_structures();

private:
    const ::feedstore::StreamStructure& _internal_structures(int index) const;
    ::feedstore::StreamStructure* _internal_add_structures();

public:
    const ::feedstore::StreamStructure& structures(int index) const;
    ::feedstore::StreamStructure* add_structures();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamStructure>& structures() const;

    // string stream_key = 1;
    void clear_stream_key();
    const std::string& stream_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_stream_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_stream_key();
    PROTOBUF_NODISCARD std::string* release_stream_key();
    void set_allocated_stream_key(std::string* stream_key);

private:
    const std::string& _internal_stream_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_key(const std::string& value);
    std::string* _internal_mutable_stream_key();

public:
    // int32 sequence_number = 2;
    void clear_sequence_number();
    int32_t sequence_number() const;
    void set_sequence_number(int32_t value);

private:
    int32_t _internal_sequence_number() const;
    void _internal_set_sequence_number(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.StreamStructureSet)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamStructure> structures_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_key_;
        int32_t sequence_number_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamStructure final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamStructure) */ {
public:
    inline StreamStructure()
        : StreamStructure(nullptr)
    {
    }
    ~StreamStructure() override;
    explicit PROTOBUF_CONSTEXPR StreamStructure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StreamStructure(const StreamStructure& from);
    StreamStructure(StreamStructure&& from) noexcept
        : StreamStructure()
    {
        *this = ::std::move(from);
    }

    inline StreamStructure& operator=(const StreamStructure& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StreamStructure& operator=(StreamStructure&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StreamStructure& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StreamStructure* internal_default_instance()
    {
        return reinterpret_cast<const StreamStructure*>(&_StreamStructure_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 8;

    friend void swap(StreamStructure& a, StreamStructure& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StreamStructure* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StreamStructure* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StreamStructure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StreamStructure>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StreamStructure& from);
    void MergeFrom(const StreamStructure& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StreamStructure* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.StreamStructure";
    }

protected:
    explicit StreamStructure(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef StreamStructure_Operation Operation;
    static constexpr Operation UNKNOWN = StreamStructure_Operation_UNKNOWN;
    static constexpr Operation CLEAR_ALL = StreamStructure_Operation_CLEAR_ALL;
    static constexpr Operation UPDATE_OR_APPEND = StreamStructure_Operation_UPDATE_OR_APPEND;
    static constexpr Operation REMOVE = StreamStructure_Operation_REMOVE;
    static inline bool Operation_IsValid(int value)
    {
        return StreamStructure_Operation_IsValid(value);
    }
    static constexpr Operation Operation_MIN = StreamStructure_Operation_Operation_MIN;
    static constexpr Operation Operation_MAX = StreamStructure_Operation_Operation_MAX;
    static constexpr int Operation_ARRAYSIZE = StreamStructure_Operation_Operation_ARRAYSIZE;
    template <typename T> static inline const std::string& Operation_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Operation>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Operation_Name.");
        return StreamStructure_Operation_Name(enum_t_value);
    }
    static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Operation* value)
    {
        return StreamStructure_Operation_Parse(name, value);
    }

    typedef StreamStructure_Type Type;
    static constexpr Type UNKNOWN_TYPE = StreamStructure_Type_UNKNOWN_TYPE;
    static constexpr Type STREAM = StreamStructure_Type_STREAM;
    static constexpr Type CARD = StreamStructure_Type_CARD;
    static constexpr Type CONTENT = StreamStructure_Type_CONTENT;
    static constexpr Type GROUP = StreamStructure_Type_GROUP;
    static inline bool Type_IsValid(int value)
    {
        return StreamStructure_Type_IsValid(value);
    }
    static constexpr Type Type_MIN = StreamStructure_Type_Type_MIN;
    static constexpr Type Type_MAX = StreamStructure_Type_Type_MAX;
    static constexpr int Type_ARRAYSIZE = StreamStructure_Type_Type_ARRAYSIZE;
    template <typename T> static inline const std::string& Type_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Type>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Type_Name.");
        return StreamStructure_Type_Name(enum_t_value);
    }
    static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value)
    {
        return StreamStructure_Type_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kContentIdFieldNumber = 2,
        kParentIdFieldNumber = 3,
        kContentInfoFieldNumber = 5,
        kOperationFieldNumber = 1,
        kTypeFieldNumber = 4,
        kIsRootFieldNumber = 6,
    };
    // .feedwire.ContentId content_id = 2;
    bool has_content_id() const;

private:
    bool _internal_has_content_id() const;

public:
    void clear_content_id();
    const ::feedwire::ContentId& content_id() const;
    PROTOBUF_NODISCARD ::feedwire::ContentId* release_content_id();
    ::feedwire::ContentId* mutable_content_id();
    void set_allocated_content_id(::feedwire::ContentId* content_id);

private:
    const ::feedwire::ContentId& _internal_content_id() const;
    ::feedwire::ContentId* _internal_mutable_content_id();

public:
    void unsafe_arena_set_allocated_content_id(::feedwire::ContentId* content_id);
    ::feedwire::ContentId* unsafe_arena_release_content_id();

    // .feedwire.ContentId parent_id = 3;
    bool has_parent_id() const;

private:
    bool _internal_has_parent_id() const;

public:
    void clear_parent_id();
    const ::feedwire::ContentId& parent_id() const;
    PROTOBUF_NODISCARD ::feedwire::ContentId* release_parent_id();
    ::feedwire::ContentId* mutable_parent_id();
    void set_allocated_parent_id(::feedwire::ContentId* parent_id);

private:
    const ::feedwire::ContentId& _internal_parent_id() const;
    ::feedwire::ContentId* _internal_mutable_parent_id();

public:
    void unsafe_arena_set_allocated_parent_id(::feedwire::ContentId* parent_id);
    ::feedwire::ContentId* unsafe_arena_release_parent_id();

    // .feedstore.ContentInfo content_info = 5;
    bool has_content_info() const;

private:
    bool _internal_has_content_info() const;

public:
    void clear_content_info();
    const ::feedstore::ContentInfo& content_info() const;
    PROTOBUF_NODISCARD ::feedstore::ContentInfo* release_content_info();
    ::feedstore::ContentInfo* mutable_content_info();
    void set_allocated_content_info(::feedstore::ContentInfo* content_info);

private:
    const ::feedstore::ContentInfo& _internal_content_info() const;
    ::feedstore::ContentInfo* _internal_mutable_content_info();

public:
    void unsafe_arena_set_allocated_content_info(::feedstore::ContentInfo* content_info);
    ::feedstore::ContentInfo* unsafe_arena_release_content_info();

    // .feedstore.StreamStructure.Operation operation = 1;
    void clear_operation();
    ::feedstore::StreamStructure_Operation operation() const;
    void set_operation(::feedstore::StreamStructure_Operation value);

private:
    ::feedstore::StreamStructure_Operation _internal_operation() const;
    void _internal_set_operation(::feedstore::StreamStructure_Operation value);

public:
    // .feedstore.StreamStructure.Type type = 4;
    void clear_type();
    ::feedstore::StreamStructure_Type type() const;
    void set_type(::feedstore::StreamStructure_Type value);

private:
    ::feedstore::StreamStructure_Type _internal_type() const;
    void _internal_set_type(::feedstore::StreamStructure_Type value);

public:
    // bool is_root = 6;
    void clear_is_root();
    bool is_root() const;
    void set_is_root(bool value);

private:
    bool _internal_is_root() const;
    void _internal_set_is_root(bool value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.StreamStructure)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::feedwire::ContentId* content_id_;
        ::feedwire::ContentId* parent_id_;
        ::feedstore::ContentInfo* content_info_;
        int operation_;
        int type_;
        bool is_root_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class DataOperation final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.DataOperation) */ {
public:
    inline DataOperation()
        : DataOperation(nullptr)
    {
    }
    ~DataOperation() override;
    explicit PROTOBUF_CONSTEXPR DataOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DataOperation(const DataOperation& from);
    DataOperation(DataOperation&& from) noexcept
        : DataOperation()
    {
        *this = ::std::move(from);
    }

    inline DataOperation& operator=(const DataOperation& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DataOperation& operator=(DataOperation&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const DataOperation& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DataOperation* internal_default_instance()
    {
        return reinterpret_cast<const DataOperation*>(&_DataOperation_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 9;

    friend void swap(DataOperation& a, DataOperation& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DataOperation* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DataOperation* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DataOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DataOperation>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DataOperation& from);
    void MergeFrom(const DataOperation& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DataOperation* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.DataOperation";
    }

protected:
    explicit DataOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStructureFieldNumber = 1,
        kContentFieldNumber = 2,
    };
    // .feedstore.StreamStructure structure = 1;
    bool has_structure() const;

private:
    bool _internal_has_structure() const;

public:
    void clear_structure();
    const ::feedstore::StreamStructure& structure() const;
    PROTOBUF_NODISCARD ::feedstore::StreamStructure* release_structure();
    ::feedstore::StreamStructure* mutable_structure();
    void set_allocated_structure(::feedstore::StreamStructure* structure);

private:
    const ::feedstore::StreamStructure& _internal_structure() const;
    ::feedstore::StreamStructure* _internal_mutable_structure();

public:
    void unsafe_arena_set_allocated_structure(::feedstore::StreamStructure* structure);
    ::feedstore::StreamStructure* unsafe_arena_release_structure();

    // .feedstore.Content content = 2;
    bool has_content() const;

private:
    bool _internal_has_content() const;

public:
    void clear_content();
    const ::feedstore::Content& content() const;
    PROTOBUF_NODISCARD ::feedstore::Content* release_content();
    ::feedstore::Content* mutable_content();
    void set_allocated_content(::feedstore::Content* content);

private:
    const ::feedstore::Content& _internal_content() const;
    ::feedstore::Content* _internal_mutable_content();

public:
    void unsafe_arena_set_allocated_content(::feedstore::Content* content);
    ::feedstore::Content* unsafe_arena_release_content();

    // @@protoc_insertion_point(class_scope:feedstore.DataOperation)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::feedstore::StreamStructure* structure_;
        ::feedstore::Content* content_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class ContentInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.ContentInfo) */ {
public:
    inline ContentInfo()
        : ContentInfo(nullptr)
    {
    }
    ~ContentInfo() override;
    explicit PROTOBUF_CONSTEXPR ContentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    ContentInfo(const ContentInfo& from);
    ContentInfo(ContentInfo&& from) noexcept
        : ContentInfo()
    {
        *this = ::std::move(from);
    }

    inline ContentInfo& operator=(const ContentInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline ContentInfo& operator=(ContentInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const ContentInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const ContentInfo* internal_default_instance()
    {
        return reinterpret_cast<const ContentInfo*>(&_ContentInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 10;

    friend void swap(ContentInfo& a, ContentInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(ContentInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(ContentInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    ContentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<ContentInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const ContentInfo& from);
    void MergeFrom(const ContentInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(ContentInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.ContentInfo";
    }

protected:
    explicit ContentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kAvailabilityTimeSecondsFieldNumber = 2,
        kScoreFieldNumber = 1,
    };
    // int64 availability_time_seconds = 2;
    void clear_availability_time_seconds();
    int64_t availability_time_seconds() const;
    void set_availability_time_seconds(int64_t value);

private:
    int64_t _internal_availability_time_seconds() const;
    void _internal_set_availability_time_seconds(int64_t value);

public:
    // float score = 1;
    void clear_score();
    float score() const;
    void set_score(float value);

private:
    float _internal_score() const;
    void _internal_set_score(float value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.ContentInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        int64_t availability_time_seconds_;
        float score_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Content final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Content) */ {
public:
    inline Content()
        : Content(nullptr)
    {
    }
    ~Content() override;
    explicit PROTOBUF_CONSTEXPR Content(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Content(const Content& from);
    Content(Content&& from) noexcept
        : Content()
    {
        *this = ::std::move(from);
    }

    inline Content& operator=(const Content& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Content& operator=(Content&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Content& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Content* internal_default_instance()
    {
        return reinterpret_cast<const Content*>(&_Content_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 11;

    friend void swap(Content& a, Content& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Content* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Content* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Content* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Content>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Content& from);
    void MergeFrom(const Content& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Content* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.Content";
    }

protected:
    explicit Content(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kPrefetchMetadataFieldNumber = 3,
        kFrameFieldNumber = 2,
        kStreamKeyFieldNumber = 4,
        kContentIdFieldNumber = 1,
    };
    // repeated .feedwire.PrefetchMetadata prefetch_metadata = 3;
    int prefetch_metadata_size() const;

private:
    int _internal_prefetch_metadata_size() const;

public:
    void clear_prefetch_metadata();
    ::feedwire::PrefetchMetadata* mutable_prefetch_metadata(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::PrefetchMetadata>* mutable_prefetch_metadata();

private:
    const ::feedwire::PrefetchMetadata& _internal_prefetch_metadata(int index) const;
    ::feedwire::PrefetchMetadata* _internal_add_prefetch_metadata();

public:
    const ::feedwire::PrefetchMetadata& prefetch_metadata(int index) const;
    ::feedwire::PrefetchMetadata* add_prefetch_metadata();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::PrefetchMetadata>& prefetch_metadata() const;

    // bytes frame = 2;
    void clear_frame();
    const std::string& frame() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_frame(ArgT0&& arg0, ArgT... args);
    std::string* mutable_frame();
    PROTOBUF_NODISCARD std::string* release_frame();
    void set_allocated_frame(std::string* frame);

private:
    const std::string& _internal_frame() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame(const std::string& value);
    std::string* _internal_mutable_frame();

public:
    // string stream_key = 4;
    void clear_stream_key();
    const std::string& stream_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_stream_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_stream_key();
    PROTOBUF_NODISCARD std::string* release_stream_key();
    void set_allocated_stream_key(std::string* stream_key);

private:
    const std::string& _internal_stream_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_key(const std::string& value);
    std::string* _internal_mutable_stream_key();

public:
    // .feedwire.ContentId content_id = 1;
    bool has_content_id() const;

private:
    bool _internal_has_content_id() const;

public:
    void clear_content_id();
    const ::feedwire::ContentId& content_id() const;
    PROTOBUF_NODISCARD ::feedwire::ContentId* release_content_id();
    ::feedwire::ContentId* mutable_content_id();
    void set_allocated_content_id(::feedwire::ContentId* content_id);

private:
    const ::feedwire::ContentId& _internal_content_id() const;
    ::feedwire::ContentId* _internal_mutable_content_id();

public:
    void unsafe_arena_set_allocated_content_id(::feedwire::ContentId* content_id);
    ::feedwire::ContentId* unsafe_arena_release_content_id();

    // @@protoc_insertion_point(class_scope:feedstore.Content)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::PrefetchMetadata> prefetch_metadata_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_key_;
        ::feedwire::ContentId* content_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamSharedState final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamSharedState) */ {
public:
    inline StreamSharedState()
        : StreamSharedState(nullptr)
    {
    }
    ~StreamSharedState() override;
    explicit PROTOBUF_CONSTEXPR StreamSharedState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StreamSharedState(const StreamSharedState& from);
    StreamSharedState(StreamSharedState&& from) noexcept
        : StreamSharedState()
    {
        *this = ::std::move(from);
    }

    inline StreamSharedState& operator=(const StreamSharedState& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StreamSharedState& operator=(StreamSharedState&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StreamSharedState& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StreamSharedState* internal_default_instance()
    {
        return reinterpret_cast<const StreamSharedState*>(&_StreamSharedState_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 12;

    friend void swap(StreamSharedState& a, StreamSharedState& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StreamSharedState* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StreamSharedState* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StreamSharedState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StreamSharedState>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StreamSharedState& from);
    void MergeFrom(const StreamSharedState& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StreamSharedState* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.StreamSharedState";
    }

protected:
    explicit StreamSharedState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSharedStateDataFieldNumber = 2,
        kStreamKeyFieldNumber = 3,
        kContentIdFieldNumber = 1,
    };
    // bytes shared_state_data = 2;
    void clear_shared_state_data();
    const std::string& shared_state_data() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_shared_state_data(ArgT0&& arg0, ArgT... args);
    std::string* mutable_shared_state_data();
    PROTOBUF_NODISCARD std::string* release_shared_state_data();
    void set_allocated_shared_state_data(std::string* shared_state_data);

private:
    const std::string& _internal_shared_state_data() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_shared_state_data(const std::string& value);
    std::string* _internal_mutable_shared_state_data();

public:
    // string stream_key = 3;
    void clear_stream_key();
    const std::string& stream_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_stream_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_stream_key();
    PROTOBUF_NODISCARD std::string* release_stream_key();
    void set_allocated_stream_key(std::string* stream_key);

private:
    const std::string& _internal_stream_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_key(const std::string& value);
    std::string* _internal_mutable_stream_key();

public:
    // .feedwire.ContentId content_id = 1;
    bool has_content_id() const;

private:
    bool _internal_has_content_id() const;

public:
    void clear_content_id();
    const ::feedwire::ContentId& content_id() const;
    PROTOBUF_NODISCARD ::feedwire::ContentId* release_content_id();
    ::feedwire::ContentId* mutable_content_id();
    void set_allocated_content_id(::feedwire::ContentId* content_id);

private:
    const ::feedwire::ContentId& _internal_content_id() const;
    ::feedwire::ContentId* _internal_mutable_content_id();

public:
    void unsafe_arena_set_allocated_content_id(::feedwire::ContentId* content_id);
    ::feedwire::ContentId* unsafe_arena_release_content_id();

    // @@protoc_insertion_point(class_scope:feedstore.StreamSharedState)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shared_state_data_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_key_;
        ::feedwire::ContentId* content_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StoredAction final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StoredAction) */ {
public:
    inline StoredAction()
        : StoredAction(nullptr)
    {
    }
    ~StoredAction() override;
    explicit PROTOBUF_CONSTEXPR StoredAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    StoredAction(const StoredAction& from);
    StoredAction(StoredAction&& from) noexcept
        : StoredAction()
    {
        *this = ::std::move(from);
    }

    inline StoredAction& operator=(const StoredAction& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline StoredAction& operator=(StoredAction&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const StoredAction& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const StoredAction* internal_default_instance()
    {
        return reinterpret_cast<const StoredAction*>(&_StoredAction_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 13;

    friend void swap(StoredAction& a, StoredAction& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(StoredAction* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(StoredAction* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    StoredAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<StoredAction>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const StoredAction& from);
    void MergeFrom(const StoredAction& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(StoredAction* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.StoredAction";
    }

protected:
    explicit StoredAction(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kActionFieldNumber = 3,
        kIdFieldNumber = 1,
        kUploadAttemptCountFieldNumber = 2,
    };
    // .feedwire.FeedAction action = 3;
    bool has_action() const;

private:
    bool _internal_has_action() const;

public:
    void clear_action();
    const ::feedwire::FeedAction& action() const;
    PROTOBUF_NODISCARD ::feedwire::FeedAction* release_action();
    ::feedwire::FeedAction* mutable_action();
    void set_allocated_action(::feedwire::FeedAction* action);

private:
    const ::feedwire::FeedAction& _internal_action() const;
    ::feedwire::FeedAction* _internal_mutable_action();

public:
    void unsafe_arena_set_allocated_action(::feedwire::FeedAction* action);
    ::feedwire::FeedAction* unsafe_arena_release_action();

    // int32 id = 1;
    void clear_id();
    int32_t id() const;
    void set_id(int32_t value);

private:
    int32_t _internal_id() const;
    void _internal_set_id(int32_t value);

public:
    // int32 upload_attempt_count = 2;
    void clear_upload_attempt_count();
    int32_t upload_attempt_count() const;
    void set_upload_attempt_count(int32_t value);

private:
    int32_t _internal_upload_attempt_count() const;
    void _internal_set_upload_attempt_count(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.StoredAction)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::feedwire::FeedAction* action_;
        int32_t id_;
        int32_t upload_attempt_count_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class SubscribedWebFeeds final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.SubscribedWebFeeds) */ {
public:
    inline SubscribedWebFeeds()
        : SubscribedWebFeeds(nullptr)
    {
    }
    ~SubscribedWebFeeds() override;
    explicit PROTOBUF_CONSTEXPR SubscribedWebFeeds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SubscribedWebFeeds(const SubscribedWebFeeds& from);
    SubscribedWebFeeds(SubscribedWebFeeds&& from) noexcept
        : SubscribedWebFeeds()
    {
        *this = ::std::move(from);
    }

    inline SubscribedWebFeeds& operator=(const SubscribedWebFeeds& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SubscribedWebFeeds& operator=(SubscribedWebFeeds&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SubscribedWebFeeds& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SubscribedWebFeeds* internal_default_instance()
    {
        return reinterpret_cast<const SubscribedWebFeeds*>(&_SubscribedWebFeeds_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 14;

    friend void swap(SubscribedWebFeeds& a, SubscribedWebFeeds& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SubscribedWebFeeds* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SubscribedWebFeeds* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SubscribedWebFeeds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SubscribedWebFeeds>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SubscribedWebFeeds& from);
    void MergeFrom(const SubscribedWebFeeds& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SubscribedWebFeeds* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.SubscribedWebFeeds";
    }

protected:
    explicit SubscribedWebFeeds(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kFeedsFieldNumber = 1,
        kUpdateTimeMillisFieldNumber = 2,
    };
    // repeated .feedstore.WebFeedInfo feeds = 1;
    int feeds_size() const;

private:
    int _internal_feeds_size() const;

public:
    void clear_feeds();
    ::feedstore::WebFeedInfo* mutable_feeds(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::WebFeedInfo>* mutable_feeds();

private:
    const ::feedstore::WebFeedInfo& _internal_feeds(int index) const;
    ::feedstore::WebFeedInfo* _internal_add_feeds();

public:
    const ::feedstore::WebFeedInfo& feeds(int index) const;
    ::feedstore::WebFeedInfo* add_feeds();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::WebFeedInfo>& feeds() const;

    // int64 update_time_millis = 2;
    void clear_update_time_millis();
    int64_t update_time_millis() const;
    void set_update_time_millis(int64_t value);

private:
    int64_t _internal_update_time_millis() const;
    void _internal_set_update_time_millis(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.SubscribedWebFeeds)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::WebFeedInfo> feeds_;
        int64_t update_time_millis_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class RecommendedWebFeedIndex_Entry final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.RecommendedWebFeedIndex.Entry) */ {
public:
    inline RecommendedWebFeedIndex_Entry()
        : RecommendedWebFeedIndex_Entry(nullptr)
    {
    }
    ~RecommendedWebFeedIndex_Entry() override;
    explicit PROTOBUF_CONSTEXPR RecommendedWebFeedIndex_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RecommendedWebFeedIndex_Entry(const RecommendedWebFeedIndex_Entry& from);
    RecommendedWebFeedIndex_Entry(RecommendedWebFeedIndex_Entry&& from) noexcept
        : RecommendedWebFeedIndex_Entry()
    {
        *this = ::std::move(from);
    }

    inline RecommendedWebFeedIndex_Entry& operator=(const RecommendedWebFeedIndex_Entry& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RecommendedWebFeedIndex_Entry& operator=(RecommendedWebFeedIndex_Entry&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const RecommendedWebFeedIndex_Entry& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RecommendedWebFeedIndex_Entry* internal_default_instance()
    {
        return reinterpret_cast<const RecommendedWebFeedIndex_Entry*>(&_RecommendedWebFeedIndex_Entry_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 15;

    friend void swap(RecommendedWebFeedIndex_Entry& a, RecommendedWebFeedIndex_Entry& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RecommendedWebFeedIndex_Entry* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RecommendedWebFeedIndex_Entry* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RecommendedWebFeedIndex_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RecommendedWebFeedIndex_Entry>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RecommendedWebFeedIndex_Entry& from);
    void MergeFrom(const RecommendedWebFeedIndex_Entry& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RecommendedWebFeedIndex_Entry* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.RecommendedWebFeedIndex.Entry";
    }

protected:
    explicit RecommendedWebFeedIndex_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kMatchersFieldNumber = 2,
        kWebFeedIdFieldNumber = 1,
    };
    // repeated .feedwire.webfeed.WebFeedMatcher matchers = 2;
    int matchers_size() const;

private:
    int _internal_matchers_size() const;

public:
    void clear_matchers();
    ::feedwire::webfeed::WebFeedMatcher* mutable_matchers(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher>* mutable_matchers();

private:
    const ::feedwire::webfeed::WebFeedMatcher& _internal_matchers(int index) const;
    ::feedwire::webfeed::WebFeedMatcher* _internal_add_matchers();

public:
    const ::feedwire::webfeed::WebFeedMatcher& matchers(int index) const;
    ::feedwire::webfeed::WebFeedMatcher* add_matchers();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher>& matchers() const;

    // string web_feed_id = 1;
    void clear_web_feed_id();
    const std::string& web_feed_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_web_feed_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_web_feed_id();
    PROTOBUF_NODISCARD std::string* release_web_feed_id();
    void set_allocated_web_feed_id(std::string* web_feed_id);

private:
    const std::string& _internal_web_feed_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_web_feed_id(const std::string& value);
    std::string* _internal_mutable_web_feed_id();

public:
    // @@protoc_insertion_point(class_scope:feedstore.RecommendedWebFeedIndex.Entry)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher> matchers_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr web_feed_id_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class RecommendedWebFeedIndex final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.RecommendedWebFeedIndex) */ {
public:
    inline RecommendedWebFeedIndex()
        : RecommendedWebFeedIndex(nullptr)
    {
    }
    ~RecommendedWebFeedIndex() override;
    explicit PROTOBUF_CONSTEXPR RecommendedWebFeedIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    RecommendedWebFeedIndex(const RecommendedWebFeedIndex& from);
    RecommendedWebFeedIndex(RecommendedWebFeedIndex&& from) noexcept
        : RecommendedWebFeedIndex()
    {
        *this = ::std::move(from);
    }

    inline RecommendedWebFeedIndex& operator=(const RecommendedWebFeedIndex& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline RecommendedWebFeedIndex& operator=(RecommendedWebFeedIndex&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const RecommendedWebFeedIndex& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const RecommendedWebFeedIndex* internal_default_instance()
    {
        return reinterpret_cast<const RecommendedWebFeedIndex*>(&_RecommendedWebFeedIndex_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 16;

    friend void swap(RecommendedWebFeedIndex& a, RecommendedWebFeedIndex& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(RecommendedWebFeedIndex* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(RecommendedWebFeedIndex* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    RecommendedWebFeedIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<RecommendedWebFeedIndex>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const RecommendedWebFeedIndex& from);
    void MergeFrom(const RecommendedWebFeedIndex& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(RecommendedWebFeedIndex* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.RecommendedWebFeedIndex";
    }

protected:
    explicit RecommendedWebFeedIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef RecommendedWebFeedIndex_Entry Entry;

    // accessors -------------------------------------------------------

    enum : int {
        kEntriesFieldNumber = 1,
        kUpdateTimeMillisFieldNumber = 2,
    };
    // repeated .feedstore.RecommendedWebFeedIndex.Entry entries = 1;
    int entries_size() const;

private:
    int _internal_entries_size() const;

public:
    void clear_entries();
    ::feedstore::RecommendedWebFeedIndex_Entry* mutable_entries(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::RecommendedWebFeedIndex_Entry>* mutable_entries();

private:
    const ::feedstore::RecommendedWebFeedIndex_Entry& _internal_entries(int index) const;
    ::feedstore::RecommendedWebFeedIndex_Entry* _internal_add_entries();

public:
    const ::feedstore::RecommendedWebFeedIndex_Entry& entries(int index) const;
    ::feedstore::RecommendedWebFeedIndex_Entry* add_entries();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::RecommendedWebFeedIndex_Entry>& entries() const;

    // int64 update_time_millis = 2;
    void clear_update_time_millis();
    int64_t update_time_millis() const;
    void set_update_time_millis(int64_t value);

private:
    int64_t _internal_update_time_millis() const;
    void _internal_set_update_time_millis(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.RecommendedWebFeedIndex)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::RecommendedWebFeedIndex_Entry> entries_;
        int64_t update_time_millis_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Image final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Image) */ {
public:
    inline Image()
        : Image(nullptr)
    {
    }
    ~Image() override;
    explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Image(const Image& from);
    Image(Image&& from) noexcept
        : Image()
    {
        *this = ::std::move(from);
    }

    inline Image& operator=(const Image& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Image& operator=(Image&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Image& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Image* internal_default_instance()
    {
        return reinterpret_cast<const Image*>(&_Image_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 17;

    friend void swap(Image& a, Image& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Image* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Image* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Image>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Image& from);
    void MergeFrom(const Image& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Image* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.Image";
    }

protected:
    explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlFieldNumber = 1,
    };
    // string url = 1;
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // @@protoc_insertion_point(class_scope:feedstore.Image)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class WebFeedInfo final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.WebFeedInfo) */ {
public:
    inline WebFeedInfo()
        : WebFeedInfo(nullptr)
    {
    }
    ~WebFeedInfo() override;
    explicit PROTOBUF_CONSTEXPR WebFeedInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WebFeedInfo(const WebFeedInfo& from);
    WebFeedInfo(WebFeedInfo&& from) noexcept
        : WebFeedInfo()
    {
        *this = ::std::move(from);
    }

    inline WebFeedInfo& operator=(const WebFeedInfo& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WebFeedInfo& operator=(WebFeedInfo&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const WebFeedInfo& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WebFeedInfo* internal_default_instance()
    {
        return reinterpret_cast<const WebFeedInfo*>(&_WebFeedInfo_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 18;

    friend void swap(WebFeedInfo& a, WebFeedInfo& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WebFeedInfo* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WebFeedInfo* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WebFeedInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WebFeedInfo>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WebFeedInfo& from);
    void MergeFrom(const WebFeedInfo& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WebFeedInfo* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.WebFeedInfo";
    }

protected:
    explicit WebFeedInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef WebFeedInfo_State State;
    static constexpr State STATE_UNSPECIFIED = WebFeedInfo_State_STATE_UNSPECIFIED;
    static constexpr State INACTIVE = WebFeedInfo_State_INACTIVE;
    static constexpr State ACTIVE = WebFeedInfo_State_ACTIVE;
    static constexpr State WAITING_FOR_CONTENT = WebFeedInfo_State_WAITING_FOR_CONTENT;
    static inline bool State_IsValid(int value)
    {
        return WebFeedInfo_State_IsValid(value);
    }
    static constexpr State State_MIN = WebFeedInfo_State_State_MIN;
    static constexpr State State_MAX = WebFeedInfo_State_State_MAX;
    static constexpr int State_ARRAYSIZE = WebFeedInfo_State_State_ARRAYSIZE;
    template <typename T> static inline const std::string& State_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, State>::value || ::std::is_integral<T>::value, "Incorrect type passed to function State_Name.");
        return WebFeedInfo_State_Name(enum_t_value);
    }
    static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, State* value)
    {
        return WebFeedInfo_State_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kMatchersFieldNumber = 10,
        kWebFeedIdFieldNumber = 1,
        kTitleFieldNumber = 2,
        kSubtitleFieldNumber = 3,
        kDetailTextFieldNumber = 4,
        kVisitUriFieldNumber = 5,
        kRssUriFieldNumber = 6,
        kFaviconFieldNumber = 7,
        kFollowerCountFieldNumber = 8,
        kStateFieldNumber = 9,
    };
    // repeated .feedwire.webfeed.WebFeedMatcher matchers = 10;
    int matchers_size() const;

private:
    int _internal_matchers_size() const;

public:
    void clear_matchers();
    ::feedwire::webfeed::WebFeedMatcher* mutable_matchers(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher>* mutable_matchers();

private:
    const ::feedwire::webfeed::WebFeedMatcher& _internal_matchers(int index) const;
    ::feedwire::webfeed::WebFeedMatcher* _internal_add_matchers();

public:
    const ::feedwire::webfeed::WebFeedMatcher& matchers(int index) const;
    ::feedwire::webfeed::WebFeedMatcher* add_matchers();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher>& matchers() const;

    // string web_feed_id = 1;
    void clear_web_feed_id();
    const std::string& web_feed_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_web_feed_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_web_feed_id();
    PROTOBUF_NODISCARD std::string* release_web_feed_id();
    void set_allocated_web_feed_id(std::string* web_feed_id);

private:
    const std::string& _internal_web_feed_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_web_feed_id(const std::string& value);
    std::string* _internal_mutable_web_feed_id();

public:
    // string title = 2;
    void clear_title();
    const std::string& title() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_title(ArgT0&& arg0, ArgT... args);
    std::string* mutable_title();
    PROTOBUF_NODISCARD std::string* release_title();
    void set_allocated_title(std::string* title);

private:
    const std::string& _internal_title() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
    std::string* _internal_mutable_title();

public:
    // string subtitle = 3;
    void clear_subtitle();
    const std::string& subtitle() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_subtitle(ArgT0&& arg0, ArgT... args);
    std::string* mutable_subtitle();
    PROTOBUF_NODISCARD std::string* release_subtitle();
    void set_allocated_subtitle(std::string* subtitle);

private:
    const std::string& _internal_subtitle() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_subtitle(const std::string& value);
    std::string* _internal_mutable_subtitle();

public:
    // string detail_text = 4;
    void clear_detail_text();
    const std::string& detail_text() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_detail_text(ArgT0&& arg0, ArgT... args);
    std::string* mutable_detail_text();
    PROTOBUF_NODISCARD std::string* release_detail_text();
    void set_allocated_detail_text(std::string* detail_text);

private:
    const std::string& _internal_detail_text() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail_text(const std::string& value);
    std::string* _internal_mutable_detail_text();

public:
    // string visit_uri = 5;
    void clear_visit_uri();
    const std::string& visit_uri() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_visit_uri(ArgT0&& arg0, ArgT... args);
    std::string* mutable_visit_uri();
    PROTOBUF_NODISCARD std::string* release_visit_uri();
    void set_allocated_visit_uri(std::string* visit_uri);

private:
    const std::string& _internal_visit_uri() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_visit_uri(const std::string& value);
    std::string* _internal_mutable_visit_uri();

public:
    // string rss_uri = 6;
    void clear_rss_uri();
    const std::string& rss_uri() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_rss_uri(ArgT0&& arg0, ArgT... args);
    std::string* mutable_rss_uri();
    PROTOBUF_NODISCARD std::string* release_rss_uri();
    void set_allocated_rss_uri(std::string* rss_uri);

private:
    const std::string& _internal_rss_uri() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_rss_uri(const std::string& value);
    std::string* _internal_mutable_rss_uri();

public:
    // .feedstore.Image favicon = 7;
    bool has_favicon() const;

private:
    bool _internal_has_favicon() const;

public:
    void clear_favicon();
    const ::feedstore::Image& favicon() const;
    PROTOBUF_NODISCARD ::feedstore::Image* release_favicon();
    ::feedstore::Image* mutable_favicon();
    void set_allocated_favicon(::feedstore::Image* favicon);

private:
    const ::feedstore::Image& _internal_favicon() const;
    ::feedstore::Image* _internal_mutable_favicon();

public:
    void unsafe_arena_set_allocated_favicon(::feedstore::Image* favicon);
    ::feedstore::Image* unsafe_arena_release_favicon();

    // int64 follower_count = 8;
    void clear_follower_count();
    int64_t follower_count() const;
    void set_follower_count(int64_t value);

private:
    int64_t _internal_follower_count() const;
    void _internal_set_follower_count(int64_t value);

public:
    // .feedstore.WebFeedInfo.State state = 9;
    void clear_state();
    ::feedstore::WebFeedInfo_State state() const;
    void set_state(::feedstore::WebFeedInfo_State value);

private:
    ::feedstore::WebFeedInfo_State _internal_state() const;
    void _internal_set_state(::feedstore::WebFeedInfo_State value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.WebFeedInfo)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher> matchers_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr web_feed_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtitle_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_text_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr visit_uri_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rss_uri_;
        ::feedstore::Image* favicon_;
        int64_t follower_count_;
        int state_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class PendingWebFeedOperation final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.PendingWebFeedOperation) */ {
public:
    inline PendingWebFeedOperation()
        : PendingWebFeedOperation(nullptr)
    {
    }
    ~PendingWebFeedOperation() override;
    explicit PROTOBUF_CONSTEXPR PendingWebFeedOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    PendingWebFeedOperation(const PendingWebFeedOperation& from);
    PendingWebFeedOperation(PendingWebFeedOperation&& from) noexcept
        : PendingWebFeedOperation()
    {
        *this = ::std::move(from);
    }

    inline PendingWebFeedOperation& operator=(const PendingWebFeedOperation& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline PendingWebFeedOperation& operator=(PendingWebFeedOperation&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const PendingWebFeedOperation& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const PendingWebFeedOperation* internal_default_instance()
    {
        return reinterpret_cast<const PendingWebFeedOperation*>(&_PendingWebFeedOperation_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 19;

    friend void swap(PendingWebFeedOperation& a, PendingWebFeedOperation& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(PendingWebFeedOperation* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(PendingWebFeedOperation* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    PendingWebFeedOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<PendingWebFeedOperation>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const PendingWebFeedOperation& from);
    void MergeFrom(const PendingWebFeedOperation& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(PendingWebFeedOperation* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.PendingWebFeedOperation";
    }

protected:
    explicit PendingWebFeedOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef PendingWebFeedOperation_Kind Kind;
    static constexpr Kind KIND_UNSPECIFIED = PendingWebFeedOperation_Kind_KIND_UNSPECIFIED;
    static constexpr Kind SUBSCRIBE = PendingWebFeedOperation_Kind_SUBSCRIBE;
    static constexpr Kind UNSUBSCRIBE = PendingWebFeedOperation_Kind_UNSUBSCRIBE;
    static inline bool Kind_IsValid(int value)
    {
        return PendingWebFeedOperation_Kind_IsValid(value);
    }
    static constexpr Kind Kind_MIN = PendingWebFeedOperation_Kind_Kind_MIN;
    static constexpr Kind Kind_MAX = PendingWebFeedOperation_Kind_Kind_MAX;
    static constexpr int Kind_ARRAYSIZE = PendingWebFeedOperation_Kind_Kind_ARRAYSIZE;
    template <typename T> static inline const std::string& Kind_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Kind>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Kind_Name.");
        return PendingWebFeedOperation_Kind_Name(enum_t_value);
    }
    static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Kind* value)
    {
        return PendingWebFeedOperation_Kind_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kWebFeedIdFieldNumber = 3,
        kIdFieldNumber = 1,
        kKindFieldNumber = 2,
        kAttemptsFieldNumber = 4,
        kChangeReasonFieldNumber = 5,
    };
    // string web_feed_id = 3;
    void clear_web_feed_id();
    const std::string& web_feed_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_web_feed_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_web_feed_id();
    PROTOBUF_NODISCARD std::string* release_web_feed_id();
    void set_allocated_web_feed_id(std::string* web_feed_id);

private:
    const std::string& _internal_web_feed_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_web_feed_id(const std::string& value);
    std::string* _internal_mutable_web_feed_id();

public:
    // int64 id = 1;
    void clear_id();
    int64_t id() const;
    void set_id(int64_t value);

private:
    int64_t _internal_id() const;
    void _internal_set_id(int64_t value);

public:
    // .feedstore.PendingWebFeedOperation.Kind kind = 2;
    void clear_kind();
    ::feedstore::PendingWebFeedOperation_Kind kind() const;
    void set_kind(::feedstore::PendingWebFeedOperation_Kind value);

private:
    ::feedstore::PendingWebFeedOperation_Kind _internal_kind() const;
    void _internal_set_kind(::feedstore::PendingWebFeedOperation_Kind value);

public:
    // int32 attempts = 4;
    void clear_attempts();
    int32_t attempts() const;
    void set_attempts(int32_t value);

private:
    int32_t _internal_attempts() const;
    void _internal_set_attempts(int32_t value);

public:
    // .feedwire.webfeed.WebFeedChangeReason change_reason = 5;
    void clear_change_reason();
    ::feedwire::webfeed::WebFeedChangeReason change_reason() const;
    void set_change_reason(::feedwire::webfeed::WebFeedChangeReason value);

private:
    ::feedwire::webfeed::WebFeedChangeReason _internal_change_reason() const;
    void _internal_set_change_reason(::feedwire::webfeed::WebFeedChangeReason value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.PendingWebFeedOperation)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr web_feed_id_;
        int64_t id_;
        int kind_;
        int32_t attempts_;
        int change_reason_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class DocView final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.DocView) */ {
public:
    inline DocView()
        : DocView(nullptr)
    {
    }
    ~DocView() override;
    explicit PROTOBUF_CONSTEXPR DocView(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    DocView(const DocView& from);
    DocView(DocView&& from) noexcept
        : DocView()
    {
        *this = ::std::move(from);
    }

    inline DocView& operator=(const DocView& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DocView& operator=(DocView&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const DocView& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DocView* internal_default_instance()
    {
        return reinterpret_cast<const DocView*>(&_DocView_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 20;

    friend void swap(DocView& a, DocView& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(DocView* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DocView* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DocView* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<DocView>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const DocView& from);
    void MergeFrom(const DocView& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(DocView* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedstore.DocView";
    }

protected:
    explicit DocView(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kDocidFieldNumber = 1,
        kViewTimeMillisFieldNumber = 4,
    };
    // uint64 docid = 1;
    void clear_docid();
    uint64_t docid() const;
    void set_docid(uint64_t value);

private:
    uint64_t _internal_docid() const;
    void _internal_set_docid(uint64_t value);

public:
    // int64 view_time_millis = 4;
    void clear_view_time_millis();
    int64_t view_time_millis() const;
    void set_view_time_millis(int64_t value);

private:
    int64_t _internal_view_time_millis() const;
    void _internal_set_view_time_millis(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:feedstore.DocView)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        uint64_t docid_;
        int64_t view_time_millis_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Record

// .feedstore.StreamData stream_data = 1;
inline bool Record::_internal_has_stream_data() const
{
    return data_case() == kStreamData;
}
inline bool Record::has_stream_data() const
{
    return _internal_has_stream_data();
}
inline void Record::set_has_stream_data()
{
    _impl_._oneof_case_[0] = kStreamData;
}
inline void Record::clear_stream_data()
{
    if (_internal_has_stream_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.stream_data_;
        }
        clear_has_data();
    }
}
inline ::feedstore::StreamData* Record::release_stream_data()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.stream_data)
    if (_internal_has_stream_data()) {
        clear_has_data();
        ::feedstore::StreamData* temp = _impl_.data_.stream_data_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.stream_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::StreamData& Record::_internal_stream_data() const
{
    return _internal_has_stream_data() ? *_impl_.data_.stream_data_ : reinterpret_cast<::feedstore::StreamData&>(::feedstore::_StreamData_default_instance_);
}
inline const ::feedstore::StreamData& Record::stream_data() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.stream_data)
    return _internal_stream_data();
}
inline ::feedstore::StreamData* Record::unsafe_arena_release_stream_data()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.stream_data)
    if (_internal_has_stream_data()) {
        clear_has_data();
        ::feedstore::StreamData* temp = _impl_.data_.stream_data_;
        _impl_.data_.stream_data_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_stream_data(::feedstore::StreamData* stream_data)
{
    clear_data();
    if (stream_data) {
        set_has_stream_data();
        _impl_.data_.stream_data_ = stream_data;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.stream_data)
}
inline ::feedstore::StreamData* Record::_internal_mutable_stream_data()
{
    if (!_internal_has_stream_data()) {
        clear_data();
        set_has_stream_data();
        _impl_.data_.stream_data_ = CreateMaybeMessage<::feedstore::StreamData>(GetArenaForAllocation());
    }
    return _impl_.data_.stream_data_;
}
inline ::feedstore::StreamData* Record::mutable_stream_data()
{
    ::feedstore::StreamData* _msg = _internal_mutable_stream_data();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.stream_data)
    return _msg;
}

// .feedstore.StreamStructureSet stream_structures = 2;
inline bool Record::_internal_has_stream_structures() const
{
    return data_case() == kStreamStructures;
}
inline bool Record::has_stream_structures() const
{
    return _internal_has_stream_structures();
}
inline void Record::set_has_stream_structures()
{
    _impl_._oneof_case_[0] = kStreamStructures;
}
inline void Record::clear_stream_structures()
{
    if (_internal_has_stream_structures()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.stream_structures_;
        }
        clear_has_data();
    }
}
inline ::feedstore::StreamStructureSet* Record::release_stream_structures()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.stream_structures)
    if (_internal_has_stream_structures()) {
        clear_has_data();
        ::feedstore::StreamStructureSet* temp = _impl_.data_.stream_structures_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.stream_structures_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::StreamStructureSet& Record::_internal_stream_structures() const
{
    return _internal_has_stream_structures() ? *_impl_.data_.stream_structures_
                                             : reinterpret_cast<::feedstore::StreamStructureSet&>(::feedstore::_StreamStructureSet_default_instance_);
}
inline const ::feedstore::StreamStructureSet& Record::stream_structures() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.stream_structures)
    return _internal_stream_structures();
}
inline ::feedstore::StreamStructureSet* Record::unsafe_arena_release_stream_structures()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.stream_structures)
    if (_internal_has_stream_structures()) {
        clear_has_data();
        ::feedstore::StreamStructureSet* temp = _impl_.data_.stream_structures_;
        _impl_.data_.stream_structures_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_stream_structures(::feedstore::StreamStructureSet* stream_structures)
{
    clear_data();
    if (stream_structures) {
        set_has_stream_structures();
        _impl_.data_.stream_structures_ = stream_structures;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.stream_structures)
}
inline ::feedstore::StreamStructureSet* Record::_internal_mutable_stream_structures()
{
    if (!_internal_has_stream_structures()) {
        clear_data();
        set_has_stream_structures();
        _impl_.data_.stream_structures_ = CreateMaybeMessage<::feedstore::StreamStructureSet>(GetArenaForAllocation());
    }
    return _impl_.data_.stream_structures_;
}
inline ::feedstore::StreamStructureSet* Record::mutable_stream_structures()
{
    ::feedstore::StreamStructureSet* _msg = _internal_mutable_stream_structures();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.stream_structures)
    return _msg;
}

// .feedstore.Content content = 3;
inline bool Record::_internal_has_content() const
{
    return data_case() == kContent;
}
inline bool Record::has_content() const
{
    return _internal_has_content();
}
inline void Record::set_has_content()
{
    _impl_._oneof_case_[0] = kContent;
}
inline void Record::clear_content()
{
    if (_internal_has_content()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.content_;
        }
        clear_has_data();
    }
}
inline ::feedstore::Content* Record::release_content()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.content)
    if (_internal_has_content()) {
        clear_has_data();
        ::feedstore::Content* temp = _impl_.data_.content_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.content_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::Content& Record::_internal_content() const
{
    return _internal_has_content() ? *_impl_.data_.content_ : reinterpret_cast<::feedstore::Content&>(::feedstore::_Content_default_instance_);
}
inline const ::feedstore::Content& Record::content() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.content)
    return _internal_content();
}
inline ::feedstore::Content* Record::unsafe_arena_release_content()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.content)
    if (_internal_has_content()) {
        clear_has_data();
        ::feedstore::Content* temp = _impl_.data_.content_;
        _impl_.data_.content_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_content(::feedstore::Content* content)
{
    clear_data();
    if (content) {
        set_has_content();
        _impl_.data_.content_ = content;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.content)
}
inline ::feedstore::Content* Record::_internal_mutable_content()
{
    if (!_internal_has_content()) {
        clear_data();
        set_has_content();
        _impl_.data_.content_ = CreateMaybeMessage<::feedstore::Content>(GetArenaForAllocation());
    }
    return _impl_.data_.content_;
}
inline ::feedstore::Content* Record::mutable_content()
{
    ::feedstore::Content* _msg = _internal_mutable_content();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.content)
    return _msg;
}

// .feedstore.StoredAction local_action = 4;
inline bool Record::_internal_has_local_action() const
{
    return data_case() == kLocalAction;
}
inline bool Record::has_local_action() const
{
    return _internal_has_local_action();
}
inline void Record::set_has_local_action()
{
    _impl_._oneof_case_[0] = kLocalAction;
}
inline void Record::clear_local_action()
{
    if (_internal_has_local_action()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.local_action_;
        }
        clear_has_data();
    }
}
inline ::feedstore::StoredAction* Record::release_local_action()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.local_action)
    if (_internal_has_local_action()) {
        clear_has_data();
        ::feedstore::StoredAction* temp = _impl_.data_.local_action_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.local_action_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::StoredAction& Record::_internal_local_action() const
{
    return _internal_has_local_action() ? *_impl_.data_.local_action_
                                        : reinterpret_cast<::feedstore::StoredAction&>(::feedstore::_StoredAction_default_instance_);
}
inline const ::feedstore::StoredAction& Record::local_action() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.local_action)
    return _internal_local_action();
}
inline ::feedstore::StoredAction* Record::unsafe_arena_release_local_action()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.local_action)
    if (_internal_has_local_action()) {
        clear_has_data();
        ::feedstore::StoredAction* temp = _impl_.data_.local_action_;
        _impl_.data_.local_action_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_local_action(::feedstore::StoredAction* local_action)
{
    clear_data();
    if (local_action) {
        set_has_local_action();
        _impl_.data_.local_action_ = local_action;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.local_action)
}
inline ::feedstore::StoredAction* Record::_internal_mutable_local_action()
{
    if (!_internal_has_local_action()) {
        clear_data();
        set_has_local_action();
        _impl_.data_.local_action_ = CreateMaybeMessage<::feedstore::StoredAction>(GetArenaForAllocation());
    }
    return _impl_.data_.local_action_;
}
inline ::feedstore::StoredAction* Record::mutable_local_action()
{
    ::feedstore::StoredAction* _msg = _internal_mutable_local_action();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.local_action)
    return _msg;
}

// .feedstore.StreamSharedState shared_state = 5;
inline bool Record::_internal_has_shared_state() const
{
    return data_case() == kSharedState;
}
inline bool Record::has_shared_state() const
{
    return _internal_has_shared_state();
}
inline void Record::set_has_shared_state()
{
    _impl_._oneof_case_[0] = kSharedState;
}
inline void Record::clear_shared_state()
{
    if (_internal_has_shared_state()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.shared_state_;
        }
        clear_has_data();
    }
}
inline ::feedstore::StreamSharedState* Record::release_shared_state()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.shared_state)
    if (_internal_has_shared_state()) {
        clear_has_data();
        ::feedstore::StreamSharedState* temp = _impl_.data_.shared_state_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.shared_state_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::StreamSharedState& Record::_internal_shared_state() const
{
    return _internal_has_shared_state() ? *_impl_.data_.shared_state_
                                        : reinterpret_cast<::feedstore::StreamSharedState&>(::feedstore::_StreamSharedState_default_instance_);
}
inline const ::feedstore::StreamSharedState& Record::shared_state() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.shared_state)
    return _internal_shared_state();
}
inline ::feedstore::StreamSharedState* Record::unsafe_arena_release_shared_state()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.shared_state)
    if (_internal_has_shared_state()) {
        clear_has_data();
        ::feedstore::StreamSharedState* temp = _impl_.data_.shared_state_;
        _impl_.data_.shared_state_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_shared_state(::feedstore::StreamSharedState* shared_state)
{
    clear_data();
    if (shared_state) {
        set_has_shared_state();
        _impl_.data_.shared_state_ = shared_state;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.shared_state)
}
inline ::feedstore::StreamSharedState* Record::_internal_mutable_shared_state()
{
    if (!_internal_has_shared_state()) {
        clear_data();
        set_has_shared_state();
        _impl_.data_.shared_state_ = CreateMaybeMessage<::feedstore::StreamSharedState>(GetArenaForAllocation());
    }
    return _impl_.data_.shared_state_;
}
inline ::feedstore::StreamSharedState* Record::mutable_shared_state()
{
    ::feedstore::StreamSharedState* _msg = _internal_mutable_shared_state();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.shared_state)
    return _msg;
}

// .feedstore.Metadata metadata = 6;
inline bool Record::_internal_has_metadata() const
{
    return data_case() == kMetadata;
}
inline bool Record::has_metadata() const
{
    return _internal_has_metadata();
}
inline void Record::set_has_metadata()
{
    _impl_._oneof_case_[0] = kMetadata;
}
inline void Record::clear_metadata()
{
    if (_internal_has_metadata()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.metadata_;
        }
        clear_has_data();
    }
}
inline ::feedstore::Metadata* Record::release_metadata()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.metadata)
    if (_internal_has_metadata()) {
        clear_has_data();
        ::feedstore::Metadata* temp = _impl_.data_.metadata_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::Metadata& Record::_internal_metadata() const
{
    return _internal_has_metadata() ? *_impl_.data_.metadata_ : reinterpret_cast<::feedstore::Metadata&>(::feedstore::_Metadata_default_instance_);
}
inline const ::feedstore::Metadata& Record::metadata() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.metadata)
    return _internal_metadata();
}
inline ::feedstore::Metadata* Record::unsafe_arena_release_metadata()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.metadata)
    if (_internal_has_metadata()) {
        clear_has_data();
        ::feedstore::Metadata* temp = _impl_.data_.metadata_;
        _impl_.data_.metadata_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_metadata(::feedstore::Metadata* metadata)
{
    clear_data();
    if (metadata) {
        set_has_metadata();
        _impl_.data_.metadata_ = metadata;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.metadata)
}
inline ::feedstore::Metadata* Record::_internal_mutable_metadata()
{
    if (!_internal_has_metadata()) {
        clear_data();
        set_has_metadata();
        _impl_.data_.metadata_ = CreateMaybeMessage<::feedstore::Metadata>(GetArenaForAllocation());
    }
    return _impl_.data_.metadata_;
}
inline ::feedstore::Metadata* Record::mutable_metadata()
{
    ::feedstore::Metadata* _msg = _internal_mutable_metadata();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.metadata)
    return _msg;
}

// .feedstore.SubscribedWebFeeds subscribed_web_feeds = 7;
inline bool Record::_internal_has_subscribed_web_feeds() const
{
    return data_case() == kSubscribedWebFeeds;
}
inline bool Record::has_subscribed_web_feeds() const
{
    return _internal_has_subscribed_web_feeds();
}
inline void Record::set_has_subscribed_web_feeds()
{
    _impl_._oneof_case_[0] = kSubscribedWebFeeds;
}
inline void Record::clear_subscribed_web_feeds()
{
    if (_internal_has_subscribed_web_feeds()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.subscribed_web_feeds_;
        }
        clear_has_data();
    }
}
inline ::feedstore::SubscribedWebFeeds* Record::release_subscribed_web_feeds()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.subscribed_web_feeds)
    if (_internal_has_subscribed_web_feeds()) {
        clear_has_data();
        ::feedstore::SubscribedWebFeeds* temp = _impl_.data_.subscribed_web_feeds_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.subscribed_web_feeds_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::SubscribedWebFeeds& Record::_internal_subscribed_web_feeds() const
{
    return _internal_has_subscribed_web_feeds() ? *_impl_.data_.subscribed_web_feeds_
                                                : reinterpret_cast<::feedstore::SubscribedWebFeeds&>(::feedstore::_SubscribedWebFeeds_default_instance_);
}
inline const ::feedstore::SubscribedWebFeeds& Record::subscribed_web_feeds() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.subscribed_web_feeds)
    return _internal_subscribed_web_feeds();
}
inline ::feedstore::SubscribedWebFeeds* Record::unsafe_arena_release_subscribed_web_feeds()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.subscribed_web_feeds)
    if (_internal_has_subscribed_web_feeds()) {
        clear_has_data();
        ::feedstore::SubscribedWebFeeds* temp = _impl_.data_.subscribed_web_feeds_;
        _impl_.data_.subscribed_web_feeds_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_subscribed_web_feeds(::feedstore::SubscribedWebFeeds* subscribed_web_feeds)
{
    clear_data();
    if (subscribed_web_feeds) {
        set_has_subscribed_web_feeds();
        _impl_.data_.subscribed_web_feeds_ = subscribed_web_feeds;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.subscribed_web_feeds)
}
inline ::feedstore::SubscribedWebFeeds* Record::_internal_mutable_subscribed_web_feeds()
{
    if (!_internal_has_subscribed_web_feeds()) {
        clear_data();
        set_has_subscribed_web_feeds();
        _impl_.data_.subscribed_web_feeds_ = CreateMaybeMessage<::feedstore::SubscribedWebFeeds>(GetArenaForAllocation());
    }
    return _impl_.data_.subscribed_web_feeds_;
}
inline ::feedstore::SubscribedWebFeeds* Record::mutable_subscribed_web_feeds()
{
    ::feedstore::SubscribedWebFeeds* _msg = _internal_mutable_subscribed_web_feeds();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.subscribed_web_feeds)
    return _msg;
}

// .feedstore.WebFeedInfo recommended_web_feed = 8;
inline bool Record::_internal_has_recommended_web_feed() const
{
    return data_case() == kRecommendedWebFeed;
}
inline bool Record::has_recommended_web_feed() const
{
    return _internal_has_recommended_web_feed();
}
inline void Record::set_has_recommended_web_feed()
{
    _impl_._oneof_case_[0] = kRecommendedWebFeed;
}
inline void Record::clear_recommended_web_feed()
{
    if (_internal_has_recommended_web_feed()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.recommended_web_feed_;
        }
        clear_has_data();
    }
}
inline ::feedstore::WebFeedInfo* Record::release_recommended_web_feed()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.recommended_web_feed)
    if (_internal_has_recommended_web_feed()) {
        clear_has_data();
        ::feedstore::WebFeedInfo* temp = _impl_.data_.recommended_web_feed_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.recommended_web_feed_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::WebFeedInfo& Record::_internal_recommended_web_feed() const
{
    return _internal_has_recommended_web_feed() ? *_impl_.data_.recommended_web_feed_
                                                : reinterpret_cast<::feedstore::WebFeedInfo&>(::feedstore::_WebFeedInfo_default_instance_);
}
inline const ::feedstore::WebFeedInfo& Record::recommended_web_feed() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.recommended_web_feed)
    return _internal_recommended_web_feed();
}
inline ::feedstore::WebFeedInfo* Record::unsafe_arena_release_recommended_web_feed()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.recommended_web_feed)
    if (_internal_has_recommended_web_feed()) {
        clear_has_data();
        ::feedstore::WebFeedInfo* temp = _impl_.data_.recommended_web_feed_;
        _impl_.data_.recommended_web_feed_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_recommended_web_feed(::feedstore::WebFeedInfo* recommended_web_feed)
{
    clear_data();
    if (recommended_web_feed) {
        set_has_recommended_web_feed();
        _impl_.data_.recommended_web_feed_ = recommended_web_feed;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.recommended_web_feed)
}
inline ::feedstore::WebFeedInfo* Record::_internal_mutable_recommended_web_feed()
{
    if (!_internal_has_recommended_web_feed()) {
        clear_data();
        set_has_recommended_web_feed();
        _impl_.data_.recommended_web_feed_ = CreateMaybeMessage<::feedstore::WebFeedInfo>(GetArenaForAllocation());
    }
    return _impl_.data_.recommended_web_feed_;
}
inline ::feedstore::WebFeedInfo* Record::mutable_recommended_web_feed()
{
    ::feedstore::WebFeedInfo* _msg = _internal_mutable_recommended_web_feed();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.recommended_web_feed)
    return _msg;
}

// .feedstore.RecommendedWebFeedIndex recommended_web_feed_index = 9;
inline bool Record::_internal_has_recommended_web_feed_index() const
{
    return data_case() == kRecommendedWebFeedIndex;
}
inline bool Record::has_recommended_web_feed_index() const
{
    return _internal_has_recommended_web_feed_index();
}
inline void Record::set_has_recommended_web_feed_index()
{
    _impl_._oneof_case_[0] = kRecommendedWebFeedIndex;
}
inline void Record::clear_recommended_web_feed_index()
{
    if (_internal_has_recommended_web_feed_index()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.recommended_web_feed_index_;
        }
        clear_has_data();
    }
}
inline ::feedstore::RecommendedWebFeedIndex* Record::release_recommended_web_feed_index()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.recommended_web_feed_index)
    if (_internal_has_recommended_web_feed_index()) {
        clear_has_data();
        ::feedstore::RecommendedWebFeedIndex* temp = _impl_.data_.recommended_web_feed_index_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.recommended_web_feed_index_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::RecommendedWebFeedIndex& Record::_internal_recommended_web_feed_index() const
{
    return _internal_has_recommended_web_feed_index()
        ? *_impl_.data_.recommended_web_feed_index_
        : reinterpret_cast<::feedstore::RecommendedWebFeedIndex&>(::feedstore::_RecommendedWebFeedIndex_default_instance_);
}
inline const ::feedstore::RecommendedWebFeedIndex& Record::recommended_web_feed_index() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.recommended_web_feed_index)
    return _internal_recommended_web_feed_index();
}
inline ::feedstore::RecommendedWebFeedIndex* Record::unsafe_arena_release_recommended_web_feed_index()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.recommended_web_feed_index)
    if (_internal_has_recommended_web_feed_index()) {
        clear_has_data();
        ::feedstore::RecommendedWebFeedIndex* temp = _impl_.data_.recommended_web_feed_index_;
        _impl_.data_.recommended_web_feed_index_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_recommended_web_feed_index(::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index)
{
    clear_data();
    if (recommended_web_feed_index) {
        set_has_recommended_web_feed_index();
        _impl_.data_.recommended_web_feed_index_ = recommended_web_feed_index;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.recommended_web_feed_index)
}
inline ::feedstore::RecommendedWebFeedIndex* Record::_internal_mutable_recommended_web_feed_index()
{
    if (!_internal_has_recommended_web_feed_index()) {
        clear_data();
        set_has_recommended_web_feed_index();
        _impl_.data_.recommended_web_feed_index_ = CreateMaybeMessage<::feedstore::RecommendedWebFeedIndex>(GetArenaForAllocation());
    }
    return _impl_.data_.recommended_web_feed_index_;
}
inline ::feedstore::RecommendedWebFeedIndex* Record::mutable_recommended_web_feed_index()
{
    ::feedstore::RecommendedWebFeedIndex* _msg = _internal_mutable_recommended_web_feed_index();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.recommended_web_feed_index)
    return _msg;
}

// .feedstore.PendingWebFeedOperation pending_web_feed_operation = 10;
inline bool Record::_internal_has_pending_web_feed_operation() const
{
    return data_case() == kPendingWebFeedOperation;
}
inline bool Record::has_pending_web_feed_operation() const
{
    return _internal_has_pending_web_feed_operation();
}
inline void Record::set_has_pending_web_feed_operation()
{
    _impl_._oneof_case_[0] = kPendingWebFeedOperation;
}
inline void Record::clear_pending_web_feed_operation()
{
    if (_internal_has_pending_web_feed_operation()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.pending_web_feed_operation_;
        }
        clear_has_data();
    }
}
inline ::feedstore::PendingWebFeedOperation* Record::release_pending_web_feed_operation()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.pending_web_feed_operation)
    if (_internal_has_pending_web_feed_operation()) {
        clear_has_data();
        ::feedstore::PendingWebFeedOperation* temp = _impl_.data_.pending_web_feed_operation_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.pending_web_feed_operation_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::PendingWebFeedOperation& Record::_internal_pending_web_feed_operation() const
{
    return _internal_has_pending_web_feed_operation()
        ? *_impl_.data_.pending_web_feed_operation_
        : reinterpret_cast<::feedstore::PendingWebFeedOperation&>(::feedstore::_PendingWebFeedOperation_default_instance_);
}
inline const ::feedstore::PendingWebFeedOperation& Record::pending_web_feed_operation() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.pending_web_feed_operation)
    return _internal_pending_web_feed_operation();
}
inline ::feedstore::PendingWebFeedOperation* Record::unsafe_arena_release_pending_web_feed_operation()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.pending_web_feed_operation)
    if (_internal_has_pending_web_feed_operation()) {
        clear_has_data();
        ::feedstore::PendingWebFeedOperation* temp = _impl_.data_.pending_web_feed_operation_;
        _impl_.data_.pending_web_feed_operation_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_pending_web_feed_operation(::feedstore::PendingWebFeedOperation* pending_web_feed_operation)
{
    clear_data();
    if (pending_web_feed_operation) {
        set_has_pending_web_feed_operation();
        _impl_.data_.pending_web_feed_operation_ = pending_web_feed_operation;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.pending_web_feed_operation)
}
inline ::feedstore::PendingWebFeedOperation* Record::_internal_mutable_pending_web_feed_operation()
{
    if (!_internal_has_pending_web_feed_operation()) {
        clear_data();
        set_has_pending_web_feed_operation();
        _impl_.data_.pending_web_feed_operation_ = CreateMaybeMessage<::feedstore::PendingWebFeedOperation>(GetArenaForAllocation());
    }
    return _impl_.data_.pending_web_feed_operation_;
}
inline ::feedstore::PendingWebFeedOperation* Record::mutable_pending_web_feed_operation()
{
    ::feedstore::PendingWebFeedOperation* _msg = _internal_mutable_pending_web_feed_operation();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.pending_web_feed_operation)
    return _msg;
}

// .feedstore.DocView doc_view = 11;
inline bool Record::_internal_has_doc_view() const
{
    return data_case() == kDocView;
}
inline bool Record::has_doc_view() const
{
    return _internal_has_doc_view();
}
inline void Record::set_has_doc_view()
{
    _impl_._oneof_case_[0] = kDocView;
}
inline void Record::clear_doc_view()
{
    if (_internal_has_doc_view()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.doc_view_;
        }
        clear_has_data();
    }
}
inline ::feedstore::DocView* Record::release_doc_view()
{
    // @@protoc_insertion_point(field_release:feedstore.Record.doc_view)
    if (_internal_has_doc_view()) {
        clear_has_data();
        ::feedstore::DocView* temp = _impl_.data_.doc_view_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.data_.doc_view_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedstore::DocView& Record::_internal_doc_view() const
{
    return _internal_has_doc_view() ? *_impl_.data_.doc_view_ : reinterpret_cast<::feedstore::DocView&>(::feedstore::_DocView_default_instance_);
}
inline const ::feedstore::DocView& Record::doc_view() const
{
    // @@protoc_insertion_point(field_get:feedstore.Record.doc_view)
    return _internal_doc_view();
}
inline ::feedstore::DocView* Record::unsafe_arena_release_doc_view()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.doc_view)
    if (_internal_has_doc_view()) {
        clear_has_data();
        ::feedstore::DocView* temp = _impl_.data_.doc_view_;
        _impl_.data_.doc_view_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Record::unsafe_arena_set_allocated_doc_view(::feedstore::DocView* doc_view)
{
    clear_data();
    if (doc_view) {
        set_has_doc_view();
        _impl_.data_.doc_view_ = doc_view;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.doc_view)
}
inline ::feedstore::DocView* Record::_internal_mutable_doc_view()
{
    if (!_internal_has_doc_view()) {
        clear_data();
        set_has_doc_view();
        _impl_.data_.doc_view_ = CreateMaybeMessage<::feedstore::DocView>(GetArenaForAllocation());
    }
    return _impl_.data_.doc_view_;
}
inline ::feedstore::DocView* Record::mutable_doc_view()
{
    ::feedstore::DocView* _msg = _internal_mutable_doc_view();
    // @@protoc_insertion_point(field_mutable:feedstore.Record.doc_view)
    return _msg;
}

inline bool Record::has_data() const
{
    return data_case() != DATA_NOT_SET;
}
inline void Record::clear_has_data()
{
    _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline Record::DataCase Record::data_case() const
{
    return Record::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamContentHashList

// repeated uint32 hashes = 1;
inline int StreamContentHashList::_internal_hashes_size() const
{
    return _impl_.hashes_.size();
}
inline int StreamContentHashList::hashes_size() const
{
    return _internal_hashes_size();
}
inline void StreamContentHashList::clear_hashes()
{
    _impl_.hashes_.Clear();
}
inline uint32_t StreamContentHashList::_internal_hashes(int index) const
{
    return _impl_.hashes_.Get(index);
}
inline uint32_t StreamContentHashList::hashes(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamContentHashList.hashes)
    return _internal_hashes(index);
}
inline void StreamContentHashList::set_hashes(int index, uint32_t value)
{
    _impl_.hashes_.Set(index, value);
    // @@protoc_insertion_point(field_set:feedstore.StreamContentHashList.hashes)
}
inline void StreamContentHashList::_internal_add_hashes(uint32_t value)
{
    _impl_.hashes_.Add(value);
}
inline void StreamContentHashList::add_hashes(uint32_t value)
{
    _internal_add_hashes(value);
    // @@protoc_insertion_point(field_add:feedstore.StreamContentHashList.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& StreamContentHashList::_internal_hashes() const
{
    return _impl_.hashes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& StreamContentHashList::hashes() const
{
    // @@protoc_insertion_point(field_list:feedstore.StreamContentHashList.hashes)
    return _internal_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* StreamContentHashList::_internal_mutable_hashes()
{
    return &_impl_.hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* StreamContentHashList::mutable_hashes()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.StreamContentHashList.hashes)
    return _internal_mutable_hashes();
}

// -------------------------------------------------------------------

// StreamData

// .feedwire.ContentId content_id = 1;
inline bool StreamData::_internal_has_content_id() const
{
    return this != internal_default_instance() && _impl_.content_id_ != nullptr;
}
inline bool StreamData::has_content_id() const
{
    return _internal_has_content_id();
}
inline const ::feedwire::ContentId& StreamData::_internal_content_id() const
{
    const ::feedwire::ContentId* p = _impl_.content_id_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& StreamData::content_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.content_id)
    return _internal_content_id();
}
inline void StreamData::unsafe_arena_set_allocated_content_id(::feedwire::ContentId* content_id)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_id_);
    }
    _impl_.content_id_ = content_id;
    if (content_id) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamData.content_id)
}
inline ::feedwire::ContentId* StreamData::release_content_id()
{

    ::feedwire::ContentId* temp = _impl_.content_id_;
    _impl_.content_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::ContentId* StreamData::unsafe_arena_release_content_id()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamData.content_id)

    ::feedwire::ContentId* temp = _impl_.content_id_;
    _impl_.content_id_ = nullptr;
    return temp;
}
inline ::feedwire::ContentId* StreamData::_internal_mutable_content_id()
{

    if (_impl_.content_id_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
        _impl_.content_id_ = p;
    }
    return _impl_.content_id_;
}
inline ::feedwire::ContentId* StreamData::mutable_content_id()
{
    ::feedwire::ContentId* _msg = _internal_mutable_content_id();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamData.content_id)
    return _msg;
}
inline void StreamData::set_allocated_content_id(::feedwire::ContentId* content_id)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_id_);
    }
    if (content_id) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id));
        if (message_arena != submessage_arena) {
            content_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content_id, submessage_arena);
        }

    } else {
    }
    _impl_.content_id_ = content_id;
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.content_id)
}

// bytes next_page_token = 2;
inline void StreamData::clear_next_page_token()
{
    _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& StreamData::next_page_token() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.next_page_token)
    return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StreamData::set_next_page_token(ArgT0&& arg0, ArgT... args)
{

    _impl_.next_page_token_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.StreamData.next_page_token)
}
inline std::string* StreamData::mutable_next_page_token()
{
    std::string* _s = _internal_mutable_next_page_token();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamData.next_page_token)
    return _s;
}
inline const std::string& StreamData::_internal_next_page_token() const
{
    return _impl_.next_page_token_.Get();
}
inline void StreamData::_internal_set_next_page_token(const std::string& value)
{

    _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_next_page_token()
{

    return _impl_.next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_next_page_token()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamData.next_page_token)
    return _impl_.next_page_token_.Release();
}
inline void StreamData::set_allocated_next_page_token(std::string* next_page_token)
{
    if (next_page_token != nullptr) {

    } else {
    }
    _impl_.next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.next_page_token_.IsDefault()) {
        _impl_.next_page_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.next_page_token)
}

// int64 last_added_time_millis = 4;
inline void StreamData::clear_last_added_time_millis()
{
    _impl_.last_added_time_millis_ = int64_t { 0 };
}
inline int64_t StreamData::_internal_last_added_time_millis() const
{
    return _impl_.last_added_time_millis_;
}
inline int64_t StreamData::last_added_time_millis() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.last_added_time_millis)
    return _internal_last_added_time_millis();
}
inline void StreamData::_internal_set_last_added_time_millis(int64_t value)
{

    _impl_.last_added_time_millis_ = value;
}
inline void StreamData::set_last_added_time_millis(int64_t value)
{
    _internal_set_last_added_time_millis(value);
    // @@protoc_insertion_point(field_set:feedstore.StreamData.last_added_time_millis)
}

// repeated .feedwire.ContentId shared_state_ids = 6;
inline int StreamData::_internal_shared_state_ids_size() const
{
    return _impl_.shared_state_ids_.size();
}
inline int StreamData::shared_state_ids_size() const
{
    return _internal_shared_state_ids_size();
}
inline ::feedwire::ContentId* StreamData::mutable_shared_state_ids(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.StreamData.shared_state_ids)
    return _impl_.shared_state_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::ContentId>* StreamData::mutable_shared_state_ids()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.StreamData.shared_state_ids)
    return &_impl_.shared_state_ids_;
}
inline const ::feedwire::ContentId& StreamData::_internal_shared_state_ids(int index) const
{
    return _impl_.shared_state_ids_.Get(index);
}
inline const ::feedwire::ContentId& StreamData::shared_state_ids(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.shared_state_ids)
    return _internal_shared_state_ids(index);
}
inline ::feedwire::ContentId* StreamData::_internal_add_shared_state_ids()
{
    return _impl_.shared_state_ids_.Add();
}
inline ::feedwire::ContentId* StreamData::add_shared_state_ids()
{
    ::feedwire::ContentId* _add = _internal_add_shared_state_ids();
    // @@protoc_insertion_point(field_add:feedstore.StreamData.shared_state_ids)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::ContentId>& StreamData::shared_state_ids() const
{
    // @@protoc_insertion_point(field_list:feedstore.StreamData.shared_state_ids)
    return _impl_.shared_state_ids_;
}

// bool signed_in = 7;
inline void StreamData::clear_signed_in()
{
    _impl_.signed_in_ = false;
}
inline bool StreamData::_internal_signed_in() const
{
    return _impl_.signed_in_;
}
inline bool StreamData::signed_in() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.signed_in)
    return _internal_signed_in();
}
inline void StreamData::_internal_set_signed_in(bool value)
{

    _impl_.signed_in_ = value;
}
inline void StreamData::set_signed_in(bool value)
{
    _internal_set_signed_in(value);
    // @@protoc_insertion_point(field_set:feedstore.StreamData.signed_in)
}

// string gaia = 13;
inline void StreamData::clear_gaia()
{
    _impl_.gaia_.ClearToEmpty();
}
inline const std::string& StreamData::gaia() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.gaia)
    return _internal_gaia();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StreamData::set_gaia(ArgT0&& arg0, ArgT... args)
{

    _impl_.gaia_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.StreamData.gaia)
}
inline std::string* StreamData::mutable_gaia()
{
    std::string* _s = _internal_mutable_gaia();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamData.gaia)
    return _s;
}
inline const std::string& StreamData::_internal_gaia() const
{
    return _impl_.gaia_.Get();
}
inline void StreamData::_internal_set_gaia(const std::string& value)
{

    _impl_.gaia_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_gaia()
{

    return _impl_.gaia_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_gaia()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamData.gaia)
    return _impl_.gaia_.Release();
}
inline void StreamData::set_allocated_gaia(std::string* gaia)
{
    if (gaia != nullptr) {

    } else {
    }
    _impl_.gaia_.SetAllocated(gaia, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.gaia_.IsDefault()) {
        _impl_.gaia_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.gaia)
}

// string email = 14;
inline void StreamData::clear_email()
{
    _impl_.email_.ClearToEmpty();
}
inline const std::string& StreamData::email() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.email)
    return _internal_email();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StreamData::set_email(ArgT0&& arg0, ArgT... args)
{

    _impl_.email_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.StreamData.email)
}
inline std::string* StreamData::mutable_email()
{
    std::string* _s = _internal_mutable_email();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamData.email)
    return _s;
}
inline const std::string& StreamData::_internal_email() const
{
    return _impl_.email_.Get();
}
inline void StreamData::_internal_set_email(const std::string& value)
{

    _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_email()
{

    return _impl_.email_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_email()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamData.email)
    return _impl_.email_.Release();
}
inline void StreamData::set_allocated_email(std::string* email)
{
    if (email != nullptr) {

    } else {
    }
    _impl_.email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.email_.IsDefault()) {
        _impl_.email_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.email)
}

// bool logging_enabled = 8;
inline void StreamData::clear_logging_enabled()
{
    _impl_.logging_enabled_ = false;
}
inline bool StreamData::_internal_logging_enabled() const
{
    return _impl_.logging_enabled_;
}
inline bool StreamData::logging_enabled() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.logging_enabled)
    return _internal_logging_enabled();
}
inline void StreamData::_internal_set_logging_enabled(bool value)
{

    _impl_.logging_enabled_ = value;
}
inline void StreamData::set_logging_enabled(bool value)
{
    _internal_set_logging_enabled(value);
    // @@protoc_insertion_point(field_set:feedstore.StreamData.logging_enabled)
}

// bool privacy_notice_fulfilled = 9;
inline void StreamData::clear_privacy_notice_fulfilled()
{
    _impl_.privacy_notice_fulfilled_ = false;
}
inline bool StreamData::_internal_privacy_notice_fulfilled() const
{
    return _impl_.privacy_notice_fulfilled_;
}
inline bool StreamData::privacy_notice_fulfilled() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.privacy_notice_fulfilled)
    return _internal_privacy_notice_fulfilled();
}
inline void StreamData::_internal_set_privacy_notice_fulfilled(bool value)
{

    _impl_.privacy_notice_fulfilled_ = value;
}
inline void StreamData::set_privacy_notice_fulfilled(bool value)
{
    _internal_set_privacy_notice_fulfilled(value);
    // @@protoc_insertion_point(field_set:feedstore.StreamData.privacy_notice_fulfilled)
}

// string stream_key = 10;
inline void StreamData::clear_stream_key()
{
    _impl_.stream_key_.ClearToEmpty();
}
inline const std::string& StreamData::stream_key() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.stream_key)
    return _internal_stream_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StreamData::set_stream_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.stream_key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.StreamData.stream_key)
}
inline std::string* StreamData::mutable_stream_key()
{
    std::string* _s = _internal_mutable_stream_key();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamData.stream_key)
    return _s;
}
inline const std::string& StreamData::_internal_stream_key() const
{
    return _impl_.stream_key_.Get();
}
inline void StreamData::_internal_set_stream_key(const std::string& value)
{

    _impl_.stream_key_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_stream_key()
{

    return _impl_.stream_key_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_stream_key()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamData.stream_key)
    return _impl_.stream_key_.Release();
}
inline void StreamData::set_allocated_stream_key(std::string* stream_key)
{
    if (stream_key != nullptr) {

    } else {
    }
    _impl_.stream_key_.SetAllocated(stream_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.stream_key_.IsDefault()) {
        _impl_.stream_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.stream_key)
}

// repeated .feedstore.StreamContentHashList content_hashes = 11;
inline int StreamData::_internal_content_hashes_size() const
{
    return _impl_.content_hashes_.size();
}
inline int StreamData::content_hashes_size() const
{
    return _internal_content_hashes_size();
}
inline void StreamData::clear_content_hashes()
{
    _impl_.content_hashes_.Clear();
}
inline ::feedstore::StreamContentHashList* StreamData::mutable_content_hashes(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.StreamData.content_hashes)
    return _impl_.content_hashes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList>* StreamData::mutable_content_hashes()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.StreamData.content_hashes)
    return &_impl_.content_hashes_;
}
inline const ::feedstore::StreamContentHashList& StreamData::_internal_content_hashes(int index) const
{
    return _impl_.content_hashes_.Get(index);
}
inline const ::feedstore::StreamContentHashList& StreamData::content_hashes(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.content_hashes)
    return _internal_content_hashes(index);
}
inline ::feedstore::StreamContentHashList* StreamData::_internal_add_content_hashes()
{
    return _impl_.content_hashes_.Add();
}
inline ::feedstore::StreamContentHashList* StreamData::add_content_hashes()
{
    ::feedstore::StreamContentHashList* _add = _internal_add_content_hashes();
    // @@protoc_insertion_point(field_add:feedstore.StreamData.content_hashes)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList>& StreamData::content_hashes() const
{
    // @@protoc_insertion_point(field_list:feedstore.StreamData.content_hashes)
    return _impl_.content_hashes_;
}

// bytes root_event_id = 12;
inline void StreamData::clear_root_event_id()
{
    _impl_.root_event_id_.ClearToEmpty();
}
inline const std::string& StreamData::root_event_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamData.root_event_id)
    return _internal_root_event_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StreamData::set_root_event_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.root_event_id_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.StreamData.root_event_id)
}
inline std::string* StreamData::mutable_root_event_id()
{
    std::string* _s = _internal_mutable_root_event_id();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamData.root_event_id)
    return _s;
}
inline const std::string& StreamData::_internal_root_event_id() const
{
    return _impl_.root_event_id_.Get();
}
inline void StreamData::_internal_set_root_event_id(const std::string& value)
{

    _impl_.root_event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_root_event_id()
{

    return _impl_.root_event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_root_event_id()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamData.root_event_id)
    return _impl_.root_event_id_.Release();
}
inline void StreamData::set_allocated_root_event_id(std::string* root_event_id)
{
    if (root_event_id != nullptr) {

    } else {
    }
    _impl_.root_event_id_.SetAllocated(root_event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.root_event_id_.IsDefault()) {
        _impl_.root_event_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.root_event_id)
}

// -------------------------------------------------------------------

// Metadata_SessionID

// string token = 1;
inline void Metadata_SessionID::clear_token()
{
    _impl_.token_.ClearToEmpty();
}
inline const std::string& Metadata_SessionID::token() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.SessionID.token)
    return _internal_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Metadata_SessionID::set_token(ArgT0&& arg0, ArgT... args)
{

    _impl_.token_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.Metadata.SessionID.token)
}
inline std::string* Metadata_SessionID::mutable_token()
{
    std::string* _s = _internal_mutable_token();
    // @@protoc_insertion_point(field_mutable:feedstore.Metadata.SessionID.token)
    return _s;
}
inline const std::string& Metadata_SessionID::_internal_token() const
{
    return _impl_.token_.Get();
}
inline void Metadata_SessionID::_internal_set_token(const std::string& value)
{

    _impl_.token_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata_SessionID::_internal_mutable_token()
{

    return _impl_.token_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata_SessionID::release_token()
{
    // @@protoc_insertion_point(field_release:feedstore.Metadata.SessionID.token)
    return _impl_.token_.Release();
}
inline void Metadata_SessionID::set_allocated_token(std::string* token)
{
    if (token != nullptr) {

    } else {
    }
    _impl_.token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.token_.IsDefault()) {
        _impl_.token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.SessionID.token)
}

// int64 expiry_time_ms = 2;
inline void Metadata_SessionID::clear_expiry_time_ms()
{
    _impl_.expiry_time_ms_ = int64_t { 0 };
}
inline int64_t Metadata_SessionID::_internal_expiry_time_ms() const
{
    return _impl_.expiry_time_ms_;
}
inline int64_t Metadata_SessionID::expiry_time_ms() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.SessionID.expiry_time_ms)
    return _internal_expiry_time_ms();
}
inline void Metadata_SessionID::_internal_set_expiry_time_ms(int64_t value)
{

    _impl_.expiry_time_ms_ = value;
}
inline void Metadata_SessionID::set_expiry_time_ms(int64_t value)
{
    _internal_set_expiry_time_ms(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.SessionID.expiry_time_ms)
}

// -------------------------------------------------------------------

// Metadata_StreamMetadata_ContentLifetime

// int64 stale_age_ms = 1;
inline void Metadata_StreamMetadata_ContentLifetime::clear_stale_age_ms()
{
    _impl_.stale_age_ms_ = int64_t { 0 };
}
inline int64_t Metadata_StreamMetadata_ContentLifetime::_internal_stale_age_ms() const
{
    return _impl_.stale_age_ms_;
}
inline int64_t Metadata_StreamMetadata_ContentLifetime::stale_age_ms() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.ContentLifetime.stale_age_ms)
    return _internal_stale_age_ms();
}
inline void Metadata_StreamMetadata_ContentLifetime::_internal_set_stale_age_ms(int64_t value)
{

    _impl_.stale_age_ms_ = value;
}
inline void Metadata_StreamMetadata_ContentLifetime::set_stale_age_ms(int64_t value)
{
    _internal_set_stale_age_ms(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.ContentLifetime.stale_age_ms)
}

// int64 invalid_age_ms = 2;
inline void Metadata_StreamMetadata_ContentLifetime::clear_invalid_age_ms()
{
    _impl_.invalid_age_ms_ = int64_t { 0 };
}
inline int64_t Metadata_StreamMetadata_ContentLifetime::_internal_invalid_age_ms() const
{
    return _impl_.invalid_age_ms_;
}
inline int64_t Metadata_StreamMetadata_ContentLifetime::invalid_age_ms() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.ContentLifetime.invalid_age_ms)
    return _internal_invalid_age_ms();
}
inline void Metadata_StreamMetadata_ContentLifetime::_internal_set_invalid_age_ms(int64_t value)
{

    _impl_.invalid_age_ms_ = value;
}
inline void Metadata_StreamMetadata_ContentLifetime::set_invalid_age_ms(int64_t value)
{
    _internal_set_invalid_age_ms(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.ContentLifetime.invalid_age_ms)
}

// -------------------------------------------------------------------

// Metadata_StreamMetadata

// string stream_key = 1;
inline void Metadata_StreamMetadata::clear_stream_key()
{
    _impl_.stream_key_.ClearToEmpty();
}
inline const std::string& Metadata_StreamMetadata::stream_key() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.stream_key)
    return _internal_stream_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Metadata_StreamMetadata::set_stream_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.stream_key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.stream_key)
}
inline std::string* Metadata_StreamMetadata::mutable_stream_key()
{
    std::string* _s = _internal_mutable_stream_key();
    // @@protoc_insertion_point(field_mutable:feedstore.Metadata.StreamMetadata.stream_key)
    return _s;
}
inline const std::string& Metadata_StreamMetadata::_internal_stream_key() const
{
    return _impl_.stream_key_.Get();
}
inline void Metadata_StreamMetadata::_internal_set_stream_key(const std::string& value)
{

    _impl_.stream_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata_StreamMetadata::_internal_mutable_stream_key()
{

    return _impl_.stream_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata_StreamMetadata::release_stream_key()
{
    // @@protoc_insertion_point(field_release:feedstore.Metadata.StreamMetadata.stream_key)
    return _impl_.stream_key_.Release();
}
inline void Metadata_StreamMetadata::set_allocated_stream_key(std::string* stream_key)
{
    if (stream_key != nullptr) {

    } else {
    }
    _impl_.stream_key_.SetAllocated(stream_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.stream_key_.IsDefault()) {
        _impl_.stream_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.StreamMetadata.stream_key)
}

// bool is_known_stale = 3;
inline void Metadata_StreamMetadata::clear_is_known_stale()
{
    _impl_.is_known_stale_ = false;
}
inline bool Metadata_StreamMetadata::_internal_is_known_stale() const
{
    return _impl_.is_known_stale_;
}
inline bool Metadata_StreamMetadata::is_known_stale() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.is_known_stale)
    return _internal_is_known_stale();
}
inline void Metadata_StreamMetadata::_internal_set_is_known_stale(bool value)
{

    _impl_.is_known_stale_ = value;
}
inline void Metadata_StreamMetadata::set_is_known_stale(bool value)
{
    _internal_set_is_known_stale(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.is_known_stale)
}

// repeated .feedstore.StreamContentHashList view_content_hashes = 4;
inline int Metadata_StreamMetadata::_internal_view_content_hashes_size() const
{
    return _impl_.view_content_hashes_.size();
}
inline int Metadata_StreamMetadata::view_content_hashes_size() const
{
    return _internal_view_content_hashes_size();
}
inline void Metadata_StreamMetadata::clear_view_content_hashes()
{
    _impl_.view_content_hashes_.Clear();
}
inline ::feedstore::StreamContentHashList* Metadata_StreamMetadata::mutable_view_content_hashes(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.Metadata.StreamMetadata.view_content_hashes)
    return _impl_.view_content_hashes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList>* Metadata_StreamMetadata::mutable_view_content_hashes()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.Metadata.StreamMetadata.view_content_hashes)
    return &_impl_.view_content_hashes_;
}
inline const ::feedstore::StreamContentHashList& Metadata_StreamMetadata::_internal_view_content_hashes(int index) const
{
    return _impl_.view_content_hashes_.Get(index);
}
inline const ::feedstore::StreamContentHashList& Metadata_StreamMetadata::view_content_hashes(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.view_content_hashes)
    return _internal_view_content_hashes(index);
}
inline ::feedstore::StreamContentHashList* Metadata_StreamMetadata::_internal_add_view_content_hashes()
{
    return _impl_.view_content_hashes_.Add();
}
inline ::feedstore::StreamContentHashList* Metadata_StreamMetadata::add_view_content_hashes()
{
    ::feedstore::StreamContentHashList* _add = _internal_add_view_content_hashes();
    // @@protoc_insertion_point(field_add:feedstore.Metadata.StreamMetadata.view_content_hashes)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamContentHashList>& Metadata_StreamMetadata::view_content_hashes() const
{
    // @@protoc_insertion_point(field_list:feedstore.Metadata.StreamMetadata.view_content_hashes)
    return _impl_.view_content_hashes_;
}

// .feedstore.Metadata.StreamMetadata.ContentLifetime content_lifetime = 5;
inline bool Metadata_StreamMetadata::_internal_has_content_lifetime() const
{
    return this != internal_default_instance() && _impl_.content_lifetime_ != nullptr;
}
inline bool Metadata_StreamMetadata::has_content_lifetime() const
{
    return _internal_has_content_lifetime();
}
inline void Metadata_StreamMetadata::clear_content_lifetime()
{
    if (GetArenaForAllocation() == nullptr && _impl_.content_lifetime_ != nullptr) {
        delete _impl_.content_lifetime_;
    }
    _impl_.content_lifetime_ = nullptr;
}
inline const ::feedstore::Metadata_StreamMetadata_ContentLifetime& Metadata_StreamMetadata::_internal_content_lifetime() const
{
    const ::feedstore::Metadata_StreamMetadata_ContentLifetime* p = _impl_.content_lifetime_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::feedstore::Metadata_StreamMetadata_ContentLifetime&>(
                            ::feedstore::_Metadata_StreamMetadata_ContentLifetime_default_instance_);
}
inline const ::feedstore::Metadata_StreamMetadata_ContentLifetime& Metadata_StreamMetadata::content_lifetime() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.content_lifetime)
    return _internal_content_lifetime();
}
inline void Metadata_StreamMetadata::unsafe_arena_set_allocated_content_lifetime(::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_lifetime_);
    }
    _impl_.content_lifetime_ = content_lifetime;
    if (content_lifetime) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Metadata.StreamMetadata.content_lifetime)
}
inline ::feedstore::Metadata_StreamMetadata_ContentLifetime* Metadata_StreamMetadata::release_content_lifetime()
{

    ::feedstore::Metadata_StreamMetadata_ContentLifetime* temp = _impl_.content_lifetime_;
    _impl_.content_lifetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedstore::Metadata_StreamMetadata_ContentLifetime* Metadata_StreamMetadata::unsafe_arena_release_content_lifetime()
{
    // @@protoc_insertion_point(field_release:feedstore.Metadata.StreamMetadata.content_lifetime)

    ::feedstore::Metadata_StreamMetadata_ContentLifetime* temp = _impl_.content_lifetime_;
    _impl_.content_lifetime_ = nullptr;
    return temp;
}
inline ::feedstore::Metadata_StreamMetadata_ContentLifetime* Metadata_StreamMetadata::_internal_mutable_content_lifetime()
{

    if (_impl_.content_lifetime_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedstore::Metadata_StreamMetadata_ContentLifetime>(GetArenaForAllocation());
        _impl_.content_lifetime_ = p;
    }
    return _impl_.content_lifetime_;
}
inline ::feedstore::Metadata_StreamMetadata_ContentLifetime* Metadata_StreamMetadata::mutable_content_lifetime()
{
    ::feedstore::Metadata_StreamMetadata_ContentLifetime* _msg = _internal_mutable_content_lifetime();
    // @@protoc_insertion_point(field_mutable:feedstore.Metadata.StreamMetadata.content_lifetime)
    return _msg;
}
inline void Metadata_StreamMetadata::set_allocated_content_lifetime(::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.content_lifetime_;
    }
    if (content_lifetime) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content_lifetime);
        if (message_arena != submessage_arena) {
            content_lifetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content_lifetime, submessage_arena);
        }

    } else {
    }
    _impl_.content_lifetime_ = content_lifetime;
    // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.StreamMetadata.content_lifetime)
}

// int64 last_fetch_time_millis = 6;
inline void Metadata_StreamMetadata::clear_last_fetch_time_millis()
{
    _impl_.last_fetch_time_millis_ = int64_t { 0 };
}
inline int64_t Metadata_StreamMetadata::_internal_last_fetch_time_millis() const
{
    return _impl_.last_fetch_time_millis_;
}
inline int64_t Metadata_StreamMetadata::last_fetch_time_millis() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.last_fetch_time_millis)
    return _internal_last_fetch_time_millis();
}
inline void Metadata_StreamMetadata::_internal_set_last_fetch_time_millis(int64_t value)
{

    _impl_.last_fetch_time_millis_ = value;
}
inline void Metadata_StreamMetadata::set_last_fetch_time_millis(int64_t value)
{
    _internal_set_last_fetch_time_millis(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.last_fetch_time_millis)
}

// int64 last_server_response_time_millis = 7;
inline void Metadata_StreamMetadata::clear_last_server_response_time_millis()
{
    _impl_.last_server_response_time_millis_ = int64_t { 0 };
}
inline int64_t Metadata_StreamMetadata::_internal_last_server_response_time_millis() const
{
    return _impl_.last_server_response_time_millis_;
}
inline int64_t Metadata_StreamMetadata::last_server_response_time_millis() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.last_server_response_time_millis)
    return _internal_last_server_response_time_millis();
}
inline void Metadata_StreamMetadata::_internal_set_last_server_response_time_millis(int64_t value)
{

    _impl_.last_server_response_time_millis_ = value;
}
inline void Metadata_StreamMetadata::set_last_server_response_time_millis(int64_t value)
{
    _internal_set_last_server_response_time_millis(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.last_server_response_time_millis)
}

// repeated uint32 viewed_content_hashes = 8;
inline int Metadata_StreamMetadata::_internal_viewed_content_hashes_size() const
{
    return _impl_.viewed_content_hashes_.size();
}
inline int Metadata_StreamMetadata::viewed_content_hashes_size() const
{
    return _internal_viewed_content_hashes_size();
}
inline void Metadata_StreamMetadata::clear_viewed_content_hashes()
{
    _impl_.viewed_content_hashes_.Clear();
}
inline uint32_t Metadata_StreamMetadata::_internal_viewed_content_hashes(int index) const
{
    return _impl_.viewed_content_hashes_.Get(index);
}
inline uint32_t Metadata_StreamMetadata::viewed_content_hashes(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.viewed_content_hashes)
    return _internal_viewed_content_hashes(index);
}
inline void Metadata_StreamMetadata::set_viewed_content_hashes(int index, uint32_t value)
{
    _impl_.viewed_content_hashes_.Set(index, value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.viewed_content_hashes)
}
inline void Metadata_StreamMetadata::_internal_add_viewed_content_hashes(uint32_t value)
{
    _impl_.viewed_content_hashes_.Add(value);
}
inline void Metadata_StreamMetadata::add_viewed_content_hashes(uint32_t value)
{
    _internal_add_viewed_content_hashes(value);
    // @@protoc_insertion_point(field_add:feedstore.Metadata.StreamMetadata.viewed_content_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& Metadata_StreamMetadata::_internal_viewed_content_hashes() const
{
    return _impl_.viewed_content_hashes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& Metadata_StreamMetadata::viewed_content_hashes() const
{
    // @@protoc_insertion_point(field_list:feedstore.Metadata.StreamMetadata.viewed_content_hashes)
    return _internal_viewed_content_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* Metadata_StreamMetadata::_internal_mutable_viewed_content_hashes()
{
    return &_impl_.viewed_content_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* Metadata_StreamMetadata::mutable_viewed_content_hashes()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.Metadata.StreamMetadata.viewed_content_hashes)
    return _internal_mutable_viewed_content_hashes();
}

// -------------------------------------------------------------------

// Metadata

// bytes consistency_token = 1;
inline void Metadata::clear_consistency_token()
{
    _impl_.consistency_token_.ClearToEmpty();
}
inline const std::string& Metadata::consistency_token() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.consistency_token)
    return _internal_consistency_token();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Metadata::set_consistency_token(ArgT0&& arg0, ArgT... args)
{

    _impl_.consistency_token_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.Metadata.consistency_token)
}
inline std::string* Metadata::mutable_consistency_token()
{
    std::string* _s = _internal_mutable_consistency_token();
    // @@protoc_insertion_point(field_mutable:feedstore.Metadata.consistency_token)
    return _s;
}
inline const std::string& Metadata::_internal_consistency_token() const
{
    return _impl_.consistency_token_.Get();
}
inline void Metadata::_internal_set_consistency_token(const std::string& value)
{

    _impl_.consistency_token_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_consistency_token()
{

    return _impl_.consistency_token_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_consistency_token()
{
    // @@protoc_insertion_point(field_release:feedstore.Metadata.consistency_token)
    return _impl_.consistency_token_.Release();
}
inline void Metadata::set_allocated_consistency_token(std::string* consistency_token)
{
    if (consistency_token != nullptr) {

    } else {
    }
    _impl_.consistency_token_.SetAllocated(consistency_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.consistency_token_.IsDefault()) {
        _impl_.consistency_token_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.consistency_token)
}

// int32 next_action_id = 2;
inline void Metadata::clear_next_action_id()
{
    _impl_.next_action_id_ = 0;
}
inline int32_t Metadata::_internal_next_action_id() const
{
    return _impl_.next_action_id_;
}
inline int32_t Metadata::next_action_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.next_action_id)
    return _internal_next_action_id();
}
inline void Metadata::_internal_set_next_action_id(int32_t value)
{

    _impl_.next_action_id_ = value;
}
inline void Metadata::set_next_action_id(int32_t value)
{
    _internal_set_next_action_id(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.next_action_id)
}

// .feedstore.Metadata.SessionID session_id = 3;
inline bool Metadata::_internal_has_session_id() const
{
    return this != internal_default_instance() && _impl_.session_id_ != nullptr;
}
inline bool Metadata::has_session_id() const
{
    return _internal_has_session_id();
}
inline void Metadata::clear_session_id()
{
    if (GetArenaForAllocation() == nullptr && _impl_.session_id_ != nullptr) {
        delete _impl_.session_id_;
    }
    _impl_.session_id_ = nullptr;
}
inline const ::feedstore::Metadata_SessionID& Metadata::_internal_session_id() const
{
    const ::feedstore::Metadata_SessionID* p = _impl_.session_id_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedstore::Metadata_SessionID&>(::feedstore::_Metadata_SessionID_default_instance_);
}
inline const ::feedstore::Metadata_SessionID& Metadata::session_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.session_id)
    return _internal_session_id();
}
inline void Metadata::unsafe_arena_set_allocated_session_id(::feedstore::Metadata_SessionID* session_id)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_id_);
    }
    _impl_.session_id_ = session_id;
    if (session_id) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Metadata.session_id)
}
inline ::feedstore::Metadata_SessionID* Metadata::release_session_id()
{

    ::feedstore::Metadata_SessionID* temp = _impl_.session_id_;
    _impl_.session_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedstore::Metadata_SessionID* Metadata::unsafe_arena_release_session_id()
{
    // @@protoc_insertion_point(field_release:feedstore.Metadata.session_id)

    ::feedstore::Metadata_SessionID* temp = _impl_.session_id_;
    _impl_.session_id_ = nullptr;
    return temp;
}
inline ::feedstore::Metadata_SessionID* Metadata::_internal_mutable_session_id()
{

    if (_impl_.session_id_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedstore::Metadata_SessionID>(GetArenaForAllocation());
        _impl_.session_id_ = p;
    }
    return _impl_.session_id_;
}
inline ::feedstore::Metadata_SessionID* Metadata::mutable_session_id()
{
    ::feedstore::Metadata_SessionID* _msg = _internal_mutable_session_id();
    // @@protoc_insertion_point(field_mutable:feedstore.Metadata.session_id)
    return _msg;
}
inline void Metadata::set_allocated_session_id(::feedstore::Metadata_SessionID* session_id)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.session_id_;
    }
    if (session_id) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_id);
        if (message_arena != submessage_arena) {
            session_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, session_id, submessage_arena);
        }

    } else {
    }
    _impl_.session_id_ = session_id;
    // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.session_id)
}

// int32 stream_schema_version = 4;
inline void Metadata::clear_stream_schema_version()
{
    _impl_.stream_schema_version_ = 0;
}
inline int32_t Metadata::_internal_stream_schema_version() const
{
    return _impl_.stream_schema_version_;
}
inline int32_t Metadata::stream_schema_version() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.stream_schema_version)
    return _internal_stream_schema_version();
}
inline void Metadata::_internal_set_stream_schema_version(int32_t value)
{

    _impl_.stream_schema_version_ = value;
}
inline void Metadata::set_stream_schema_version(int32_t value)
{
    _internal_set_stream_schema_version(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.stream_schema_version)
}

// repeated .feedstore.Metadata.StreamMetadata stream_metadata = 5;
inline int Metadata::_internal_stream_metadata_size() const
{
    return _impl_.stream_metadata_.size();
}
inline int Metadata::stream_metadata_size() const
{
    return _internal_stream_metadata_size();
}
inline void Metadata::clear_stream_metadata()
{
    _impl_.stream_metadata_.Clear();
}
inline ::feedstore::Metadata_StreamMetadata* Metadata::mutable_stream_metadata(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.Metadata.stream_metadata)
    return _impl_.stream_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::Metadata_StreamMetadata>* Metadata::mutable_stream_metadata()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.Metadata.stream_metadata)
    return &_impl_.stream_metadata_;
}
inline const ::feedstore::Metadata_StreamMetadata& Metadata::_internal_stream_metadata(int index) const
{
    return _impl_.stream_metadata_.Get(index);
}
inline const ::feedstore::Metadata_StreamMetadata& Metadata::stream_metadata(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.stream_metadata)
    return _internal_stream_metadata(index);
}
inline ::feedstore::Metadata_StreamMetadata* Metadata::_internal_add_stream_metadata()
{
    return _impl_.stream_metadata_.Add();
}
inline ::feedstore::Metadata_StreamMetadata* Metadata::add_stream_metadata()
{
    ::feedstore::Metadata_StreamMetadata* _add = _internal_add_stream_metadata();
    // @@protoc_insertion_point(field_add:feedstore.Metadata.stream_metadata)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::Metadata_StreamMetadata>& Metadata::stream_metadata() const
{
    // @@protoc_insertion_point(field_list:feedstore.Metadata.stream_metadata)
    return _impl_.stream_metadata_;
}

// string gaia = 6;
inline void Metadata::clear_gaia()
{
    _impl_.gaia_.ClearToEmpty();
}
inline const std::string& Metadata::gaia() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.gaia)
    return _internal_gaia();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Metadata::set_gaia(ArgT0&& arg0, ArgT... args)
{

    _impl_.gaia_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.Metadata.gaia)
}
inline std::string* Metadata::mutable_gaia()
{
    std::string* _s = _internal_mutable_gaia();
    // @@protoc_insertion_point(field_mutable:feedstore.Metadata.gaia)
    return _s;
}
inline const std::string& Metadata::_internal_gaia() const
{
    return _impl_.gaia_.Get();
}
inline void Metadata::_internal_set_gaia(const std::string& value)
{

    _impl_.gaia_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_gaia()
{

    return _impl_.gaia_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_gaia()
{
    // @@protoc_insertion_point(field_release:feedstore.Metadata.gaia)
    return _impl_.gaia_.Release();
}
inline void Metadata::set_allocated_gaia(std::string* gaia)
{
    if (gaia != nullptr) {

    } else {
    }
    _impl_.gaia_.SetAllocated(gaia, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.gaia_.IsDefault()) {
        _impl_.gaia_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.gaia)
}

// bool web_and_app_activity_enabled = 7;
inline void Metadata::clear_web_and_app_activity_enabled()
{
    _impl_.web_and_app_activity_enabled_ = false;
}
inline bool Metadata::_internal_web_and_app_activity_enabled() const
{
    return _impl_.web_and_app_activity_enabled_;
}
inline bool Metadata::web_and_app_activity_enabled() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.web_and_app_activity_enabled)
    return _internal_web_and_app_activity_enabled();
}
inline void Metadata::_internal_set_web_and_app_activity_enabled(bool value)
{

    _impl_.web_and_app_activity_enabled_ = value;
}
inline void Metadata::set_web_and_app_activity_enabled(bool value)
{
    _internal_set_web_and_app_activity_enabled(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.web_and_app_activity_enabled)
}

// bool discover_personalization_enabled = 8;
inline void Metadata::clear_discover_personalization_enabled()
{
    _impl_.discover_personalization_enabled_ = false;
}
inline bool Metadata::_internal_discover_personalization_enabled() const
{
    return _impl_.discover_personalization_enabled_;
}
inline bool Metadata::discover_personalization_enabled() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.discover_personalization_enabled)
    return _internal_discover_personalization_enabled();
}
inline void Metadata::_internal_set_discover_personalization_enabled(bool value)
{

    _impl_.discover_personalization_enabled_ = value;
}
inline void Metadata::set_discover_personalization_enabled(bool value)
{
    _internal_set_discover_personalization_enabled(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.discover_personalization_enabled)
}

// int32 followed_from_web_page_menu_count = 9;
inline void Metadata::clear_followed_from_web_page_menu_count()
{
    _impl_.followed_from_web_page_menu_count_ = 0;
}
inline int32_t Metadata::_internal_followed_from_web_page_menu_count() const
{
    return _impl_.followed_from_web_page_menu_count_;
}
inline int32_t Metadata::followed_from_web_page_menu_count() const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.followed_from_web_page_menu_count)
    return _internal_followed_from_web_page_menu_count();
}
inline void Metadata::_internal_set_followed_from_web_page_menu_count(int32_t value)
{

    _impl_.followed_from_web_page_menu_count_ = value;
}
inline void Metadata::set_followed_from_web_page_menu_count(int32_t value)
{
    _internal_set_followed_from_web_page_menu_count(value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.followed_from_web_page_menu_count)
}

// repeated uint32 most_recent_viewed_content_hashes = 11;
inline int Metadata::_internal_most_recent_viewed_content_hashes_size() const
{
    return _impl_.most_recent_viewed_content_hashes_.size();
}
inline int Metadata::most_recent_viewed_content_hashes_size() const
{
    return _internal_most_recent_viewed_content_hashes_size();
}
inline void Metadata::clear_most_recent_viewed_content_hashes()
{
    _impl_.most_recent_viewed_content_hashes_.Clear();
}
inline uint32_t Metadata::_internal_most_recent_viewed_content_hashes(int index) const
{
    return _impl_.most_recent_viewed_content_hashes_.Get(index);
}
inline uint32_t Metadata::most_recent_viewed_content_hashes(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.Metadata.most_recent_viewed_content_hashes)
    return _internal_most_recent_viewed_content_hashes(index);
}
inline void Metadata::set_most_recent_viewed_content_hashes(int index, uint32_t value)
{
    _impl_.most_recent_viewed_content_hashes_.Set(index, value);
    // @@protoc_insertion_point(field_set:feedstore.Metadata.most_recent_viewed_content_hashes)
}
inline void Metadata::_internal_add_most_recent_viewed_content_hashes(uint32_t value)
{
    _impl_.most_recent_viewed_content_hashes_.Add(value);
}
inline void Metadata::add_most_recent_viewed_content_hashes(uint32_t value)
{
    _internal_add_most_recent_viewed_content_hashes(value);
    // @@protoc_insertion_point(field_add:feedstore.Metadata.most_recent_viewed_content_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& Metadata::_internal_most_recent_viewed_content_hashes() const
{
    return _impl_.most_recent_viewed_content_hashes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>& Metadata::most_recent_viewed_content_hashes() const
{
    // @@protoc_insertion_point(field_list:feedstore.Metadata.most_recent_viewed_content_hashes)
    return _internal_most_recent_viewed_content_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* Metadata::_internal_mutable_most_recent_viewed_content_hashes()
{
    return &_impl_.most_recent_viewed_content_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<uint32_t>* Metadata::mutable_most_recent_viewed_content_hashes()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.Metadata.most_recent_viewed_content_hashes)
    return _internal_mutable_most_recent_viewed_content_hashes();
}

// -------------------------------------------------------------------

// StreamStructureSet

// string stream_key = 1;
inline void StreamStructureSet::clear_stream_key()
{
    _impl_.stream_key_.ClearToEmpty();
}
inline const std::string& StreamStructureSet::stream_key() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructureSet.stream_key)
    return _internal_stream_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StreamStructureSet::set_stream_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.stream_key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.StreamStructureSet.stream_key)
}
inline std::string* StreamStructureSet::mutable_stream_key()
{
    std::string* _s = _internal_mutable_stream_key();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamStructureSet.stream_key)
    return _s;
}
inline const std::string& StreamStructureSet::_internal_stream_key() const
{
    return _impl_.stream_key_.Get();
}
inline void StreamStructureSet::_internal_set_stream_key(const std::string& value)
{

    _impl_.stream_key_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamStructureSet::_internal_mutable_stream_key()
{

    return _impl_.stream_key_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamStructureSet::release_stream_key()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamStructureSet.stream_key)
    return _impl_.stream_key_.Release();
}
inline void StreamStructureSet::set_allocated_stream_key(std::string* stream_key)
{
    if (stream_key != nullptr) {

    } else {
    }
    _impl_.stream_key_.SetAllocated(stream_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.stream_key_.IsDefault()) {
        _impl_.stream_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamStructureSet.stream_key)
}

// int32 sequence_number = 2;
inline void StreamStructureSet::clear_sequence_number()
{
    _impl_.sequence_number_ = 0;
}
inline int32_t StreamStructureSet::_internal_sequence_number() const
{
    return _impl_.sequence_number_;
}
inline int32_t StreamStructureSet::sequence_number() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructureSet.sequence_number)
    return _internal_sequence_number();
}
inline void StreamStructureSet::_internal_set_sequence_number(int32_t value)
{

    _impl_.sequence_number_ = value;
}
inline void StreamStructureSet::set_sequence_number(int32_t value)
{
    _internal_set_sequence_number(value);
    // @@protoc_insertion_point(field_set:feedstore.StreamStructureSet.sequence_number)
}

// repeated .feedstore.StreamStructure structures = 3;
inline int StreamStructureSet::_internal_structures_size() const
{
    return _impl_.structures_.size();
}
inline int StreamStructureSet::structures_size() const
{
    return _internal_structures_size();
}
inline void StreamStructureSet::clear_structures()
{
    _impl_.structures_.Clear();
}
inline ::feedstore::StreamStructure* StreamStructureSet::mutable_structures(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.StreamStructureSet.structures)
    return _impl_.structures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamStructure>* StreamStructureSet::mutable_structures()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.StreamStructureSet.structures)
    return &_impl_.structures_;
}
inline const ::feedstore::StreamStructure& StreamStructureSet::_internal_structures(int index) const
{
    return _impl_.structures_.Get(index);
}
inline const ::feedstore::StreamStructure& StreamStructureSet::structures(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructureSet.structures)
    return _internal_structures(index);
}
inline ::feedstore::StreamStructure* StreamStructureSet::_internal_add_structures()
{
    return _impl_.structures_.Add();
}
inline ::feedstore::StreamStructure* StreamStructureSet::add_structures()
{
    ::feedstore::StreamStructure* _add = _internal_add_structures();
    // @@protoc_insertion_point(field_add:feedstore.StreamStructureSet.structures)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::StreamStructure>& StreamStructureSet::structures() const
{
    // @@protoc_insertion_point(field_list:feedstore.StreamStructureSet.structures)
    return _impl_.structures_;
}

// -------------------------------------------------------------------

// StreamStructure

// .feedstore.StreamStructure.Operation operation = 1;
inline void StreamStructure::clear_operation()
{
    _impl_.operation_ = 0;
}
inline ::feedstore::StreamStructure_Operation StreamStructure::_internal_operation() const
{
    return static_cast<::feedstore::StreamStructure_Operation>(_impl_.operation_);
}
inline ::feedstore::StreamStructure_Operation StreamStructure::operation() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructure.operation)
    return _internal_operation();
}
inline void StreamStructure::_internal_set_operation(::feedstore::StreamStructure_Operation value)
{

    _impl_.operation_ = value;
}
inline void StreamStructure::set_operation(::feedstore::StreamStructure_Operation value)
{
    _internal_set_operation(value);
    // @@protoc_insertion_point(field_set:feedstore.StreamStructure.operation)
}

// .feedwire.ContentId content_id = 2;
inline bool StreamStructure::_internal_has_content_id() const
{
    return this != internal_default_instance() && _impl_.content_id_ != nullptr;
}
inline bool StreamStructure::has_content_id() const
{
    return _internal_has_content_id();
}
inline const ::feedwire::ContentId& StreamStructure::_internal_content_id() const
{
    const ::feedwire::ContentId* p = _impl_.content_id_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& StreamStructure::content_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructure.content_id)
    return _internal_content_id();
}
inline void StreamStructure::unsafe_arena_set_allocated_content_id(::feedwire::ContentId* content_id)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_id_);
    }
    _impl_.content_id_ = content_id;
    if (content_id) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamStructure.content_id)
}
inline ::feedwire::ContentId* StreamStructure::release_content_id()
{

    ::feedwire::ContentId* temp = _impl_.content_id_;
    _impl_.content_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::ContentId* StreamStructure::unsafe_arena_release_content_id()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamStructure.content_id)

    ::feedwire::ContentId* temp = _impl_.content_id_;
    _impl_.content_id_ = nullptr;
    return temp;
}
inline ::feedwire::ContentId* StreamStructure::_internal_mutable_content_id()
{

    if (_impl_.content_id_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
        _impl_.content_id_ = p;
    }
    return _impl_.content_id_;
}
inline ::feedwire::ContentId* StreamStructure::mutable_content_id()
{
    ::feedwire::ContentId* _msg = _internal_mutable_content_id();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamStructure.content_id)
    return _msg;
}
inline void StreamStructure::set_allocated_content_id(::feedwire::ContentId* content_id)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_id_);
    }
    if (content_id) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id));
        if (message_arena != submessage_arena) {
            content_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content_id, submessage_arena);
        }

    } else {
    }
    _impl_.content_id_ = content_id;
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamStructure.content_id)
}

// .feedwire.ContentId parent_id = 3;
inline bool StreamStructure::_internal_has_parent_id() const
{
    return this != internal_default_instance() && _impl_.parent_id_ != nullptr;
}
inline bool StreamStructure::has_parent_id() const
{
    return _internal_has_parent_id();
}
inline const ::feedwire::ContentId& StreamStructure::_internal_parent_id() const
{
    const ::feedwire::ContentId* p = _impl_.parent_id_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& StreamStructure::parent_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructure.parent_id)
    return _internal_parent_id();
}
inline void StreamStructure::unsafe_arena_set_allocated_parent_id(::feedwire::ContentId* parent_id)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_id_);
    }
    _impl_.parent_id_ = parent_id;
    if (parent_id) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamStructure.parent_id)
}
inline ::feedwire::ContentId* StreamStructure::release_parent_id()
{

    ::feedwire::ContentId* temp = _impl_.parent_id_;
    _impl_.parent_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::ContentId* StreamStructure::unsafe_arena_release_parent_id()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamStructure.parent_id)

    ::feedwire::ContentId* temp = _impl_.parent_id_;
    _impl_.parent_id_ = nullptr;
    return temp;
}
inline ::feedwire::ContentId* StreamStructure::_internal_mutable_parent_id()
{

    if (_impl_.parent_id_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
        _impl_.parent_id_ = p;
    }
    return _impl_.parent_id_;
}
inline ::feedwire::ContentId* StreamStructure::mutable_parent_id()
{
    ::feedwire::ContentId* _msg = _internal_mutable_parent_id();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamStructure.parent_id)
    return _msg;
}
inline void StreamStructure::set_allocated_parent_id(::feedwire::ContentId* parent_id)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.parent_id_);
    }
    if (parent_id) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_id));
        if (message_arena != submessage_arena) {
            parent_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, parent_id, submessage_arena);
        }

    } else {
    }
    _impl_.parent_id_ = parent_id;
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamStructure.parent_id)
}

// .feedstore.StreamStructure.Type type = 4;
inline void StreamStructure::clear_type()
{
    _impl_.type_ = 0;
}
inline ::feedstore::StreamStructure_Type StreamStructure::_internal_type() const
{
    return static_cast<::feedstore::StreamStructure_Type>(_impl_.type_);
}
inline ::feedstore::StreamStructure_Type StreamStructure::type() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructure.type)
    return _internal_type();
}
inline void StreamStructure::_internal_set_type(::feedstore::StreamStructure_Type value)
{

    _impl_.type_ = value;
}
inline void StreamStructure::set_type(::feedstore::StreamStructure_Type value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:feedstore.StreamStructure.type)
}

// .feedstore.ContentInfo content_info = 5;
inline bool StreamStructure::_internal_has_content_info() const
{
    return this != internal_default_instance() && _impl_.content_info_ != nullptr;
}
inline bool StreamStructure::has_content_info() const
{
    return _internal_has_content_info();
}
inline void StreamStructure::clear_content_info()
{
    if (GetArenaForAllocation() == nullptr && _impl_.content_info_ != nullptr) {
        delete _impl_.content_info_;
    }
    _impl_.content_info_ = nullptr;
}
inline const ::feedstore::ContentInfo& StreamStructure::_internal_content_info() const
{
    const ::feedstore::ContentInfo* p = _impl_.content_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedstore::ContentInfo&>(::feedstore::_ContentInfo_default_instance_);
}
inline const ::feedstore::ContentInfo& StreamStructure::content_info() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructure.content_info)
    return _internal_content_info();
}
inline void StreamStructure::unsafe_arena_set_allocated_content_info(::feedstore::ContentInfo* content_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_info_);
    }
    _impl_.content_info_ = content_info;
    if (content_info) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamStructure.content_info)
}
inline ::feedstore::ContentInfo* StreamStructure::release_content_info()
{

    ::feedstore::ContentInfo* temp = _impl_.content_info_;
    _impl_.content_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedstore::ContentInfo* StreamStructure::unsafe_arena_release_content_info()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamStructure.content_info)

    ::feedstore::ContentInfo* temp = _impl_.content_info_;
    _impl_.content_info_ = nullptr;
    return temp;
}
inline ::feedstore::ContentInfo* StreamStructure::_internal_mutable_content_info()
{

    if (_impl_.content_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedstore::ContentInfo>(GetArenaForAllocation());
        _impl_.content_info_ = p;
    }
    return _impl_.content_info_;
}
inline ::feedstore::ContentInfo* StreamStructure::mutable_content_info()
{
    ::feedstore::ContentInfo* _msg = _internal_mutable_content_info();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamStructure.content_info)
    return _msg;
}
inline void StreamStructure::set_allocated_content_info(::feedstore::ContentInfo* content_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.content_info_;
    }
    if (content_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content_info);
        if (message_arena != submessage_arena) {
            content_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content_info, submessage_arena);
        }

    } else {
    }
    _impl_.content_info_ = content_info;
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamStructure.content_info)
}

// bool is_root = 6;
inline void StreamStructure::clear_is_root()
{
    _impl_.is_root_ = false;
}
inline bool StreamStructure::_internal_is_root() const
{
    return _impl_.is_root_;
}
inline bool StreamStructure::is_root() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamStructure.is_root)
    return _internal_is_root();
}
inline void StreamStructure::_internal_set_is_root(bool value)
{

    _impl_.is_root_ = value;
}
inline void StreamStructure::set_is_root(bool value)
{
    _internal_set_is_root(value);
    // @@protoc_insertion_point(field_set:feedstore.StreamStructure.is_root)
}

// -------------------------------------------------------------------

// DataOperation

// .feedstore.StreamStructure structure = 1;
inline bool DataOperation::_internal_has_structure() const
{
    return this != internal_default_instance() && _impl_.structure_ != nullptr;
}
inline bool DataOperation::has_structure() const
{
    return _internal_has_structure();
}
inline void DataOperation::clear_structure()
{
    if (GetArenaForAllocation() == nullptr && _impl_.structure_ != nullptr) {
        delete _impl_.structure_;
    }
    _impl_.structure_ = nullptr;
}
inline const ::feedstore::StreamStructure& DataOperation::_internal_structure() const
{
    const ::feedstore::StreamStructure* p = _impl_.structure_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedstore::StreamStructure&>(::feedstore::_StreamStructure_default_instance_);
}
inline const ::feedstore::StreamStructure& DataOperation::structure() const
{
    // @@protoc_insertion_point(field_get:feedstore.DataOperation.structure)
    return _internal_structure();
}
inline void DataOperation::unsafe_arena_set_allocated_structure(::feedstore::StreamStructure* structure)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.structure_);
    }
    _impl_.structure_ = structure;
    if (structure) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.DataOperation.structure)
}
inline ::feedstore::StreamStructure* DataOperation::release_structure()
{

    ::feedstore::StreamStructure* temp = _impl_.structure_;
    _impl_.structure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedstore::StreamStructure* DataOperation::unsafe_arena_release_structure()
{
    // @@protoc_insertion_point(field_release:feedstore.DataOperation.structure)

    ::feedstore::StreamStructure* temp = _impl_.structure_;
    _impl_.structure_ = nullptr;
    return temp;
}
inline ::feedstore::StreamStructure* DataOperation::_internal_mutable_structure()
{

    if (_impl_.structure_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedstore::StreamStructure>(GetArenaForAllocation());
        _impl_.structure_ = p;
    }
    return _impl_.structure_;
}
inline ::feedstore::StreamStructure* DataOperation::mutable_structure()
{
    ::feedstore::StreamStructure* _msg = _internal_mutable_structure();
    // @@protoc_insertion_point(field_mutable:feedstore.DataOperation.structure)
    return _msg;
}
inline void DataOperation::set_allocated_structure(::feedstore::StreamStructure* structure)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.structure_;
    }
    if (structure) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(structure);
        if (message_arena != submessage_arena) {
            structure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, structure, submessage_arena);
        }

    } else {
    }
    _impl_.structure_ = structure;
    // @@protoc_insertion_point(field_set_allocated:feedstore.DataOperation.structure)
}

// .feedstore.Content content = 2;
inline bool DataOperation::_internal_has_content() const
{
    return this != internal_default_instance() && _impl_.content_ != nullptr;
}
inline bool DataOperation::has_content() const
{
    return _internal_has_content();
}
inline void DataOperation::clear_content()
{
    if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
        delete _impl_.content_;
    }
    _impl_.content_ = nullptr;
}
inline const ::feedstore::Content& DataOperation::_internal_content() const
{
    const ::feedstore::Content* p = _impl_.content_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedstore::Content&>(::feedstore::_Content_default_instance_);
}
inline const ::feedstore::Content& DataOperation::content() const
{
    // @@protoc_insertion_point(field_get:feedstore.DataOperation.content)
    return _internal_content();
}
inline void DataOperation::unsafe_arena_set_allocated_content(::feedstore::Content* content)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
    }
    _impl_.content_ = content;
    if (content) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.DataOperation.content)
}
inline ::feedstore::Content* DataOperation::release_content()
{

    ::feedstore::Content* temp = _impl_.content_;
    _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedstore::Content* DataOperation::unsafe_arena_release_content()
{
    // @@protoc_insertion_point(field_release:feedstore.DataOperation.content)

    ::feedstore::Content* temp = _impl_.content_;
    _impl_.content_ = nullptr;
    return temp;
}
inline ::feedstore::Content* DataOperation::_internal_mutable_content()
{

    if (_impl_.content_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedstore::Content>(GetArenaForAllocation());
        _impl_.content_ = p;
    }
    return _impl_.content_;
}
inline ::feedstore::Content* DataOperation::mutable_content()
{
    ::feedstore::Content* _msg = _internal_mutable_content();
    // @@protoc_insertion_point(field_mutable:feedstore.DataOperation.content)
    return _msg;
}
inline void DataOperation::set_allocated_content(::feedstore::Content* content)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.content_;
    }
    if (content) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
        if (message_arena != submessage_arena) {
            content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content, submessage_arena);
        }

    } else {
    }
    _impl_.content_ = content;
    // @@protoc_insertion_point(field_set_allocated:feedstore.DataOperation.content)
}

// -------------------------------------------------------------------

// ContentInfo

// float score = 1;
inline void ContentInfo::clear_score()
{
    _impl_.score_ = 0;
}
inline float ContentInfo::_internal_score() const
{
    return _impl_.score_;
}
inline float ContentInfo::score() const
{
    // @@protoc_insertion_point(field_get:feedstore.ContentInfo.score)
    return _internal_score();
}
inline void ContentInfo::_internal_set_score(float value)
{

    _impl_.score_ = value;
}
inline void ContentInfo::set_score(float value)
{
    _internal_set_score(value);
    // @@protoc_insertion_point(field_set:feedstore.ContentInfo.score)
}

// int64 availability_time_seconds = 2;
inline void ContentInfo::clear_availability_time_seconds()
{
    _impl_.availability_time_seconds_ = int64_t { 0 };
}
inline int64_t ContentInfo::_internal_availability_time_seconds() const
{
    return _impl_.availability_time_seconds_;
}
inline int64_t ContentInfo::availability_time_seconds() const
{
    // @@protoc_insertion_point(field_get:feedstore.ContentInfo.availability_time_seconds)
    return _internal_availability_time_seconds();
}
inline void ContentInfo::_internal_set_availability_time_seconds(int64_t value)
{

    _impl_.availability_time_seconds_ = value;
}
inline void ContentInfo::set_availability_time_seconds(int64_t value)
{
    _internal_set_availability_time_seconds(value);
    // @@protoc_insertion_point(field_set:feedstore.ContentInfo.availability_time_seconds)
}

// -------------------------------------------------------------------

// Content

// .feedwire.ContentId content_id = 1;
inline bool Content::_internal_has_content_id() const
{
    return this != internal_default_instance() && _impl_.content_id_ != nullptr;
}
inline bool Content::has_content_id() const
{
    return _internal_has_content_id();
}
inline const ::feedwire::ContentId& Content::_internal_content_id() const
{
    const ::feedwire::ContentId* p = _impl_.content_id_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& Content::content_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.Content.content_id)
    return _internal_content_id();
}
inline void Content::unsafe_arena_set_allocated_content_id(::feedwire::ContentId* content_id)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_id_);
    }
    _impl_.content_id_ = content_id;
    if (content_id) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Content.content_id)
}
inline ::feedwire::ContentId* Content::release_content_id()
{

    ::feedwire::ContentId* temp = _impl_.content_id_;
    _impl_.content_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::ContentId* Content::unsafe_arena_release_content_id()
{
    // @@protoc_insertion_point(field_release:feedstore.Content.content_id)

    ::feedwire::ContentId* temp = _impl_.content_id_;
    _impl_.content_id_ = nullptr;
    return temp;
}
inline ::feedwire::ContentId* Content::_internal_mutable_content_id()
{

    if (_impl_.content_id_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
        _impl_.content_id_ = p;
    }
    return _impl_.content_id_;
}
inline ::feedwire::ContentId* Content::mutable_content_id()
{
    ::feedwire::ContentId* _msg = _internal_mutable_content_id();
    // @@protoc_insertion_point(field_mutable:feedstore.Content.content_id)
    return _msg;
}
inline void Content::set_allocated_content_id(::feedwire::ContentId* content_id)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_id_);
    }
    if (content_id) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id));
        if (message_arena != submessage_arena) {
            content_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content_id, submessage_arena);
        }

    } else {
    }
    _impl_.content_id_ = content_id;
    // @@protoc_insertion_point(field_set_allocated:feedstore.Content.content_id)
}

// bytes frame = 2;
inline void Content::clear_frame()
{
    _impl_.frame_.ClearToEmpty();
}
inline const std::string& Content::frame() const
{
    // @@protoc_insertion_point(field_get:feedstore.Content.frame)
    return _internal_frame();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Content::set_frame(ArgT0&& arg0, ArgT... args)
{

    _impl_.frame_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.Content.frame)
}
inline std::string* Content::mutable_frame()
{
    std::string* _s = _internal_mutable_frame();
    // @@protoc_insertion_point(field_mutable:feedstore.Content.frame)
    return _s;
}
inline const std::string& Content::_internal_frame() const
{
    return _impl_.frame_.Get();
}
inline void Content::_internal_set_frame(const std::string& value)
{

    _impl_.frame_.Set(value, GetArenaForAllocation());
}
inline std::string* Content::_internal_mutable_frame()
{

    return _impl_.frame_.Mutable(GetArenaForAllocation());
}
inline std::string* Content::release_frame()
{
    // @@protoc_insertion_point(field_release:feedstore.Content.frame)
    return _impl_.frame_.Release();
}
inline void Content::set_allocated_frame(std::string* frame)
{
    if (frame != nullptr) {

    } else {
    }
    _impl_.frame_.SetAllocated(frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.frame_.IsDefault()) {
        _impl_.frame_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.Content.frame)
}

// repeated .feedwire.PrefetchMetadata prefetch_metadata = 3;
inline int Content::_internal_prefetch_metadata_size() const
{
    return _impl_.prefetch_metadata_.size();
}
inline int Content::prefetch_metadata_size() const
{
    return _internal_prefetch_metadata_size();
}
inline ::feedwire::PrefetchMetadata* Content::mutable_prefetch_metadata(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.Content.prefetch_metadata)
    return _impl_.prefetch_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::PrefetchMetadata>* Content::mutable_prefetch_metadata()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.Content.prefetch_metadata)
    return &_impl_.prefetch_metadata_;
}
inline const ::feedwire::PrefetchMetadata& Content::_internal_prefetch_metadata(int index) const
{
    return _impl_.prefetch_metadata_.Get(index);
}
inline const ::feedwire::PrefetchMetadata& Content::prefetch_metadata(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.Content.prefetch_metadata)
    return _internal_prefetch_metadata(index);
}
inline ::feedwire::PrefetchMetadata* Content::_internal_add_prefetch_metadata()
{
    return _impl_.prefetch_metadata_.Add();
}
inline ::feedwire::PrefetchMetadata* Content::add_prefetch_metadata()
{
    ::feedwire::PrefetchMetadata* _add = _internal_add_prefetch_metadata();
    // @@protoc_insertion_point(field_add:feedstore.Content.prefetch_metadata)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::PrefetchMetadata>& Content::prefetch_metadata() const
{
    // @@protoc_insertion_point(field_list:feedstore.Content.prefetch_metadata)
    return _impl_.prefetch_metadata_;
}

// string stream_key = 4;
inline void Content::clear_stream_key()
{
    _impl_.stream_key_.ClearToEmpty();
}
inline const std::string& Content::stream_key() const
{
    // @@protoc_insertion_point(field_get:feedstore.Content.stream_key)
    return _internal_stream_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Content::set_stream_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.stream_key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.Content.stream_key)
}
inline std::string* Content::mutable_stream_key()
{
    std::string* _s = _internal_mutable_stream_key();
    // @@protoc_insertion_point(field_mutable:feedstore.Content.stream_key)
    return _s;
}
inline const std::string& Content::_internal_stream_key() const
{
    return _impl_.stream_key_.Get();
}
inline void Content::_internal_set_stream_key(const std::string& value)
{

    _impl_.stream_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Content::_internal_mutable_stream_key()
{

    return _impl_.stream_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Content::release_stream_key()
{
    // @@protoc_insertion_point(field_release:feedstore.Content.stream_key)
    return _impl_.stream_key_.Release();
}
inline void Content::set_allocated_stream_key(std::string* stream_key)
{
    if (stream_key != nullptr) {

    } else {
    }
    _impl_.stream_key_.SetAllocated(stream_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.stream_key_.IsDefault()) {
        _impl_.stream_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.Content.stream_key)
}

// -------------------------------------------------------------------

// StreamSharedState

// .feedwire.ContentId content_id = 1;
inline bool StreamSharedState::_internal_has_content_id() const
{
    return this != internal_default_instance() && _impl_.content_id_ != nullptr;
}
inline bool StreamSharedState::has_content_id() const
{
    return _internal_has_content_id();
}
inline const ::feedwire::ContentId& StreamSharedState::_internal_content_id() const
{
    const ::feedwire::ContentId* p = _impl_.content_id_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& StreamSharedState::content_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamSharedState.content_id)
    return _internal_content_id();
}
inline void StreamSharedState::unsafe_arena_set_allocated_content_id(::feedwire::ContentId* content_id)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_id_);
    }
    _impl_.content_id_ = content_id;
    if (content_id) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamSharedState.content_id)
}
inline ::feedwire::ContentId* StreamSharedState::release_content_id()
{

    ::feedwire::ContentId* temp = _impl_.content_id_;
    _impl_.content_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::ContentId* StreamSharedState::unsafe_arena_release_content_id()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamSharedState.content_id)

    ::feedwire::ContentId* temp = _impl_.content_id_;
    _impl_.content_id_ = nullptr;
    return temp;
}
inline ::feedwire::ContentId* StreamSharedState::_internal_mutable_content_id()
{

    if (_impl_.content_id_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
        _impl_.content_id_ = p;
    }
    return _impl_.content_id_;
}
inline ::feedwire::ContentId* StreamSharedState::mutable_content_id()
{
    ::feedwire::ContentId* _msg = _internal_mutable_content_id();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamSharedState.content_id)
    return _msg;
}
inline void StreamSharedState::set_allocated_content_id(::feedwire::ContentId* content_id)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_id_);
    }
    if (content_id) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id));
        if (message_arena != submessage_arena) {
            content_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content_id, submessage_arena);
        }

    } else {
    }
    _impl_.content_id_ = content_id;
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamSharedState.content_id)
}

// bytes shared_state_data = 2;
inline void StreamSharedState::clear_shared_state_data()
{
    _impl_.shared_state_data_.ClearToEmpty();
}
inline const std::string& StreamSharedState::shared_state_data() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamSharedState.shared_state_data)
    return _internal_shared_state_data();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StreamSharedState::set_shared_state_data(ArgT0&& arg0, ArgT... args)
{

    _impl_.shared_state_data_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.StreamSharedState.shared_state_data)
}
inline std::string* StreamSharedState::mutable_shared_state_data()
{
    std::string* _s = _internal_mutable_shared_state_data();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamSharedState.shared_state_data)
    return _s;
}
inline const std::string& StreamSharedState::_internal_shared_state_data() const
{
    return _impl_.shared_state_data_.Get();
}
inline void StreamSharedState::_internal_set_shared_state_data(const std::string& value)
{

    _impl_.shared_state_data_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamSharedState::_internal_mutable_shared_state_data()
{

    return _impl_.shared_state_data_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamSharedState::release_shared_state_data()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamSharedState.shared_state_data)
    return _impl_.shared_state_data_.Release();
}
inline void StreamSharedState::set_allocated_shared_state_data(std::string* shared_state_data)
{
    if (shared_state_data != nullptr) {

    } else {
    }
    _impl_.shared_state_data_.SetAllocated(shared_state_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.shared_state_data_.IsDefault()) {
        _impl_.shared_state_data_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamSharedState.shared_state_data)
}

// string stream_key = 3;
inline void StreamSharedState::clear_stream_key()
{
    _impl_.stream_key_.ClearToEmpty();
}
inline const std::string& StreamSharedState::stream_key() const
{
    // @@protoc_insertion_point(field_get:feedstore.StreamSharedState.stream_key)
    return _internal_stream_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void StreamSharedState::set_stream_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.stream_key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.StreamSharedState.stream_key)
}
inline std::string* StreamSharedState::mutable_stream_key()
{
    std::string* _s = _internal_mutable_stream_key();
    // @@protoc_insertion_point(field_mutable:feedstore.StreamSharedState.stream_key)
    return _s;
}
inline const std::string& StreamSharedState::_internal_stream_key() const
{
    return _impl_.stream_key_.Get();
}
inline void StreamSharedState::_internal_set_stream_key(const std::string& value)
{

    _impl_.stream_key_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamSharedState::_internal_mutable_stream_key()
{

    return _impl_.stream_key_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamSharedState::release_stream_key()
{
    // @@protoc_insertion_point(field_release:feedstore.StreamSharedState.stream_key)
    return _impl_.stream_key_.Release();
}
inline void StreamSharedState::set_allocated_stream_key(std::string* stream_key)
{
    if (stream_key != nullptr) {

    } else {
    }
    _impl_.stream_key_.SetAllocated(stream_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.stream_key_.IsDefault()) {
        _impl_.stream_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.StreamSharedState.stream_key)
}

// -------------------------------------------------------------------

// StoredAction

// int32 id = 1;
inline void StoredAction::clear_id()
{
    _impl_.id_ = 0;
}
inline int32_t StoredAction::_internal_id() const
{
    return _impl_.id_;
}
inline int32_t StoredAction::id() const
{
    // @@protoc_insertion_point(field_get:feedstore.StoredAction.id)
    return _internal_id();
}
inline void StoredAction::_internal_set_id(int32_t value)
{

    _impl_.id_ = value;
}
inline void StoredAction::set_id(int32_t value)
{
    _internal_set_id(value);
    // @@protoc_insertion_point(field_set:feedstore.StoredAction.id)
}

// int32 upload_attempt_count = 2;
inline void StoredAction::clear_upload_attempt_count()
{
    _impl_.upload_attempt_count_ = 0;
}
inline int32_t StoredAction::_internal_upload_attempt_count() const
{
    return _impl_.upload_attempt_count_;
}
inline int32_t StoredAction::upload_attempt_count() const
{
    // @@protoc_insertion_point(field_get:feedstore.StoredAction.upload_attempt_count)
    return _internal_upload_attempt_count();
}
inline void StoredAction::_internal_set_upload_attempt_count(int32_t value)
{

    _impl_.upload_attempt_count_ = value;
}
inline void StoredAction::set_upload_attempt_count(int32_t value)
{
    _internal_set_upload_attempt_count(value);
    // @@protoc_insertion_point(field_set:feedstore.StoredAction.upload_attempt_count)
}

// .feedwire.FeedAction action = 3;
inline bool StoredAction::_internal_has_action() const
{
    return this != internal_default_instance() && _impl_.action_ != nullptr;
}
inline bool StoredAction::has_action() const
{
    return _internal_has_action();
}
inline const ::feedwire::FeedAction& StoredAction::_internal_action() const
{
    const ::feedwire::FeedAction* p = _impl_.action_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::FeedAction&>(::feedwire::_FeedAction_default_instance_);
}
inline const ::feedwire::FeedAction& StoredAction::action() const
{
    // @@protoc_insertion_point(field_get:feedstore.StoredAction.action)
    return _internal_action();
}
inline void StoredAction::unsafe_arena_set_allocated_action(::feedwire::FeedAction* action)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_);
    }
    _impl_.action_ = action;
    if (action) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StoredAction.action)
}
inline ::feedwire::FeedAction* StoredAction::release_action()
{

    ::feedwire::FeedAction* temp = _impl_.action_;
    _impl_.action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::FeedAction* StoredAction::unsafe_arena_release_action()
{
    // @@protoc_insertion_point(field_release:feedstore.StoredAction.action)

    ::feedwire::FeedAction* temp = _impl_.action_;
    _impl_.action_ = nullptr;
    return temp;
}
inline ::feedwire::FeedAction* StoredAction::_internal_mutable_action()
{

    if (_impl_.action_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::FeedAction>(GetArenaForAllocation());
        _impl_.action_ = p;
    }
    return _impl_.action_;
}
inline ::feedwire::FeedAction* StoredAction::mutable_action()
{
    ::feedwire::FeedAction* _msg = _internal_mutable_action();
    // @@protoc_insertion_point(field_mutable:feedstore.StoredAction.action)
    return _msg;
}
inline void StoredAction::set_allocated_action(::feedwire::FeedAction* action)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.action_);
    }
    if (action) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action));
        if (message_arena != submessage_arena) {
            action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, action, submessage_arena);
        }

    } else {
    }
    _impl_.action_ = action;
    // @@protoc_insertion_point(field_set_allocated:feedstore.StoredAction.action)
}

// -------------------------------------------------------------------

// SubscribedWebFeeds

// repeated .feedstore.WebFeedInfo feeds = 1;
inline int SubscribedWebFeeds::_internal_feeds_size() const
{
    return _impl_.feeds_.size();
}
inline int SubscribedWebFeeds::feeds_size() const
{
    return _internal_feeds_size();
}
inline void SubscribedWebFeeds::clear_feeds()
{
    _impl_.feeds_.Clear();
}
inline ::feedstore::WebFeedInfo* SubscribedWebFeeds::mutable_feeds(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.SubscribedWebFeeds.feeds)
    return _impl_.feeds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::WebFeedInfo>* SubscribedWebFeeds::mutable_feeds()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.SubscribedWebFeeds.feeds)
    return &_impl_.feeds_;
}
inline const ::feedstore::WebFeedInfo& SubscribedWebFeeds::_internal_feeds(int index) const
{
    return _impl_.feeds_.Get(index);
}
inline const ::feedstore::WebFeedInfo& SubscribedWebFeeds::feeds(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.SubscribedWebFeeds.feeds)
    return _internal_feeds(index);
}
inline ::feedstore::WebFeedInfo* SubscribedWebFeeds::_internal_add_feeds()
{
    return _impl_.feeds_.Add();
}
inline ::feedstore::WebFeedInfo* SubscribedWebFeeds::add_feeds()
{
    ::feedstore::WebFeedInfo* _add = _internal_add_feeds();
    // @@protoc_insertion_point(field_add:feedstore.SubscribedWebFeeds.feeds)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::WebFeedInfo>& SubscribedWebFeeds::feeds() const
{
    // @@protoc_insertion_point(field_list:feedstore.SubscribedWebFeeds.feeds)
    return _impl_.feeds_;
}

// int64 update_time_millis = 2;
inline void SubscribedWebFeeds::clear_update_time_millis()
{
    _impl_.update_time_millis_ = int64_t { 0 };
}
inline int64_t SubscribedWebFeeds::_internal_update_time_millis() const
{
    return _impl_.update_time_millis_;
}
inline int64_t SubscribedWebFeeds::update_time_millis() const
{
    // @@protoc_insertion_point(field_get:feedstore.SubscribedWebFeeds.update_time_millis)
    return _internal_update_time_millis();
}
inline void SubscribedWebFeeds::_internal_set_update_time_millis(int64_t value)
{

    _impl_.update_time_millis_ = value;
}
inline void SubscribedWebFeeds::set_update_time_millis(int64_t value)
{
    _internal_set_update_time_millis(value);
    // @@protoc_insertion_point(field_set:feedstore.SubscribedWebFeeds.update_time_millis)
}

// -------------------------------------------------------------------

// RecommendedWebFeedIndex_Entry

// string web_feed_id = 1;
inline void RecommendedWebFeedIndex_Entry::clear_web_feed_id()
{
    _impl_.web_feed_id_.ClearToEmpty();
}
inline const std::string& RecommendedWebFeedIndex_Entry::web_feed_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
    return _internal_web_feed_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void RecommendedWebFeedIndex_Entry::set_web_feed_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.web_feed_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
}
inline std::string* RecommendedWebFeedIndex_Entry::mutable_web_feed_id()
{
    std::string* _s = _internal_mutable_web_feed_id();
    // @@protoc_insertion_point(field_mutable:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
    return _s;
}
inline const std::string& RecommendedWebFeedIndex_Entry::_internal_web_feed_id() const
{
    return _impl_.web_feed_id_.Get();
}
inline void RecommendedWebFeedIndex_Entry::_internal_set_web_feed_id(const std::string& value)
{

    _impl_.web_feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RecommendedWebFeedIndex_Entry::_internal_mutable_web_feed_id()
{

    return _impl_.web_feed_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RecommendedWebFeedIndex_Entry::release_web_feed_id()
{
    // @@protoc_insertion_point(field_release:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
    return _impl_.web_feed_id_.Release();
}
inline void RecommendedWebFeedIndex_Entry::set_allocated_web_feed_id(std::string* web_feed_id)
{
    if (web_feed_id != nullptr) {

    } else {
    }
    _impl_.web_feed_id_.SetAllocated(web_feed_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.web_feed_id_.IsDefault()) {
        _impl_.web_feed_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
}

// repeated .feedwire.webfeed.WebFeedMatcher matchers = 2;
inline int RecommendedWebFeedIndex_Entry::_internal_matchers_size() const
{
    return _impl_.matchers_.size();
}
inline int RecommendedWebFeedIndex_Entry::matchers_size() const
{
    return _internal_matchers_size();
}
inline ::feedwire::webfeed::WebFeedMatcher* RecommendedWebFeedIndex_Entry::mutable_matchers(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.RecommendedWebFeedIndex.Entry.matchers)
    return _impl_.matchers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher>* RecommendedWebFeedIndex_Entry::mutable_matchers()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.RecommendedWebFeedIndex.Entry.matchers)
    return &_impl_.matchers_;
}
inline const ::feedwire::webfeed::WebFeedMatcher& RecommendedWebFeedIndex_Entry::_internal_matchers(int index) const
{
    return _impl_.matchers_.Get(index);
}
inline const ::feedwire::webfeed::WebFeedMatcher& RecommendedWebFeedIndex_Entry::matchers(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.RecommendedWebFeedIndex.Entry.matchers)
    return _internal_matchers(index);
}
inline ::feedwire::webfeed::WebFeedMatcher* RecommendedWebFeedIndex_Entry::_internal_add_matchers()
{
    return _impl_.matchers_.Add();
}
inline ::feedwire::webfeed::WebFeedMatcher* RecommendedWebFeedIndex_Entry::add_matchers()
{
    ::feedwire::webfeed::WebFeedMatcher* _add = _internal_add_matchers();
    // @@protoc_insertion_point(field_add:feedstore.RecommendedWebFeedIndex.Entry.matchers)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher>& RecommendedWebFeedIndex_Entry::matchers() const
{
    // @@protoc_insertion_point(field_list:feedstore.RecommendedWebFeedIndex.Entry.matchers)
    return _impl_.matchers_;
}

// -------------------------------------------------------------------

// RecommendedWebFeedIndex

// repeated .feedstore.RecommendedWebFeedIndex.Entry entries = 1;
inline int RecommendedWebFeedIndex::_internal_entries_size() const
{
    return _impl_.entries_.size();
}
inline int RecommendedWebFeedIndex::entries_size() const
{
    return _internal_entries_size();
}
inline void RecommendedWebFeedIndex::clear_entries()
{
    _impl_.entries_.Clear();
}
inline ::feedstore::RecommendedWebFeedIndex_Entry* RecommendedWebFeedIndex::mutable_entries(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.RecommendedWebFeedIndex.entries)
    return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::RecommendedWebFeedIndex_Entry>* RecommendedWebFeedIndex::mutable_entries()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.RecommendedWebFeedIndex.entries)
    return &_impl_.entries_;
}
inline const ::feedstore::RecommendedWebFeedIndex_Entry& RecommendedWebFeedIndex::_internal_entries(int index) const
{
    return _impl_.entries_.Get(index);
}
inline const ::feedstore::RecommendedWebFeedIndex_Entry& RecommendedWebFeedIndex::entries(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.RecommendedWebFeedIndex.entries)
    return _internal_entries(index);
}
inline ::feedstore::RecommendedWebFeedIndex_Entry* RecommendedWebFeedIndex::_internal_add_entries()
{
    return _impl_.entries_.Add();
}
inline ::feedstore::RecommendedWebFeedIndex_Entry* RecommendedWebFeedIndex::add_entries()
{
    ::feedstore::RecommendedWebFeedIndex_Entry* _add = _internal_add_entries();
    // @@protoc_insertion_point(field_add:feedstore.RecommendedWebFeedIndex.entries)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedstore::RecommendedWebFeedIndex_Entry>& RecommendedWebFeedIndex::entries() const
{
    // @@protoc_insertion_point(field_list:feedstore.RecommendedWebFeedIndex.entries)
    return _impl_.entries_;
}

// int64 update_time_millis = 2;
inline void RecommendedWebFeedIndex::clear_update_time_millis()
{
    _impl_.update_time_millis_ = int64_t { 0 };
}
inline int64_t RecommendedWebFeedIndex::_internal_update_time_millis() const
{
    return _impl_.update_time_millis_;
}
inline int64_t RecommendedWebFeedIndex::update_time_millis() const
{
    // @@protoc_insertion_point(field_get:feedstore.RecommendedWebFeedIndex.update_time_millis)
    return _internal_update_time_millis();
}
inline void RecommendedWebFeedIndex::_internal_set_update_time_millis(int64_t value)
{

    _impl_.update_time_millis_ = value;
}
inline void RecommendedWebFeedIndex::set_update_time_millis(int64_t value)
{
    _internal_set_update_time_millis(value);
    // @@protoc_insertion_point(field_set:feedstore.RecommendedWebFeedIndex.update_time_millis)
}

// -------------------------------------------------------------------

// Image

// string url = 1;
inline void Image::clear_url()
{
    _impl_.url_.ClearToEmpty();
}
inline const std::string& Image::url() const
{
    // @@protoc_insertion_point(field_get:feedstore.Image.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Image::set_url(ArgT0&& arg0, ArgT... args)
{

    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.Image.url)
}
inline std::string* Image::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:feedstore.Image.url)
    return _s;
}
inline const std::string& Image::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void Image::_internal_set_url(const std::string& value)
{

    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_url()
{

    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_url()
{
    // @@protoc_insertion_point(field_release:feedstore.Image.url)
    return _impl_.url_.Release();
}
inline void Image::set_allocated_url(std::string* url)
{
    if (url != nullptr) {

    } else {
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.Image.url)
}

// -------------------------------------------------------------------

// WebFeedInfo

// string web_feed_id = 1;
inline void WebFeedInfo::clear_web_feed_id()
{
    _impl_.web_feed_id_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::web_feed_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.web_feed_id)
    return _internal_web_feed_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebFeedInfo::set_web_feed_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.web_feed_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.web_feed_id)
}
inline std::string* WebFeedInfo::mutable_web_feed_id()
{
    std::string* _s = _internal_mutable_web_feed_id();
    // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.web_feed_id)
    return _s;
}
inline const std::string& WebFeedInfo::_internal_web_feed_id() const
{
    return _impl_.web_feed_id_.Get();
}
inline void WebFeedInfo::_internal_set_web_feed_id(const std::string& value)
{

    _impl_.web_feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_web_feed_id()
{

    return _impl_.web_feed_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_web_feed_id()
{
    // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.web_feed_id)
    return _impl_.web_feed_id_.Release();
}
inline void WebFeedInfo::set_allocated_web_feed_id(std::string* web_feed_id)
{
    if (web_feed_id != nullptr) {

    } else {
    }
    _impl_.web_feed_id_.SetAllocated(web_feed_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.web_feed_id_.IsDefault()) {
        _impl_.web_feed_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.web_feed_id)
}

// string title = 2;
inline void WebFeedInfo::clear_title()
{
    _impl_.title_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::title() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.title)
    return _internal_title();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebFeedInfo::set_title(ArgT0&& arg0, ArgT... args)
{

    _impl_.title_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.title)
}
inline std::string* WebFeedInfo::mutable_title()
{
    std::string* _s = _internal_mutable_title();
    // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.title)
    return _s;
}
inline const std::string& WebFeedInfo::_internal_title() const
{
    return _impl_.title_.Get();
}
inline void WebFeedInfo::_internal_set_title(const std::string& value)
{

    _impl_.title_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_title()
{

    return _impl_.title_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_title()
{
    // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.title)
    return _impl_.title_.Release();
}
inline void WebFeedInfo::set_allocated_title(std::string* title)
{
    if (title != nullptr) {

    } else {
    }
    _impl_.title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.title_.IsDefault()) {
        _impl_.title_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.title)
}

// string subtitle = 3;
inline void WebFeedInfo::clear_subtitle()
{
    _impl_.subtitle_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::subtitle() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.subtitle)
    return _internal_subtitle();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebFeedInfo::set_subtitle(ArgT0&& arg0, ArgT... args)
{

    _impl_.subtitle_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.subtitle)
}
inline std::string* WebFeedInfo::mutable_subtitle()
{
    std::string* _s = _internal_mutable_subtitle();
    // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.subtitle)
    return _s;
}
inline const std::string& WebFeedInfo::_internal_subtitle() const
{
    return _impl_.subtitle_.Get();
}
inline void WebFeedInfo::_internal_set_subtitle(const std::string& value)
{

    _impl_.subtitle_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_subtitle()
{

    return _impl_.subtitle_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_subtitle()
{
    // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.subtitle)
    return _impl_.subtitle_.Release();
}
inline void WebFeedInfo::set_allocated_subtitle(std::string* subtitle)
{
    if (subtitle != nullptr) {

    } else {
    }
    _impl_.subtitle_.SetAllocated(subtitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.subtitle_.IsDefault()) {
        _impl_.subtitle_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.subtitle)
}

// string detail_text = 4;
inline void WebFeedInfo::clear_detail_text()
{
    _impl_.detail_text_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::detail_text() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.detail_text)
    return _internal_detail_text();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebFeedInfo::set_detail_text(ArgT0&& arg0, ArgT... args)
{

    _impl_.detail_text_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.detail_text)
}
inline std::string* WebFeedInfo::mutable_detail_text()
{
    std::string* _s = _internal_mutable_detail_text();
    // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.detail_text)
    return _s;
}
inline const std::string& WebFeedInfo::_internal_detail_text() const
{
    return _impl_.detail_text_.Get();
}
inline void WebFeedInfo::_internal_set_detail_text(const std::string& value)
{

    _impl_.detail_text_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_detail_text()
{

    return _impl_.detail_text_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_detail_text()
{
    // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.detail_text)
    return _impl_.detail_text_.Release();
}
inline void WebFeedInfo::set_allocated_detail_text(std::string* detail_text)
{
    if (detail_text != nullptr) {

    } else {
    }
    _impl_.detail_text_.SetAllocated(detail_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.detail_text_.IsDefault()) {
        _impl_.detail_text_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.detail_text)
}

// string visit_uri = 5;
inline void WebFeedInfo::clear_visit_uri()
{
    _impl_.visit_uri_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::visit_uri() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.visit_uri)
    return _internal_visit_uri();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebFeedInfo::set_visit_uri(ArgT0&& arg0, ArgT... args)
{

    _impl_.visit_uri_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.visit_uri)
}
inline std::string* WebFeedInfo::mutable_visit_uri()
{
    std::string* _s = _internal_mutable_visit_uri();
    // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.visit_uri)
    return _s;
}
inline const std::string& WebFeedInfo::_internal_visit_uri() const
{
    return _impl_.visit_uri_.Get();
}
inline void WebFeedInfo::_internal_set_visit_uri(const std::string& value)
{

    _impl_.visit_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_visit_uri()
{

    return _impl_.visit_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_visit_uri()
{
    // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.visit_uri)
    return _impl_.visit_uri_.Release();
}
inline void WebFeedInfo::set_allocated_visit_uri(std::string* visit_uri)
{
    if (visit_uri != nullptr) {

    } else {
    }
    _impl_.visit_uri_.SetAllocated(visit_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.visit_uri_.IsDefault()) {
        _impl_.visit_uri_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.visit_uri)
}

// string rss_uri = 6;
inline void WebFeedInfo::clear_rss_uri()
{
    _impl_.rss_uri_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::rss_uri() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.rss_uri)
    return _internal_rss_uri();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WebFeedInfo::set_rss_uri(ArgT0&& arg0, ArgT... args)
{

    _impl_.rss_uri_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.rss_uri)
}
inline std::string* WebFeedInfo::mutable_rss_uri()
{
    std::string* _s = _internal_mutable_rss_uri();
    // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.rss_uri)
    return _s;
}
inline const std::string& WebFeedInfo::_internal_rss_uri() const
{
    return _impl_.rss_uri_.Get();
}
inline void WebFeedInfo::_internal_set_rss_uri(const std::string& value)
{

    _impl_.rss_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_rss_uri()
{

    return _impl_.rss_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_rss_uri()
{
    // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.rss_uri)
    return _impl_.rss_uri_.Release();
}
inline void WebFeedInfo::set_allocated_rss_uri(std::string* rss_uri)
{
    if (rss_uri != nullptr) {

    } else {
    }
    _impl_.rss_uri_.SetAllocated(rss_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.rss_uri_.IsDefault()) {
        _impl_.rss_uri_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.rss_uri)
}

// .feedstore.Image favicon = 7;
inline bool WebFeedInfo::_internal_has_favicon() const
{
    return this != internal_default_instance() && _impl_.favicon_ != nullptr;
}
inline bool WebFeedInfo::has_favicon() const
{
    return _internal_has_favicon();
}
inline void WebFeedInfo::clear_favicon()
{
    if (GetArenaForAllocation() == nullptr && _impl_.favicon_ != nullptr) {
        delete _impl_.favicon_;
    }
    _impl_.favicon_ = nullptr;
}
inline const ::feedstore::Image& WebFeedInfo::_internal_favicon() const
{
    const ::feedstore::Image* p = _impl_.favicon_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedstore::Image&>(::feedstore::_Image_default_instance_);
}
inline const ::feedstore::Image& WebFeedInfo::favicon() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.favicon)
    return _internal_favicon();
}
inline void WebFeedInfo::unsafe_arena_set_allocated_favicon(::feedstore::Image* favicon)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.favicon_);
    }
    _impl_.favicon_ = favicon;
    if (favicon) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.WebFeedInfo.favicon)
}
inline ::feedstore::Image* WebFeedInfo::release_favicon()
{

    ::feedstore::Image* temp = _impl_.favicon_;
    _impl_.favicon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedstore::Image* WebFeedInfo::unsafe_arena_release_favicon()
{
    // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.favicon)

    ::feedstore::Image* temp = _impl_.favicon_;
    _impl_.favicon_ = nullptr;
    return temp;
}
inline ::feedstore::Image* WebFeedInfo::_internal_mutable_favicon()
{

    if (_impl_.favicon_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedstore::Image>(GetArenaForAllocation());
        _impl_.favicon_ = p;
    }
    return _impl_.favicon_;
}
inline ::feedstore::Image* WebFeedInfo::mutable_favicon()
{
    ::feedstore::Image* _msg = _internal_mutable_favicon();
    // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.favicon)
    return _msg;
}
inline void WebFeedInfo::set_allocated_favicon(::feedstore::Image* favicon)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.favicon_;
    }
    if (favicon) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(favicon);
        if (message_arena != submessage_arena) {
            favicon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, favicon, submessage_arena);
        }

    } else {
    }
    _impl_.favicon_ = favicon;
    // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.favicon)
}

// int64 follower_count = 8;
inline void WebFeedInfo::clear_follower_count()
{
    _impl_.follower_count_ = int64_t { 0 };
}
inline int64_t WebFeedInfo::_internal_follower_count() const
{
    return _impl_.follower_count_;
}
inline int64_t WebFeedInfo::follower_count() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.follower_count)
    return _internal_follower_count();
}
inline void WebFeedInfo::_internal_set_follower_count(int64_t value)
{

    _impl_.follower_count_ = value;
}
inline void WebFeedInfo::set_follower_count(int64_t value)
{
    _internal_set_follower_count(value);
    // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.follower_count)
}

// .feedstore.WebFeedInfo.State state = 9;
inline void WebFeedInfo::clear_state()
{
    _impl_.state_ = 0;
}
inline ::feedstore::WebFeedInfo_State WebFeedInfo::_internal_state() const
{
    return static_cast<::feedstore::WebFeedInfo_State>(_impl_.state_);
}
inline ::feedstore::WebFeedInfo_State WebFeedInfo::state() const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.state)
    return _internal_state();
}
inline void WebFeedInfo::_internal_set_state(::feedstore::WebFeedInfo_State value)
{

    _impl_.state_ = value;
}
inline void WebFeedInfo::set_state(::feedstore::WebFeedInfo_State value)
{
    _internal_set_state(value);
    // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.state)
}

// repeated .feedwire.webfeed.WebFeedMatcher matchers = 10;
inline int WebFeedInfo::_internal_matchers_size() const
{
    return _impl_.matchers_.size();
}
inline int WebFeedInfo::matchers_size() const
{
    return _internal_matchers_size();
}
inline ::feedwire::webfeed::WebFeedMatcher* WebFeedInfo::mutable_matchers(int index)
{
    // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.matchers)
    return _impl_.matchers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher>* WebFeedInfo::mutable_matchers()
{
    // @@protoc_insertion_point(field_mutable_list:feedstore.WebFeedInfo.matchers)
    return &_impl_.matchers_;
}
inline const ::feedwire::webfeed::WebFeedMatcher& WebFeedInfo::_internal_matchers(int index) const
{
    return _impl_.matchers_.Get(index);
}
inline const ::feedwire::webfeed::WebFeedMatcher& WebFeedInfo::matchers(int index) const
{
    // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.matchers)
    return _internal_matchers(index);
}
inline ::feedwire::webfeed::WebFeedMatcher* WebFeedInfo::_internal_add_matchers()
{
    return _impl_.matchers_.Add();
}
inline ::feedwire::webfeed::WebFeedMatcher* WebFeedInfo::add_matchers()
{
    ::feedwire::webfeed::WebFeedMatcher* _add = _internal_add_matchers();
    // @@protoc_insertion_point(field_add:feedstore.WebFeedInfo.matchers)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::feedwire::webfeed::WebFeedMatcher>& WebFeedInfo::matchers() const
{
    // @@protoc_insertion_point(field_list:feedstore.WebFeedInfo.matchers)
    return _impl_.matchers_;
}

// -------------------------------------------------------------------

// PendingWebFeedOperation

// int64 id = 1;
inline void PendingWebFeedOperation::clear_id()
{
    _impl_.id_ = int64_t { 0 };
}
inline int64_t PendingWebFeedOperation::_internal_id() const
{
    return _impl_.id_;
}
inline int64_t PendingWebFeedOperation::id() const
{
    // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.id)
    return _internal_id();
}
inline void PendingWebFeedOperation::_internal_set_id(int64_t value)
{

    _impl_.id_ = value;
}
inline void PendingWebFeedOperation::set_id(int64_t value)
{
    _internal_set_id(value);
    // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.id)
}

// .feedstore.PendingWebFeedOperation.Kind kind = 2;
inline void PendingWebFeedOperation::clear_kind()
{
    _impl_.kind_ = 0;
}
inline ::feedstore::PendingWebFeedOperation_Kind PendingWebFeedOperation::_internal_kind() const
{
    return static_cast<::feedstore::PendingWebFeedOperation_Kind>(_impl_.kind_);
}
inline ::feedstore::PendingWebFeedOperation_Kind PendingWebFeedOperation::kind() const
{
    // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.kind)
    return _internal_kind();
}
inline void PendingWebFeedOperation::_internal_set_kind(::feedstore::PendingWebFeedOperation_Kind value)
{

    _impl_.kind_ = value;
}
inline void PendingWebFeedOperation::set_kind(::feedstore::PendingWebFeedOperation_Kind value)
{
    _internal_set_kind(value);
    // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.kind)
}

// string web_feed_id = 3;
inline void PendingWebFeedOperation::clear_web_feed_id()
{
    _impl_.web_feed_id_.ClearToEmpty();
}
inline const std::string& PendingWebFeedOperation::web_feed_id() const
{
    // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.web_feed_id)
    return _internal_web_feed_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void PendingWebFeedOperation::set_web_feed_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.web_feed_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.web_feed_id)
}
inline std::string* PendingWebFeedOperation::mutable_web_feed_id()
{
    std::string* _s = _internal_mutable_web_feed_id();
    // @@protoc_insertion_point(field_mutable:feedstore.PendingWebFeedOperation.web_feed_id)
    return _s;
}
inline const std::string& PendingWebFeedOperation::_internal_web_feed_id() const
{
    return _impl_.web_feed_id_.Get();
}
inline void PendingWebFeedOperation::_internal_set_web_feed_id(const std::string& value)
{

    _impl_.web_feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PendingWebFeedOperation::_internal_mutable_web_feed_id()
{

    return _impl_.web_feed_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PendingWebFeedOperation::release_web_feed_id()
{
    // @@protoc_insertion_point(field_release:feedstore.PendingWebFeedOperation.web_feed_id)
    return _impl_.web_feed_id_.Release();
}
inline void PendingWebFeedOperation::set_allocated_web_feed_id(std::string* web_feed_id)
{
    if (web_feed_id != nullptr) {

    } else {
    }
    _impl_.web_feed_id_.SetAllocated(web_feed_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.web_feed_id_.IsDefault()) {
        _impl_.web_feed_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:feedstore.PendingWebFeedOperation.web_feed_id)
}

// int32 attempts = 4;
inline void PendingWebFeedOperation::clear_attempts()
{
    _impl_.attempts_ = 0;
}
inline int32_t PendingWebFeedOperation::_internal_attempts() const
{
    return _impl_.attempts_;
}
inline int32_t PendingWebFeedOperation::attempts() const
{
    // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.attempts)
    return _internal_attempts();
}
inline void PendingWebFeedOperation::_internal_set_attempts(int32_t value)
{

    _impl_.attempts_ = value;
}
inline void PendingWebFeedOperation::set_attempts(int32_t value)
{
    _internal_set_attempts(value);
    // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.attempts)
}

// .feedwire.webfeed.WebFeedChangeReason change_reason = 5;
inline void PendingWebFeedOperation::clear_change_reason()
{
    _impl_.change_reason_ = 0;
}
inline ::feedwire::webfeed::WebFeedChangeReason PendingWebFeedOperation::_internal_change_reason() const
{
    return static_cast<::feedwire::webfeed::WebFeedChangeReason>(_impl_.change_reason_);
}
inline ::feedwire::webfeed::WebFeedChangeReason PendingWebFeedOperation::change_reason() const
{
    // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.change_reason)
    return _internal_change_reason();
}
inline void PendingWebFeedOperation::_internal_set_change_reason(::feedwire::webfeed::WebFeedChangeReason value)
{

    _impl_.change_reason_ = value;
}
inline void PendingWebFeedOperation::set_change_reason(::feedwire::webfeed::WebFeedChangeReason value)
{
    _internal_set_change_reason(value);
    // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.change_reason)
}

// -------------------------------------------------------------------

// DocView

// uint64 docid = 1;
inline void DocView::clear_docid()
{
    _impl_.docid_ = uint64_t { 0u };
}
inline uint64_t DocView::_internal_docid() const
{
    return _impl_.docid_;
}
inline uint64_t DocView::docid() const
{
    // @@protoc_insertion_point(field_get:feedstore.DocView.docid)
    return _internal_docid();
}
inline void DocView::_internal_set_docid(uint64_t value)
{

    _impl_.docid_ = value;
}
inline void DocView::set_docid(uint64_t value)
{
    _internal_set_docid(value);
    // @@protoc_insertion_point(field_set:feedstore.DocView.docid)
}

// int64 view_time_millis = 4;
inline void DocView::clear_view_time_millis()
{
    _impl_.view_time_millis_ = int64_t { 0 };
}
inline int64_t DocView::_internal_view_time_millis() const
{
    return _impl_.view_time_millis_;
}
inline int64_t DocView::view_time_millis() const
{
    // @@protoc_insertion_point(field_get:feedstore.DocView.view_time_millis)
    return _internal_view_time_millis();
}
inline void DocView::_internal_set_view_time_millis(int64_t value)
{

    _impl_.view_time_millis_ = value;
}
inline void DocView::set_view_time_millis(int64_t value)
{
    _internal_set_view_time_millis(value);
    // @@protoc_insertion_point(field_set:feedstore.DocView.view_time_millis)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace feedstore

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::feedstore::StreamStructure_Operation> : ::std::true_type { };
template <> struct is_proto_enum<::feedstore::StreamStructure_Type> : ::std::true_type { };
template <> struct is_proto_enum<::feedstore::WebFeedInfo_State> : ::std::true_type { };
template <> struct is_proto_enum<::feedstore::PendingWebFeedOperation_Kind> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto
