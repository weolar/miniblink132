// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/feed/core/proto/v2/wire/feature.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fwire_2ffeature_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fwire_2ffeature_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/feed/core/proto/v2/wire/content_id.pb.h"
#include "components/feed/core/proto/v2/wire/expiration_info.pb.h"
#include "components/feed/core/proto/v2/wire/stream_structure.pb.h"
#include "components/feed/core/proto/v2/wire/token.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2ffeed_2fcore_2fproto_2fv2_2fwire_2ffeature_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fwire_2ffeature_2eproto {
    static const uint32_t offsets[];
};
namespace feedwire {
class Feature;
struct FeatureDefaultTypeInternal;
extern FeatureDefaultTypeInternal _Feature_default_instance_;
} // namespace feedwire
PROTOBUF_NAMESPACE_OPEN
template <>::feedwire::Feature* Arena::CreateMaybeMessage<::feedwire::Feature>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace feedwire {

enum Feature_RenderableUnit : int {
    Feature_RenderableUnit_UNKNOWN_RENDERABLE_UNIT = 0,
    Feature_RenderableUnit_STREAM = 1,
    Feature_RenderableUnit_CONTENT = 3,
    Feature_RenderableUnit_GROUP = 4
};
bool Feature_RenderableUnit_IsValid(int value);
constexpr Feature_RenderableUnit Feature_RenderableUnit_RenderableUnit_MIN = Feature_RenderableUnit_UNKNOWN_RENDERABLE_UNIT;
constexpr Feature_RenderableUnit Feature_RenderableUnit_RenderableUnit_MAX = Feature_RenderableUnit_GROUP;
constexpr int Feature_RenderableUnit_RenderableUnit_ARRAYSIZE = Feature_RenderableUnit_RenderableUnit_MAX + 1;

const std::string& Feature_RenderableUnit_Name(Feature_RenderableUnit value);
template <typename T> inline const std::string& Feature_RenderableUnit_Name(T enum_t_value)
{
    static_assert(
        ::std::is_same<T, Feature_RenderableUnit>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Feature_RenderableUnit_Name.");
    return Feature_RenderableUnit_Name(static_cast<Feature_RenderableUnit>(enum_t_value));
}
bool Feature_RenderableUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Feature_RenderableUnit* value);
// ===================================================================

class Feature final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedwire.Feature) */ {
public:
    inline Feature()
        : Feature(nullptr)
    {
    }
    ~Feature() override;
    explicit PROTOBUF_CONSTEXPR Feature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Feature(const Feature& from);
    Feature(Feature&& from) noexcept
        : Feature()
    {
        *this = ::std::move(from);
    }

    inline Feature& operator=(const Feature& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Feature& operator=(Feature&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Feature& default_instance()
    {
        return *internal_default_instance();
    }
    enum ParentInfoCase {
        kParentId = 1,
        kIsRoot = 4,
        PARENT_INFO_NOT_SET = 0,
    };

    static inline const Feature* internal_default_instance()
    {
        return reinterpret_cast<const Feature*>(&_Feature_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(Feature& a, Feature& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Feature* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Feature* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Feature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Feature>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Feature& from);
    void MergeFrom(const Feature& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Feature* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "feedwire.Feature";
    }

protected:
    explicit Feature(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Feature_RenderableUnit RenderableUnit;
    static constexpr RenderableUnit UNKNOWN_RENDERABLE_UNIT = Feature_RenderableUnit_UNKNOWN_RENDERABLE_UNIT;
    static constexpr RenderableUnit STREAM = Feature_RenderableUnit_STREAM;
    static constexpr RenderableUnit CONTENT = Feature_RenderableUnit_CONTENT;
    static constexpr RenderableUnit GROUP = Feature_RenderableUnit_GROUP;
    static inline bool RenderableUnit_IsValid(int value)
    {
        return Feature_RenderableUnit_IsValid(value);
    }
    static constexpr RenderableUnit RenderableUnit_MIN = Feature_RenderableUnit_RenderableUnit_MIN;
    static constexpr RenderableUnit RenderableUnit_MAX = Feature_RenderableUnit_RenderableUnit_MAX;
    static constexpr int RenderableUnit_ARRAYSIZE = Feature_RenderableUnit_RenderableUnit_ARRAYSIZE;
    template <typename T> static inline const std::string& RenderableUnit_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, RenderableUnit>::value || ::std::is_integral<T>::value, "Incorrect type passed to function RenderableUnit_Name.");
        return Feature_RenderableUnit_Name(enum_t_value);
    }
    static inline bool RenderableUnit_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RenderableUnit* value)
    {
        return Feature_RenderableUnit_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kExpirationInfoFieldNumber = 3,
        kStreamFieldNumber = 185431437,
        kContentFieldNumber = 185431439,
        kGroupFieldNumber = 190812910,
        kTokenFieldNumber = 194964015,
        kRenderableUnitFieldNumber = 2,
        kParentIdFieldNumber = 1,
        kIsRootFieldNumber = 4,
    };
    // optional .feedwire.ExpirationInfo expiration_info = 3;
    bool has_expiration_info() const;

private:
    bool _internal_has_expiration_info() const;

public:
    void clear_expiration_info();
    const ::feedwire::ExpirationInfo& expiration_info() const;
    PROTOBUF_NODISCARD ::feedwire::ExpirationInfo* release_expiration_info();
    ::feedwire::ExpirationInfo* mutable_expiration_info();
    void set_allocated_expiration_info(::feedwire::ExpirationInfo* expiration_info);

private:
    const ::feedwire::ExpirationInfo& _internal_expiration_info() const;
    ::feedwire::ExpirationInfo* _internal_mutable_expiration_info();

public:
    void unsafe_arena_set_allocated_expiration_info(::feedwire::ExpirationInfo* expiration_info);
    ::feedwire::ExpirationInfo* unsafe_arena_release_expiration_info();

    // optional .feedwire.Stream stream = 185431437;
    bool has_stream() const;

private:
    bool _internal_has_stream() const;

public:
    void clear_stream();
    const ::feedwire::Stream& stream() const;
    PROTOBUF_NODISCARD ::feedwire::Stream* release_stream();
    ::feedwire::Stream* mutable_stream();
    void set_allocated_stream(::feedwire::Stream* stream);

private:
    const ::feedwire::Stream& _internal_stream() const;
    ::feedwire::Stream* _internal_mutable_stream();

public:
    void unsafe_arena_set_allocated_stream(::feedwire::Stream* stream);
    ::feedwire::Stream* unsafe_arena_release_stream();

    // optional .feedwire.Content content = 185431439;
    bool has_content() const;

private:
    bool _internal_has_content() const;

public:
    void clear_content();
    const ::feedwire::Content& content() const;
    PROTOBUF_NODISCARD ::feedwire::Content* release_content();
    ::feedwire::Content* mutable_content();
    void set_allocated_content(::feedwire::Content* content);

private:
    const ::feedwire::Content& _internal_content() const;
    ::feedwire::Content* _internal_mutable_content();

public:
    void unsafe_arena_set_allocated_content(::feedwire::Content* content);
    ::feedwire::Content* unsafe_arena_release_content();

    // optional .feedwire.Group group = 190812910;
    bool has_group() const;

private:
    bool _internal_has_group() const;

public:
    void clear_group();
    const ::feedwire::Group& group() const;
    PROTOBUF_NODISCARD ::feedwire::Group* release_group();
    ::feedwire::Group* mutable_group();
    void set_allocated_group(::feedwire::Group* group);

private:
    const ::feedwire::Group& _internal_group() const;
    ::feedwire::Group* _internal_mutable_group();

public:
    void unsafe_arena_set_allocated_group(::feedwire::Group* group);
    ::feedwire::Group* unsafe_arena_release_group();

    // optional .feedwire.Token token = 194964015;
    bool has_token() const;

private:
    bool _internal_has_token() const;

public:
    void clear_token();
    const ::feedwire::Token& token() const;
    PROTOBUF_NODISCARD ::feedwire::Token* release_token();
    ::feedwire::Token* mutable_token();
    void set_allocated_token(::feedwire::Token* token);

private:
    const ::feedwire::Token& _internal_token() const;
    ::feedwire::Token* _internal_mutable_token();

public:
    void unsafe_arena_set_allocated_token(::feedwire::Token* token);
    ::feedwire::Token* unsafe_arena_release_token();

    // optional .feedwire.Feature.RenderableUnit renderable_unit = 2;
    bool has_renderable_unit() const;

private:
    bool _internal_has_renderable_unit() const;

public:
    void clear_renderable_unit();
    ::feedwire::Feature_RenderableUnit renderable_unit() const;
    void set_renderable_unit(::feedwire::Feature_RenderableUnit value);

private:
    ::feedwire::Feature_RenderableUnit _internal_renderable_unit() const;
    void _internal_set_renderable_unit(::feedwire::Feature_RenderableUnit value);

public:
    // .feedwire.ContentId parent_id = 1;
    bool has_parent_id() const;

private:
    bool _internal_has_parent_id() const;

public:
    void clear_parent_id();
    const ::feedwire::ContentId& parent_id() const;
    PROTOBUF_NODISCARD ::feedwire::ContentId* release_parent_id();
    ::feedwire::ContentId* mutable_parent_id();
    void set_allocated_parent_id(::feedwire::ContentId* parent_id);

private:
    const ::feedwire::ContentId& _internal_parent_id() const;
    ::feedwire::ContentId* _internal_mutable_parent_id();

public:
    void unsafe_arena_set_allocated_parent_id(::feedwire::ContentId* parent_id);
    ::feedwire::ContentId* unsafe_arena_release_parent_id();

    // bool is_root = 4;
    bool has_is_root() const;

private:
    bool _internal_has_is_root() const;

public:
    void clear_is_root();
    bool is_root() const;
    void set_is_root(bool value);

private:
    bool _internal_is_root() const;
    void _internal_set_is_root(bool value);

public:
    void clear_parent_info();
    ParentInfoCase parent_info_case() const;
    // @@protoc_insertion_point(class_scope:feedwire.Feature)
private:
    class _Internal;
    void set_has_parent_id();
    void set_has_is_root();

    inline bool has_parent_info() const;
    inline void clear_has_parent_info();

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::feedwire::ExpirationInfo* expiration_info_;
        ::feedwire::Stream* stream_;
        ::feedwire::Content* content_;
        ::feedwire::Group* group_;
        ::feedwire::Token* token_;
        int renderable_unit_;
        union ParentInfoUnion {
            constexpr ParentInfoUnion()
                : _constinit_ {}
            {
            }
            ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
            ::feedwire::ContentId* parent_id_;
            bool is_root_;
        } parent_info_;
        uint32_t _oneof_case_[1];
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fwire_2ffeature_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Feature

// .feedwire.ContentId parent_id = 1;
inline bool Feature::_internal_has_parent_id() const
{
    return parent_info_case() == kParentId;
}
inline bool Feature::has_parent_id() const
{
    return _internal_has_parent_id();
}
inline void Feature::set_has_parent_id()
{
    _impl_._oneof_case_[0] = kParentId;
}
inline ::feedwire::ContentId* Feature::release_parent_id()
{
    // @@protoc_insertion_point(field_release:feedwire.Feature.parent_id)
    if (_internal_has_parent_id()) {
        clear_has_parent_info();
        ::feedwire::ContentId* temp = _impl_.parent_info_.parent_id_;
        if (GetArenaForAllocation() != nullptr) {
            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
        }
        _impl_.parent_info_.parent_id_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline const ::feedwire::ContentId& Feature::_internal_parent_id() const
{
    return _internal_has_parent_id() ? *_impl_.parent_info_.parent_id_ : reinterpret_cast<::feedwire::ContentId&>(::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& Feature::parent_id() const
{
    // @@protoc_insertion_point(field_get:feedwire.Feature.parent_id)
    return _internal_parent_id();
}
inline ::feedwire::ContentId* Feature::unsafe_arena_release_parent_id()
{
    // @@protoc_insertion_point(field_unsafe_arena_release:feedwire.Feature.parent_id)
    if (_internal_has_parent_id()) {
        clear_has_parent_info();
        ::feedwire::ContentId* temp = _impl_.parent_info_.parent_id_;
        _impl_.parent_info_.parent_id_ = nullptr;
        return temp;
    } else {
        return nullptr;
    }
}
inline void Feature::unsafe_arena_set_allocated_parent_id(::feedwire::ContentId* parent_id)
{
    clear_parent_info();
    if (parent_id) {
        set_has_parent_id();
        _impl_.parent_info_.parent_id_ = parent_id;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedwire.Feature.parent_id)
}
inline ::feedwire::ContentId* Feature::_internal_mutable_parent_id()
{
    if (!_internal_has_parent_id()) {
        clear_parent_info();
        set_has_parent_id();
        _impl_.parent_info_.parent_id_ = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
    }
    return _impl_.parent_info_.parent_id_;
}
inline ::feedwire::ContentId* Feature::mutable_parent_id()
{
    ::feedwire::ContentId* _msg = _internal_mutable_parent_id();
    // @@protoc_insertion_point(field_mutable:feedwire.Feature.parent_id)
    return _msg;
}

// bool is_root = 4;
inline bool Feature::_internal_has_is_root() const
{
    return parent_info_case() == kIsRoot;
}
inline bool Feature::has_is_root() const
{
    return _internal_has_is_root();
}
inline void Feature::set_has_is_root()
{
    _impl_._oneof_case_[0] = kIsRoot;
}
inline void Feature::clear_is_root()
{
    if (_internal_has_is_root()) {
        _impl_.parent_info_.is_root_ = false;
        clear_has_parent_info();
    }
}
inline bool Feature::_internal_is_root() const
{
    if (_internal_has_is_root()) {
        return _impl_.parent_info_.is_root_;
    }
    return false;
}
inline void Feature::_internal_set_is_root(bool value)
{
    if (!_internal_has_is_root()) {
        clear_parent_info();
        set_has_is_root();
    }
    _impl_.parent_info_.is_root_ = value;
}
inline bool Feature::is_root() const
{
    // @@protoc_insertion_point(field_get:feedwire.Feature.is_root)
    return _internal_is_root();
}
inline void Feature::set_is_root(bool value)
{
    _internal_set_is_root(value);
    // @@protoc_insertion_point(field_set:feedwire.Feature.is_root)
}

// optional .feedwire.Feature.RenderableUnit renderable_unit = 2;
inline bool Feature::_internal_has_renderable_unit() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool Feature::has_renderable_unit() const
{
    return _internal_has_renderable_unit();
}
inline void Feature::clear_renderable_unit()
{
    _impl_.renderable_unit_ = 0;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::feedwire::Feature_RenderableUnit Feature::_internal_renderable_unit() const
{
    return static_cast<::feedwire::Feature_RenderableUnit>(_impl_.renderable_unit_);
}
inline ::feedwire::Feature_RenderableUnit Feature::renderable_unit() const
{
    // @@protoc_insertion_point(field_get:feedwire.Feature.renderable_unit)
    return _internal_renderable_unit();
}
inline void Feature::_internal_set_renderable_unit(::feedwire::Feature_RenderableUnit value)
{
    assert(::feedwire::Feature_RenderableUnit_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.renderable_unit_ = value;
}
inline void Feature::set_renderable_unit(::feedwire::Feature_RenderableUnit value)
{
    _internal_set_renderable_unit(value);
    // @@protoc_insertion_point(field_set:feedwire.Feature.renderable_unit)
}

// optional .feedwire.ExpirationInfo expiration_info = 3;
inline bool Feature::_internal_has_expiration_info() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.expiration_info_ != nullptr);
    return value;
}
inline bool Feature::has_expiration_info() const
{
    return _internal_has_expiration_info();
}
inline const ::feedwire::ExpirationInfo& Feature::_internal_expiration_info() const
{
    const ::feedwire::ExpirationInfo* p = _impl_.expiration_info_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ExpirationInfo&>(::feedwire::_ExpirationInfo_default_instance_);
}
inline const ::feedwire::ExpirationInfo& Feature::expiration_info() const
{
    // @@protoc_insertion_point(field_get:feedwire.Feature.expiration_info)
    return _internal_expiration_info();
}
inline void Feature::unsafe_arena_set_allocated_expiration_info(::feedwire::ExpirationInfo* expiration_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiration_info_);
    }
    _impl_.expiration_info_ = expiration_info;
    if (expiration_info) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedwire.Feature.expiration_info)
}
inline ::feedwire::ExpirationInfo* Feature::release_expiration_info()
{
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::feedwire::ExpirationInfo* temp = _impl_.expiration_info_;
    _impl_.expiration_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::ExpirationInfo* Feature::unsafe_arena_release_expiration_info()
{
    // @@protoc_insertion_point(field_release:feedwire.Feature.expiration_info)
    _impl_._has_bits_[0] &= ~0x00000001u;
    ::feedwire::ExpirationInfo* temp = _impl_.expiration_info_;
    _impl_.expiration_info_ = nullptr;
    return temp;
}
inline ::feedwire::ExpirationInfo* Feature::_internal_mutable_expiration_info()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    if (_impl_.expiration_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::ExpirationInfo>(GetArenaForAllocation());
        _impl_.expiration_info_ = p;
    }
    return _impl_.expiration_info_;
}
inline ::feedwire::ExpirationInfo* Feature::mutable_expiration_info()
{
    ::feedwire::ExpirationInfo* _msg = _internal_mutable_expiration_info();
    // @@protoc_insertion_point(field_mutable:feedwire.Feature.expiration_info)
    return _msg;
}
inline void Feature::set_allocated_expiration_info(::feedwire::ExpirationInfo* expiration_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.expiration_info_);
    }
    if (expiration_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(expiration_info));
        if (message_arena != submessage_arena) {
            expiration_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, expiration_info, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.expiration_info_ = expiration_info;
    // @@protoc_insertion_point(field_set_allocated:feedwire.Feature.expiration_info)
}

// optional .feedwire.Stream stream = 185431437;
inline bool Feature::_internal_has_stream() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.stream_ != nullptr);
    return value;
}
inline bool Feature::has_stream() const
{
    return _internal_has_stream();
}
inline const ::feedwire::Stream& Feature::_internal_stream() const
{
    const ::feedwire::Stream* p = _impl_.stream_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::Stream&>(::feedwire::_Stream_default_instance_);
}
inline const ::feedwire::Stream& Feature::stream() const
{
    // @@protoc_insertion_point(field_get:feedwire.Feature.stream)
    return _internal_stream();
}
inline void Feature::unsafe_arena_set_allocated_stream(::feedwire::Stream* stream)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
    }
    _impl_.stream_ = stream;
    if (stream) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedwire.Feature.stream)
}
inline ::feedwire::Stream* Feature::release_stream()
{
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::feedwire::Stream* temp = _impl_.stream_;
    _impl_.stream_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::Stream* Feature::unsafe_arena_release_stream()
{
    // @@protoc_insertion_point(field_release:feedwire.Feature.stream)
    _impl_._has_bits_[0] &= ~0x00000002u;
    ::feedwire::Stream* temp = _impl_.stream_;
    _impl_.stream_ = nullptr;
    return temp;
}
inline ::feedwire::Stream* Feature::_internal_mutable_stream()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    if (_impl_.stream_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::Stream>(GetArenaForAllocation());
        _impl_.stream_ = p;
    }
    return _impl_.stream_;
}
inline ::feedwire::Stream* Feature::mutable_stream()
{
    ::feedwire::Stream* _msg = _internal_mutable_stream();
    // @@protoc_insertion_point(field_mutable:feedwire.Feature.stream)
    return _msg;
}
inline void Feature::set_allocated_stream(::feedwire::Stream* stream)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.stream_);
    }
    if (stream) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream));
        if (message_arena != submessage_arena) {
            stream = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, stream, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.stream_ = stream;
    // @@protoc_insertion_point(field_set_allocated:feedwire.Feature.stream)
}

// optional .feedwire.Content content = 185431439;
inline bool Feature::_internal_has_content() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.content_ != nullptr);
    return value;
}
inline bool Feature::has_content() const
{
    return _internal_has_content();
}
inline const ::feedwire::Content& Feature::_internal_content() const
{
    const ::feedwire::Content* p = _impl_.content_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::Content&>(::feedwire::_Content_default_instance_);
}
inline const ::feedwire::Content& Feature::content() const
{
    // @@protoc_insertion_point(field_get:feedwire.Feature.content)
    return _internal_content();
}
inline void Feature::unsafe_arena_set_allocated_content(::feedwire::Content* content)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
    }
    _impl_.content_ = content;
    if (content) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedwire.Feature.content)
}
inline ::feedwire::Content* Feature::release_content()
{
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::feedwire::Content* temp = _impl_.content_;
    _impl_.content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::Content* Feature::unsafe_arena_release_content()
{
    // @@protoc_insertion_point(field_release:feedwire.Feature.content)
    _impl_._has_bits_[0] &= ~0x00000004u;
    ::feedwire::Content* temp = _impl_.content_;
    _impl_.content_ = nullptr;
    return temp;
}
inline ::feedwire::Content* Feature::_internal_mutable_content()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    if (_impl_.content_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::Content>(GetArenaForAllocation());
        _impl_.content_ = p;
    }
    return _impl_.content_;
}
inline ::feedwire::Content* Feature::mutable_content()
{
    ::feedwire::Content* _msg = _internal_mutable_content();
    // @@protoc_insertion_point(field_mutable:feedwire.Feature.content)
    return _msg;
}
inline void Feature::set_allocated_content(::feedwire::Content* content)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.content_);
    }
    if (content) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content));
        if (message_arena != submessage_arena) {
            content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.content_ = content;
    // @@protoc_insertion_point(field_set_allocated:feedwire.Feature.content)
}

// optional .feedwire.Group group = 190812910;
inline bool Feature::_internal_has_group() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.group_ != nullptr);
    return value;
}
inline bool Feature::has_group() const
{
    return _internal_has_group();
}
inline const ::feedwire::Group& Feature::_internal_group() const
{
    const ::feedwire::Group* p = _impl_.group_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::Group&>(::feedwire::_Group_default_instance_);
}
inline const ::feedwire::Group& Feature::group() const
{
    // @@protoc_insertion_point(field_get:feedwire.Feature.group)
    return _internal_group();
}
inline void Feature::unsafe_arena_set_allocated_group(::feedwire::Group* group)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
    }
    _impl_.group_ = group;
    if (group) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedwire.Feature.group)
}
inline ::feedwire::Group* Feature::release_group()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::feedwire::Group* temp = _impl_.group_;
    _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::Group* Feature::unsafe_arena_release_group()
{
    // @@protoc_insertion_point(field_release:feedwire.Feature.group)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::feedwire::Group* temp = _impl_.group_;
    _impl_.group_ = nullptr;
    return temp;
}
inline ::feedwire::Group* Feature::_internal_mutable_group()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.group_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::Group>(GetArenaForAllocation());
        _impl_.group_ = p;
    }
    return _impl_.group_;
}
inline ::feedwire::Group* Feature::mutable_group()
{
    ::feedwire::Group* _msg = _internal_mutable_group();
    // @@protoc_insertion_point(field_mutable:feedwire.Feature.group)
    return _msg;
}
inline void Feature::set_allocated_group(::feedwire::Group* group)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
    }
    if (group) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(group));
        if (message_arena != submessage_arena) {
            group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, group, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.group_ = group;
    // @@protoc_insertion_point(field_set_allocated:feedwire.Feature.group)
}

// optional .feedwire.Token token = 194964015;
inline bool Feature::_internal_has_token() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.token_ != nullptr);
    return value;
}
inline bool Feature::has_token() const
{
    return _internal_has_token();
}
inline const ::feedwire::Token& Feature::_internal_token() const
{
    const ::feedwire::Token* p = _impl_.token_;
    return p != nullptr ? *p : reinterpret_cast<const ::feedwire::Token&>(::feedwire::_Token_default_instance_);
}
inline const ::feedwire::Token& Feature::token() const
{
    // @@protoc_insertion_point(field_get:feedwire.Feature.token)
    return _internal_token();
}
inline void Feature::unsafe_arena_set_allocated_token(::feedwire::Token* token)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_);
    }
    _impl_.token_ = token;
    if (token) {
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedwire.Feature.token)
}
inline ::feedwire::Token* Feature::release_token()
{
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::feedwire::Token* temp = _impl_.token_;
    _impl_.token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::feedwire::Token* Feature::unsafe_arena_release_token()
{
    // @@protoc_insertion_point(field_release:feedwire.Feature.token)
    _impl_._has_bits_[0] &= ~0x00000010u;
    ::feedwire::Token* temp = _impl_.token_;
    _impl_.token_ = nullptr;
    return temp;
}
inline ::feedwire::Token* Feature::_internal_mutable_token()
{
    _impl_._has_bits_[0] |= 0x00000010u;
    if (_impl_.token_ == nullptr) {
        auto* p = CreateMaybeMessage<::feedwire::Token>(GetArenaForAllocation());
        _impl_.token_ = p;
    }
    return _impl_.token_;
}
inline ::feedwire::Token* Feature::mutable_token()
{
    ::feedwire::Token* _msg = _internal_mutable_token();
    // @@protoc_insertion_point(field_mutable:feedwire.Feature.token)
    return _msg;
}
inline void Feature::set_allocated_token(::feedwire::Token* token)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.token_);
    }
    if (token) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(token));
        if (message_arena != submessage_arena) {
            token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, token, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000010u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000010u;
    }
    _impl_.token_ = token;
    // @@protoc_insertion_point(field_set_allocated:feedwire.Feature.token)
}

inline bool Feature::has_parent_info() const
{
    return parent_info_case() != PARENT_INFO_NOT_SET;
}
inline void Feature::clear_has_parent_info()
{
    _impl_._oneof_case_[0] = PARENT_INFO_NOT_SET;
}
inline Feature::ParentInfoCase Feature::parent_info_case() const
{
    return Feature::ParentInfoCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__

// @@protoc_insertion_point(namespace_scope)

} // namespace feedwire

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::feedwire::Feature_RenderableUnit> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fwire_2ffeature_2eproto
