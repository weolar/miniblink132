// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/feed/core/proto/v2/ui.proto

#include "components/feed/core/proto/v2/ui.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace feedui {
PROTOBUF_CONSTEXPR StreamUpdate_SliceUpdate::StreamUpdate_SliceUpdate(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.update_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct StreamUpdate_SliceUpdateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StreamUpdate_SliceUpdateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StreamUpdate_SliceUpdateDefaultTypeInternal()
    {
    }
    union {
        StreamUpdate_SliceUpdate _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamUpdate_SliceUpdateDefaultTypeInternal
    _StreamUpdate_SliceUpdate_default_instance_;
PROTOBUF_CONSTEXPR StreamUpdate::StreamUpdate(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.updated_slices_)*/ {}, /*decltype(_impl_.new_shared_states_)*/ {}, /*decltype(_impl_.logging_parameters_)*/ nullptr,
        /*decltype(_impl_.fetch_time_ms_)*/ int64_t { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct StreamUpdateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StreamUpdateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StreamUpdateDefaultTypeInternal()
    {
    }
    union {
        StreamUpdate _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamUpdateDefaultTypeInternal _StreamUpdate_default_instance_;
PROTOBUF_CONSTEXPR LoggingParameters::LoggingParameters(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.session_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.client_instance_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.root_event_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.logging_enabled_)*/ false, /*decltype(_impl_.view_actions_enabled_)*/ false, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct LoggingParametersDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoggingParametersDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoggingParametersDefaultTypeInternal()
    {
    }
    union {
        LoggingParameters _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoggingParametersDefaultTypeInternal _LoggingParameters_default_instance_;
PROTOBUF_CONSTEXPR Slice::Slice(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.slice_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.SliceData_)*/ {},
        /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct SliceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SliceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SliceDefaultTypeInternal()
    {
    }
    union {
        Slice _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SliceDefaultTypeInternal _Slice_default_instance_;
PROTOBUF_CONSTEXPR ZeroStateSlice::ZeroStateSlice(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ZeroStateSliceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ZeroStateSliceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ZeroStateSliceDefaultTypeInternal()
    {
    }
    union {
        ZeroStateSlice _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ZeroStateSliceDefaultTypeInternal _ZeroStateSlice_default_instance_;
PROTOBUF_CONSTEXPR LoadingSpinnerSlice::LoadingSpinnerSlice(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.is_at_top_)*/ false, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct LoadingSpinnerSliceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LoadingSpinnerSliceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LoadingSpinnerSliceDefaultTypeInternal()
    {
    }
    union {
        LoadingSpinnerSlice _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoadingSpinnerSliceDefaultTypeInternal
    _LoadingSpinnerSlice_default_instance_;
PROTOBUF_CONSTEXPR XSurfaceSlice::XSurfaceSlice(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.xsurface_frame_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct XSurfaceSliceDefaultTypeInternal {
    PROTOBUF_CONSTEXPR XSurfaceSliceDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~XSurfaceSliceDefaultTypeInternal()
    {
    }
    union {
        XSurfaceSlice _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XSurfaceSliceDefaultTypeInternal _XSurfaceSlice_default_instance_;
PROTOBUF_CONSTEXPR SharedState::SharedState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.xsurface_shared_state_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SharedStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SharedStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SharedStateDefaultTypeInternal()
    {
    }
    union {
        SharedState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SharedStateDefaultTypeInternal _SharedState_default_instance_;
} // namespace feedui
namespace feedui {
bool ZeroStateSlice_Type_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ZeroStateSlice_Type_strings[4] = {};

static const char ZeroStateSlice_Type_names[] = "CANT_REFRESH"
                                                "NO_CARDS_AVAILABLE"
                                                "NO_WEB_FEED_SUBSCRIPTIONS"
                                                "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ZeroStateSlice_Type_entries[] = {
    { { ZeroStateSlice_Type_names + 0, 12 }, 2 },
    { { ZeroStateSlice_Type_names + 12, 18 }, 1 },
    { { ZeroStateSlice_Type_names + 30, 25 }, 3 },
    { { ZeroStateSlice_Type_names + 55, 7 }, 0 },
};

static const int ZeroStateSlice_Type_entries_by_number[] = {
    3, // 0 -> UNKNOWN
    1, // 1 -> NO_CARDS_AVAILABLE
    0, // 2 -> CANT_REFRESH
    2, // 3 -> NO_WEB_FEED_SUBSCRIPTIONS
};

const std::string& ZeroStateSlice_Type_Name(ZeroStateSlice_Type value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        ZeroStateSlice_Type_entries, ZeroStateSlice_Type_entries_by_number, 4, ZeroStateSlice_Type_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(ZeroStateSlice_Type_entries, ZeroStateSlice_Type_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : ZeroStateSlice_Type_strings[idx].get();
}
bool ZeroStateSlice_Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ZeroStateSlice_Type* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(ZeroStateSlice_Type_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<ZeroStateSlice_Type>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ZeroStateSlice_Type ZeroStateSlice::UNKNOWN;
constexpr ZeroStateSlice_Type ZeroStateSlice::NO_CARDS_AVAILABLE;
constexpr ZeroStateSlice_Type ZeroStateSlice::CANT_REFRESH;
constexpr ZeroStateSlice_Type ZeroStateSlice::NO_WEB_FEED_SUBSCRIPTIONS;
constexpr ZeroStateSlice_Type ZeroStateSlice::Type_MIN;
constexpr ZeroStateSlice_Type ZeroStateSlice::Type_MAX;
constexpr int ZeroStateSlice::Type_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class StreamUpdate_SliceUpdate::_Internal {
public:
    static const ::feedui::Slice& slice(const StreamUpdate_SliceUpdate* msg);
};

const ::feedui::Slice& StreamUpdate_SliceUpdate::_Internal::slice(const StreamUpdate_SliceUpdate* msg)
{
    return *msg->_impl_.update_.slice_;
}
void StreamUpdate_SliceUpdate::set_allocated_slice(::feedui::Slice* slice)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_update();
    if (slice) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(slice);
        if (message_arena != submessage_arena) {
            slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, slice, submessage_arena);
        }
        set_has_slice();
        _impl_.update_.slice_ = slice;
    }
    // @@protoc_insertion_point(field_set_allocated:feedui.StreamUpdate.SliceUpdate.slice)
}
StreamUpdate_SliceUpdate::StreamUpdate_SliceUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedui.StreamUpdate.SliceUpdate)
}
StreamUpdate_SliceUpdate::StreamUpdate_SliceUpdate(const StreamUpdate_SliceUpdate& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StreamUpdate_SliceUpdate* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.update_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_update();
    switch (from.update_case()) {
    case kSlice: {
        _this->_internal_mutable_slice()->::feedui::Slice::MergeFrom(from._internal_slice());
        break;
    }
    case kSliceId: {
        _this->_internal_set_slice_id(from._internal_slice_id());
        break;
    }
    case UPDATE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:feedui.StreamUpdate.SliceUpdate)
}

inline void StreamUpdate_SliceUpdate::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.update_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_update();
}

StreamUpdate_SliceUpdate::~StreamUpdate_SliceUpdate()
{
    // @@protoc_insertion_point(destructor:feedui.StreamUpdate.SliceUpdate)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StreamUpdate_SliceUpdate::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_update()) {
        clear_update();
    }
}

void StreamUpdate_SliceUpdate::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StreamUpdate_SliceUpdate::clear_update()
{
    // @@protoc_insertion_point(one_of_clear_start:feedui.StreamUpdate.SliceUpdate)
    switch (update_case()) {
    case kSlice: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.update_.slice_;
        }
        break;
    }
    case kSliceId: {
        _impl_.update_.slice_id_.Destroy();
        break;
    }
    case UPDATE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = UPDATE_NOT_SET;
}

void StreamUpdate_SliceUpdate::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedui.StreamUpdate.SliceUpdate)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_update();
    _internal_metadata_.Clear<std::string>();
}

const char* StreamUpdate_SliceUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedui.Slice slice = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_slice(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string slice_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_slice_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StreamUpdate_SliceUpdate::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedui.StreamUpdate.SliceUpdate)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedui.Slice slice = 1;
    if (_internal_has_slice()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::slice(this), _Internal::slice(this).GetCachedSize(), target, stream);
    }

    // string slice_id = 2;
    if (_internal_has_slice_id()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_slice_id().data(),
            static_cast<int>(this->_internal_slice_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedui.StreamUpdate.SliceUpdate.slice_id");
        target = stream->WriteStringMaybeAliased(2, this->_internal_slice_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedui.StreamUpdate.SliceUpdate)
    return target;
}

size_t StreamUpdate_SliceUpdate::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedui.StreamUpdate.SliceUpdate)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (update_case()) {
    // .feedui.Slice slice = 1;
    case kSlice: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.update_.slice_);
        break;
    }
    // string slice_id = 2;
    case kSliceId: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_slice_id());
        break;
    }
    case UPDATE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StreamUpdate_SliceUpdate::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StreamUpdate_SliceUpdate*>(&from));
}

void StreamUpdate_SliceUpdate::MergeFrom(const StreamUpdate_SliceUpdate& from)
{
    StreamUpdate_SliceUpdate* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedui.StreamUpdate.SliceUpdate)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.update_case()) {
    case kSlice: {
        _this->_internal_mutable_slice()->::feedui::Slice::MergeFrom(from._internal_slice());
        break;
    }
    case kSliceId: {
        _this->_internal_set_slice_id(from._internal_slice_id());
        break;
    }
    case UPDATE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamUpdate_SliceUpdate::CopyFrom(const StreamUpdate_SliceUpdate& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedui.StreamUpdate.SliceUpdate)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StreamUpdate_SliceUpdate::IsInitialized() const
{
    return true;
}

void StreamUpdate_SliceUpdate::InternalSwap(StreamUpdate_SliceUpdate* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.update_, other->_impl_.update_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string StreamUpdate_SliceUpdate::GetTypeName() const
{
    return "feedui.StreamUpdate.SliceUpdate";
}

// ===================================================================

class StreamUpdate::_Internal {
public:
    static const ::feedui::LoggingParameters& logging_parameters(const StreamUpdate* msg);
};

const ::feedui::LoggingParameters& StreamUpdate::_Internal::logging_parameters(const StreamUpdate* msg)
{
    return *msg->_impl_.logging_parameters_;
}
StreamUpdate::StreamUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedui.StreamUpdate)
}
StreamUpdate::StreamUpdate(const StreamUpdate& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StreamUpdate* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.updated_slices_) { from._impl_.updated_slices_ }, decltype(_impl_.new_shared_states_) { from._impl_.new_shared_states_ },
            decltype(_impl_.logging_parameters_) { nullptr }, decltype(_impl_.fetch_time_ms_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_logging_parameters()) {
        _this->_impl_.logging_parameters_ = new ::feedui::LoggingParameters(*from._impl_.logging_parameters_);
    }
    _this->_impl_.fetch_time_ms_ = from._impl_.fetch_time_ms_;
    // @@protoc_insertion_point(copy_constructor:feedui.StreamUpdate)
}

inline void StreamUpdate::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.updated_slices_) { arena }, decltype(_impl_.new_shared_states_) { arena },
        decltype(_impl_.logging_parameters_) { nullptr }, decltype(_impl_.fetch_time_ms_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
}

StreamUpdate::~StreamUpdate()
{
    // @@protoc_insertion_point(destructor:feedui.StreamUpdate)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StreamUpdate::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.updated_slices_.~RepeatedPtrField();
    _impl_.new_shared_states_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.logging_parameters_;
}

void StreamUpdate::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StreamUpdate::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedui.StreamUpdate)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.updated_slices_.Clear();
    _impl_.new_shared_states_.Clear();
    if (GetArenaForAllocation() == nullptr && _impl_.logging_parameters_ != nullptr) {
        delete _impl_.logging_parameters_;
    }
    _impl_.logging_parameters_ = nullptr;
    _impl_.fetch_time_ms_ = int64_t { 0 };
    _internal_metadata_.Clear<std::string>();
}

const char* StreamUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .feedui.StreamUpdate.SliceUpdate updated_slices = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_updated_slices(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .feedui.SharedState new_shared_states = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_new_shared_states(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        // int64 fetch_time_ms = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _impl_.fetch_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedui.LoggingParameters logging_parameters = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_logging_parameters(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StreamUpdate::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedui.StreamUpdate)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .feedui.StreamUpdate.SliceUpdate updated_slices = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_updated_slices_size()); i < n; i++) {
        const auto& repfield = this->_internal_updated_slices(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .feedui.SharedState new_shared_states = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_new_shared_states_size()); i < n; i++) {
        const auto& repfield = this->_internal_new_shared_states(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    // int64 fetch_time_ms = 3;
    if (this->_internal_fetch_time_ms() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_fetch_time_ms(), target);
    }

    // .feedui.LoggingParameters logging_parameters = 4;
    if (this->_internal_has_logging_parameters()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::logging_parameters(this), _Internal::logging_parameters(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedui.StreamUpdate)
    return target;
}

size_t StreamUpdate::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedui.StreamUpdate)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedui.StreamUpdate.SliceUpdate updated_slices = 1;
    total_size += 1UL * this->_internal_updated_slices_size();
    for (const auto& msg : this->_impl_.updated_slices_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .feedui.SharedState new_shared_states = 2;
    total_size += 1UL * this->_internal_new_shared_states_size();
    for (const auto& msg : this->_impl_.new_shared_states_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // .feedui.LoggingParameters logging_parameters = 4;
    if (this->_internal_has_logging_parameters()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.logging_parameters_);
    }

    // int64 fetch_time_ms = 3;
    if (this->_internal_fetch_time_ms() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_fetch_time_ms());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StreamUpdate::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StreamUpdate*>(&from));
}

void StreamUpdate::MergeFrom(const StreamUpdate& from)
{
    StreamUpdate* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedui.StreamUpdate)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.updated_slices_.MergeFrom(from._impl_.updated_slices_);
    _this->_impl_.new_shared_states_.MergeFrom(from._impl_.new_shared_states_);
    if (from._internal_has_logging_parameters()) {
        _this->_internal_mutable_logging_parameters()->::feedui::LoggingParameters::MergeFrom(from._internal_logging_parameters());
    }
    if (from._internal_fetch_time_ms() != 0) {
        _this->_internal_set_fetch_time_ms(from._internal_fetch_time_ms());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamUpdate::CopyFrom(const StreamUpdate& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedui.StreamUpdate)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StreamUpdate::IsInitialized() const
{
    return true;
}

void StreamUpdate::InternalSwap(StreamUpdate* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.updated_slices_.InternalSwap(&other->_impl_.updated_slices_);
    _impl_.new_shared_states_.InternalSwap(&other->_impl_.new_shared_states_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(StreamUpdate, _impl_.fetch_time_ms_) + sizeof(StreamUpdate::_impl_.fetch_time_ms_)
        - PROTOBUF_FIELD_OFFSET(StreamUpdate, _impl_.logging_parameters_)>(
        reinterpret_cast<char*>(&_impl_.logging_parameters_), reinterpret_cast<char*>(&other->_impl_.logging_parameters_));
}

std::string StreamUpdate::GetTypeName() const
{
    return "feedui.StreamUpdate";
}

// ===================================================================

class LoggingParameters::_Internal {
public:
};

LoggingParameters::LoggingParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedui.LoggingParameters)
}
LoggingParameters::LoggingParameters(const LoggingParameters& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoggingParameters* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.session_id_) {}, decltype(_impl_.email_) {}, decltype(_impl_.client_instance_id_) {}, decltype(_impl_.root_event_id_) {},
            decltype(_impl_.logging_enabled_) {}, decltype(_impl_.view_actions_enabled_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.session_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_session_id().empty()) {
        _this->_impl_.session_id_.Set(from._internal_session_id(), _this->GetArenaForAllocation());
    }
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_email().empty()) {
        _this->_impl_.email_.Set(from._internal_email(), _this->GetArenaForAllocation());
    }
    _impl_.client_instance_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_instance_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_client_instance_id().empty()) {
        _this->_impl_.client_instance_id_.Set(from._internal_client_instance_id(), _this->GetArenaForAllocation());
    }
    _impl_.root_event_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_event_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_root_event_id().empty()) {
        _this->_impl_.root_event_id_.Set(from._internal_root_event_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.logging_enabled_, &from._impl_.logging_enabled_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.view_actions_enabled_) - reinterpret_cast<char*>(&_impl_.logging_enabled_))
            + sizeof(_impl_.view_actions_enabled_));
    // @@protoc_insertion_point(copy_constructor:feedui.LoggingParameters)
}

inline void LoggingParameters::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.session_id_) {}, decltype(_impl_.email_) {}, decltype(_impl_.client_instance_id_) {}, decltype(_impl_.root_event_id_) {},
            decltype(_impl_.logging_enabled_) { false }, decltype(_impl_.view_actions_enabled_) { false }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.session_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.session_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_instance_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.client_instance_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_event_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_event_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LoggingParameters::~LoggingParameters()
{
    // @@protoc_insertion_point(destructor:feedui.LoggingParameters)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoggingParameters::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.session_id_.Destroy();
    _impl_.email_.Destroy();
    _impl_.client_instance_id_.Destroy();
    _impl_.root_event_id_.Destroy();
}

void LoggingParameters::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoggingParameters::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedui.LoggingParameters)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.session_id_.ClearToEmpty();
    _impl_.email_.ClearToEmpty();
    _impl_.client_instance_id_.ClearToEmpty();
    _impl_.root_event_id_.ClearToEmpty();
    ::memset(&_impl_.logging_enabled_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.view_actions_enabled_) - reinterpret_cast<char*>(&_impl_.logging_enabled_))
            + sizeof(_impl_.view_actions_enabled_));
    _internal_metadata_.Clear<std::string>();
}

const char* LoggingParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string session_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_session_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string email = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string client_instance_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_client_instance_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // bool logging_enabled = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.logging_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool view_actions_enabled = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                _impl_.view_actions_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes root_event_id = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_root_event_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoggingParameters::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedui.LoggingParameters)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string session_id = 1;
    if (!this->_internal_session_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_session_id().data(),
            static_cast<int>(this->_internal_session_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedui.LoggingParameters.session_id");
        target = stream->WriteStringMaybeAliased(1, this->_internal_session_id(), target);
    }

    // string email = 2;
    if (!this->_internal_email().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedui.LoggingParameters.email");
        target = stream->WriteStringMaybeAliased(2, this->_internal_email(), target);
    }

    // string client_instance_id = 3;
    if (!this->_internal_client_instance_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_client_instance_id().data(),
            static_cast<int>(this->_internal_client_instance_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedui.LoggingParameters.client_instance_id");
        target = stream->WriteStringMaybeAliased(3, this->_internal_client_instance_id(), target);
    }

    // bool logging_enabled = 4;
    if (this->_internal_logging_enabled() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_logging_enabled(), target);
    }

    // bool view_actions_enabled = 5;
    if (this->_internal_view_actions_enabled() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_view_actions_enabled(), target);
    }

    // bytes root_event_id = 6;
    if (!this->_internal_root_event_id().empty()) {
        target = stream->WriteBytesMaybeAliased(6, this->_internal_root_event_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedui.LoggingParameters)
    return target;
}

size_t LoggingParameters::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedui.LoggingParameters)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string session_id = 1;
    if (!this->_internal_session_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_session_id());
    }

    // string email = 2;
    if (!this->_internal_email().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_email());
    }

    // string client_instance_id = 3;
    if (!this->_internal_client_instance_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_client_instance_id());
    }

    // bytes root_event_id = 6;
    if (!this->_internal_root_event_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_root_event_id());
    }

    // bool logging_enabled = 4;
    if (this->_internal_logging_enabled() != 0) {
        total_size += 1 + 1;
    }

    // bool view_actions_enabled = 5;
    if (this->_internal_view_actions_enabled() != 0) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoggingParameters::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoggingParameters*>(&from));
}

void LoggingParameters::MergeFrom(const LoggingParameters& from)
{
    LoggingParameters* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedui.LoggingParameters)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_session_id().empty()) {
        _this->_internal_set_session_id(from._internal_session_id());
    }
    if (!from._internal_email().empty()) {
        _this->_internal_set_email(from._internal_email());
    }
    if (!from._internal_client_instance_id().empty()) {
        _this->_internal_set_client_instance_id(from._internal_client_instance_id());
    }
    if (!from._internal_root_event_id().empty()) {
        _this->_internal_set_root_event_id(from._internal_root_event_id());
    }
    if (from._internal_logging_enabled() != 0) {
        _this->_internal_set_logging_enabled(from._internal_logging_enabled());
    }
    if (from._internal_view_actions_enabled() != 0) {
        _this->_internal_set_view_actions_enabled(from._internal_view_actions_enabled());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoggingParameters::CopyFrom(const LoggingParameters& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedui.LoggingParameters)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoggingParameters::IsInitialized() const
{
    return true;
}

void LoggingParameters::InternalSwap(LoggingParameters* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.session_id_, lhs_arena, &other->_impl_.session_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.email_, lhs_arena, &other->_impl_.email_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.client_instance_id_, lhs_arena, &other->_impl_.client_instance_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.root_event_id_, lhs_arena, &other->_impl_.root_event_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(LoggingParameters, _impl_.view_actions_enabled_)
        + sizeof(LoggingParameters::_impl_.view_actions_enabled_) - PROTOBUF_FIELD_OFFSET(LoggingParameters, _impl_.logging_enabled_)>(
        reinterpret_cast<char*>(&_impl_.logging_enabled_), reinterpret_cast<char*>(&other->_impl_.logging_enabled_));
}

std::string LoggingParameters::GetTypeName() const
{
    return "feedui.LoggingParameters";
}

// ===================================================================

class Slice::_Internal {
public:
    static const ::feedui::XSurfaceSlice& xsurface_slice(const Slice* msg);
    static const ::feedui::ZeroStateSlice& zero_state_slice(const Slice* msg);
    static const ::feedui::LoadingSpinnerSlice& loading_spinner_slice(const Slice* msg);
};

const ::feedui::XSurfaceSlice& Slice::_Internal::xsurface_slice(const Slice* msg)
{
    return *msg->_impl_.SliceData_.xsurface_slice_;
}
const ::feedui::ZeroStateSlice& Slice::_Internal::zero_state_slice(const Slice* msg)
{
    return *msg->_impl_.SliceData_.zero_state_slice_;
}
const ::feedui::LoadingSpinnerSlice& Slice::_Internal::loading_spinner_slice(const Slice* msg)
{
    return *msg->_impl_.SliceData_.loading_spinner_slice_;
}
void Slice::set_allocated_xsurface_slice(::feedui::XSurfaceSlice* xsurface_slice)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_SliceData();
    if (xsurface_slice) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(xsurface_slice);
        if (message_arena != submessage_arena) {
            xsurface_slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, xsurface_slice, submessage_arena);
        }
        set_has_xsurface_slice();
        _impl_.SliceData_.xsurface_slice_ = xsurface_slice;
    }
    // @@protoc_insertion_point(field_set_allocated:feedui.Slice.xsurface_slice)
}
void Slice::set_allocated_zero_state_slice(::feedui::ZeroStateSlice* zero_state_slice)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_SliceData();
    if (zero_state_slice) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(zero_state_slice);
        if (message_arena != submessage_arena) {
            zero_state_slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, zero_state_slice, submessage_arena);
        }
        set_has_zero_state_slice();
        _impl_.SliceData_.zero_state_slice_ = zero_state_slice;
    }
    // @@protoc_insertion_point(field_set_allocated:feedui.Slice.zero_state_slice)
}
void Slice::set_allocated_loading_spinner_slice(::feedui::LoadingSpinnerSlice* loading_spinner_slice)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_SliceData();
    if (loading_spinner_slice) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loading_spinner_slice);
        if (message_arena != submessage_arena) {
            loading_spinner_slice = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, loading_spinner_slice, submessage_arena);
        }
        set_has_loading_spinner_slice();
        _impl_.SliceData_.loading_spinner_slice_ = loading_spinner_slice;
    }
    // @@protoc_insertion_point(field_set_allocated:feedui.Slice.loading_spinner_slice)
}
Slice::Slice(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedui.Slice)
}
Slice::Slice(const Slice& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Slice* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.slice_id_) {}, decltype(_impl_.SliceData_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.slice_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.slice_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_slice_id().empty()) {
        _this->_impl_.slice_id_.Set(from._internal_slice_id(), _this->GetArenaForAllocation());
    }
    clear_has_SliceData();
    switch (from.SliceData_case()) {
    case kXsurfaceSlice: {
        _this->_internal_mutable_xsurface_slice()->::feedui::XSurfaceSlice::MergeFrom(from._internal_xsurface_slice());
        break;
    }
    case kZeroStateSlice: {
        _this->_internal_mutable_zero_state_slice()->::feedui::ZeroStateSlice::MergeFrom(from._internal_zero_state_slice());
        break;
    }
    case kLoadingSpinnerSlice: {
        _this->_internal_mutable_loading_spinner_slice()->::feedui::LoadingSpinnerSlice::MergeFrom(from._internal_loading_spinner_slice());
        break;
    }
    case SLICEDATA_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:feedui.Slice)
}

inline void Slice::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.slice_id_) {}, decltype(_impl_.SliceData_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    _impl_.slice_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.slice_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clear_has_SliceData();
}

Slice::~Slice()
{
    // @@protoc_insertion_point(destructor:feedui.Slice)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Slice::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.slice_id_.Destroy();
    if (has_SliceData()) {
        clear_SliceData();
    }
}

void Slice::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Slice::clear_SliceData()
{
    // @@protoc_insertion_point(one_of_clear_start:feedui.Slice)
    switch (SliceData_case()) {
    case kXsurfaceSlice: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.SliceData_.xsurface_slice_;
        }
        break;
    }
    case kZeroStateSlice: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.SliceData_.zero_state_slice_;
        }
        break;
    }
    case kLoadingSpinnerSlice: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.SliceData_.loading_spinner_slice_;
        }
        break;
    }
    case SLICEDATA_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = SLICEDATA_NOT_SET;
}

void Slice::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedui.Slice)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.slice_id_.ClearToEmpty();
    clear_SliceData();
    _internal_metadata_.Clear<std::string>();
}

const char* Slice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedui.XSurfaceSlice xsurface_slice = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_xsurface_slice(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string slice_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_slice_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .feedui.ZeroStateSlice zero_state_slice = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_zero_state_slice(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedui.LoadingSpinnerSlice loading_spinner_slice = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_loading_spinner_slice(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Slice::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedui.Slice)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedui.XSurfaceSlice xsurface_slice = 1;
    if (_internal_has_xsurface_slice()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::xsurface_slice(this), _Internal::xsurface_slice(this).GetCachedSize(), target, stream);
    }

    // string slice_id = 2;
    if (!this->_internal_slice_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_slice_id().data(),
            static_cast<int>(this->_internal_slice_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedui.Slice.slice_id");
        target = stream->WriteStringMaybeAliased(2, this->_internal_slice_id(), target);
    }

    // .feedui.ZeroStateSlice zero_state_slice = 3;
    if (_internal_has_zero_state_slice()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::zero_state_slice(this), _Internal::zero_state_slice(this).GetCachedSize(), target, stream);
    }

    // .feedui.LoadingSpinnerSlice loading_spinner_slice = 4;
    if (_internal_has_loading_spinner_slice()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::loading_spinner_slice(this), _Internal::loading_spinner_slice(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedui.Slice)
    return target;
}

size_t Slice::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedui.Slice)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string slice_id = 2;
    if (!this->_internal_slice_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_slice_id());
    }

    switch (SliceData_case()) {
    // .feedui.XSurfaceSlice xsurface_slice = 1;
    case kXsurfaceSlice: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.SliceData_.xsurface_slice_);
        break;
    }
    // .feedui.ZeroStateSlice zero_state_slice = 3;
    case kZeroStateSlice: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.SliceData_.zero_state_slice_);
        break;
    }
    // .feedui.LoadingSpinnerSlice loading_spinner_slice = 4;
    case kLoadingSpinnerSlice: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.SliceData_.loading_spinner_slice_);
        break;
    }
    case SLICEDATA_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Slice::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Slice*>(&from));
}

void Slice::MergeFrom(const Slice& from)
{
    Slice* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedui.Slice)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_slice_id().empty()) {
        _this->_internal_set_slice_id(from._internal_slice_id());
    }
    switch (from.SliceData_case()) {
    case kXsurfaceSlice: {
        _this->_internal_mutable_xsurface_slice()->::feedui::XSurfaceSlice::MergeFrom(from._internal_xsurface_slice());
        break;
    }
    case kZeroStateSlice: {
        _this->_internal_mutable_zero_state_slice()->::feedui::ZeroStateSlice::MergeFrom(from._internal_zero_state_slice());
        break;
    }
    case kLoadingSpinnerSlice: {
        _this->_internal_mutable_loading_spinner_slice()->::feedui::LoadingSpinnerSlice::MergeFrom(from._internal_loading_spinner_slice());
        break;
    }
    case SLICEDATA_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Slice::CopyFrom(const Slice& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedui.Slice)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Slice::IsInitialized() const
{
    return true;
}

void Slice::InternalSwap(Slice* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.slice_id_, lhs_arena, &other->_impl_.slice_id_, rhs_arena);
    swap(_impl_.SliceData_, other->_impl_.SliceData_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Slice::GetTypeName() const
{
    return "feedui.Slice";
}

// ===================================================================

class ZeroStateSlice::_Internal {
public:
};

ZeroStateSlice::ZeroStateSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedui.ZeroStateSlice)
}
ZeroStateSlice::ZeroStateSlice(const ZeroStateSlice& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ZeroStateSlice* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.type_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.type_ = from._impl_.type_;
    // @@protoc_insertion_point(copy_constructor:feedui.ZeroStateSlice)
}

inline void ZeroStateSlice::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.type_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

ZeroStateSlice::~ZeroStateSlice()
{
    // @@protoc_insertion_point(destructor:feedui.ZeroStateSlice)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ZeroStateSlice::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ZeroStateSlice::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ZeroStateSlice::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedui.ZeroStateSlice)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.type_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* ZeroStateSlice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedui.ZeroStateSlice.Type type = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_type(static_cast<::feedui::ZeroStateSlice_Type>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ZeroStateSlice::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedui.ZeroStateSlice)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedui.ZeroStateSlice.Type type = 1;
    if (this->_internal_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedui.ZeroStateSlice)
    return target;
}

size_t ZeroStateSlice::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedui.ZeroStateSlice)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .feedui.ZeroStateSlice.Type type = 1;
    if (this->_internal_type() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ZeroStateSlice::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ZeroStateSlice*>(&from));
}

void ZeroStateSlice::MergeFrom(const ZeroStateSlice& from)
{
    ZeroStateSlice* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedui.ZeroStateSlice)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_type() != 0) {
        _this->_internal_set_type(from._internal_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ZeroStateSlice::CopyFrom(const ZeroStateSlice& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedui.ZeroStateSlice)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ZeroStateSlice::IsInitialized() const
{
    return true;
}

void ZeroStateSlice::InternalSwap(ZeroStateSlice* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.type_, other->_impl_.type_);
}

std::string ZeroStateSlice::GetTypeName() const
{
    return "feedui.ZeroStateSlice";
}

// ===================================================================

class LoadingSpinnerSlice::_Internal {
public:
};

LoadingSpinnerSlice::LoadingSpinnerSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedui.LoadingSpinnerSlice)
}
LoadingSpinnerSlice::LoadingSpinnerSlice(const LoadingSpinnerSlice& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LoadingSpinnerSlice* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.is_at_top_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.is_at_top_ = from._impl_.is_at_top_;
    // @@protoc_insertion_point(copy_constructor:feedui.LoadingSpinnerSlice)
}

inline void LoadingSpinnerSlice::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.is_at_top_) { false }, /*decltype(_impl_._cached_size_)*/ {} };
}

LoadingSpinnerSlice::~LoadingSpinnerSlice()
{
    // @@protoc_insertion_point(destructor:feedui.LoadingSpinnerSlice)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LoadingSpinnerSlice::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void LoadingSpinnerSlice::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LoadingSpinnerSlice::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedui.LoadingSpinnerSlice)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.is_at_top_ = false;
    _internal_metadata_.Clear<std::string>();
}

const char* LoadingSpinnerSlice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bool is_at_top = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.is_at_top_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LoadingSpinnerSlice::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedui.LoadingSpinnerSlice)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bool is_at_top = 1;
    if (this->_internal_is_at_top() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_at_top(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedui.LoadingSpinnerSlice)
    return target;
}

size_t LoadingSpinnerSlice::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedui.LoadingSpinnerSlice)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bool is_at_top = 1;
    if (this->_internal_is_at_top() != 0) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LoadingSpinnerSlice::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LoadingSpinnerSlice*>(&from));
}

void LoadingSpinnerSlice::MergeFrom(const LoadingSpinnerSlice& from)
{
    LoadingSpinnerSlice* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedui.LoadingSpinnerSlice)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_is_at_top() != 0) {
        _this->_internal_set_is_at_top(from._internal_is_at_top());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LoadingSpinnerSlice::CopyFrom(const LoadingSpinnerSlice& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedui.LoadingSpinnerSlice)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LoadingSpinnerSlice::IsInitialized() const
{
    return true;
}

void LoadingSpinnerSlice::InternalSwap(LoadingSpinnerSlice* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.is_at_top_, other->_impl_.is_at_top_);
}

std::string LoadingSpinnerSlice::GetTypeName() const
{
    return "feedui.LoadingSpinnerSlice";
}

// ===================================================================

class XSurfaceSlice::_Internal {
public:
};

XSurfaceSlice::XSurfaceSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedui.XSurfaceSlice)
}
XSurfaceSlice::XSurfaceSlice(const XSurfaceSlice& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    XSurfaceSlice* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.xsurface_frame_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.xsurface_frame_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.xsurface_frame_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_xsurface_frame().empty()) {
        _this->_impl_.xsurface_frame_.Set(from._internal_xsurface_frame(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:feedui.XSurfaceSlice)
}

inline void XSurfaceSlice::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.xsurface_frame_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.xsurface_frame_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.xsurface_frame_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

XSurfaceSlice::~XSurfaceSlice()
{
    // @@protoc_insertion_point(destructor:feedui.XSurfaceSlice)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void XSurfaceSlice::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.xsurface_frame_.Destroy();
}

void XSurfaceSlice::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void XSurfaceSlice::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedui.XSurfaceSlice)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.xsurface_frame_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* XSurfaceSlice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bytes xsurface_frame = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_xsurface_frame();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* XSurfaceSlice::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedui.XSurfaceSlice)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bytes xsurface_frame = 1;
    if (!this->_internal_xsurface_frame().empty()) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_xsurface_frame(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedui.XSurfaceSlice)
    return target;
}

size_t XSurfaceSlice::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedui.XSurfaceSlice)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bytes xsurface_frame = 1;
    if (!this->_internal_xsurface_frame().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_xsurface_frame());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void XSurfaceSlice::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const XSurfaceSlice*>(&from));
}

void XSurfaceSlice::MergeFrom(const XSurfaceSlice& from)
{
    XSurfaceSlice* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedui.XSurfaceSlice)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_xsurface_frame().empty()) {
        _this->_internal_set_xsurface_frame(from._internal_xsurface_frame());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void XSurfaceSlice::CopyFrom(const XSurfaceSlice& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedui.XSurfaceSlice)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool XSurfaceSlice::IsInitialized() const
{
    return true;
}

void XSurfaceSlice::InternalSwap(XSurfaceSlice* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.xsurface_frame_, lhs_arena, &other->_impl_.xsurface_frame_, rhs_arena);
}

std::string XSurfaceSlice::GetTypeName() const
{
    return "feedui.XSurfaceSlice";
}

// ===================================================================

class SharedState::_Internal {
public:
};

SharedState::SharedState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedui.SharedState)
}
SharedState::SharedState(const SharedState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SharedState* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.id_) {}, decltype(_impl_.xsurface_shared_state_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_id().empty()) {
        _this->_impl_.id_.Set(from._internal_id(), _this->GetArenaForAllocation());
    }
    _impl_.xsurface_shared_state_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.xsurface_shared_state_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_xsurface_shared_state().empty()) {
        _this->_impl_.xsurface_shared_state_.Set(from._internal_xsurface_shared_state(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:feedui.SharedState)
}

inline void SharedState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.id_) {}, decltype(_impl_.xsurface_shared_state_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.xsurface_shared_state_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.xsurface_shared_state_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SharedState::~SharedState()
{
    // @@protoc_insertion_point(destructor:feedui.SharedState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SharedState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.id_.Destroy();
    _impl_.xsurface_shared_state_.Destroy();
}

void SharedState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SharedState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedui.SharedState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.id_.ClearToEmpty();
    _impl_.xsurface_shared_state_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* SharedState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // bytes xsurface_shared_state = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_xsurface_shared_state();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SharedState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedui.SharedState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string id = 1;
    if (!this->_internal_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedui.SharedState.id");
        target = stream->WriteStringMaybeAliased(1, this->_internal_id(), target);
    }

    // bytes xsurface_shared_state = 2;
    if (!this->_internal_xsurface_shared_state().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_xsurface_shared_state(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedui.SharedState)
    return target;
}

size_t SharedState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedui.SharedState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string id = 1;
    if (!this->_internal_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_id());
    }

    // bytes xsurface_shared_state = 2;
    if (!this->_internal_xsurface_shared_state().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_xsurface_shared_state());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SharedState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SharedState*>(&from));
}

void SharedState::MergeFrom(const SharedState& from)
{
    SharedState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedui.SharedState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_id().empty()) {
        _this->_internal_set_id(from._internal_id());
    }
    if (!from._internal_xsurface_shared_state().empty()) {
        _this->_internal_set_xsurface_shared_state(from._internal_xsurface_shared_state());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SharedState::CopyFrom(const SharedState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedui.SharedState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SharedState::IsInitialized() const
{
    return true;
}

void SharedState::InternalSwap(SharedState* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.id_, lhs_arena, &other->_impl_.id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.xsurface_shared_state_, lhs_arena, &other->_impl_.xsurface_shared_state_, rhs_arena);
}

std::string SharedState::GetTypeName() const
{
    return "feedui.SharedState";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace feedui
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::feedui::StreamUpdate_SliceUpdate* Arena::CreateMaybeMessage<::feedui::StreamUpdate_SliceUpdate>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedui::StreamUpdate_SliceUpdate>(arena);
}
template <> PROTOBUF_NOINLINE ::feedui::StreamUpdate* Arena::CreateMaybeMessage<::feedui::StreamUpdate>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedui::StreamUpdate>(arena);
}
template <> PROTOBUF_NOINLINE ::feedui::LoggingParameters* Arena::CreateMaybeMessage<::feedui::LoggingParameters>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedui::LoggingParameters>(arena);
}
template <> PROTOBUF_NOINLINE ::feedui::Slice* Arena::CreateMaybeMessage<::feedui::Slice>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedui::Slice>(arena);
}
template <> PROTOBUF_NOINLINE ::feedui::ZeroStateSlice* Arena::CreateMaybeMessage<::feedui::ZeroStateSlice>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedui::ZeroStateSlice>(arena);
}
template <> PROTOBUF_NOINLINE ::feedui::LoadingSpinnerSlice* Arena::CreateMaybeMessage<::feedui::LoadingSpinnerSlice>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedui::LoadingSpinnerSlice>(arena);
}
template <> PROTOBUF_NOINLINE ::feedui::XSurfaceSlice* Arena::CreateMaybeMessage<::feedui::XSurfaceSlice>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedui::XSurfaceSlice>(arena);
}
template <> PROTOBUF_NOINLINE ::feedui::SharedState* Arena::CreateMaybeMessage<::feedui::SharedState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedui::SharedState>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
