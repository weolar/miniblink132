// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/feed/core/proto/v2/store.proto

#include "components/feed/core/proto/v2/store.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace feedstore {
PROTOBUF_CONSTEXPR Record::Record(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.data_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct RecordDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RecordDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RecordDefaultTypeInternal()
    {
    }
    union {
        Record _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecordDefaultTypeInternal _Record_default_instance_;
PROTOBUF_CONSTEXPR StreamContentHashList::StreamContentHashList(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.hashes_)*/ {}, /*decltype(_impl_._hashes_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct StreamContentHashListDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StreamContentHashListDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StreamContentHashListDefaultTypeInternal()
    {
    }
    union {
        StreamContentHashList _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamContentHashListDefaultTypeInternal
    _StreamContentHashList_default_instance_;
PROTOBUF_CONSTEXPR StreamData::StreamData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.shared_state_ids_)*/ {}, /*decltype(_impl_.content_hashes_)*/ {},
        /*decltype(_impl_.next_page_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.stream_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.root_event_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.gaia_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.email_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.content_id_)*/ nullptr,
        /*decltype(_impl_.last_added_time_millis_)*/ int64_t { 0 }, /*decltype(_impl_.signed_in_)*/ false, /*decltype(_impl_.logging_enabled_)*/ false,
        /*decltype(_impl_.privacy_notice_fulfilled_)*/ false, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct StreamDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StreamDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StreamDataDefaultTypeInternal()
    {
    }
    union {
        StreamData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamDataDefaultTypeInternal _StreamData_default_instance_;
PROTOBUF_CONSTEXPR Metadata_SessionID::Metadata_SessionID(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.expiry_time_ms_)*/ int64_t { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct Metadata_SessionIDDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Metadata_SessionIDDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Metadata_SessionIDDefaultTypeInternal()
    {
    }
    union {
        Metadata_SessionID _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Metadata_SessionIDDefaultTypeInternal _Metadata_SessionID_default_instance_;
PROTOBUF_CONSTEXPR Metadata_StreamMetadata_ContentLifetime::Metadata_StreamMetadata_ContentLifetime(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.stale_age_ms_)*/ int64_t { 0 }, /*decltype(_impl_.invalid_age_ms_)*/ int64_t { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct Metadata_StreamMetadata_ContentLifetimeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Metadata_StreamMetadata_ContentLifetimeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Metadata_StreamMetadata_ContentLifetimeDefaultTypeInternal()
    {
    }
    union {
        Metadata_StreamMetadata_ContentLifetime _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Metadata_StreamMetadata_ContentLifetimeDefaultTypeInternal
    _Metadata_StreamMetadata_ContentLifetime_default_instance_;
PROTOBUF_CONSTEXPR Metadata_StreamMetadata::Metadata_StreamMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.view_content_hashes_)*/ {}, /*decltype(_impl_.viewed_content_hashes_)*/ {},
        /*decltype(_impl_._viewed_content_hashes_cached_byte_size_)*/ { 0 },
        /*decltype(_impl_.stream_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.content_lifetime_)*/ nullptr, /*decltype(_impl_.last_fetch_time_millis_)*/ int64_t { 0 },
        /*decltype(_impl_.last_server_response_time_millis_)*/ int64_t { 0 }, /*decltype(_impl_.is_known_stale_)*/ false,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct Metadata_StreamMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR Metadata_StreamMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~Metadata_StreamMetadataDefaultTypeInternal()
    {
    }
    union {
        Metadata_StreamMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Metadata_StreamMetadataDefaultTypeInternal
    _Metadata_StreamMetadata_default_instance_;
PROTOBUF_CONSTEXPR Metadata::Metadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.stream_metadata_)*/ {}, /*decltype(_impl_.most_recent_viewed_content_hashes_)*/ {},
        /*decltype(_impl_._most_recent_viewed_content_hashes_cached_byte_size_)*/ { 0 },
        /*decltype(_impl_.consistency_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.gaia_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.session_id_)*/ nullptr,
        /*decltype(_impl_.next_action_id_)*/ 0, /*decltype(_impl_.stream_schema_version_)*/ 0, /*decltype(_impl_.web_and_app_activity_enabled_)*/ false,
        /*decltype(_impl_.discover_personalization_enabled_)*/ false, /*decltype(_impl_.followed_from_web_page_menu_count_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct MetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR MetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~MetadataDefaultTypeInternal()
    {
    }
    union {
        Metadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MetadataDefaultTypeInternal _Metadata_default_instance_;
PROTOBUF_CONSTEXPR StreamStructureSet::StreamStructureSet(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.structures_)*/ {}, /*decltype(_impl_.stream_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.sequence_number_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct StreamStructureSetDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StreamStructureSetDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StreamStructureSetDefaultTypeInternal()
    {
    }
    union {
        StreamStructureSet _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamStructureSetDefaultTypeInternal _StreamStructureSet_default_instance_;
PROTOBUF_CONSTEXPR StreamStructure::StreamStructure(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.content_id_)*/ nullptr, /*decltype(_impl_.parent_id_)*/ nullptr, /*decltype(_impl_.content_info_)*/ nullptr,
        /*decltype(_impl_.operation_)*/ 0, /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.is_root_)*/ false, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct StreamStructureDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StreamStructureDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StreamStructureDefaultTypeInternal()
    {
    }
    union {
        StreamStructure _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamStructureDefaultTypeInternal _StreamStructure_default_instance_;
PROTOBUF_CONSTEXPR DataOperation::DataOperation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.structure_)*/ nullptr, /*decltype(_impl_.content_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct DataOperationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DataOperationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DataOperationDefaultTypeInternal()
    {
    }
    union {
        DataOperation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataOperationDefaultTypeInternal _DataOperation_default_instance_;
PROTOBUF_CONSTEXPR ContentInfo::ContentInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.availability_time_seconds_)*/ int64_t { 0 }, /*decltype(_impl_.score_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ContentInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentInfoDefaultTypeInternal()
    {
    }
    union {
        ContentInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentInfoDefaultTypeInternal _ContentInfo_default_instance_;
PROTOBUF_CONSTEXPR Content::Content(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.prefetch_metadata_)*/ {}, /*decltype(_impl_.frame_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.stream_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.content_id_)*/ nullptr,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ContentDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ContentDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ContentDefaultTypeInternal()
    {
    }
    union {
        Content _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ContentDefaultTypeInternal _Content_default_instance_;
PROTOBUF_CONSTEXPR StreamSharedState::StreamSharedState(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.shared_state_data_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.stream_key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.content_id_)*/ nullptr,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct StreamSharedStateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StreamSharedStateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StreamSharedStateDefaultTypeInternal()
    {
    }
    union {
        StreamSharedState _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamSharedStateDefaultTypeInternal _StreamSharedState_default_instance_;
PROTOBUF_CONSTEXPR StoredAction::StoredAction(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.action_)*/ nullptr, /*decltype(_impl_.id_)*/ 0, /*decltype(_impl_.upload_attempt_count_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct StoredActionDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StoredActionDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StoredActionDefaultTypeInternal()
    {
    }
    union {
        StoredAction _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StoredActionDefaultTypeInternal _StoredAction_default_instance_;
PROTOBUF_CONSTEXPR SubscribedWebFeeds::SubscribedWebFeeds(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.feeds_)*/ {}, /*decltype(_impl_.update_time_millis_)*/ int64_t { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SubscribedWebFeedsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SubscribedWebFeedsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SubscribedWebFeedsDefaultTypeInternal()
    {
    }
    union {
        SubscribedWebFeeds _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SubscribedWebFeedsDefaultTypeInternal _SubscribedWebFeeds_default_instance_;
PROTOBUF_CONSTEXPR RecommendedWebFeedIndex_Entry::RecommendedWebFeedIndex_Entry(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.matchers_)*/ {}, /*decltype(_impl_.web_feed_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct RecommendedWebFeedIndex_EntryDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RecommendedWebFeedIndex_EntryDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RecommendedWebFeedIndex_EntryDefaultTypeInternal()
    {
    }
    union {
        RecommendedWebFeedIndex_Entry _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecommendedWebFeedIndex_EntryDefaultTypeInternal
    _RecommendedWebFeedIndex_Entry_default_instance_;
PROTOBUF_CONSTEXPR RecommendedWebFeedIndex::RecommendedWebFeedIndex(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.entries_)*/ {}, /*decltype(_impl_.update_time_millis_)*/ int64_t { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct RecommendedWebFeedIndexDefaultTypeInternal {
    PROTOBUF_CONSTEXPR RecommendedWebFeedIndexDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~RecommendedWebFeedIndexDefaultTypeInternal()
    {
    }
    union {
        RecommendedWebFeedIndex _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RecommendedWebFeedIndexDefaultTypeInternal
    _RecommendedWebFeedIndex_default_instance_;
PROTOBUF_CONSTEXPR Image::Image(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ImageDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ImageDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ImageDefaultTypeInternal()
    {
    }
    union {
        Image _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ImageDefaultTypeInternal _Image_default_instance_;
PROTOBUF_CONSTEXPR WebFeedInfo::WebFeedInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.matchers_)*/ {}, /*decltype(_impl_.web_feed_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.title_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.subtitle_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.detail_text_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.visit_uri_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.rss_uri_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.favicon_)*/ nullptr,
        /*decltype(_impl_.follower_count_)*/ int64_t { 0 }, /*decltype(_impl_.state_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct WebFeedInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR WebFeedInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~WebFeedInfoDefaultTypeInternal()
    {
    }
    union {
        WebFeedInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WebFeedInfoDefaultTypeInternal _WebFeedInfo_default_instance_;
PROTOBUF_CONSTEXPR PendingWebFeedOperation::PendingWebFeedOperation(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.web_feed_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.id_)*/ int64_t { 0 }, /*decltype(_impl_.kind_)*/ 0, /*decltype(_impl_.attempts_)*/ 0, /*decltype(_impl_.change_reason_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PendingWebFeedOperationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PendingWebFeedOperationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PendingWebFeedOperationDefaultTypeInternal()
    {
    }
    union {
        PendingWebFeedOperation _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PendingWebFeedOperationDefaultTypeInternal
    _PendingWebFeedOperation_default_instance_;
PROTOBUF_CONSTEXPR DocView::DocView(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.docid_)*/ uint64_t { 0u }, /*decltype(_impl_.view_time_millis_)*/ int64_t { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct DocViewDefaultTypeInternal {
    PROTOBUF_CONSTEXPR DocViewDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~DocViewDefaultTypeInternal()
    {
    }
    union {
        DocView _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DocViewDefaultTypeInternal _DocView_default_instance_;
} // namespace feedstore
namespace feedstore {
bool StreamStructure_Operation_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StreamStructure_Operation_strings[4] = {};

static const char StreamStructure_Operation_names[] = "CLEAR_ALL"
                                                      "REMOVE"
                                                      "UNKNOWN"
                                                      "UPDATE_OR_APPEND";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StreamStructure_Operation_entries[] = {
    { { StreamStructure_Operation_names + 0, 9 }, 1 },
    { { StreamStructure_Operation_names + 9, 6 }, 3 },
    { { StreamStructure_Operation_names + 15, 7 }, 0 },
    { { StreamStructure_Operation_names + 22, 16 }, 2 },
};

static const int StreamStructure_Operation_entries_by_number[] = {
    2, // 0 -> UNKNOWN
    0, // 1 -> CLEAR_ALL
    3, // 2 -> UPDATE_OR_APPEND
    1, // 3 -> REMOVE
};

const std::string& StreamStructure_Operation_Name(StreamStructure_Operation value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        StreamStructure_Operation_entries, StreamStructure_Operation_entries_by_number, 4, StreamStructure_Operation_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(StreamStructure_Operation_entries, StreamStructure_Operation_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : StreamStructure_Operation_strings[idx].get();
}
bool StreamStructure_Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamStructure_Operation* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(StreamStructure_Operation_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<StreamStructure_Operation>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StreamStructure_Operation StreamStructure::UNKNOWN;
constexpr StreamStructure_Operation StreamStructure::CLEAR_ALL;
constexpr StreamStructure_Operation StreamStructure::UPDATE_OR_APPEND;
constexpr StreamStructure_Operation StreamStructure::REMOVE;
constexpr StreamStructure_Operation StreamStructure::Operation_MIN;
constexpr StreamStructure_Operation StreamStructure::Operation_MAX;
constexpr int StreamStructure::Operation_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool StreamStructure_Type_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> StreamStructure_Type_strings[5] = {};

static const char StreamStructure_Type_names[] = "CARD"
                                                 "CONTENT"
                                                 "GROUP"
                                                 "STREAM"
                                                 "UNKNOWN_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry StreamStructure_Type_entries[] = {
    { { StreamStructure_Type_names + 0, 4 }, 2 },
    { { StreamStructure_Type_names + 4, 7 }, 3 },
    { { StreamStructure_Type_names + 11, 5 }, 4 },
    { { StreamStructure_Type_names + 16, 6 }, 1 },
    { { StreamStructure_Type_names + 22, 12 }, 0 },
};

static const int StreamStructure_Type_entries_by_number[] = {
    4, // 0 -> UNKNOWN_TYPE
    3, // 1 -> STREAM
    0, // 2 -> CARD
    1, // 3 -> CONTENT
    2, // 4 -> GROUP
};

const std::string& StreamStructure_Type_Name(StreamStructure_Type value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        StreamStructure_Type_entries, StreamStructure_Type_entries_by_number, 5, StreamStructure_Type_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(StreamStructure_Type_entries, StreamStructure_Type_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : StreamStructure_Type_strings[idx].get();
}
bool StreamStructure_Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamStructure_Type* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(StreamStructure_Type_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<StreamStructure_Type>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr StreamStructure_Type StreamStructure::UNKNOWN_TYPE;
constexpr StreamStructure_Type StreamStructure::STREAM;
constexpr StreamStructure_Type StreamStructure::CARD;
constexpr StreamStructure_Type StreamStructure::CONTENT;
constexpr StreamStructure_Type StreamStructure::GROUP;
constexpr StreamStructure_Type StreamStructure::Type_MIN;
constexpr StreamStructure_Type StreamStructure::Type_MAX;
constexpr int StreamStructure::Type_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool WebFeedInfo_State_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> WebFeedInfo_State_strings[4] = {};

static const char WebFeedInfo_State_names[] = "ACTIVE"
                                              "INACTIVE"
                                              "STATE_UNSPECIFIED"
                                              "WAITING_FOR_CONTENT";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry WebFeedInfo_State_entries[] = {
    { { WebFeedInfo_State_names + 0, 6 }, 2 },
    { { WebFeedInfo_State_names + 6, 8 }, 1 },
    { { WebFeedInfo_State_names + 14, 17 }, 0 },
    { { WebFeedInfo_State_names + 31, 19 }, 4 },
};

static const int WebFeedInfo_State_entries_by_number[] = {
    2, // 0 -> STATE_UNSPECIFIED
    1, // 1 -> INACTIVE
    0, // 2 -> ACTIVE
    3, // 4 -> WAITING_FOR_CONTENT
};

const std::string& WebFeedInfo_State_Name(WebFeedInfo_State value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        WebFeedInfo_State_entries, WebFeedInfo_State_entries_by_number, 4, WebFeedInfo_State_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(WebFeedInfo_State_entries, WebFeedInfo_State_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : WebFeedInfo_State_strings[idx].get();
}
bool WebFeedInfo_State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebFeedInfo_State* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(WebFeedInfo_State_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<WebFeedInfo_State>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr WebFeedInfo_State WebFeedInfo::STATE_UNSPECIFIED;
constexpr WebFeedInfo_State WebFeedInfo::INACTIVE;
constexpr WebFeedInfo_State WebFeedInfo::ACTIVE;
constexpr WebFeedInfo_State WebFeedInfo::WAITING_FOR_CONTENT;
constexpr WebFeedInfo_State WebFeedInfo::State_MIN;
constexpr WebFeedInfo_State WebFeedInfo::State_MAX;
constexpr int WebFeedInfo::State_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool PendingWebFeedOperation_Kind_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PendingWebFeedOperation_Kind_strings[3] = {};

static const char PendingWebFeedOperation_Kind_names[] = "KIND_UNSPECIFIED"
                                                         "SUBSCRIBE"
                                                         "UNSUBSCRIBE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PendingWebFeedOperation_Kind_entries[] = {
    { { PendingWebFeedOperation_Kind_names + 0, 16 }, 0 },
    { { PendingWebFeedOperation_Kind_names + 16, 9 }, 1 },
    { { PendingWebFeedOperation_Kind_names + 25, 11 }, 2 },
};

static const int PendingWebFeedOperation_Kind_entries_by_number[] = {
    0, // 0 -> KIND_UNSPECIFIED
    1, // 1 -> SUBSCRIBE
    2, // 2 -> UNSUBSCRIBE
};

const std::string& PendingWebFeedOperation_Kind_Name(PendingWebFeedOperation_Kind value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        PendingWebFeedOperation_Kind_entries, PendingWebFeedOperation_Kind_entries_by_number, 3, PendingWebFeedOperation_Kind_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(PendingWebFeedOperation_Kind_entries, PendingWebFeedOperation_Kind_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : PendingWebFeedOperation_Kind_strings[idx].get();
}
bool PendingWebFeedOperation_Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PendingWebFeedOperation_Kind* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(PendingWebFeedOperation_Kind_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<PendingWebFeedOperation_Kind>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation::KIND_UNSPECIFIED;
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation::SUBSCRIBE;
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation::UNSUBSCRIBE;
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation::Kind_MIN;
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation::Kind_MAX;
constexpr int PendingWebFeedOperation::Kind_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Record::_Internal {
public:
    static const ::feedstore::StreamData& stream_data(const Record* msg);
    static const ::feedstore::StreamStructureSet& stream_structures(const Record* msg);
    static const ::feedstore::Content& content(const Record* msg);
    static const ::feedstore::StoredAction& local_action(const Record* msg);
    static const ::feedstore::StreamSharedState& shared_state(const Record* msg);
    static const ::feedstore::Metadata& metadata(const Record* msg);
    static const ::feedstore::SubscribedWebFeeds& subscribed_web_feeds(const Record* msg);
    static const ::feedstore::WebFeedInfo& recommended_web_feed(const Record* msg);
    static const ::feedstore::RecommendedWebFeedIndex& recommended_web_feed_index(const Record* msg);
    static const ::feedstore::PendingWebFeedOperation& pending_web_feed_operation(const Record* msg);
    static const ::feedstore::DocView& doc_view(const Record* msg);
};

const ::feedstore::StreamData& Record::_Internal::stream_data(const Record* msg)
{
    return *msg->_impl_.data_.stream_data_;
}
const ::feedstore::StreamStructureSet& Record::_Internal::stream_structures(const Record* msg)
{
    return *msg->_impl_.data_.stream_structures_;
}
const ::feedstore::Content& Record::_Internal::content(const Record* msg)
{
    return *msg->_impl_.data_.content_;
}
const ::feedstore::StoredAction& Record::_Internal::local_action(const Record* msg)
{
    return *msg->_impl_.data_.local_action_;
}
const ::feedstore::StreamSharedState& Record::_Internal::shared_state(const Record* msg)
{
    return *msg->_impl_.data_.shared_state_;
}
const ::feedstore::Metadata& Record::_Internal::metadata(const Record* msg)
{
    return *msg->_impl_.data_.metadata_;
}
const ::feedstore::SubscribedWebFeeds& Record::_Internal::subscribed_web_feeds(const Record* msg)
{
    return *msg->_impl_.data_.subscribed_web_feeds_;
}
const ::feedstore::WebFeedInfo& Record::_Internal::recommended_web_feed(const Record* msg)
{
    return *msg->_impl_.data_.recommended_web_feed_;
}
const ::feedstore::RecommendedWebFeedIndex& Record::_Internal::recommended_web_feed_index(const Record* msg)
{
    return *msg->_impl_.data_.recommended_web_feed_index_;
}
const ::feedstore::PendingWebFeedOperation& Record::_Internal::pending_web_feed_operation(const Record* msg)
{
    return *msg->_impl_.data_.pending_web_feed_operation_;
}
const ::feedstore::DocView& Record::_Internal::doc_view(const Record* msg)
{
    return *msg->_impl_.data_.doc_view_;
}
void Record::set_allocated_stream_data(::feedstore::StreamData* stream_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (stream_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream_data);
        if (message_arena != submessage_arena) {
            stream_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, stream_data, submessage_arena);
        }
        set_has_stream_data();
        _impl_.data_.stream_data_ = stream_data;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.stream_data)
}
void Record::set_allocated_stream_structures(::feedstore::StreamStructureSet* stream_structures)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (stream_structures) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stream_structures);
        if (message_arena != submessage_arena) {
            stream_structures = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, stream_structures, submessage_arena);
        }
        set_has_stream_structures();
        _impl_.data_.stream_structures_ = stream_structures;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.stream_structures)
}
void Record::set_allocated_content(::feedstore::Content* content)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (content) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
        if (message_arena != submessage_arena) {
            content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, content, submessage_arena);
        }
        set_has_content();
        _impl_.data_.content_ = content;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.content)
}
void Record::set_allocated_local_action(::feedstore::StoredAction* local_action)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (local_action) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(local_action);
        if (message_arena != submessage_arena) {
            local_action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, local_action, submessage_arena);
        }
        set_has_local_action();
        _impl_.data_.local_action_ = local_action;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.local_action)
}
void Record::set_allocated_shared_state(::feedstore::StreamSharedState* shared_state)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (shared_state) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(shared_state);
        if (message_arena != submessage_arena) {
            shared_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, shared_state, submessage_arena);
        }
        set_has_shared_state();
        _impl_.data_.shared_state_ = shared_state;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.shared_state)
}
void Record::set_allocated_metadata(::feedstore::Metadata* metadata)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (metadata) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(metadata);
        if (message_arena != submessage_arena) {
            metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, metadata, submessage_arena);
        }
        set_has_metadata();
        _impl_.data_.metadata_ = metadata;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.metadata)
}
void Record::set_allocated_subscribed_web_feeds(::feedstore::SubscribedWebFeeds* subscribed_web_feeds)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (subscribed_web_feeds) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subscribed_web_feeds);
        if (message_arena != submessage_arena) {
            subscribed_web_feeds = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, subscribed_web_feeds, submessage_arena);
        }
        set_has_subscribed_web_feeds();
        _impl_.data_.subscribed_web_feeds_ = subscribed_web_feeds;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.subscribed_web_feeds)
}
void Record::set_allocated_recommended_web_feed(::feedstore::WebFeedInfo* recommended_web_feed)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (recommended_web_feed) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recommended_web_feed);
        if (message_arena != submessage_arena) {
            recommended_web_feed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, recommended_web_feed, submessage_arena);
        }
        set_has_recommended_web_feed();
        _impl_.data_.recommended_web_feed_ = recommended_web_feed;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.recommended_web_feed)
}
void Record::set_allocated_recommended_web_feed_index(::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (recommended_web_feed_index) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(recommended_web_feed_index);
        if (message_arena != submessage_arena) {
            recommended_web_feed_index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, recommended_web_feed_index, submessage_arena);
        }
        set_has_recommended_web_feed_index();
        _impl_.data_.recommended_web_feed_index_ = recommended_web_feed_index;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.recommended_web_feed_index)
}
void Record::set_allocated_pending_web_feed_operation(::feedstore::PendingWebFeedOperation* pending_web_feed_operation)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (pending_web_feed_operation) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pending_web_feed_operation);
        if (message_arena != submessage_arena) {
            pending_web_feed_operation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, pending_web_feed_operation, submessage_arena);
        }
        set_has_pending_web_feed_operation();
        _impl_.data_.pending_web_feed_operation_ = pending_web_feed_operation;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.pending_web_feed_operation)
}
void Record::set_allocated_doc_view(::feedstore::DocView* doc_view)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_data();
    if (doc_view) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(doc_view);
        if (message_arena != submessage_arena) {
            doc_view = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, doc_view, submessage_arena);
        }
        set_has_doc_view();
        _impl_.data_.doc_view_ = doc_view;
    }
    // @@protoc_insertion_point(field_set_allocated:feedstore.Record.doc_view)
}
Record::Record(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.Record)
}
Record::Record(const Record& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Record* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.data_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    clear_has_data();
    switch (from.data_case()) {
    case kStreamData: {
        _this->_internal_mutable_stream_data()->::feedstore::StreamData::MergeFrom(from._internal_stream_data());
        break;
    }
    case kStreamStructures: {
        _this->_internal_mutable_stream_structures()->::feedstore::StreamStructureSet::MergeFrom(from._internal_stream_structures());
        break;
    }
    case kContent: {
        _this->_internal_mutable_content()->::feedstore::Content::MergeFrom(from._internal_content());
        break;
    }
    case kLocalAction: {
        _this->_internal_mutable_local_action()->::feedstore::StoredAction::MergeFrom(from._internal_local_action());
        break;
    }
    case kSharedState: {
        _this->_internal_mutable_shared_state()->::feedstore::StreamSharedState::MergeFrom(from._internal_shared_state());
        break;
    }
    case kMetadata: {
        _this->_internal_mutable_metadata()->::feedstore::Metadata::MergeFrom(from._internal_metadata());
        break;
    }
    case kSubscribedWebFeeds: {
        _this->_internal_mutable_subscribed_web_feeds()->::feedstore::SubscribedWebFeeds::MergeFrom(from._internal_subscribed_web_feeds());
        break;
    }
    case kRecommendedWebFeed: {
        _this->_internal_mutable_recommended_web_feed()->::feedstore::WebFeedInfo::MergeFrom(from._internal_recommended_web_feed());
        break;
    }
    case kRecommendedWebFeedIndex: {
        _this->_internal_mutable_recommended_web_feed_index()->::feedstore::RecommendedWebFeedIndex::MergeFrom(from._internal_recommended_web_feed_index());
        break;
    }
    case kPendingWebFeedOperation: {
        _this->_internal_mutable_pending_web_feed_operation()->::feedstore::PendingWebFeedOperation::MergeFrom(from._internal_pending_web_feed_operation());
        break;
    }
    case kDocView: {
        _this->_internal_mutable_doc_view()->::feedstore::DocView::MergeFrom(from._internal_doc_view());
        break;
    }
    case DATA_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:feedstore.Record)
}

inline void Record::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.data_) {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    clear_has_data();
}

Record::~Record()
{
    // @@protoc_insertion_point(destructor:feedstore.Record)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Record::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (has_data()) {
        clear_data();
    }
}

void Record::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Record::clear_data()
{
    // @@protoc_insertion_point(one_of_clear_start:feedstore.Record)
    switch (data_case()) {
    case kStreamData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.stream_data_;
        }
        break;
    }
    case kStreamStructures: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.stream_structures_;
        }
        break;
    }
    case kContent: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.content_;
        }
        break;
    }
    case kLocalAction: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.local_action_;
        }
        break;
    }
    case kSharedState: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.shared_state_;
        }
        break;
    }
    case kMetadata: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.metadata_;
        }
        break;
    }
    case kSubscribedWebFeeds: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.subscribed_web_feeds_;
        }
        break;
    }
    case kRecommendedWebFeed: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.recommended_web_feed_;
        }
        break;
    }
    case kRecommendedWebFeedIndex: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.recommended_web_feed_index_;
        }
        break;
    }
    case kPendingWebFeedOperation: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.pending_web_feed_operation_;
        }
        break;
    }
    case kDocView: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.data_.doc_view_;
        }
        break;
    }
    case DATA_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = DATA_NOT_SET;
}

void Record::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.Record)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    clear_data();
    _internal_metadata_.Clear<std::string>();
}

const char* Record::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedstore.StreamData stream_data = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_stream_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.StreamStructureSet stream_structures = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_stream_structures(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.Content content = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_content(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.StoredAction local_action = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ctx->ParseMessage(_internal_mutable_local_action(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.StreamSharedState shared_state = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_shared_state(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.Metadata metadata = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.SubscribedWebFeeds subscribed_web_feeds = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_subscribed_web_feeds(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.WebFeedInfo recommended_web_feed = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_recommended_web_feed(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.RecommendedWebFeedIndex recommended_web_feed_index = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_recommended_web_feed_index(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.PendingWebFeedOperation pending_web_feed_operation = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr = ctx->ParseMessage(_internal_mutable_pending_web_feed_operation(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.DocView doc_view = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_doc_view(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Record::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.Record)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedstore.StreamData stream_data = 1;
    if (_internal_has_stream_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::stream_data(this), _Internal::stream_data(this).GetCachedSize(), target, stream);
    }

    // .feedstore.StreamStructureSet stream_structures = 2;
    if (_internal_has_stream_structures()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::stream_structures(this), _Internal::stream_structures(this).GetCachedSize(), target, stream);
    }

    // .feedstore.Content content = 3;
    if (_internal_has_content()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::content(this), _Internal::content(this).GetCachedSize(), target, stream);
    }

    // .feedstore.StoredAction local_action = 4;
    if (_internal_has_local_action()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            4, _Internal::local_action(this), _Internal::local_action(this).GetCachedSize(), target, stream);
    }

    // .feedstore.StreamSharedState shared_state = 5;
    if (_internal_has_shared_state()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::shared_state(this), _Internal::shared_state(this).GetCachedSize(), target, stream);
    }

    // .feedstore.Metadata metadata = 6;
    if (_internal_has_metadata()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::metadata(this), _Internal::metadata(this).GetCachedSize(), target, stream);
    }

    // .feedstore.SubscribedWebFeeds subscribed_web_feeds = 7;
    if (_internal_has_subscribed_web_feeds()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::subscribed_web_feeds(this), _Internal::subscribed_web_feeds(this).GetCachedSize(), target, stream);
    }

    // .feedstore.WebFeedInfo recommended_web_feed = 8;
    if (_internal_has_recommended_web_feed()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::recommended_web_feed(this), _Internal::recommended_web_feed(this).GetCachedSize(), target, stream);
    }

    // .feedstore.RecommendedWebFeedIndex recommended_web_feed_index = 9;
    if (_internal_has_recommended_web_feed_index()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::recommended_web_feed_index(this), _Internal::recommended_web_feed_index(this).GetCachedSize(), target, stream);
    }

    // .feedstore.PendingWebFeedOperation pending_web_feed_operation = 10;
    if (_internal_has_pending_web_feed_operation()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            10, _Internal::pending_web_feed_operation(this), _Internal::pending_web_feed_operation(this).GetCachedSize(), target, stream);
    }

    // .feedstore.DocView doc_view = 11;
    if (_internal_has_doc_view()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::doc_view(this), _Internal::doc_view(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.Record)
    return target;
}

size_t Record::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.Record)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    switch (data_case()) {
    // .feedstore.StreamData stream_data = 1;
    case kStreamData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.stream_data_);
        break;
    }
    // .feedstore.StreamStructureSet stream_structures = 2;
    case kStreamStructures: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.stream_structures_);
        break;
    }
    // .feedstore.Content content = 3;
    case kContent: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.content_);
        break;
    }
    // .feedstore.StoredAction local_action = 4;
    case kLocalAction: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.local_action_);
        break;
    }
    // .feedstore.StreamSharedState shared_state = 5;
    case kSharedState: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.shared_state_);
        break;
    }
    // .feedstore.Metadata metadata = 6;
    case kMetadata: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.metadata_);
        break;
    }
    // .feedstore.SubscribedWebFeeds subscribed_web_feeds = 7;
    case kSubscribedWebFeeds: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.subscribed_web_feeds_);
        break;
    }
    // .feedstore.WebFeedInfo recommended_web_feed = 8;
    case kRecommendedWebFeed: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.recommended_web_feed_);
        break;
    }
    // .feedstore.RecommendedWebFeedIndex recommended_web_feed_index = 9;
    case kRecommendedWebFeedIndex: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.recommended_web_feed_index_);
        break;
    }
    // .feedstore.PendingWebFeedOperation pending_web_feed_operation = 10;
    case kPendingWebFeedOperation: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.pending_web_feed_operation_);
        break;
    }
    // .feedstore.DocView doc_view = 11;
    case kDocView: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.data_.doc_view_);
        break;
    }
    case DATA_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Record::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Record*>(&from));
}

void Record::MergeFrom(const Record& from)
{
    Record* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.Record)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    switch (from.data_case()) {
    case kStreamData: {
        _this->_internal_mutable_stream_data()->::feedstore::StreamData::MergeFrom(from._internal_stream_data());
        break;
    }
    case kStreamStructures: {
        _this->_internal_mutable_stream_structures()->::feedstore::StreamStructureSet::MergeFrom(from._internal_stream_structures());
        break;
    }
    case kContent: {
        _this->_internal_mutable_content()->::feedstore::Content::MergeFrom(from._internal_content());
        break;
    }
    case kLocalAction: {
        _this->_internal_mutable_local_action()->::feedstore::StoredAction::MergeFrom(from._internal_local_action());
        break;
    }
    case kSharedState: {
        _this->_internal_mutable_shared_state()->::feedstore::StreamSharedState::MergeFrom(from._internal_shared_state());
        break;
    }
    case kMetadata: {
        _this->_internal_mutable_metadata()->::feedstore::Metadata::MergeFrom(from._internal_metadata());
        break;
    }
    case kSubscribedWebFeeds: {
        _this->_internal_mutable_subscribed_web_feeds()->::feedstore::SubscribedWebFeeds::MergeFrom(from._internal_subscribed_web_feeds());
        break;
    }
    case kRecommendedWebFeed: {
        _this->_internal_mutable_recommended_web_feed()->::feedstore::WebFeedInfo::MergeFrom(from._internal_recommended_web_feed());
        break;
    }
    case kRecommendedWebFeedIndex: {
        _this->_internal_mutable_recommended_web_feed_index()->::feedstore::RecommendedWebFeedIndex::MergeFrom(from._internal_recommended_web_feed_index());
        break;
    }
    case kPendingWebFeedOperation: {
        _this->_internal_mutable_pending_web_feed_operation()->::feedstore::PendingWebFeedOperation::MergeFrom(from._internal_pending_web_feed_operation());
        break;
    }
    case kDocView: {
        _this->_internal_mutable_doc_view()->::feedstore::DocView::MergeFrom(from._internal_doc_view());
        break;
    }
    case DATA_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Record::CopyFrom(const Record& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.Record)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Record::IsInitialized() const
{
    return true;
}

void Record::InternalSwap(Record* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_.data_, other->_impl_.data_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string Record::GetTypeName() const
{
    return "feedstore.Record";
}

// ===================================================================

class StreamContentHashList::_Internal {
public:
};

StreamContentHashList::StreamContentHashList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.StreamContentHashList)
}
StreamContentHashList::StreamContentHashList(const StreamContentHashList& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StreamContentHashList* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.hashes_) { from._impl_.hashes_ }, /*decltype(_impl_._hashes_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:feedstore.StreamContentHashList)
}

inline void StreamContentHashList::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.hashes_) { arena }, /*decltype(_impl_._hashes_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

StreamContentHashList::~StreamContentHashList()
{
    // @@protoc_insertion_point(destructor:feedstore.StreamContentHashList)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StreamContentHashList::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.hashes_.~RepeatedField();
}

void StreamContentHashList::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StreamContentHashList::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.StreamContentHashList)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.hashes_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* StreamContentHashList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated uint32 hashes = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_hashes(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 8) {
                _internal_add_hashes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StreamContentHashList::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.StreamContentHashList)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated uint32 hashes = 1;
    {
        int byte_size = _impl_._hashes_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteUInt32Packed(1, _internal_hashes(), byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.StreamContentHashList)
    return target;
}

size_t StreamContentHashList::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.StreamContentHashList)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated uint32 hashes = 1;
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.hashes_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._hashes_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StreamContentHashList::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StreamContentHashList*>(&from));
}

void StreamContentHashList::MergeFrom(const StreamContentHashList& from)
{
    StreamContentHashList* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.StreamContentHashList)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.hashes_.MergeFrom(from._impl_.hashes_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamContentHashList::CopyFrom(const StreamContentHashList& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.StreamContentHashList)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StreamContentHashList::IsInitialized() const
{
    return true;
}

void StreamContentHashList::InternalSwap(StreamContentHashList* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.hashes_.InternalSwap(&other->_impl_.hashes_);
}

std::string StreamContentHashList::GetTypeName() const
{
    return "feedstore.StreamContentHashList";
}

// ===================================================================

class StreamData::_Internal {
public:
    static const ::feedwire::ContentId& content_id(const StreamData* msg);
};

const ::feedwire::ContentId& StreamData::_Internal::content_id(const StreamData* msg)
{
    return *msg->_impl_.content_id_;
}
void StreamData::clear_content_id()
{
    if (GetArenaForAllocation() == nullptr && _impl_.content_id_ != nullptr) {
        delete _impl_.content_id_;
    }
    _impl_.content_id_ = nullptr;
}
void StreamData::clear_shared_state_ids()
{
    _impl_.shared_state_ids_.Clear();
}
StreamData::StreamData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.StreamData)
}
StreamData::StreamData(const StreamData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StreamData* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.shared_state_ids_) { from._impl_.shared_state_ids_ }, decltype(_impl_.content_hashes_) { from._impl_.content_hashes_ },
            decltype(_impl_.next_page_token_) {}, decltype(_impl_.stream_key_) {}, decltype(_impl_.root_event_id_) {}, decltype(_impl_.gaia_) {},
            decltype(_impl_.email_) {}, decltype(_impl_.content_id_) { nullptr }, decltype(_impl_.last_added_time_millis_) {}, decltype(_impl_.signed_in_) {},
            decltype(_impl_.logging_enabled_) {}, decltype(_impl_.privacy_notice_fulfilled_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.next_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_next_page_token().empty()) {
        _this->_impl_.next_page_token_.Set(from._internal_next_page_token(), _this->GetArenaForAllocation());
    }
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_stream_key().empty()) {
        _this->_impl_.stream_key_.Set(from._internal_stream_key(), _this->GetArenaForAllocation());
    }
    _impl_.root_event_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_event_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_root_event_id().empty()) {
        _this->_impl_.root_event_id_.Set(from._internal_root_event_id(), _this->GetArenaForAllocation());
    }
    _impl_.gaia_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_gaia().empty()) {
        _this->_impl_.gaia_.Set(from._internal_gaia(), _this->GetArenaForAllocation());
    }
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_email().empty()) {
        _this->_impl_.email_.Set(from._internal_email(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_content_id()) {
        _this->_impl_.content_id_ = new ::feedwire::ContentId(*from._impl_.content_id_);
    }
    ::memcpy(&_impl_.last_added_time_millis_, &from._impl_.last_added_time_millis_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.privacy_notice_fulfilled_) - reinterpret_cast<char*>(&_impl_.last_added_time_millis_))
            + sizeof(_impl_.privacy_notice_fulfilled_));
    // @@protoc_insertion_point(copy_constructor:feedstore.StreamData)
}

inline void StreamData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.shared_state_ids_) { arena }, decltype(_impl_.content_hashes_) { arena }, decltype(_impl_.next_page_token_) {},
        decltype(_impl_.stream_key_) {}, decltype(_impl_.root_event_id_) {}, decltype(_impl_.gaia_) {}, decltype(_impl_.email_) {},
        decltype(_impl_.content_id_) { nullptr }, decltype(_impl_.last_added_time_millis_) { int64_t { 0 } }, decltype(_impl_.signed_in_) { false },
        decltype(_impl_.logging_enabled_) { false }, decltype(_impl_.privacy_notice_fulfilled_) { false }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.next_page_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.next_page_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_event_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_event_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.email_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamData::~StreamData()
{
    // @@protoc_insertion_point(destructor:feedstore.StreamData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StreamData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.shared_state_ids_.~RepeatedPtrField();
    _impl_.content_hashes_.~RepeatedPtrField();
    _impl_.next_page_token_.Destroy();
    _impl_.stream_key_.Destroy();
    _impl_.root_event_id_.Destroy();
    _impl_.gaia_.Destroy();
    _impl_.email_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.content_id_;
}

void StreamData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StreamData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.StreamData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.shared_state_ids_.Clear();
    _impl_.content_hashes_.Clear();
    _impl_.next_page_token_.ClearToEmpty();
    _impl_.stream_key_.ClearToEmpty();
    _impl_.root_event_id_.ClearToEmpty();
    _impl_.gaia_.ClearToEmpty();
    _impl_.email_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.content_id_ != nullptr) {
        delete _impl_.content_id_;
    }
    _impl_.content_id_ = nullptr;
    ::memset(&_impl_.last_added_time_millis_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.privacy_notice_fulfilled_) - reinterpret_cast<char*>(&_impl_.last_added_time_millis_))
            + sizeof(_impl_.privacy_notice_fulfilled_));
    _internal_metadata_.Clear<std::string>();
}

const char* StreamData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedwire.ContentId content_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_content_id(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes next_page_token = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_next_page_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int64 last_added_time_millis = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.last_added_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .feedwire.ContentId shared_state_ids = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_shared_state_ids(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        // bool signed_in = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _impl_.signed_in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool logging_enabled = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _impl_.logging_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool privacy_notice_fulfilled = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _impl_.privacy_notice_fulfilled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string stream_key = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                auto str = _internal_mutable_stream_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .feedstore.StreamContentHashList content_hashes = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_content_hashes(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
            } else
                goto handle_unusual;
            continue;
        // bytes root_event_id = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
                auto str = _internal_mutable_root_event_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string gaia = 13;
        case 13:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
                auto str = _internal_mutable_gaia();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string email = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_email();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StreamData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.StreamData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedwire.ContentId content_id = 1;
    if (this->_internal_has_content_id()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::content_id(this), _Internal::content_id(this).GetCachedSize(), target, stream);
    }

    // bytes next_page_token = 2;
    if (!this->_internal_next_page_token().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_next_page_token(), target);
    }

    // int64 last_added_time_millis = 4;
    if (this->_internal_last_added_time_millis() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_last_added_time_millis(), target);
    }

    // repeated .feedwire.ContentId shared_state_ids = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_shared_state_ids_size()); i < n; i++) {
        const auto& repfield = this->_internal_shared_state_ids(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    // bool signed_in = 7;
    if (this->_internal_signed_in() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_signed_in(), target);
    }

    // bool logging_enabled = 8;
    if (this->_internal_logging_enabled() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_logging_enabled(), target);
    }

    // bool privacy_notice_fulfilled = 9;
    if (this->_internal_privacy_notice_fulfilled() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_privacy_notice_fulfilled(), target);
    }

    // string stream_key = 10;
    if (!this->_internal_stream_key().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_stream_key().data(),
            static_cast<int>(this->_internal_stream_key().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.StreamData.stream_key");
        target = stream->WriteStringMaybeAliased(10, this->_internal_stream_key(), target);
    }

    // repeated .feedstore.StreamContentHashList content_hashes = 11;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_content_hashes_size()); i < n; i++) {
        const auto& repfield = this->_internal_content_hashes(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
    }

    // bytes root_event_id = 12;
    if (!this->_internal_root_event_id().empty()) {
        target = stream->WriteBytesMaybeAliased(12, this->_internal_root_event_id(), target);
    }

    // string gaia = 13;
    if (!this->_internal_gaia().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_gaia().data(), static_cast<int>(this->_internal_gaia().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedstore.StreamData.gaia");
        target = stream->WriteStringMaybeAliased(13, this->_internal_gaia(), target);
    }

    // string email = 14;
    if (!this->_internal_email().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_email().data(), static_cast<int>(this->_internal_email().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedstore.StreamData.email");
        target = stream->WriteStringMaybeAliased(14, this->_internal_email(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.StreamData)
    return target;
}

size_t StreamData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.StreamData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedwire.ContentId shared_state_ids = 6;
    total_size += 1UL * this->_internal_shared_state_ids_size();
    for (const auto& msg : this->_impl_.shared_state_ids_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .feedstore.StreamContentHashList content_hashes = 11;
    total_size += 1UL * this->_internal_content_hashes_size();
    for (const auto& msg : this->_impl_.content_hashes_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // bytes next_page_token = 2;
    if (!this->_internal_next_page_token().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_next_page_token());
    }

    // string stream_key = 10;
    if (!this->_internal_stream_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_stream_key());
    }

    // bytes root_event_id = 12;
    if (!this->_internal_root_event_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_root_event_id());
    }

    // string gaia = 13;
    if (!this->_internal_gaia().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_gaia());
    }

    // string email = 14;
    if (!this->_internal_email().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_email());
    }

    // .feedwire.ContentId content_id = 1;
    if (this->_internal_has_content_id()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.content_id_);
    }

    // int64 last_added_time_millis = 4;
    if (this->_internal_last_added_time_millis() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_added_time_millis());
    }

    // bool signed_in = 7;
    if (this->_internal_signed_in() != 0) {
        total_size += 1 + 1;
    }

    // bool logging_enabled = 8;
    if (this->_internal_logging_enabled() != 0) {
        total_size += 1 + 1;
    }

    // bool privacy_notice_fulfilled = 9;
    if (this->_internal_privacy_notice_fulfilled() != 0) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StreamData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StreamData*>(&from));
}

void StreamData::MergeFrom(const StreamData& from)
{
    StreamData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.StreamData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.shared_state_ids_.MergeFrom(from._impl_.shared_state_ids_);
    _this->_impl_.content_hashes_.MergeFrom(from._impl_.content_hashes_);
    if (!from._internal_next_page_token().empty()) {
        _this->_internal_set_next_page_token(from._internal_next_page_token());
    }
    if (!from._internal_stream_key().empty()) {
        _this->_internal_set_stream_key(from._internal_stream_key());
    }
    if (!from._internal_root_event_id().empty()) {
        _this->_internal_set_root_event_id(from._internal_root_event_id());
    }
    if (!from._internal_gaia().empty()) {
        _this->_internal_set_gaia(from._internal_gaia());
    }
    if (!from._internal_email().empty()) {
        _this->_internal_set_email(from._internal_email());
    }
    if (from._internal_has_content_id()) {
        _this->_internal_mutable_content_id()->::feedwire::ContentId::MergeFrom(from._internal_content_id());
    }
    if (from._internal_last_added_time_millis() != 0) {
        _this->_internal_set_last_added_time_millis(from._internal_last_added_time_millis());
    }
    if (from._internal_signed_in() != 0) {
        _this->_internal_set_signed_in(from._internal_signed_in());
    }
    if (from._internal_logging_enabled() != 0) {
        _this->_internal_set_logging_enabled(from._internal_logging_enabled());
    }
    if (from._internal_privacy_notice_fulfilled() != 0) {
        _this->_internal_set_privacy_notice_fulfilled(from._internal_privacy_notice_fulfilled());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamData::CopyFrom(const StreamData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.StreamData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StreamData::IsInitialized() const
{
    return true;
}

void StreamData::InternalSwap(StreamData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.shared_state_ids_.InternalSwap(&other->_impl_.shared_state_ids_);
    _impl_.content_hashes_.InternalSwap(&other->_impl_.content_hashes_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.next_page_token_, lhs_arena, &other->_impl_.next_page_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.stream_key_, lhs_arena, &other->_impl_.stream_key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.root_event_id_, lhs_arena, &other->_impl_.root_event_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.gaia_, lhs_arena, &other->_impl_.gaia_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.email_, lhs_arena, &other->_impl_.email_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(StreamData, _impl_.privacy_notice_fulfilled_)
        + sizeof(StreamData::_impl_.privacy_notice_fulfilled_) - PROTOBUF_FIELD_OFFSET(StreamData, _impl_.content_id_)>(
        reinterpret_cast<char*>(&_impl_.content_id_), reinterpret_cast<char*>(&other->_impl_.content_id_));
}

std::string StreamData::GetTypeName() const
{
    return "feedstore.StreamData";
}

// ===================================================================

class Metadata_SessionID::_Internal {
public:
};

Metadata_SessionID::Metadata_SessionID(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.Metadata.SessionID)
}
Metadata_SessionID::Metadata_SessionID(const Metadata_SessionID& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Metadata_SessionID* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.token_) {}, decltype(_impl_.expiry_time_ms_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_token().empty()) {
        _this->_impl_.token_.Set(from._internal_token(), _this->GetArenaForAllocation());
    }
    _this->_impl_.expiry_time_ms_ = from._impl_.expiry_time_ms_;
    // @@protoc_insertion_point(copy_constructor:feedstore.Metadata.SessionID)
}

inline void Metadata_SessionID::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.token_) {}, decltype(_impl_.expiry_time_ms_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Metadata_SessionID::~Metadata_SessionID()
{
    // @@protoc_insertion_point(destructor:feedstore.Metadata.SessionID)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Metadata_SessionID::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.token_.Destroy();
}

void Metadata_SessionID::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Metadata_SessionID::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.Metadata.SessionID)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.token_.ClearToEmpty();
    _impl_.expiry_time_ms_ = int64_t { 0 };
    _internal_metadata_.Clear<std::string>();
}

const char* Metadata_SessionID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // int64 expiry_time_ms = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.expiry_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Metadata_SessionID::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.Metadata.SessionID)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string token = 1;
    if (!this->_internal_token().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedstore.Metadata.SessionID.token");
        target = stream->WriteStringMaybeAliased(1, this->_internal_token(), target);
    }

    // int64 expiry_time_ms = 2;
    if (this->_internal_expiry_time_ms() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_expiry_time_ms(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.Metadata.SessionID)
    return target;
}

size_t Metadata_SessionID::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.Metadata.SessionID)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string token = 1;
    if (!this->_internal_token().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_token());
    }

    // int64 expiry_time_ms = 2;
    if (this->_internal_expiry_time_ms() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expiry_time_ms());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Metadata_SessionID::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Metadata_SessionID*>(&from));
}

void Metadata_SessionID::MergeFrom(const Metadata_SessionID& from)
{
    Metadata_SessionID* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.Metadata.SessionID)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_token().empty()) {
        _this->_internal_set_token(from._internal_token());
    }
    if (from._internal_expiry_time_ms() != 0) {
        _this->_internal_set_expiry_time_ms(from._internal_expiry_time_ms());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Metadata_SessionID::CopyFrom(const Metadata_SessionID& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.Metadata.SessionID)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Metadata_SessionID::IsInitialized() const
{
    return true;
}

void Metadata_SessionID::InternalSwap(Metadata_SessionID* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.token_, lhs_arena, &other->_impl_.token_, rhs_arena);
    swap(_impl_.expiry_time_ms_, other->_impl_.expiry_time_ms_);
}

std::string Metadata_SessionID::GetTypeName() const
{
    return "feedstore.Metadata.SessionID";
}

// ===================================================================

class Metadata_StreamMetadata_ContentLifetime::_Internal {
public:
};

Metadata_StreamMetadata_ContentLifetime::Metadata_StreamMetadata_ContentLifetime(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.Metadata.StreamMetadata.ContentLifetime)
}
Metadata_StreamMetadata_ContentLifetime::Metadata_StreamMetadata_ContentLifetime(const Metadata_StreamMetadata_ContentLifetime& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Metadata_StreamMetadata_ContentLifetime* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.stale_age_ms_) {}, decltype(_impl_.invalid_age_ms_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.stale_age_ms_, &from._impl_.stale_age_ms_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.invalid_age_ms_) - reinterpret_cast<char*>(&_impl_.stale_age_ms_))
            + sizeof(_impl_.invalid_age_ms_));
    // @@protoc_insertion_point(copy_constructor:feedstore.Metadata.StreamMetadata.ContentLifetime)
}

inline void Metadata_StreamMetadata_ContentLifetime::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.stale_age_ms_) { int64_t { 0 } }, decltype(_impl_.invalid_age_ms_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
}

Metadata_StreamMetadata_ContentLifetime::~Metadata_StreamMetadata_ContentLifetime()
{
    // @@protoc_insertion_point(destructor:feedstore.Metadata.StreamMetadata.ContentLifetime)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Metadata_StreamMetadata_ContentLifetime::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Metadata_StreamMetadata_ContentLifetime::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Metadata_StreamMetadata_ContentLifetime::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.Metadata.StreamMetadata.ContentLifetime)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    ::memset(&_impl_.stale_age_ms_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.invalid_age_ms_) - reinterpret_cast<char*>(&_impl_.stale_age_ms_))
            + sizeof(_impl_.invalid_age_ms_));
    _internal_metadata_.Clear<std::string>();
}

const char* Metadata_StreamMetadata_ContentLifetime::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int64 stale_age_ms = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.stale_age_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int64 invalid_age_ms = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.invalid_age_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Metadata_StreamMetadata_ContentLifetime::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.Metadata.StreamMetadata.ContentLifetime)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int64 stale_age_ms = 1;
    if (this->_internal_stale_age_ms() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_stale_age_ms(), target);
    }

    // int64 invalid_age_ms = 2;
    if (this->_internal_invalid_age_ms() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_invalid_age_ms(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.Metadata.StreamMetadata.ContentLifetime)
    return target;
}

size_t Metadata_StreamMetadata_ContentLifetime::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.Metadata.StreamMetadata.ContentLifetime)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // int64 stale_age_ms = 1;
    if (this->_internal_stale_age_ms() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_stale_age_ms());
    }

    // int64 invalid_age_ms = 2;
    if (this->_internal_invalid_age_ms() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_invalid_age_ms());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Metadata_StreamMetadata_ContentLifetime::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Metadata_StreamMetadata_ContentLifetime*>(&from));
}

void Metadata_StreamMetadata_ContentLifetime::MergeFrom(const Metadata_StreamMetadata_ContentLifetime& from)
{
    Metadata_StreamMetadata_ContentLifetime* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.Metadata.StreamMetadata.ContentLifetime)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_stale_age_ms() != 0) {
        _this->_internal_set_stale_age_ms(from._internal_stale_age_ms());
    }
    if (from._internal_invalid_age_ms() != 0) {
        _this->_internal_set_invalid_age_ms(from._internal_invalid_age_ms());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Metadata_StreamMetadata_ContentLifetime::CopyFrom(const Metadata_StreamMetadata_ContentLifetime& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.Metadata.StreamMetadata.ContentLifetime)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Metadata_StreamMetadata_ContentLifetime::IsInitialized() const
{
    return true;
}

void Metadata_StreamMetadata_ContentLifetime::InternalSwap(Metadata_StreamMetadata_ContentLifetime* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Metadata_StreamMetadata_ContentLifetime, _impl_.invalid_age_ms_)
        + sizeof(Metadata_StreamMetadata_ContentLifetime::_impl_.invalid_age_ms_)
        - PROTOBUF_FIELD_OFFSET(Metadata_StreamMetadata_ContentLifetime, _impl_.stale_age_ms_)>(
        reinterpret_cast<char*>(&_impl_.stale_age_ms_), reinterpret_cast<char*>(&other->_impl_.stale_age_ms_));
}

std::string Metadata_StreamMetadata_ContentLifetime::GetTypeName() const
{
    return "feedstore.Metadata.StreamMetadata.ContentLifetime";
}

// ===================================================================

class Metadata_StreamMetadata::_Internal {
public:
    static const ::feedstore::Metadata_StreamMetadata_ContentLifetime& content_lifetime(const Metadata_StreamMetadata* msg);
};

const ::feedstore::Metadata_StreamMetadata_ContentLifetime& Metadata_StreamMetadata::_Internal::content_lifetime(const Metadata_StreamMetadata* msg)
{
    return *msg->_impl_.content_lifetime_;
}
Metadata_StreamMetadata::Metadata_StreamMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.Metadata.StreamMetadata)
}
Metadata_StreamMetadata::Metadata_StreamMetadata(const Metadata_StreamMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Metadata_StreamMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.view_content_hashes_) { from._impl_.view_content_hashes_ },
        decltype(_impl_.viewed_content_hashes_) { from._impl_.viewed_content_hashes_ }, /*decltype(_impl_._viewed_content_hashes_cached_byte_size_)*/ { 0 },
        decltype(_impl_.stream_key_) {}, decltype(_impl_.content_lifetime_) { nullptr }, decltype(_impl_.last_fetch_time_millis_) {},
        decltype(_impl_.last_server_response_time_millis_) {}, decltype(_impl_.is_known_stale_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_stream_key().empty()) {
        _this->_impl_.stream_key_.Set(from._internal_stream_key(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_content_lifetime()) {
        _this->_impl_.content_lifetime_ = new ::feedstore::Metadata_StreamMetadata_ContentLifetime(*from._impl_.content_lifetime_);
    }
    ::memcpy(&_impl_.last_fetch_time_millis_, &from._impl_.last_fetch_time_millis_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_known_stale_) - reinterpret_cast<char*>(&_impl_.last_fetch_time_millis_))
            + sizeof(_impl_.is_known_stale_));
    // @@protoc_insertion_point(copy_constructor:feedstore.Metadata.StreamMetadata)
}

inline void Metadata_StreamMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.view_content_hashes_) { arena }, decltype(_impl_.viewed_content_hashes_) { arena },
        /*decltype(_impl_._viewed_content_hashes_cached_byte_size_)*/ { 0 }, decltype(_impl_.stream_key_) {}, decltype(_impl_.content_lifetime_) { nullptr },
        decltype(_impl_.last_fetch_time_millis_) { int64_t { 0 } }, decltype(_impl_.last_server_response_time_millis_) { int64_t { 0 } },
        decltype(_impl_.is_known_stale_) { false }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Metadata_StreamMetadata::~Metadata_StreamMetadata()
{
    // @@protoc_insertion_point(destructor:feedstore.Metadata.StreamMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Metadata_StreamMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.view_content_hashes_.~RepeatedPtrField();
    _impl_.viewed_content_hashes_.~RepeatedField();
    _impl_.stream_key_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.content_lifetime_;
}

void Metadata_StreamMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Metadata_StreamMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.Metadata.StreamMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.view_content_hashes_.Clear();
    _impl_.viewed_content_hashes_.Clear();
    _impl_.stream_key_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.content_lifetime_ != nullptr) {
        delete _impl_.content_lifetime_;
    }
    _impl_.content_lifetime_ = nullptr;
    ::memset(&_impl_.last_fetch_time_millis_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_known_stale_) - reinterpret_cast<char*>(&_impl_.last_fetch_time_millis_))
            + sizeof(_impl_.is_known_stale_));
    _internal_metadata_.Clear<std::string>();
}

const char* Metadata_StreamMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string stream_key = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_stream_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // bool is_known_stale = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _impl_.is_known_stale_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .feedstore.StreamContentHashList view_content_hashes = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_view_content_hashes(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // .feedstore.Metadata.StreamMetadata.ContentLifetime content_lifetime = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_content_lifetime(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int64 last_fetch_time_millis = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _impl_.last_fetch_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int64 last_server_response_time_millis = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _impl_.last_server_response_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated uint32 viewed_content_hashes = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_viewed_content_hashes(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 64) {
                _internal_add_viewed_content_hashes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Metadata_StreamMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.Metadata.StreamMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string stream_key = 1;
    if (!this->_internal_stream_key().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_stream_key().data(),
            static_cast<int>(this->_internal_stream_key().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.Metadata.StreamMetadata.stream_key");
        target = stream->WriteStringMaybeAliased(1, this->_internal_stream_key(), target);
    }

    // bool is_known_stale = 3;
    if (this->_internal_is_known_stale() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_known_stale(), target);
    }

    // repeated .feedstore.StreamContentHashList view_content_hashes = 4;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_view_content_hashes_size()); i < n; i++) {
        const auto& repfield = this->_internal_view_content_hashes(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
    }

    // .feedstore.Metadata.StreamMetadata.ContentLifetime content_lifetime = 5;
    if (this->_internal_has_content_lifetime()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::content_lifetime(this), _Internal::content_lifetime(this).GetCachedSize(), target, stream);
    }

    // int64 last_fetch_time_millis = 6;
    if (this->_internal_last_fetch_time_millis() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_last_fetch_time_millis(), target);
    }

    // int64 last_server_response_time_millis = 7;
    if (this->_internal_last_server_response_time_millis() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_last_server_response_time_millis(), target);
    }

    // repeated uint32 viewed_content_hashes = 8;
    {
        int byte_size = _impl_._viewed_content_hashes_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteUInt32Packed(8, _internal_viewed_content_hashes(), byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.Metadata.StreamMetadata)
    return target;
}

size_t Metadata_StreamMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.Metadata.StreamMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedstore.StreamContentHashList view_content_hashes = 4;
    total_size += 1UL * this->_internal_view_content_hashes_size();
    for (const auto& msg : this->_impl_.view_content_hashes_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated uint32 viewed_content_hashes = 8;
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.viewed_content_hashes_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._viewed_content_hashes_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // string stream_key = 1;
    if (!this->_internal_stream_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_stream_key());
    }

    // .feedstore.Metadata.StreamMetadata.ContentLifetime content_lifetime = 5;
    if (this->_internal_has_content_lifetime()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.content_lifetime_);
    }

    // int64 last_fetch_time_millis = 6;
    if (this->_internal_last_fetch_time_millis() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_fetch_time_millis());
    }

    // int64 last_server_response_time_millis = 7;
    if (this->_internal_last_server_response_time_millis() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_last_server_response_time_millis());
    }

    // bool is_known_stale = 3;
    if (this->_internal_is_known_stale() != 0) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Metadata_StreamMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Metadata_StreamMetadata*>(&from));
}

void Metadata_StreamMetadata::MergeFrom(const Metadata_StreamMetadata& from)
{
    Metadata_StreamMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.Metadata.StreamMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.view_content_hashes_.MergeFrom(from._impl_.view_content_hashes_);
    _this->_impl_.viewed_content_hashes_.MergeFrom(from._impl_.viewed_content_hashes_);
    if (!from._internal_stream_key().empty()) {
        _this->_internal_set_stream_key(from._internal_stream_key());
    }
    if (from._internal_has_content_lifetime()) {
        _this->_internal_mutable_content_lifetime()->::feedstore::Metadata_StreamMetadata_ContentLifetime::MergeFrom(from._internal_content_lifetime());
    }
    if (from._internal_last_fetch_time_millis() != 0) {
        _this->_internal_set_last_fetch_time_millis(from._internal_last_fetch_time_millis());
    }
    if (from._internal_last_server_response_time_millis() != 0) {
        _this->_internal_set_last_server_response_time_millis(from._internal_last_server_response_time_millis());
    }
    if (from._internal_is_known_stale() != 0) {
        _this->_internal_set_is_known_stale(from._internal_is_known_stale());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Metadata_StreamMetadata::CopyFrom(const Metadata_StreamMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.Metadata.StreamMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Metadata_StreamMetadata::IsInitialized() const
{
    return true;
}

void Metadata_StreamMetadata::InternalSwap(Metadata_StreamMetadata* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.view_content_hashes_.InternalSwap(&other->_impl_.view_content_hashes_);
    _impl_.viewed_content_hashes_.InternalSwap(&other->_impl_.viewed_content_hashes_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.stream_key_, lhs_arena, &other->_impl_.stream_key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Metadata_StreamMetadata, _impl_.is_known_stale_)
        + sizeof(Metadata_StreamMetadata::_impl_.is_known_stale_) - PROTOBUF_FIELD_OFFSET(Metadata_StreamMetadata, _impl_.content_lifetime_)>(
        reinterpret_cast<char*>(&_impl_.content_lifetime_), reinterpret_cast<char*>(&other->_impl_.content_lifetime_));
}

std::string Metadata_StreamMetadata::GetTypeName() const
{
    return "feedstore.Metadata.StreamMetadata";
}

// ===================================================================

class Metadata::_Internal {
public:
    static const ::feedstore::Metadata_SessionID& session_id(const Metadata* msg);
};

const ::feedstore::Metadata_SessionID& Metadata::_Internal::session_id(const Metadata* msg)
{
    return *msg->_impl_.session_id_;
}
Metadata::Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.Metadata)
}
Metadata::Metadata(const Metadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Metadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.stream_metadata_) { from._impl_.stream_metadata_ },
        decltype(_impl_.most_recent_viewed_content_hashes_) { from._impl_.most_recent_viewed_content_hashes_ },
        /*decltype(_impl_._most_recent_viewed_content_hashes_cached_byte_size_)*/ { 0 }, decltype(_impl_.consistency_token_) {}, decltype(_impl_.gaia_) {},
        decltype(_impl_.session_id_) { nullptr }, decltype(_impl_.next_action_id_) {}, decltype(_impl_.stream_schema_version_) {},
        decltype(_impl_.web_and_app_activity_enabled_) {}, decltype(_impl_.discover_personalization_enabled_) {},
        decltype(_impl_.followed_from_web_page_menu_count_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.consistency_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.consistency_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_consistency_token().empty()) {
        _this->_impl_.consistency_token_.Set(from._internal_consistency_token(), _this->GetArenaForAllocation());
    }
    _impl_.gaia_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_gaia().empty()) {
        _this->_impl_.gaia_.Set(from._internal_gaia(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_session_id()) {
        _this->_impl_.session_id_ = new ::feedstore::Metadata_SessionID(*from._impl_.session_id_);
    }
    ::memcpy(&_impl_.next_action_id_, &from._impl_.next_action_id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.followed_from_web_page_menu_count_) - reinterpret_cast<char*>(&_impl_.next_action_id_))
            + sizeof(_impl_.followed_from_web_page_menu_count_));
    // @@protoc_insertion_point(copy_constructor:feedstore.Metadata)
}

inline void Metadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.stream_metadata_) { arena }, decltype(_impl_.most_recent_viewed_content_hashes_) { arena },
        /*decltype(_impl_._most_recent_viewed_content_hashes_cached_byte_size_)*/ { 0 }, decltype(_impl_.consistency_token_) {}, decltype(_impl_.gaia_) {},
        decltype(_impl_.session_id_) { nullptr }, decltype(_impl_.next_action_id_) { 0 }, decltype(_impl_.stream_schema_version_) { 0 },
        decltype(_impl_.web_and_app_activity_enabled_) { false }, decltype(_impl_.discover_personalization_enabled_) { false },
        decltype(_impl_.followed_from_web_page_menu_count_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.consistency_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.consistency_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.gaia_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Metadata::~Metadata()
{
    // @@protoc_insertion_point(destructor:feedstore.Metadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Metadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.stream_metadata_.~RepeatedPtrField();
    _impl_.most_recent_viewed_content_hashes_.~RepeatedField();
    _impl_.consistency_token_.Destroy();
    _impl_.gaia_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.session_id_;
}

void Metadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Metadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.Metadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.stream_metadata_.Clear();
    _impl_.most_recent_viewed_content_hashes_.Clear();
    _impl_.consistency_token_.ClearToEmpty();
    _impl_.gaia_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.session_id_ != nullptr) {
        delete _impl_.session_id_;
    }
    _impl_.session_id_ = nullptr;
    ::memset(&_impl_.next_action_id_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.followed_from_web_page_menu_count_) - reinterpret_cast<char*>(&_impl_.next_action_id_))
            + sizeof(_impl_.followed_from_web_page_menu_count_));
    _internal_metadata_.Clear<std::string>();
}

const char* Metadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bytes consistency_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_consistency_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int32 next_action_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.next_action_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.Metadata.SessionID session_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_session_id(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int32 stream_schema_version = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.stream_schema_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .feedstore.Metadata.StreamMetadata stream_metadata = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_stream_metadata(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // string gaia = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_gaia();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // bool web_and_app_activity_enabled = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                _impl_.web_and_app_activity_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool discover_personalization_enabled = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _impl_.discover_personalization_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int32 followed_from_web_page_menu_count = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                _impl_.followed_from_web_page_menu_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated uint32 most_recent_viewed_content_hashes = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_most_recent_viewed_content_hashes(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 88) {
                _internal_add_most_recent_viewed_content_hashes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Metadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.Metadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bytes consistency_token = 1;
    if (!this->_internal_consistency_token().empty()) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_consistency_token(), target);
    }

    // int32 next_action_id = 2;
    if (this->_internal_next_action_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_next_action_id(), target);
    }

    // .feedstore.Metadata.SessionID session_id = 3;
    if (this->_internal_has_session_id()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::session_id(this), _Internal::session_id(this).GetCachedSize(), target, stream);
    }

    // int32 stream_schema_version = 4;
    if (this->_internal_stream_schema_version() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_stream_schema_version(), target);
    }

    // repeated .feedstore.Metadata.StreamMetadata stream_metadata = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_stream_metadata_size()); i < n; i++) {
        const auto& repfield = this->_internal_stream_metadata(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // string gaia = 6;
    if (!this->_internal_gaia().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_gaia().data(), static_cast<int>(this->_internal_gaia().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedstore.Metadata.gaia");
        target = stream->WriteStringMaybeAliased(6, this->_internal_gaia(), target);
    }

    // bool web_and_app_activity_enabled = 7;
    if (this->_internal_web_and_app_activity_enabled() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_web_and_app_activity_enabled(), target);
    }

    // bool discover_personalization_enabled = 8;
    if (this->_internal_discover_personalization_enabled() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_discover_personalization_enabled(), target);
    }

    // int32 followed_from_web_page_menu_count = 9;
    if (this->_internal_followed_from_web_page_menu_count() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_followed_from_web_page_menu_count(), target);
    }

    // repeated uint32 most_recent_viewed_content_hashes = 11;
    {
        int byte_size = _impl_._most_recent_viewed_content_hashes_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteUInt32Packed(11, _internal_most_recent_viewed_content_hashes(), byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.Metadata)
    return target;
}

size_t Metadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.Metadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedstore.Metadata.StreamMetadata stream_metadata = 5;
    total_size += 1UL * this->_internal_stream_metadata_size();
    for (const auto& msg : this->_impl_.stream_metadata_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated uint32 most_recent_viewed_content_hashes = 11;
    {
        size_t data_size = ::_pbi::WireFormatLite::UInt32Size(this->_impl_.most_recent_viewed_content_hashes_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._most_recent_viewed_content_hashes_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // bytes consistency_token = 1;
    if (!this->_internal_consistency_token().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_consistency_token());
    }

    // string gaia = 6;
    if (!this->_internal_gaia().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_gaia());
    }

    // .feedstore.Metadata.SessionID session_id = 3;
    if (this->_internal_has_session_id()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.session_id_);
    }

    // int32 next_action_id = 2;
    if (this->_internal_next_action_id() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_next_action_id());
    }

    // int32 stream_schema_version = 4;
    if (this->_internal_stream_schema_version() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_stream_schema_version());
    }

    // bool web_and_app_activity_enabled = 7;
    if (this->_internal_web_and_app_activity_enabled() != 0) {
        total_size += 1 + 1;
    }

    // bool discover_personalization_enabled = 8;
    if (this->_internal_discover_personalization_enabled() != 0) {
        total_size += 1 + 1;
    }

    // int32 followed_from_web_page_menu_count = 9;
    if (this->_internal_followed_from_web_page_menu_count() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_followed_from_web_page_menu_count());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Metadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Metadata*>(&from));
}

void Metadata::MergeFrom(const Metadata& from)
{
    Metadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.Metadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.stream_metadata_.MergeFrom(from._impl_.stream_metadata_);
    _this->_impl_.most_recent_viewed_content_hashes_.MergeFrom(from._impl_.most_recent_viewed_content_hashes_);
    if (!from._internal_consistency_token().empty()) {
        _this->_internal_set_consistency_token(from._internal_consistency_token());
    }
    if (!from._internal_gaia().empty()) {
        _this->_internal_set_gaia(from._internal_gaia());
    }
    if (from._internal_has_session_id()) {
        _this->_internal_mutable_session_id()->::feedstore::Metadata_SessionID::MergeFrom(from._internal_session_id());
    }
    if (from._internal_next_action_id() != 0) {
        _this->_internal_set_next_action_id(from._internal_next_action_id());
    }
    if (from._internal_stream_schema_version() != 0) {
        _this->_internal_set_stream_schema_version(from._internal_stream_schema_version());
    }
    if (from._internal_web_and_app_activity_enabled() != 0) {
        _this->_internal_set_web_and_app_activity_enabled(from._internal_web_and_app_activity_enabled());
    }
    if (from._internal_discover_personalization_enabled() != 0) {
        _this->_internal_set_discover_personalization_enabled(from._internal_discover_personalization_enabled());
    }
    if (from._internal_followed_from_web_page_menu_count() != 0) {
        _this->_internal_set_followed_from_web_page_menu_count(from._internal_followed_from_web_page_menu_count());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Metadata::CopyFrom(const Metadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.Metadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Metadata::IsInitialized() const
{
    return true;
}

void Metadata::InternalSwap(Metadata* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.stream_metadata_.InternalSwap(&other->_impl_.stream_metadata_);
    _impl_.most_recent_viewed_content_hashes_.InternalSwap(&other->_impl_.most_recent_viewed_content_hashes_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.consistency_token_, lhs_arena, &other->_impl_.consistency_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.gaia_, lhs_arena, &other->_impl_.gaia_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(Metadata, _impl_.followed_from_web_page_menu_count_)
        + sizeof(Metadata::_impl_.followed_from_web_page_menu_count_) - PROTOBUF_FIELD_OFFSET(Metadata, _impl_.session_id_)>(
        reinterpret_cast<char*>(&_impl_.session_id_), reinterpret_cast<char*>(&other->_impl_.session_id_));
}

std::string Metadata::GetTypeName() const
{
    return "feedstore.Metadata";
}

// ===================================================================

class StreamStructureSet::_Internal {
public:
};

StreamStructureSet::StreamStructureSet(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.StreamStructureSet)
}
StreamStructureSet::StreamStructureSet(const StreamStructureSet& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StreamStructureSet* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.structures_) { from._impl_.structures_ }, decltype(_impl_.stream_key_) {}, decltype(_impl_.sequence_number_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_stream_key().empty()) {
        _this->_impl_.stream_key_.Set(from._internal_stream_key(), _this->GetArenaForAllocation());
    }
    _this->_impl_.sequence_number_ = from._impl_.sequence_number_;
    // @@protoc_insertion_point(copy_constructor:feedstore.StreamStructureSet)
}

inline void StreamStructureSet::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.structures_) { arena }, decltype(_impl_.stream_key_) {}, decltype(_impl_.sequence_number_) { 0 },
        /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamStructureSet::~StreamStructureSet()
{
    // @@protoc_insertion_point(destructor:feedstore.StreamStructureSet)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StreamStructureSet::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.structures_.~RepeatedPtrField();
    _impl_.stream_key_.Destroy();
}

void StreamStructureSet::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StreamStructureSet::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.StreamStructureSet)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.structures_.Clear();
    _impl_.stream_key_.ClearToEmpty();
    _impl_.sequence_number_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* StreamStructureSet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string stream_key = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_stream_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // int32 sequence_number = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .feedstore.StreamStructure structures = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_structures(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StreamStructureSet::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.StreamStructureSet)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string stream_key = 1;
    if (!this->_internal_stream_key().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_stream_key().data(),
            static_cast<int>(this->_internal_stream_key().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.StreamStructureSet.stream_key");
        target = stream->WriteStringMaybeAliased(1, this->_internal_stream_key(), target);
    }

    // int32 sequence_number = 2;
    if (this->_internal_sequence_number() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_sequence_number(), target);
    }

    // repeated .feedstore.StreamStructure structures = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_structures_size()); i < n; i++) {
        const auto& repfield = this->_internal_structures(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.StreamStructureSet)
    return target;
}

size_t StreamStructureSet::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.StreamStructureSet)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedstore.StreamStructure structures = 3;
    total_size += 1UL * this->_internal_structures_size();
    for (const auto& msg : this->_impl_.structures_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string stream_key = 1;
    if (!this->_internal_stream_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_stream_key());
    }

    // int32 sequence_number = 2;
    if (this->_internal_sequence_number() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sequence_number());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StreamStructureSet::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StreamStructureSet*>(&from));
}

void StreamStructureSet::MergeFrom(const StreamStructureSet& from)
{
    StreamStructureSet* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.StreamStructureSet)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.structures_.MergeFrom(from._impl_.structures_);
    if (!from._internal_stream_key().empty()) {
        _this->_internal_set_stream_key(from._internal_stream_key());
    }
    if (from._internal_sequence_number() != 0) {
        _this->_internal_set_sequence_number(from._internal_sequence_number());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamStructureSet::CopyFrom(const StreamStructureSet& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.StreamStructureSet)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StreamStructureSet::IsInitialized() const
{
    return true;
}

void StreamStructureSet::InternalSwap(StreamStructureSet* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.structures_.InternalSwap(&other->_impl_.structures_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.stream_key_, lhs_arena, &other->_impl_.stream_key_, rhs_arena);
    swap(_impl_.sequence_number_, other->_impl_.sequence_number_);
}

std::string StreamStructureSet::GetTypeName() const
{
    return "feedstore.StreamStructureSet";
}

// ===================================================================

class StreamStructure::_Internal {
public:
    static const ::feedwire::ContentId& content_id(const StreamStructure* msg);
    static const ::feedwire::ContentId& parent_id(const StreamStructure* msg);
    static const ::feedstore::ContentInfo& content_info(const StreamStructure* msg);
};

const ::feedwire::ContentId& StreamStructure::_Internal::content_id(const StreamStructure* msg)
{
    return *msg->_impl_.content_id_;
}
const ::feedwire::ContentId& StreamStructure::_Internal::parent_id(const StreamStructure* msg)
{
    return *msg->_impl_.parent_id_;
}
const ::feedstore::ContentInfo& StreamStructure::_Internal::content_info(const StreamStructure* msg)
{
    return *msg->_impl_.content_info_;
}
void StreamStructure::clear_content_id()
{
    if (GetArenaForAllocation() == nullptr && _impl_.content_id_ != nullptr) {
        delete _impl_.content_id_;
    }
    _impl_.content_id_ = nullptr;
}
void StreamStructure::clear_parent_id()
{
    if (GetArenaForAllocation() == nullptr && _impl_.parent_id_ != nullptr) {
        delete _impl_.parent_id_;
    }
    _impl_.parent_id_ = nullptr;
}
StreamStructure::StreamStructure(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.StreamStructure)
}
StreamStructure::StreamStructure(const StreamStructure& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StreamStructure* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.content_id_) { nullptr }, decltype(_impl_.parent_id_) { nullptr }, decltype(_impl_.content_info_) { nullptr },
        decltype(_impl_.operation_) {}, decltype(_impl_.type_) {}, decltype(_impl_.is_root_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_content_id()) {
        _this->_impl_.content_id_ = new ::feedwire::ContentId(*from._impl_.content_id_);
    }
    if (from._internal_has_parent_id()) {
        _this->_impl_.parent_id_ = new ::feedwire::ContentId(*from._impl_.parent_id_);
    }
    if (from._internal_has_content_info()) {
        _this->_impl_.content_info_ = new ::feedstore::ContentInfo(*from._impl_.content_info_);
    }
    ::memcpy(&_impl_.operation_, &from._impl_.operation_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_root_) - reinterpret_cast<char*>(&_impl_.operation_)) + sizeof(_impl_.is_root_));
    // @@protoc_insertion_point(copy_constructor:feedstore.StreamStructure)
}

inline void StreamStructure::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.content_id_) { nullptr }, decltype(_impl_.parent_id_) { nullptr }, decltype(_impl_.content_info_) { nullptr },
        decltype(_impl_.operation_) { 0 }, decltype(_impl_.type_) { 0 }, decltype(_impl_.is_root_) { false }, /*decltype(_impl_._cached_size_)*/ {} };
}

StreamStructure::~StreamStructure()
{
    // @@protoc_insertion_point(destructor:feedstore.StreamStructure)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StreamStructure::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.content_id_;
    if (this != internal_default_instance())
        delete _impl_.parent_id_;
    if (this != internal_default_instance())
        delete _impl_.content_info_;
}

void StreamStructure::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StreamStructure::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.StreamStructure)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.content_id_ != nullptr) {
        delete _impl_.content_id_;
    }
    _impl_.content_id_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.parent_id_ != nullptr) {
        delete _impl_.parent_id_;
    }
    _impl_.parent_id_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.content_info_ != nullptr) {
        delete _impl_.content_info_;
    }
    _impl_.content_info_ = nullptr;
    ::memset(&_impl_.operation_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.is_root_) - reinterpret_cast<char*>(&_impl_.operation_)) + sizeof(_impl_.is_root_));
    _internal_metadata_.Clear<std::string>();
}

const char* StreamStructure::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedstore.StreamStructure.Operation operation = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_operation(static_cast<::feedstore::StreamStructure_Operation>(val));
            } else
                goto handle_unusual;
            continue;
        // .feedwire.ContentId content_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_content_id(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedwire.ContentId parent_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_parent_id(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.StreamStructure.Type type = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_type(static_cast<::feedstore::StreamStructure_Type>(val));
            } else
                goto handle_unusual;
            continue;
        // .feedstore.ContentInfo content_info = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_content_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool is_root = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
                _impl_.is_root_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StreamStructure::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.StreamStructure)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedstore.StreamStructure.Operation operation = 1;
    if (this->_internal_operation() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_operation(), target);
    }

    // .feedwire.ContentId content_id = 2;
    if (this->_internal_has_content_id()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::content_id(this), _Internal::content_id(this).GetCachedSize(), target, stream);
    }

    // .feedwire.ContentId parent_id = 3;
    if (this->_internal_has_parent_id()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::parent_id(this), _Internal::parent_id(this).GetCachedSize(), target, stream);
    }

    // .feedstore.StreamStructure.Type type = 4;
    if (this->_internal_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_type(), target);
    }

    // .feedstore.ContentInfo content_info = 5;
    if (this->_internal_has_content_info()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::content_info(this), _Internal::content_info(this).GetCachedSize(), target, stream);
    }

    // bool is_root = 6;
    if (this->_internal_is_root() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_root(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.StreamStructure)
    return target;
}

size_t StreamStructure::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.StreamStructure)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .feedwire.ContentId content_id = 2;
    if (this->_internal_has_content_id()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.content_id_);
    }

    // .feedwire.ContentId parent_id = 3;
    if (this->_internal_has_parent_id()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.parent_id_);
    }

    // .feedstore.ContentInfo content_info = 5;
    if (this->_internal_has_content_info()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.content_info_);
    }

    // .feedstore.StreamStructure.Operation operation = 1;
    if (this->_internal_operation() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_operation());
    }

    // .feedstore.StreamStructure.Type type = 4;
    if (this->_internal_type() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // bool is_root = 6;
    if (this->_internal_is_root() != 0) {
        total_size += 1 + 1;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StreamStructure::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StreamStructure*>(&from));
}

void StreamStructure::MergeFrom(const StreamStructure& from)
{
    StreamStructure* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.StreamStructure)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_content_id()) {
        _this->_internal_mutable_content_id()->::feedwire::ContentId::MergeFrom(from._internal_content_id());
    }
    if (from._internal_has_parent_id()) {
        _this->_internal_mutable_parent_id()->::feedwire::ContentId::MergeFrom(from._internal_parent_id());
    }
    if (from._internal_has_content_info()) {
        _this->_internal_mutable_content_info()->::feedstore::ContentInfo::MergeFrom(from._internal_content_info());
    }
    if (from._internal_operation() != 0) {
        _this->_internal_set_operation(from._internal_operation());
    }
    if (from._internal_type() != 0) {
        _this->_internal_set_type(from._internal_type());
    }
    if (from._internal_is_root() != 0) {
        _this->_internal_set_is_root(from._internal_is_root());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamStructure::CopyFrom(const StreamStructure& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.StreamStructure)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StreamStructure::IsInitialized() const
{
    return true;
}

void StreamStructure::InternalSwap(StreamStructure* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(StreamStructure, _impl_.is_root_) + sizeof(StreamStructure::_impl_.is_root_)
        - PROTOBUF_FIELD_OFFSET(StreamStructure, _impl_.content_id_)>(
        reinterpret_cast<char*>(&_impl_.content_id_), reinterpret_cast<char*>(&other->_impl_.content_id_));
}

std::string StreamStructure::GetTypeName() const
{
    return "feedstore.StreamStructure";
}

// ===================================================================

class DataOperation::_Internal {
public:
    static const ::feedstore::StreamStructure& structure(const DataOperation* msg);
    static const ::feedstore::Content& content(const DataOperation* msg);
};

const ::feedstore::StreamStructure& DataOperation::_Internal::structure(const DataOperation* msg)
{
    return *msg->_impl_.structure_;
}
const ::feedstore::Content& DataOperation::_Internal::content(const DataOperation* msg)
{
    return *msg->_impl_.content_;
}
DataOperation::DataOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.DataOperation)
}
DataOperation::DataOperation(const DataOperation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DataOperation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.structure_) { nullptr }, decltype(_impl_.content_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_structure()) {
        _this->_impl_.structure_ = new ::feedstore::StreamStructure(*from._impl_.structure_);
    }
    if (from._internal_has_content()) {
        _this->_impl_.content_ = new ::feedstore::Content(*from._impl_.content_);
    }
    // @@protoc_insertion_point(copy_constructor:feedstore.DataOperation)
}

inline void DataOperation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.structure_) { nullptr }, decltype(_impl_.content_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

DataOperation::~DataOperation()
{
    // @@protoc_insertion_point(destructor:feedstore.DataOperation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DataOperation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.structure_;
    if (this != internal_default_instance())
        delete _impl_.content_;
}

void DataOperation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DataOperation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.DataOperation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.structure_ != nullptr) {
        delete _impl_.structure_;
    }
    _impl_.structure_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.content_ != nullptr) {
        delete _impl_.content_;
    }
    _impl_.content_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* DataOperation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedstore.StreamStructure structure = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_structure(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.Content content = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_content(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DataOperation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.DataOperation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedstore.StreamStructure structure = 1;
    if (this->_internal_has_structure()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::structure(this), _Internal::structure(this).GetCachedSize(), target, stream);
    }

    // .feedstore.Content content = 2;
    if (this->_internal_has_content()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::content(this), _Internal::content(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.DataOperation)
    return target;
}

size_t DataOperation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.DataOperation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .feedstore.StreamStructure structure = 1;
    if (this->_internal_has_structure()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.structure_);
    }

    // .feedstore.Content content = 2;
    if (this->_internal_has_content()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.content_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DataOperation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DataOperation*>(&from));
}

void DataOperation::MergeFrom(const DataOperation& from)
{
    DataOperation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.DataOperation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_structure()) {
        _this->_internal_mutable_structure()->::feedstore::StreamStructure::MergeFrom(from._internal_structure());
    }
    if (from._internal_has_content()) {
        _this->_internal_mutable_content()->::feedstore::Content::MergeFrom(from._internal_content());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DataOperation::CopyFrom(const DataOperation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.DataOperation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DataOperation::IsInitialized() const
{
    return true;
}

void DataOperation::InternalSwap(DataOperation* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DataOperation, _impl_.content_) + sizeof(DataOperation::_impl_.content_)
        - PROTOBUF_FIELD_OFFSET(DataOperation, _impl_.structure_)>(
        reinterpret_cast<char*>(&_impl_.structure_), reinterpret_cast<char*>(&other->_impl_.structure_));
}

std::string DataOperation::GetTypeName() const
{
    return "feedstore.DataOperation";
}

// ===================================================================

class ContentInfo::_Internal {
public:
};

ContentInfo::ContentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.ContentInfo)
}
ContentInfo::ContentInfo(const ContentInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ContentInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.availability_time_seconds_) {}, decltype(_impl_.score_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.availability_time_seconds_, &from._impl_.availability_time_seconds_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.score_) - reinterpret_cast<char*>(&_impl_.availability_time_seconds_)) + sizeof(_impl_.score_));
    // @@protoc_insertion_point(copy_constructor:feedstore.ContentInfo)
}

inline void ContentInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.availability_time_seconds_) { int64_t { 0 } }, decltype(_impl_.score_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

ContentInfo::~ContentInfo()
{
    // @@protoc_insertion_point(destructor:feedstore.ContentInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ContentInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ContentInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ContentInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.ContentInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    ::memset(&_impl_.availability_time_seconds_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.score_) - reinterpret_cast<char*>(&_impl_.availability_time_seconds_)) + sizeof(_impl_.score_));
    _internal_metadata_.Clear<std::string>();
}

const char* ContentInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // float score = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _impl_.score_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // int64 availability_time_seconds = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.availability_time_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ContentInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.ContentInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // float score = 1;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_score = this->_internal_score();
    uint32_t raw_score;
    memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
    if (raw_score != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_score(), target);
    }

    // int64 availability_time_seconds = 2;
    if (this->_internal_availability_time_seconds() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_availability_time_seconds(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.ContentInfo)
    return target;
}

size_t ContentInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.ContentInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // int64 availability_time_seconds = 2;
    if (this->_internal_availability_time_seconds() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_availability_time_seconds());
    }

    // float score = 1;
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_score = this->_internal_score();
    uint32_t raw_score;
    memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
    if (raw_score != 0) {
        total_size += 1 + 4;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ContentInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ContentInfo*>(&from));
}

void ContentInfo::MergeFrom(const ContentInfo& from)
{
    ContentInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.ContentInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_availability_time_seconds() != 0) {
        _this->_internal_set_availability_time_seconds(from._internal_availability_time_seconds());
    }
    static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
    float tmp_score = from._internal_score();
    uint32_t raw_score;
    memcpy(&raw_score, &tmp_score, sizeof(tmp_score));
    if (raw_score != 0) {
        _this->_internal_set_score(from._internal_score());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ContentInfo::CopyFrom(const ContentInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.ContentInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ContentInfo::IsInitialized() const
{
    return true;
}

void ContentInfo::InternalSwap(ContentInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(ContentInfo, _impl_.score_) + sizeof(ContentInfo::_impl_.score_)
        - PROTOBUF_FIELD_OFFSET(ContentInfo, _impl_.availability_time_seconds_)>(
        reinterpret_cast<char*>(&_impl_.availability_time_seconds_), reinterpret_cast<char*>(&other->_impl_.availability_time_seconds_));
}

std::string ContentInfo::GetTypeName() const
{
    return "feedstore.ContentInfo";
}

// ===================================================================

class Content::_Internal {
public:
    static const ::feedwire::ContentId& content_id(const Content* msg);
};

const ::feedwire::ContentId& Content::_Internal::content_id(const Content* msg)
{
    return *msg->_impl_.content_id_;
}
void Content::clear_content_id()
{
    if (GetArenaForAllocation() == nullptr && _impl_.content_id_ != nullptr) {
        delete _impl_.content_id_;
    }
    _impl_.content_id_ = nullptr;
}
void Content::clear_prefetch_metadata()
{
    _impl_.prefetch_metadata_.Clear();
}
Content::Content(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.Content)
}
Content::Content(const Content& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Content* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.prefetch_metadata_) { from._impl_.prefetch_metadata_ }, decltype(_impl_.frame_) {}, decltype(_impl_.stream_key_) {},
        decltype(_impl_.content_id_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.frame_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_frame().empty()) {
        _this->_impl_.frame_.Set(from._internal_frame(), _this->GetArenaForAllocation());
    }
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_stream_key().empty()) {
        _this->_impl_.stream_key_.Set(from._internal_stream_key(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_content_id()) {
        _this->_impl_.content_id_ = new ::feedwire::ContentId(*from._impl_.content_id_);
    }
    // @@protoc_insertion_point(copy_constructor:feedstore.Content)
}

inline void Content::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.prefetch_metadata_) { arena }, decltype(_impl_.frame_) {}, decltype(_impl_.stream_key_) {},
        decltype(_impl_.content_id_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.frame_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.frame_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Content::~Content()
{
    // @@protoc_insertion_point(destructor:feedstore.Content)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Content::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.prefetch_metadata_.~RepeatedPtrField();
    _impl_.frame_.Destroy();
    _impl_.stream_key_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.content_id_;
}

void Content::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Content::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.Content)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.prefetch_metadata_.Clear();
    _impl_.frame_.ClearToEmpty();
    _impl_.stream_key_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.content_id_ != nullptr) {
        delete _impl_.content_id_;
    }
    _impl_.content_id_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* Content::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedwire.ContentId content_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_content_id(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes frame = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_frame();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .feedwire.PrefetchMetadata prefetch_metadata = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_prefetch_metadata(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        // string stream_key = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_stream_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Content::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.Content)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedwire.ContentId content_id = 1;
    if (this->_internal_has_content_id()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::content_id(this), _Internal::content_id(this).GetCachedSize(), target, stream);
    }

    // bytes frame = 2;
    if (!this->_internal_frame().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_frame(), target);
    }

    // repeated .feedwire.PrefetchMetadata prefetch_metadata = 3;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_prefetch_metadata_size()); i < n; i++) {
        const auto& repfield = this->_internal_prefetch_metadata(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
    }

    // string stream_key = 4;
    if (!this->_internal_stream_key().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_stream_key().data(),
            static_cast<int>(this->_internal_stream_key().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.Content.stream_key");
        target = stream->WriteStringMaybeAliased(4, this->_internal_stream_key(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.Content)
    return target;
}

size_t Content::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.Content)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedwire.PrefetchMetadata prefetch_metadata = 3;
    total_size += 1UL * this->_internal_prefetch_metadata_size();
    for (const auto& msg : this->_impl_.prefetch_metadata_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // bytes frame = 2;
    if (!this->_internal_frame().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_frame());
    }

    // string stream_key = 4;
    if (!this->_internal_stream_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_stream_key());
    }

    // .feedwire.ContentId content_id = 1;
    if (this->_internal_has_content_id()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.content_id_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Content::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Content*>(&from));
}

void Content::MergeFrom(const Content& from)
{
    Content* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.Content)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.prefetch_metadata_.MergeFrom(from._impl_.prefetch_metadata_);
    if (!from._internal_frame().empty()) {
        _this->_internal_set_frame(from._internal_frame());
    }
    if (!from._internal_stream_key().empty()) {
        _this->_internal_set_stream_key(from._internal_stream_key());
    }
    if (from._internal_has_content_id()) {
        _this->_internal_mutable_content_id()->::feedwire::ContentId::MergeFrom(from._internal_content_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Content::CopyFrom(const Content& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.Content)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Content::IsInitialized() const
{
    return true;
}

void Content::InternalSwap(Content* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.prefetch_metadata_.InternalSwap(&other->_impl_.prefetch_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.frame_, lhs_arena, &other->_impl_.frame_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.stream_key_, lhs_arena, &other->_impl_.stream_key_, rhs_arena);
    swap(_impl_.content_id_, other->_impl_.content_id_);
}

std::string Content::GetTypeName() const
{
    return "feedstore.Content";
}

// ===================================================================

class StreamSharedState::_Internal {
public:
    static const ::feedwire::ContentId& content_id(const StreamSharedState* msg);
};

const ::feedwire::ContentId& StreamSharedState::_Internal::content_id(const StreamSharedState* msg)
{
    return *msg->_impl_.content_id_;
}
void StreamSharedState::clear_content_id()
{
    if (GetArenaForAllocation() == nullptr && _impl_.content_id_ != nullptr) {
        delete _impl_.content_id_;
    }
    _impl_.content_id_ = nullptr;
}
StreamSharedState::StreamSharedState(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.StreamSharedState)
}
StreamSharedState::StreamSharedState(const StreamSharedState& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StreamSharedState* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.shared_state_data_) {}, decltype(_impl_.stream_key_) {}, decltype(_impl_.content_id_) { nullptr },
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.shared_state_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shared_state_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_shared_state_data().empty()) {
        _this->_impl_.shared_state_data_.Set(from._internal_shared_state_data(), _this->GetArenaForAllocation());
    }
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_stream_key().empty()) {
        _this->_impl_.stream_key_.Set(from._internal_stream_key(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_content_id()) {
        _this->_impl_.content_id_ = new ::feedwire::ContentId(*from._impl_.content_id_);
    }
    // @@protoc_insertion_point(copy_constructor:feedstore.StreamSharedState)
}

inline void StreamSharedState::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.shared_state_data_) {}, decltype(_impl_.stream_key_) {}, decltype(_impl_.content_id_) { nullptr },
        /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.shared_state_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.shared_state_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.stream_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

StreamSharedState::~StreamSharedState()
{
    // @@protoc_insertion_point(destructor:feedstore.StreamSharedState)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StreamSharedState::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.shared_state_data_.Destroy();
    _impl_.stream_key_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.content_id_;
}

void StreamSharedState::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StreamSharedState::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.StreamSharedState)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.shared_state_data_.ClearToEmpty();
    _impl_.stream_key_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.content_id_ != nullptr) {
        delete _impl_.content_id_;
    }
    _impl_.content_id_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* StreamSharedState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .feedwire.ContentId content_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_content_id(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes shared_state_data = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_shared_state_data();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string stream_key = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_stream_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StreamSharedState::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.StreamSharedState)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .feedwire.ContentId content_id = 1;
    if (this->_internal_has_content_id()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::content_id(this), _Internal::content_id(this).GetCachedSize(), target, stream);
    }

    // bytes shared_state_data = 2;
    if (!this->_internal_shared_state_data().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_shared_state_data(), target);
    }

    // string stream_key = 3;
    if (!this->_internal_stream_key().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_stream_key().data(),
            static_cast<int>(this->_internal_stream_key().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.StreamSharedState.stream_key");
        target = stream->WriteStringMaybeAliased(3, this->_internal_stream_key(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.StreamSharedState)
    return target;
}

size_t StreamSharedState::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.StreamSharedState)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bytes shared_state_data = 2;
    if (!this->_internal_shared_state_data().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_shared_state_data());
    }

    // string stream_key = 3;
    if (!this->_internal_stream_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_stream_key());
    }

    // .feedwire.ContentId content_id = 1;
    if (this->_internal_has_content_id()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.content_id_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StreamSharedState::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StreamSharedState*>(&from));
}

void StreamSharedState::MergeFrom(const StreamSharedState& from)
{
    StreamSharedState* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.StreamSharedState)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_shared_state_data().empty()) {
        _this->_internal_set_shared_state_data(from._internal_shared_state_data());
    }
    if (!from._internal_stream_key().empty()) {
        _this->_internal_set_stream_key(from._internal_stream_key());
    }
    if (from._internal_has_content_id()) {
        _this->_internal_mutable_content_id()->::feedwire::ContentId::MergeFrom(from._internal_content_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StreamSharedState::CopyFrom(const StreamSharedState& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.StreamSharedState)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StreamSharedState::IsInitialized() const
{
    return true;
}

void StreamSharedState::InternalSwap(StreamSharedState* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.shared_state_data_, lhs_arena, &other->_impl_.shared_state_data_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.stream_key_, lhs_arena, &other->_impl_.stream_key_, rhs_arena);
    swap(_impl_.content_id_, other->_impl_.content_id_);
}

std::string StreamSharedState::GetTypeName() const
{
    return "feedstore.StreamSharedState";
}

// ===================================================================

class StoredAction::_Internal {
public:
    static const ::feedwire::FeedAction& action(const StoredAction* msg);
};

const ::feedwire::FeedAction& StoredAction::_Internal::action(const StoredAction* msg)
{
    return *msg->_impl_.action_;
}
void StoredAction::clear_action()
{
    if (GetArenaForAllocation() == nullptr && _impl_.action_ != nullptr) {
        delete _impl_.action_;
    }
    _impl_.action_ = nullptr;
}
StoredAction::StoredAction(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.StoredAction)
}
StoredAction::StoredAction(const StoredAction& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StoredAction* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.action_) { nullptr }, decltype(_impl_.id_) {}, decltype(_impl_.upload_attempt_count_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_action()) {
        _this->_impl_.action_ = new ::feedwire::FeedAction(*from._impl_.action_);
    }
    ::memcpy(&_impl_.id_, &from._impl_.id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upload_attempt_count_) - reinterpret_cast<char*>(&_impl_.id_))
            + sizeof(_impl_.upload_attempt_count_));
    // @@protoc_insertion_point(copy_constructor:feedstore.StoredAction)
}

inline void StoredAction::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.action_) { nullptr }, decltype(_impl_.id_) { 0 }, decltype(_impl_.upload_attempt_count_) { 0 },
        /*decltype(_impl_._cached_size_)*/ {} };
}

StoredAction::~StoredAction()
{
    // @@protoc_insertion_point(destructor:feedstore.StoredAction)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StoredAction::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.action_;
}

void StoredAction::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StoredAction::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.StoredAction)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.action_ != nullptr) {
        delete _impl_.action_;
    }
    _impl_.action_ = nullptr;
    ::memset(&_impl_.id_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.upload_attempt_count_) - reinterpret_cast<char*>(&_impl_.id_))
            + sizeof(_impl_.upload_attempt_count_));
    _internal_metadata_.Clear<std::string>();
}

const char* StoredAction::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int32 id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int32 upload_attempt_count = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.upload_attempt_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedwire.FeedAction action = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_action(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StoredAction::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.StoredAction)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int32 id = 1;
    if (this->_internal_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
    }

    // int32 upload_attempt_count = 2;
    if (this->_internal_upload_attempt_count() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_upload_attempt_count(), target);
    }

    // .feedwire.FeedAction action = 3;
    if (this->_internal_has_action()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::action(this), _Internal::action(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.StoredAction)
    return target;
}

size_t StoredAction::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.StoredAction)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .feedwire.FeedAction action = 3;
    if (this->_internal_has_action()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.action_);
    }

    // int32 id = 1;
    if (this->_internal_id() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

    // int32 upload_attempt_count = 2;
    if (this->_internal_upload_attempt_count() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_upload_attempt_count());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StoredAction::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StoredAction*>(&from));
}

void StoredAction::MergeFrom(const StoredAction& from)
{
    StoredAction* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.StoredAction)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_action()) {
        _this->_internal_mutable_action()->::feedwire::FeedAction::MergeFrom(from._internal_action());
    }
    if (from._internal_id() != 0) {
        _this->_internal_set_id(from._internal_id());
    }
    if (from._internal_upload_attempt_count() != 0) {
        _this->_internal_set_upload_attempt_count(from._internal_upload_attempt_count());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StoredAction::CopyFrom(const StoredAction& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.StoredAction)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StoredAction::IsInitialized() const
{
    return true;
}

void StoredAction::InternalSwap(StoredAction* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(StoredAction, _impl_.upload_attempt_count_)
        + sizeof(StoredAction::_impl_.upload_attempt_count_) - PROTOBUF_FIELD_OFFSET(StoredAction, _impl_.action_)>(
        reinterpret_cast<char*>(&_impl_.action_), reinterpret_cast<char*>(&other->_impl_.action_));
}

std::string StoredAction::GetTypeName() const
{
    return "feedstore.StoredAction";
}

// ===================================================================

class SubscribedWebFeeds::_Internal {
public:
};

SubscribedWebFeeds::SubscribedWebFeeds(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.SubscribedWebFeeds)
}
SubscribedWebFeeds::SubscribedWebFeeds(const SubscribedWebFeeds& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SubscribedWebFeeds* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.feeds_) { from._impl_.feeds_ }, decltype(_impl_.update_time_millis_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.update_time_millis_ = from._impl_.update_time_millis_;
    // @@protoc_insertion_point(copy_constructor:feedstore.SubscribedWebFeeds)
}

inline void SubscribedWebFeeds::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.feeds_) { arena }, decltype(_impl_.update_time_millis_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
}

SubscribedWebFeeds::~SubscribedWebFeeds()
{
    // @@protoc_insertion_point(destructor:feedstore.SubscribedWebFeeds)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SubscribedWebFeeds::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.feeds_.~RepeatedPtrField();
}

void SubscribedWebFeeds::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SubscribedWebFeeds::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.SubscribedWebFeeds)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.feeds_.Clear();
    _impl_.update_time_millis_ = int64_t { 0 };
    _internal_metadata_.Clear<std::string>();
}

const char* SubscribedWebFeeds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .feedstore.WebFeedInfo feeds = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_feeds(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // int64 update_time_millis = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.update_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SubscribedWebFeeds::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.SubscribedWebFeeds)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .feedstore.WebFeedInfo feeds = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_feeds_size()); i < n; i++) {
        const auto& repfield = this->_internal_feeds(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // int64 update_time_millis = 2;
    if (this->_internal_update_time_millis() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_update_time_millis(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.SubscribedWebFeeds)
    return target;
}

size_t SubscribedWebFeeds::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.SubscribedWebFeeds)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedstore.WebFeedInfo feeds = 1;
    total_size += 1UL * this->_internal_feeds_size();
    for (const auto& msg : this->_impl_.feeds_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // int64 update_time_millis = 2;
    if (this->_internal_update_time_millis() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_update_time_millis());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SubscribedWebFeeds::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SubscribedWebFeeds*>(&from));
}

void SubscribedWebFeeds::MergeFrom(const SubscribedWebFeeds& from)
{
    SubscribedWebFeeds* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.SubscribedWebFeeds)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.feeds_.MergeFrom(from._impl_.feeds_);
    if (from._internal_update_time_millis() != 0) {
        _this->_internal_set_update_time_millis(from._internal_update_time_millis());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SubscribedWebFeeds::CopyFrom(const SubscribedWebFeeds& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.SubscribedWebFeeds)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SubscribedWebFeeds::IsInitialized() const
{
    return true;
}

void SubscribedWebFeeds::InternalSwap(SubscribedWebFeeds* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.feeds_.InternalSwap(&other->_impl_.feeds_);
    swap(_impl_.update_time_millis_, other->_impl_.update_time_millis_);
}

std::string SubscribedWebFeeds::GetTypeName() const
{
    return "feedstore.SubscribedWebFeeds";
}

// ===================================================================

class RecommendedWebFeedIndex_Entry::_Internal {
public:
};

void RecommendedWebFeedIndex_Entry::clear_matchers()
{
    _impl_.matchers_.Clear();
}
RecommendedWebFeedIndex_Entry::RecommendedWebFeedIndex_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.RecommendedWebFeedIndex.Entry)
}
RecommendedWebFeedIndex_Entry::RecommendedWebFeedIndex_Entry(const RecommendedWebFeedIndex_Entry& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RecommendedWebFeedIndex_Entry* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.matchers_) { from._impl_.matchers_ }, decltype(_impl_.web_feed_id_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.web_feed_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.web_feed_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_web_feed_id().empty()) {
        _this->_impl_.web_feed_id_.Set(from._internal_web_feed_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:feedstore.RecommendedWebFeedIndex.Entry)
}

inline void RecommendedWebFeedIndex_Entry::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.matchers_) { arena }, decltype(_impl_.web_feed_id_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.web_feed_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.web_feed_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RecommendedWebFeedIndex_Entry::~RecommendedWebFeedIndex_Entry()
{
    // @@protoc_insertion_point(destructor:feedstore.RecommendedWebFeedIndex.Entry)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RecommendedWebFeedIndex_Entry::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.matchers_.~RepeatedPtrField();
    _impl_.web_feed_id_.Destroy();
}

void RecommendedWebFeedIndex_Entry::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RecommendedWebFeedIndex_Entry::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.RecommendedWebFeedIndex.Entry)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.matchers_.Clear();
    _impl_.web_feed_id_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* RecommendedWebFeedIndex_Entry::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string web_feed_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_web_feed_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .feedwire.webfeed.WebFeedMatcher matchers = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_matchers(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RecommendedWebFeedIndex_Entry::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.RecommendedWebFeedIndex.Entry)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string web_feed_id = 1;
    if (!this->_internal_web_feed_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_web_feed_id().data(),
            static_cast<int>(this->_internal_web_feed_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.RecommendedWebFeedIndex.Entry.web_feed_id");
        target = stream->WriteStringMaybeAliased(1, this->_internal_web_feed_id(), target);
    }

    // repeated .feedwire.webfeed.WebFeedMatcher matchers = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_matchers_size()); i < n; i++) {
        const auto& repfield = this->_internal_matchers(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.RecommendedWebFeedIndex.Entry)
    return target;
}

size_t RecommendedWebFeedIndex_Entry::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.RecommendedWebFeedIndex.Entry)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedwire.webfeed.WebFeedMatcher matchers = 2;
    total_size += 1UL * this->_internal_matchers_size();
    for (const auto& msg : this->_impl_.matchers_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string web_feed_id = 1;
    if (!this->_internal_web_feed_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_web_feed_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RecommendedWebFeedIndex_Entry::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RecommendedWebFeedIndex_Entry*>(&from));
}

void RecommendedWebFeedIndex_Entry::MergeFrom(const RecommendedWebFeedIndex_Entry& from)
{
    RecommendedWebFeedIndex_Entry* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.RecommendedWebFeedIndex.Entry)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.matchers_.MergeFrom(from._impl_.matchers_);
    if (!from._internal_web_feed_id().empty()) {
        _this->_internal_set_web_feed_id(from._internal_web_feed_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RecommendedWebFeedIndex_Entry::CopyFrom(const RecommendedWebFeedIndex_Entry& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.RecommendedWebFeedIndex.Entry)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RecommendedWebFeedIndex_Entry::IsInitialized() const
{
    return true;
}

void RecommendedWebFeedIndex_Entry::InternalSwap(RecommendedWebFeedIndex_Entry* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.matchers_.InternalSwap(&other->_impl_.matchers_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.web_feed_id_, lhs_arena, &other->_impl_.web_feed_id_, rhs_arena);
}

std::string RecommendedWebFeedIndex_Entry::GetTypeName() const
{
    return "feedstore.RecommendedWebFeedIndex.Entry";
}

// ===================================================================

class RecommendedWebFeedIndex::_Internal {
public:
};

RecommendedWebFeedIndex::RecommendedWebFeedIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.RecommendedWebFeedIndex)
}
RecommendedWebFeedIndex::RecommendedWebFeedIndex(const RecommendedWebFeedIndex& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    RecommendedWebFeedIndex* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.entries_) { from._impl_.entries_ }, decltype(_impl_.update_time_millis_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.update_time_millis_ = from._impl_.update_time_millis_;
    // @@protoc_insertion_point(copy_constructor:feedstore.RecommendedWebFeedIndex)
}

inline void RecommendedWebFeedIndex::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.entries_) { arena }, decltype(_impl_.update_time_millis_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
}

RecommendedWebFeedIndex::~RecommendedWebFeedIndex()
{
    // @@protoc_insertion_point(destructor:feedstore.RecommendedWebFeedIndex)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void RecommendedWebFeedIndex::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.entries_.~RepeatedPtrField();
}

void RecommendedWebFeedIndex::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void RecommendedWebFeedIndex::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.RecommendedWebFeedIndex)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.entries_.Clear();
    _impl_.update_time_millis_ = int64_t { 0 };
    _internal_metadata_.Clear<std::string>();
}

const char* RecommendedWebFeedIndex::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .feedstore.RecommendedWebFeedIndex.Entry entries = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        // int64 update_time_millis = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.update_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* RecommendedWebFeedIndex::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.RecommendedWebFeedIndex)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .feedstore.RecommendedWebFeedIndex.Entry entries = 1;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
        const auto& repfield = this->_internal_entries(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
    }

    // int64 update_time_millis = 2;
    if (this->_internal_update_time_millis() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_update_time_millis(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.RecommendedWebFeedIndex)
    return target;
}

size_t RecommendedWebFeedIndex::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.RecommendedWebFeedIndex)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedstore.RecommendedWebFeedIndex.Entry entries = 1;
    total_size += 1UL * this->_internal_entries_size();
    for (const auto& msg : this->_impl_.entries_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // int64 update_time_millis = 2;
    if (this->_internal_update_time_millis() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_update_time_millis());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void RecommendedWebFeedIndex::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const RecommendedWebFeedIndex*>(&from));
}

void RecommendedWebFeedIndex::MergeFrom(const RecommendedWebFeedIndex& from)
{
    RecommendedWebFeedIndex* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.RecommendedWebFeedIndex)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.entries_.MergeFrom(from._impl_.entries_);
    if (from._internal_update_time_millis() != 0) {
        _this->_internal_set_update_time_millis(from._internal_update_time_millis());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RecommendedWebFeedIndex::CopyFrom(const RecommendedWebFeedIndex& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.RecommendedWebFeedIndex)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool RecommendedWebFeedIndex::IsInitialized() const
{
    return true;
}

void RecommendedWebFeedIndex::InternalSwap(RecommendedWebFeedIndex* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.entries_.InternalSwap(&other->_impl_.entries_);
    swap(_impl_.update_time_millis_, other->_impl_.update_time_millis_);
}

std::string RecommendedWebFeedIndex::GetTypeName() const
{
    return "feedstore.RecommendedWebFeedIndex";
}

// ===================================================================

class Image::_Internal {
public:
};

Image::Image(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.Image)
}
Image::Image(const Image& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    Image* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.url_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_url().empty()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:feedstore.Image)
}

inline void Image::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.url_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Image::~Image()
{
    // @@protoc_insertion_point(destructor:feedstore.Image)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void Image::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.url_.Destroy();
}

void Image::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void Image::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.Image)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.url_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* Image::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string url = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* Image::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.Image)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string url = 1;
    if (!this->_internal_url().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedstore.Image.url");
        target = stream->WriteStringMaybeAliased(1, this->_internal_url(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.Image)
    return target;
}

size_t Image::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.Image)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string url = 1;
    if (!this->_internal_url().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void Image::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const Image*>(&from));
}

void Image::MergeFrom(const Image& from)
{
    Image* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.Image)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_url().empty()) {
        _this->_internal_set_url(from._internal_url());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Image::CopyFrom(const Image& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.Image)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool Image::IsInitialized() const
{
    return true;
}

void Image::InternalSwap(Image* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
}

std::string Image::GetTypeName() const
{
    return "feedstore.Image";
}

// ===================================================================

class WebFeedInfo::_Internal {
public:
    static const ::feedstore::Image& favicon(const WebFeedInfo* msg);
};

const ::feedstore::Image& WebFeedInfo::_Internal::favicon(const WebFeedInfo* msg)
{
    return *msg->_impl_.favicon_;
}
void WebFeedInfo::clear_matchers()
{
    _impl_.matchers_.Clear();
}
WebFeedInfo::WebFeedInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.WebFeedInfo)
}
WebFeedInfo::WebFeedInfo(const WebFeedInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    WebFeedInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.matchers_) { from._impl_.matchers_ }, decltype(_impl_.web_feed_id_) {}, decltype(_impl_.title_) {},
        decltype(_impl_.subtitle_) {}, decltype(_impl_.detail_text_) {}, decltype(_impl_.visit_uri_) {}, decltype(_impl_.rss_uri_) {},
        decltype(_impl_.favicon_) { nullptr }, decltype(_impl_.follower_count_) {}, decltype(_impl_.state_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.web_feed_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.web_feed_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_web_feed_id().empty()) {
        _this->_impl_.web_feed_id_.Set(from._internal_web_feed_id(), _this->GetArenaForAllocation());
    }
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_title().empty()) {
        _this->_impl_.title_.Set(from._internal_title(), _this->GetArenaForAllocation());
    }
    _impl_.subtitle_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subtitle_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_subtitle().empty()) {
        _this->_impl_.subtitle_.Set(from._internal_subtitle(), _this->GetArenaForAllocation());
    }
    _impl_.detail_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.detail_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_detail_text().empty()) {
        _this->_impl_.detail_text_.Set(from._internal_detail_text(), _this->GetArenaForAllocation());
    }
    _impl_.visit_uri_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.visit_uri_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_visit_uri().empty()) {
        _this->_impl_.visit_uri_.Set(from._internal_visit_uri(), _this->GetArenaForAllocation());
    }
    _impl_.rss_uri_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rss_uri_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_rss_uri().empty()) {
        _this->_impl_.rss_uri_.Set(from._internal_rss_uri(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_favicon()) {
        _this->_impl_.favicon_ = new ::feedstore::Image(*from._impl_.favicon_);
    }
    ::memcpy(&_impl_.follower_count_, &from._impl_.follower_count_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) - reinterpret_cast<char*>(&_impl_.follower_count_)) + sizeof(_impl_.state_));
    // @@protoc_insertion_point(copy_constructor:feedstore.WebFeedInfo)
}

inline void WebFeedInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.matchers_) { arena }, decltype(_impl_.web_feed_id_) {}, decltype(_impl_.title_) {}, decltype(_impl_.subtitle_) {},
        decltype(_impl_.detail_text_) {}, decltype(_impl_.visit_uri_) {}, decltype(_impl_.rss_uri_) {}, decltype(_impl_.favicon_) { nullptr },
        decltype(_impl_.follower_count_) { int64_t { 0 } }, decltype(_impl_.state_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.web_feed_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.web_feed_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.title_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subtitle_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.subtitle_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.detail_text_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.detail_text_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.visit_uri_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.visit_uri_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rss_uri_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.rss_uri_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

WebFeedInfo::~WebFeedInfo()
{
    // @@protoc_insertion_point(destructor:feedstore.WebFeedInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void WebFeedInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.matchers_.~RepeatedPtrField();
    _impl_.web_feed_id_.Destroy();
    _impl_.title_.Destroy();
    _impl_.subtitle_.Destroy();
    _impl_.detail_text_.Destroy();
    _impl_.visit_uri_.Destroy();
    _impl_.rss_uri_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.favicon_;
}

void WebFeedInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void WebFeedInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.WebFeedInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.matchers_.Clear();
    _impl_.web_feed_id_.ClearToEmpty();
    _impl_.title_.ClearToEmpty();
    _impl_.subtitle_.ClearToEmpty();
    _impl_.detail_text_.ClearToEmpty();
    _impl_.visit_uri_.ClearToEmpty();
    _impl_.rss_uri_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.favicon_ != nullptr) {
        delete _impl_.favicon_;
    }
    _impl_.favicon_ = nullptr;
    ::memset(&_impl_.follower_count_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) - reinterpret_cast<char*>(&_impl_.follower_count_)) + sizeof(_impl_.state_));
    _internal_metadata_.Clear<std::string>();
}

const char* WebFeedInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string web_feed_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_web_feed_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string title = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_title();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string subtitle = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_subtitle();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string detail_text = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_detail_text();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string visit_uri = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_visit_uri();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string rss_uri = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_rss_uri();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .feedstore.Image favicon = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_favicon(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int64 follower_count = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
                _impl_.follower_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.WebFeedInfo.State state = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_state(static_cast<::feedstore::WebFeedInfo_State>(val));
            } else
                goto handle_unusual;
            continue;
        // repeated .feedwire.webfeed.WebFeedMatcher matchers = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_matchers(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* WebFeedInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.WebFeedInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string web_feed_id = 1;
    if (!this->_internal_web_feed_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_web_feed_id().data(),
            static_cast<int>(this->_internal_web_feed_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.WebFeedInfo.web_feed_id");
        target = stream->WriteStringMaybeAliased(1, this->_internal_web_feed_id(), target);
    }

    // string title = 2;
    if (!this->_internal_title().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_title().data(), static_cast<int>(this->_internal_title().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "feedstore.WebFeedInfo.title");
        target = stream->WriteStringMaybeAliased(2, this->_internal_title(), target);
    }

    // string subtitle = 3;
    if (!this->_internal_subtitle().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_subtitle().data(),
            static_cast<int>(this->_internal_subtitle().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.WebFeedInfo.subtitle");
        target = stream->WriteStringMaybeAliased(3, this->_internal_subtitle(), target);
    }

    // string detail_text = 4;
    if (!this->_internal_detail_text().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_detail_text().data(),
            static_cast<int>(this->_internal_detail_text().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.WebFeedInfo.detail_text");
        target = stream->WriteStringMaybeAliased(4, this->_internal_detail_text(), target);
    }

    // string visit_uri = 5;
    if (!this->_internal_visit_uri().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_visit_uri().data(),
            static_cast<int>(this->_internal_visit_uri().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.WebFeedInfo.visit_uri");
        target = stream->WriteStringMaybeAliased(5, this->_internal_visit_uri(), target);
    }

    // string rss_uri = 6;
    if (!this->_internal_rss_uri().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_rss_uri().data(),
            static_cast<int>(this->_internal_rss_uri().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.WebFeedInfo.rss_uri");
        target = stream->WriteStringMaybeAliased(6, this->_internal_rss_uri(), target);
    }

    // .feedstore.Image favicon = 7;
    if (this->_internal_has_favicon()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::favicon(this), _Internal::favicon(this).GetCachedSize(), target, stream);
    }

    // int64 follower_count = 8;
    if (this->_internal_follower_count() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_follower_count(), target);
    }

    // .feedstore.WebFeedInfo.State state = 9;
    if (this->_internal_state() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(9, this->_internal_state(), target);
    }

    // repeated .feedwire.webfeed.WebFeedMatcher matchers = 10;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_matchers_size()); i < n; i++) {
        const auto& repfield = this->_internal_matchers(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(10, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.WebFeedInfo)
    return target;
}

size_t WebFeedInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.WebFeedInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .feedwire.webfeed.WebFeedMatcher matchers = 10;
    total_size += 1UL * this->_internal_matchers_size();
    for (const auto& msg : this->_impl_.matchers_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string web_feed_id = 1;
    if (!this->_internal_web_feed_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_web_feed_id());
    }

    // string title = 2;
    if (!this->_internal_title().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_title());
    }

    // string subtitle = 3;
    if (!this->_internal_subtitle().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_subtitle());
    }

    // string detail_text = 4;
    if (!this->_internal_detail_text().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_detail_text());
    }

    // string visit_uri = 5;
    if (!this->_internal_visit_uri().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_visit_uri());
    }

    // string rss_uri = 6;
    if (!this->_internal_rss_uri().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_rss_uri());
    }

    // .feedstore.Image favicon = 7;
    if (this->_internal_has_favicon()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.favicon_);
    }

    // int64 follower_count = 8;
    if (this->_internal_follower_count() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_follower_count());
    }

    // .feedstore.WebFeedInfo.State state = 9;
    if (this->_internal_state() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void WebFeedInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const WebFeedInfo*>(&from));
}

void WebFeedInfo::MergeFrom(const WebFeedInfo& from)
{
    WebFeedInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.WebFeedInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.matchers_.MergeFrom(from._impl_.matchers_);
    if (!from._internal_web_feed_id().empty()) {
        _this->_internal_set_web_feed_id(from._internal_web_feed_id());
    }
    if (!from._internal_title().empty()) {
        _this->_internal_set_title(from._internal_title());
    }
    if (!from._internal_subtitle().empty()) {
        _this->_internal_set_subtitle(from._internal_subtitle());
    }
    if (!from._internal_detail_text().empty()) {
        _this->_internal_set_detail_text(from._internal_detail_text());
    }
    if (!from._internal_visit_uri().empty()) {
        _this->_internal_set_visit_uri(from._internal_visit_uri());
    }
    if (!from._internal_rss_uri().empty()) {
        _this->_internal_set_rss_uri(from._internal_rss_uri());
    }
    if (from._internal_has_favicon()) {
        _this->_internal_mutable_favicon()->::feedstore::Image::MergeFrom(from._internal_favicon());
    }
    if (from._internal_follower_count() != 0) {
        _this->_internal_set_follower_count(from._internal_follower_count());
    }
    if (from._internal_state() != 0) {
        _this->_internal_set_state(from._internal_state());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WebFeedInfo::CopyFrom(const WebFeedInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.WebFeedInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool WebFeedInfo::IsInitialized() const
{
    return true;
}

void WebFeedInfo::InternalSwap(WebFeedInfo* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.matchers_.InternalSwap(&other->_impl_.matchers_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.web_feed_id_, lhs_arena, &other->_impl_.web_feed_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.title_, lhs_arena, &other->_impl_.title_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.subtitle_, lhs_arena, &other->_impl_.subtitle_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.detail_text_, lhs_arena, &other->_impl_.detail_text_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.visit_uri_, lhs_arena, &other->_impl_.visit_uri_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.rss_uri_, lhs_arena, &other->_impl_.rss_uri_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(WebFeedInfo, _impl_.state_) + sizeof(WebFeedInfo::_impl_.state_)
        - PROTOBUF_FIELD_OFFSET(WebFeedInfo, _impl_.favicon_)>(reinterpret_cast<char*>(&_impl_.favicon_), reinterpret_cast<char*>(&other->_impl_.favicon_));
}

std::string WebFeedInfo::GetTypeName() const
{
    return "feedstore.WebFeedInfo";
}

// ===================================================================

class PendingWebFeedOperation::_Internal {
public:
};

PendingWebFeedOperation::PendingWebFeedOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.PendingWebFeedOperation)
}
PendingWebFeedOperation::PendingWebFeedOperation(const PendingWebFeedOperation& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PendingWebFeedOperation* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.web_feed_id_) {}, decltype(_impl_.id_) {}, decltype(_impl_.kind_) {}, decltype(_impl_.attempts_) {},
        decltype(_impl_.change_reason_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.web_feed_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.web_feed_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_web_feed_id().empty()) {
        _this->_impl_.web_feed_id_.Set(from._internal_web_feed_id(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.id_, &from._impl_.id_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.change_reason_) - reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.change_reason_));
    // @@protoc_insertion_point(copy_constructor:feedstore.PendingWebFeedOperation)
}

inline void PendingWebFeedOperation::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.web_feed_id_) {}, decltype(_impl_.id_) { int64_t { 0 } }, decltype(_impl_.kind_) { 0 },
        decltype(_impl_.attempts_) { 0 }, decltype(_impl_.change_reason_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.web_feed_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.web_feed_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PendingWebFeedOperation::~PendingWebFeedOperation()
{
    // @@protoc_insertion_point(destructor:feedstore.PendingWebFeedOperation)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PendingWebFeedOperation::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.web_feed_id_.Destroy();
}

void PendingWebFeedOperation::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PendingWebFeedOperation::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.PendingWebFeedOperation)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.web_feed_id_.ClearToEmpty();
    ::memset(&_impl_.id_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.change_reason_) - reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.change_reason_));
    _internal_metadata_.Clear<std::string>();
}

const char* PendingWebFeedOperation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int64 id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedstore.PendingWebFeedOperation.Kind kind = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_kind(static_cast<::feedstore::PendingWebFeedOperation_Kind>(val));
            } else
                goto handle_unusual;
            continue;
        // string web_feed_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_web_feed_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // int32 attempts = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.attempts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .feedwire.webfeed.WebFeedChangeReason change_reason = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_change_reason(static_cast<::feedwire::webfeed::WebFeedChangeReason>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PendingWebFeedOperation::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.PendingWebFeedOperation)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int64 id = 1;
    if (this->_internal_id() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_id(), target);
    }

    // .feedstore.PendingWebFeedOperation.Kind kind = 2;
    if (this->_internal_kind() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_kind(), target);
    }

    // string web_feed_id = 3;
    if (!this->_internal_web_feed_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_web_feed_id().data(),
            static_cast<int>(this->_internal_web_feed_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "feedstore.PendingWebFeedOperation.web_feed_id");
        target = stream->WriteStringMaybeAliased(3, this->_internal_web_feed_id(), target);
    }

    // int32 attempts = 4;
    if (this->_internal_attempts() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_attempts(), target);
    }

    // .feedwire.webfeed.WebFeedChangeReason change_reason = 5;
    if (this->_internal_change_reason() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_change_reason(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.PendingWebFeedOperation)
    return target;
}

size_t PendingWebFeedOperation::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.PendingWebFeedOperation)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string web_feed_id = 3;
    if (!this->_internal_web_feed_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_web_feed_id());
    }

    // int64 id = 1;
    if (this->_internal_id() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_id());
    }

    // .feedstore.PendingWebFeedOperation.Kind kind = 2;
    if (this->_internal_kind() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_kind());
    }

    // int32 attempts = 4;
    if (this->_internal_attempts() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_attempts());
    }

    // .feedwire.webfeed.WebFeedChangeReason change_reason = 5;
    if (this->_internal_change_reason() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_change_reason());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PendingWebFeedOperation::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PendingWebFeedOperation*>(&from));
}

void PendingWebFeedOperation::MergeFrom(const PendingWebFeedOperation& from)
{
    PendingWebFeedOperation* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.PendingWebFeedOperation)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_web_feed_id().empty()) {
        _this->_internal_set_web_feed_id(from._internal_web_feed_id());
    }
    if (from._internal_id() != 0) {
        _this->_internal_set_id(from._internal_id());
    }
    if (from._internal_kind() != 0) {
        _this->_internal_set_kind(from._internal_kind());
    }
    if (from._internal_attempts() != 0) {
        _this->_internal_set_attempts(from._internal_attempts());
    }
    if (from._internal_change_reason() != 0) {
        _this->_internal_set_change_reason(from._internal_change_reason());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PendingWebFeedOperation::CopyFrom(const PendingWebFeedOperation& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.PendingWebFeedOperation)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PendingWebFeedOperation::IsInitialized() const
{
    return true;
}

void PendingWebFeedOperation::InternalSwap(PendingWebFeedOperation* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.web_feed_id_, lhs_arena, &other->_impl_.web_feed_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PendingWebFeedOperation, _impl_.change_reason_)
        + sizeof(PendingWebFeedOperation::_impl_.change_reason_) - PROTOBUF_FIELD_OFFSET(PendingWebFeedOperation, _impl_.id_)>(
        reinterpret_cast<char*>(&_impl_.id_), reinterpret_cast<char*>(&other->_impl_.id_));
}

std::string PendingWebFeedOperation::GetTypeName() const
{
    return "feedstore.PendingWebFeedOperation";
}

// ===================================================================

class DocView::_Internal {
public:
};

DocView::DocView(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:feedstore.DocView)
}
DocView::DocView(const DocView& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    DocView* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.docid_) {}, decltype(_impl_.view_time_millis_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.docid_, &from._impl_.docid_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.view_time_millis_) - reinterpret_cast<char*>(&_impl_.docid_)) + sizeof(_impl_.view_time_millis_));
    // @@protoc_insertion_point(copy_constructor:feedstore.DocView)
}

inline void DocView::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_)
        Impl_ { decltype(_impl_.docid_) { uint64_t { 0u } }, decltype(_impl_.view_time_millis_) { int64_t { 0 } }, /*decltype(_impl_._cached_size_)*/ {} };
}

DocView::~DocView()
{
    // @@protoc_insertion_point(destructor:feedstore.DocView)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void DocView::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DocView::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void DocView::Clear()
{
    // @@protoc_insertion_point(message_clear_start:feedstore.DocView)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    ::memset(&_impl_.docid_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.view_time_millis_) - reinterpret_cast<char*>(&_impl_.docid_)) + sizeof(_impl_.view_time_millis_));
    _internal_metadata_.Clear<std::string>();
}

const char* DocView::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // uint64 docid = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.docid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int64 view_time_millis = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.view_time_millis_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* DocView::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:feedstore.DocView)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // uint64 docid = 1;
    if (this->_internal_docid() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_docid(), target);
    }

    // int64 view_time_millis = 4;
    if (this->_internal_view_time_millis() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_view_time_millis(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:feedstore.DocView)
    return target;
}

size_t DocView::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:feedstore.DocView)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // uint64 docid = 1;
    if (this->_internal_docid() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_docid());
    }

    // int64 view_time_millis = 4;
    if (this->_internal_view_time_millis() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_view_time_millis());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void DocView::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const DocView*>(&from));
}

void DocView::MergeFrom(const DocView& from)
{
    DocView* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:feedstore.DocView)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_docid() != 0) {
        _this->_internal_set_docid(from._internal_docid());
    }
    if (from._internal_view_time_millis() != 0) {
        _this->_internal_set_view_time_millis(from._internal_view_time_millis());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DocView::CopyFrom(const DocView& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:feedstore.DocView)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool DocView::IsInitialized() const
{
    return true;
}

void DocView::InternalSwap(DocView* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(DocView, _impl_.view_time_millis_) + sizeof(DocView::_impl_.view_time_millis_)
        - PROTOBUF_FIELD_OFFSET(DocView, _impl_.docid_)>(reinterpret_cast<char*>(&_impl_.docid_), reinterpret_cast<char*>(&other->_impl_.docid_));
}

std::string DocView::GetTypeName() const
{
    return "feedstore.DocView";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace feedstore
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::feedstore::Record* Arena::CreateMaybeMessage<::feedstore::Record>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::Record>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::StreamContentHashList* Arena::CreateMaybeMessage<::feedstore::StreamContentHashList>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::StreamContentHashList>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::StreamData* Arena::CreateMaybeMessage<::feedstore::StreamData>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::StreamData>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::Metadata_SessionID* Arena::CreateMaybeMessage<::feedstore::Metadata_SessionID>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::Metadata_SessionID>(arena);
}
template <>
PROTOBUF_NOINLINE ::feedstore::Metadata_StreamMetadata_ContentLifetime* Arena::CreateMaybeMessage<::feedstore::Metadata_StreamMetadata_ContentLifetime>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::Metadata_StreamMetadata_ContentLifetime>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::Metadata_StreamMetadata* Arena::CreateMaybeMessage<::feedstore::Metadata_StreamMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::Metadata_StreamMetadata>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::Metadata* Arena::CreateMaybeMessage<::feedstore::Metadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::Metadata>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::StreamStructureSet* Arena::CreateMaybeMessage<::feedstore::StreamStructureSet>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::StreamStructureSet>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::StreamStructure* Arena::CreateMaybeMessage<::feedstore::StreamStructure>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::StreamStructure>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::DataOperation* Arena::CreateMaybeMessage<::feedstore::DataOperation>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::DataOperation>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::ContentInfo* Arena::CreateMaybeMessage<::feedstore::ContentInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::ContentInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::Content* Arena::CreateMaybeMessage<::feedstore::Content>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::Content>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::StreamSharedState* Arena::CreateMaybeMessage<::feedstore::StreamSharedState>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::StreamSharedState>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::StoredAction* Arena::CreateMaybeMessage<::feedstore::StoredAction>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::StoredAction>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::SubscribedWebFeeds* Arena::CreateMaybeMessage<::feedstore::SubscribedWebFeeds>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::SubscribedWebFeeds>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::RecommendedWebFeedIndex_Entry* Arena::CreateMaybeMessage<::feedstore::RecommendedWebFeedIndex_Entry>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::RecommendedWebFeedIndex_Entry>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::RecommendedWebFeedIndex* Arena::CreateMaybeMessage<::feedstore::RecommendedWebFeedIndex>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::RecommendedWebFeedIndex>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::Image* Arena::CreateMaybeMessage<::feedstore::Image>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::Image>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::WebFeedInfo* Arena::CreateMaybeMessage<::feedstore::WebFeedInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::WebFeedInfo>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::PendingWebFeedOperation* Arena::CreateMaybeMessage<::feedstore::PendingWebFeedOperation>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::PendingWebFeedOperation>(arena);
}
template <> PROTOBUF_NOINLINE ::feedstore::DocView* Arena::CreateMaybeMessage<::feedstore::DocView>(Arena* arena)
{
    return Arena::CreateMessageInternal<::feedstore::DocView>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
