// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: certificate_transparency.proto

#include "certificate_transparency.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace chrome_browser_certificate_transparency {
PROTOBUF_CONSTEXPR FinalTreeHead::FinalTreeHead(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.sha256_root_hash_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.tree_size_)*/ uint64_t { 0u }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FinalTreeHeadDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FinalTreeHeadDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FinalTreeHeadDefaultTypeInternal()
    {
    }
    union {
        FinalTreeHead _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FinalTreeHeadDefaultTypeInternal _FinalTreeHead_default_instance_;
PROTOBUF_CONSTEXPR CTLog_Interval::CTLog_Interval(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.start_)*/ nullptr, /*decltype(_impl_.end_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CTLog_IntervalDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CTLog_IntervalDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CTLog_IntervalDefaultTypeInternal()
    {
    }
    union {
        CTLog_Interval _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLog_IntervalDefaultTypeInternal _CTLog_Interval_default_instance_;
PROTOBUF_CONSTEXPR CTLog_State::CTLog_State(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.state_start_)*/ nullptr, /*decltype(_impl_.current_state_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CTLog_StateDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CTLog_StateDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CTLog_StateDefaultTypeInternal()
    {
    }
    union {
        CTLog_State _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLog_StateDefaultTypeInternal _CTLog_State_default_instance_;
PROTOBUF_CONSTEXPR CTLog_OperatorChange::CTLog_OperatorChange(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.operator_start_)*/ nullptr,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CTLog_OperatorChangeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CTLog_OperatorChangeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CTLog_OperatorChangeDefaultTypeInternal()
    {
    }
    union {
        CTLog_OperatorChange _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLog_OperatorChangeDefaultTypeInternal
    _CTLog_OperatorChange_default_instance_;
PROTOBUF_CONSTEXPR CTLog::CTLog(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.state_)*/ {}, /*decltype(_impl_.operator_history_)*/ {},
        /*decltype(_impl_.description_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.key_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.log_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.url_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.temporal_interval_)*/ nullptr,
        /*decltype(_impl_.read_only_info_)*/ nullptr, /*decltype(_impl_.mmd_secs_)*/ uint64_t { 0u }, /*decltype(_impl_.purpose_)*/ 0,
        /*decltype(_impl_.log_type_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CTLogDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CTLogDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CTLogDefaultTypeInternal()
    {
    }
    union {
        CTLog _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLogDefaultTypeInternal _CTLog_default_instance_;
PROTOBUF_CONSTEXPR LogOperator::LogOperator(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.email_)*/ {}, /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct LogOperatorDefaultTypeInternal {
    PROTOBUF_CONSTEXPR LogOperatorDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~LogOperatorDefaultTypeInternal()
    {
    }
    union {
        LogOperator _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LogOperatorDefaultTypeInternal _LogOperator_default_instance_;
PROTOBUF_CONSTEXPR CTLogList::CTLogList(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.operators_)*/ {}, /*decltype(_impl_.logs_)*/ {}, /*decltype(_impl_.timestamp_)*/ nullptr,
        /*decltype(_impl_.list_version_major_)*/ uint64_t { 0u }, /*decltype(_impl_.list_version_minor_)*/ uint64_t { 0u },
        /*decltype(_impl_.compatibility_version_)*/ uint64_t { 0u }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct CTLogListDefaultTypeInternal {
    PROTOBUF_CONSTEXPR CTLogListDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~CTLogListDefaultTypeInternal()
    {
    }
    union {
        CTLogList _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CTLogListDefaultTypeInternal _CTLogList_default_instance_;
} // namespace chrome_browser_certificate_transparency
namespace chrome_browser_certificate_transparency {
bool CTLog_Purpose_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CTLog_Purpose_strings[3] = {};

static const char CTLog_Purpose_names[] = "PROD"
                                          "TEST"
                                          "UNSET_PURPOSE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CTLog_Purpose_entries[] = {
    { { CTLog_Purpose_names + 0, 4 }, 1 },
    { { CTLog_Purpose_names + 4, 4 }, 2 },
    { { CTLog_Purpose_names + 8, 13 }, 0 },
};

static const int CTLog_Purpose_entries_by_number[] = {
    2, // 0 -> UNSET_PURPOSE
    0, // 1 -> PROD
    1, // 2 -> TEST
};

const std::string& CTLog_Purpose_Name(CTLog_Purpose value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(CTLog_Purpose_entries, CTLog_Purpose_entries_by_number, 3, CTLog_Purpose_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(CTLog_Purpose_entries, CTLog_Purpose_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : CTLog_Purpose_strings[idx].get();
}
bool CTLog_Purpose_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CTLog_Purpose* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(CTLog_Purpose_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<CTLog_Purpose>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CTLog_Purpose CTLog::UNSET_PURPOSE;
constexpr CTLog_Purpose CTLog::PROD;
constexpr CTLog_Purpose CTLog::TEST;
constexpr CTLog_Purpose CTLog::Purpose_MIN;
constexpr CTLog_Purpose CTLog::Purpose_MAX;
constexpr int CTLog::Purpose_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CTLog_CurrentState_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CTLog_CurrentState_strings[7] = {};

static const char CTLog_CurrentState_names[] = "PENDING"
                                               "QUALIFIED"
                                               "READ_ONLY"
                                               "REJECTED"
                                               "RETIRED"
                                               "UNSET_STATE"
                                               "USABLE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CTLog_CurrentState_entries[] = {
    { { CTLog_CurrentState_names + 0, 7 }, 1 },
    { { CTLog_CurrentState_names + 7, 9 }, 2 },
    { { CTLog_CurrentState_names + 16, 9 }, 4 },
    { { CTLog_CurrentState_names + 25, 8 }, 6 },
    { { CTLog_CurrentState_names + 33, 7 }, 5 },
    { { CTLog_CurrentState_names + 40, 11 }, 0 },
    { { CTLog_CurrentState_names + 51, 6 }, 3 },
};

static const int CTLog_CurrentState_entries_by_number[] = {
    5, // 0 -> UNSET_STATE
    0, // 1 -> PENDING
    1, // 2 -> QUALIFIED
    6, // 3 -> USABLE
    2, // 4 -> READ_ONLY
    4, // 5 -> RETIRED
    3, // 6 -> REJECTED
};

const std::string& CTLog_CurrentState_Name(CTLog_CurrentState value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        CTLog_CurrentState_entries, CTLog_CurrentState_entries_by_number, 7, CTLog_CurrentState_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(CTLog_CurrentState_entries, CTLog_CurrentState_entries_by_number, 7, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : CTLog_CurrentState_strings[idx].get();
}
bool CTLog_CurrentState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CTLog_CurrentState* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(CTLog_CurrentState_entries, 7, name, &int_value);
    if (success) {
        *value = static_cast<CTLog_CurrentState>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CTLog_CurrentState CTLog::UNSET_STATE;
constexpr CTLog_CurrentState CTLog::PENDING;
constexpr CTLog_CurrentState CTLog::QUALIFIED;
constexpr CTLog_CurrentState CTLog::USABLE;
constexpr CTLog_CurrentState CTLog::READ_ONLY;
constexpr CTLog_CurrentState CTLog::RETIRED;
constexpr CTLog_CurrentState CTLog::REJECTED;
constexpr CTLog_CurrentState CTLog::CurrentState_MIN;
constexpr CTLog_CurrentState CTLog::CurrentState_MAX;
constexpr int CTLog::CurrentState_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CTLog_LogType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CTLog_LogType_strings[3] = {};

static const char CTLog_LogType_names[] = "LOG_TYPE_UNSPECIFIED"
                                          "RFC6962"
                                          "STATIC_CT_API";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CTLog_LogType_entries[] = {
    { { CTLog_LogType_names + 0, 20 }, 0 },
    { { CTLog_LogType_names + 20, 7 }, 1 },
    { { CTLog_LogType_names + 27, 13 }, 2 },
};

static const int CTLog_LogType_entries_by_number[] = {
    0, // 0 -> LOG_TYPE_UNSPECIFIED
    1, // 1 -> RFC6962
    2, // 2 -> STATIC_CT_API
};

const std::string& CTLog_LogType_Name(CTLog_LogType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(CTLog_LogType_entries, CTLog_LogType_entries_by_number, 3, CTLog_LogType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(CTLog_LogType_entries, CTLog_LogType_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : CTLog_LogType_strings[idx].get();
}
bool CTLog_LogType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CTLog_LogType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(CTLog_LogType_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<CTLog_LogType>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CTLog_LogType CTLog::LOG_TYPE_UNSPECIFIED;
constexpr CTLog_LogType CTLog::RFC6962;
constexpr CTLog_LogType CTLog::STATIC_CT_API;
constexpr CTLog_LogType CTLog::LogType_MIN;
constexpr CTLog_LogType CTLog::LogType_MAX;
constexpr int CTLog::LogType_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class FinalTreeHead::_Internal {
public:
};

FinalTreeHead::FinalTreeHead(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.FinalTreeHead)
}
FinalTreeHead::FinalTreeHead(const FinalTreeHead& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FinalTreeHead* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.sha256_root_hash_) {}, decltype(_impl_.tree_size_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.sha256_root_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_root_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_sha256_root_hash().empty()) {
        _this->_impl_.sha256_root_hash_.Set(from._internal_sha256_root_hash(), _this->GetArenaForAllocation());
    }
    _this->_impl_.tree_size_ = from._impl_.tree_size_;
    // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.FinalTreeHead)
}

inline void FinalTreeHead::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.sha256_root_hash_) {}, decltype(_impl_.tree_size_) { uint64_t { 0u } }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.sha256_root_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sha256_root_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

FinalTreeHead::~FinalTreeHead()
{
    // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.FinalTreeHead)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FinalTreeHead::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.sha256_root_hash_.Destroy();
}

void FinalTreeHead::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FinalTreeHead::Clear()
{
    // @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.FinalTreeHead)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.sha256_root_hash_.ClearToEmpty();
    _impl_.tree_size_ = uint64_t { 0u };
    _internal_metadata_.Clear<std::string>();
}

const char* FinalTreeHead::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // uint64 tree_size = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.tree_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string sha256_root_hash = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_sha256_root_hash();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FinalTreeHead::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.FinalTreeHead)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // uint64 tree_size = 1;
    if (this->_internal_tree_size() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_tree_size(), target);
    }

    // string sha256_root_hash = 2;
    if (!this->_internal_sha256_root_hash().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_sha256_root_hash().data(),
            static_cast<int>(this->_internal_sha256_root_hash().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "chrome_browser_certificate_transparency.FinalTreeHead.sha256_root_hash");
        target = stream->WriteStringMaybeAliased(2, this->_internal_sha256_root_hash(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.FinalTreeHead)
    return target;
}

size_t FinalTreeHead::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.FinalTreeHead)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string sha256_root_hash = 2;
    if (!this->_internal_sha256_root_hash().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_sha256_root_hash());
    }

    // uint64 tree_size = 1;
    if (this->_internal_tree_size() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_tree_size());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FinalTreeHead::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FinalTreeHead*>(&from));
}

void FinalTreeHead::MergeFrom(const FinalTreeHead& from)
{
    FinalTreeHead* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.FinalTreeHead)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_sha256_root_hash().empty()) {
        _this->_internal_set_sha256_root_hash(from._internal_sha256_root_hash());
    }
    if (from._internal_tree_size() != 0) {
        _this->_internal_set_tree_size(from._internal_tree_size());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FinalTreeHead::CopyFrom(const FinalTreeHead& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.FinalTreeHead)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FinalTreeHead::IsInitialized() const
{
    return true;
}

void FinalTreeHead::InternalSwap(FinalTreeHead* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.sha256_root_hash_, lhs_arena, &other->_impl_.sha256_root_hash_, rhs_arena);
    swap(_impl_.tree_size_, other->_impl_.tree_size_);
}

std::string FinalTreeHead::GetTypeName() const
{
    return "chrome_browser_certificate_transparency.FinalTreeHead";
}

// ===================================================================

class CTLog_Interval::_Internal {
public:
    static const ::chrome_browser_certificate_transparency::CTTimestamp& start(const CTLog_Interval* msg);
    static const ::chrome_browser_certificate_transparency::CTTimestamp& end(const CTLog_Interval* msg);
};

const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_Interval::_Internal::start(const CTLog_Interval* msg)
{
    return *msg->_impl_.start_;
}
const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_Interval::_Internal::end(const CTLog_Interval* msg)
{
    return *msg->_impl_.end_;
}
void CTLog_Interval::clear_start()
{
    if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
        delete _impl_.start_;
    }
    _impl_.start_ = nullptr;
}
void CTLog_Interval::clear_end()
{
    if (GetArenaForAllocation() == nullptr && _impl_.end_ != nullptr) {
        delete _impl_.end_;
    }
    _impl_.end_ = nullptr;
}
CTLog_Interval::CTLog_Interval(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLog.Interval)
}
CTLog_Interval::CTLog_Interval(const CTLog_Interval& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CTLog_Interval* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.start_) { nullptr }, decltype(_impl_.end_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_start()) {
        _this->_impl_.start_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from._impl_.start_);
    }
    if (from._internal_has_end()) {
        _this->_impl_.end_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from._impl_.end_);
    }
    // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLog.Interval)
}

inline void CTLog_Interval::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.start_) { nullptr }, decltype(_impl_.end_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

CTLog_Interval::~CTLog_Interval()
{
    // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLog.Interval)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CTLog_Interval::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.start_;
    if (this != internal_default_instance())
        delete _impl_.end_;
}

void CTLog_Interval::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CTLog_Interval::Clear()
{
    // @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLog.Interval)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.start_ != nullptr) {
        delete _impl_.start_;
    }
    _impl_.start_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.end_ != nullptr) {
        delete _impl_.end_;
    }
    _impl_.end_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* CTLog_Interval::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .chrome_browser_certificate_transparency.CTTimestamp start = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .chrome_browser_certificate_transparency.CTTimestamp end = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CTLog_Interval::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLog.Interval)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .chrome_browser_certificate_transparency.CTTimestamp start = 1;
    if (this->_internal_has_start()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::start(this), _Internal::start(this).GetCachedSize(), target, stream);
    }

    // .chrome_browser_certificate_transparency.CTTimestamp end = 2;
    if (this->_internal_has_end()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::end(this), _Internal::end(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLog.Interval)
    return target;
}

size_t CTLog_Interval::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLog.Interval)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .chrome_browser_certificate_transparency.CTTimestamp start = 1;
    if (this->_internal_has_start()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.start_);
    }

    // .chrome_browser_certificate_transparency.CTTimestamp end = 2;
    if (this->_internal_has_end()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.end_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CTLog_Interval::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CTLog_Interval*>(&from));
}

void CTLog_Interval::MergeFrom(const CTLog_Interval& from)
{
    CTLog_Interval* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLog.Interval)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_start()) {
        _this->_internal_mutable_start()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_start());
    }
    if (from._internal_has_end()) {
        _this->_internal_mutable_end()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_end());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLog_Interval::CopyFrom(const CTLog_Interval& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLog.Interval)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CTLog_Interval::IsInitialized() const
{
    return true;
}

void CTLog_Interval::InternalSwap(CTLog_Interval* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CTLog_Interval, _impl_.end_) + sizeof(CTLog_Interval::_impl_.end_)
        - PROTOBUF_FIELD_OFFSET(CTLog_Interval, _impl_.start_)>(reinterpret_cast<char*>(&_impl_.start_), reinterpret_cast<char*>(&other->_impl_.start_));
}

std::string CTLog_Interval::GetTypeName() const
{
    return "chrome_browser_certificate_transparency.CTLog.Interval";
}

// ===================================================================

class CTLog_State::_Internal {
public:
    static const ::chrome_browser_certificate_transparency::CTTimestamp& state_start(const CTLog_State* msg);
};

const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_State::_Internal::state_start(const CTLog_State* msg)
{
    return *msg->_impl_.state_start_;
}
void CTLog_State::clear_state_start()
{
    if (GetArenaForAllocation() == nullptr && _impl_.state_start_ != nullptr) {
        delete _impl_.state_start_;
    }
    _impl_.state_start_ = nullptr;
}
CTLog_State::CTLog_State(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLog.State)
}
CTLog_State::CTLog_State(const CTLog_State& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CTLog_State* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.state_start_) { nullptr }, decltype(_impl_.current_state_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_state_start()) {
        _this->_impl_.state_start_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from._impl_.state_start_);
    }
    _this->_impl_.current_state_ = from._impl_.current_state_;
    // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLog.State)
}

inline void CTLog_State::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.state_start_) { nullptr }, decltype(_impl_.current_state_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

CTLog_State::~CTLog_State()
{
    // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLog.State)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CTLog_State::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.state_start_;
}

void CTLog_State::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CTLog_State::Clear()
{
    // @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLog.State)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.state_start_ != nullptr) {
        delete _impl_.state_start_;
    }
    _impl_.state_start_ = nullptr;
    _impl_.current_state_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* CTLog_State::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .chrome_browser_certificate_transparency.CTLog.CurrentState current_state = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_current_state(static_cast<::chrome_browser_certificate_transparency::CTLog_CurrentState>(val));
            } else
                goto handle_unusual;
            continue;
        // .chrome_browser_certificate_transparency.CTTimestamp state_start = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_state_start(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CTLog_State::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLog.State)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .chrome_browser_certificate_transparency.CTLog.CurrentState current_state = 1;
    if (this->_internal_current_state() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_current_state(), target);
    }

    // .chrome_browser_certificate_transparency.CTTimestamp state_start = 2;
    if (this->_internal_has_state_start()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::state_start(this), _Internal::state_start(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLog.State)
    return target;
}

size_t CTLog_State::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLog.State)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .chrome_browser_certificate_transparency.CTTimestamp state_start = 2;
    if (this->_internal_has_state_start()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.state_start_);
    }

    // .chrome_browser_certificate_transparency.CTLog.CurrentState current_state = 1;
    if (this->_internal_current_state() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_current_state());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CTLog_State::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CTLog_State*>(&from));
}

void CTLog_State::MergeFrom(const CTLog_State& from)
{
    CTLog_State* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLog.State)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_state_start()) {
        _this->_internal_mutable_state_start()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_state_start());
    }
    if (from._internal_current_state() != 0) {
        _this->_internal_set_current_state(from._internal_current_state());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLog_State::CopyFrom(const CTLog_State& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLog.State)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CTLog_State::IsInitialized() const
{
    return true;
}

void CTLog_State::InternalSwap(CTLog_State* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CTLog_State, _impl_.current_state_) + sizeof(CTLog_State::_impl_.current_state_)
        - PROTOBUF_FIELD_OFFSET(CTLog_State, _impl_.state_start_)>(
        reinterpret_cast<char*>(&_impl_.state_start_), reinterpret_cast<char*>(&other->_impl_.state_start_));
}

std::string CTLog_State::GetTypeName() const
{
    return "chrome_browser_certificate_transparency.CTLog.State";
}

// ===================================================================

class CTLog_OperatorChange::_Internal {
public:
    static const ::chrome_browser_certificate_transparency::CTTimestamp& operator_start(const CTLog_OperatorChange* msg);
};

const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_OperatorChange::_Internal::operator_start(const CTLog_OperatorChange* msg)
{
    return *msg->_impl_.operator_start_;
}
void CTLog_OperatorChange::clear_operator_start()
{
    if (GetArenaForAllocation() == nullptr && _impl_.operator_start_ != nullptr) {
        delete _impl_.operator_start_;
    }
    _impl_.operator_start_ = nullptr;
}
CTLog_OperatorChange::CTLog_OperatorChange(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLog.OperatorChange)
}
CTLog_OperatorChange::CTLog_OperatorChange(const CTLog_OperatorChange& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CTLog_OperatorChange* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.name_) {}, decltype(_impl_.operator_start_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_name().empty()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_operator_start()) {
        _this->_impl_.operator_start_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from._impl_.operator_start_);
    }
    // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLog.OperatorChange)
}

inline void CTLog_OperatorChange::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.name_) {}, decltype(_impl_.operator_start_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CTLog_OperatorChange::~CTLog_OperatorChange()
{
    // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLog.OperatorChange)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CTLog_OperatorChange::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.operator_start_;
}

void CTLog_OperatorChange::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CTLog_OperatorChange::Clear()
{
    // @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.name_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.operator_start_ != nullptr) {
        delete _impl_.operator_start_;
    }
    _impl_.operator_start_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* CTLog_OperatorChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .chrome_browser_certificate_transparency.CTTimestamp operator_start = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_operator_start(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CTLog_OperatorChange::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string name = 1;
    if (!this->_internal_name().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "chrome_browser_certificate_transparency.CTLog.OperatorChange.name");
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // .chrome_browser_certificate_transparency.CTTimestamp operator_start = 2;
    if (this->_internal_has_operator_start()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::operator_start(this), _Internal::operator_start(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLog.OperatorChange)
    return target;
}

size_t CTLog_OperatorChange::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string name = 1;
    if (!this->_internal_name().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    // .chrome_browser_certificate_transparency.CTTimestamp operator_start = 2;
    if (this->_internal_has_operator_start()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.operator_start_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CTLog_OperatorChange::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CTLog_OperatorChange*>(&from));
}

void CTLog_OperatorChange::MergeFrom(const CTLog_OperatorChange& from)
{
    CTLog_OperatorChange* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
    }
    if (from._internal_has_operator_start()) {
        _this->_internal_mutable_operator_start()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_operator_start());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLog_OperatorChange::CopyFrom(const CTLog_OperatorChange& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLog.OperatorChange)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CTLog_OperatorChange::IsInitialized() const
{
    return true;
}

void CTLog_OperatorChange::InternalSwap(CTLog_OperatorChange* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    swap(_impl_.operator_start_, other->_impl_.operator_start_);
}

std::string CTLog_OperatorChange::GetTypeName() const
{
    return "chrome_browser_certificate_transparency.CTLog.OperatorChange";
}

// ===================================================================

class CTLog::_Internal {
public:
    static const ::chrome_browser_certificate_transparency::CTLog_Interval& temporal_interval(const CTLog* msg);
    static const ::chrome_browser_certificate_transparency::FinalTreeHead& read_only_info(const CTLog* msg);
};

const ::chrome_browser_certificate_transparency::CTLog_Interval& CTLog::_Internal::temporal_interval(const CTLog* msg)
{
    return *msg->_impl_.temporal_interval_;
}
const ::chrome_browser_certificate_transparency::FinalTreeHead& CTLog::_Internal::read_only_info(const CTLog* msg)
{
    return *msg->_impl_.read_only_info_;
}
CTLog::CTLog(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLog)
}
CTLog::CTLog(const CTLog& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CTLog* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.state_) { from._impl_.state_ }, decltype(_impl_.operator_history_) { from._impl_.operator_history_ },
        decltype(_impl_.description_) {}, decltype(_impl_.key_) {}, decltype(_impl_.log_id_) {}, decltype(_impl_.url_) {},
        decltype(_impl_.temporal_interval_) { nullptr }, decltype(_impl_.read_only_info_) { nullptr }, decltype(_impl_.mmd_secs_) {},
        decltype(_impl_.purpose_) {}, decltype(_impl_.log_type_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_description().empty()) {
        _this->_impl_.description_.Set(from._internal_description(), _this->GetArenaForAllocation());
    }
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_key().empty()) {
        _this->_impl_.key_.Set(from._internal_key(), _this->GetArenaForAllocation());
    }
    _impl_.log_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.log_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_log_id().empty()) {
        _this->_impl_.log_id_.Set(from._internal_log_id(), _this->GetArenaForAllocation());
    }
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_url().empty()) {
        _this->_impl_.url_.Set(from._internal_url(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_temporal_interval()) {
        _this->_impl_.temporal_interval_ = new ::chrome_browser_certificate_transparency::CTLog_Interval(*from._impl_.temporal_interval_);
    }
    if (from._internal_has_read_only_info()) {
        _this->_impl_.read_only_info_ = new ::chrome_browser_certificate_transparency::FinalTreeHead(*from._impl_.read_only_info_);
    }
    ::memcpy(&_impl_.mmd_secs_, &from._impl_.mmd_secs_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.log_type_) - reinterpret_cast<char*>(&_impl_.mmd_secs_)) + sizeof(_impl_.log_type_));
    // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLog)
}

inline void CTLog::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.state_) { arena }, decltype(_impl_.operator_history_) { arena }, decltype(_impl_.description_) {},
        decltype(_impl_.key_) {}, decltype(_impl_.log_id_) {}, decltype(_impl_.url_) {}, decltype(_impl_.temporal_interval_) { nullptr },
        decltype(_impl_.read_only_info_) { nullptr }, decltype(_impl_.mmd_secs_) { uint64_t { 0u } }, decltype(_impl_.purpose_) { 0 },
        decltype(_impl_.log_type_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.log_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.log_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CTLog::~CTLog()
{
    // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLog)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CTLog::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.state_.~RepeatedPtrField();
    _impl_.operator_history_.~RepeatedPtrField();
    _impl_.description_.Destroy();
    _impl_.key_.Destroy();
    _impl_.log_id_.Destroy();
    _impl_.url_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.temporal_interval_;
    if (this != internal_default_instance())
        delete _impl_.read_only_info_;
}

void CTLog::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CTLog::Clear()
{
    // @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLog)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.state_.Clear();
    _impl_.operator_history_.Clear();
    _impl_.description_.ClearToEmpty();
    _impl_.key_.ClearToEmpty();
    _impl_.log_id_.ClearToEmpty();
    _impl_.url_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.temporal_interval_ != nullptr) {
        delete _impl_.temporal_interval_;
    }
    _impl_.temporal_interval_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.read_only_info_ != nullptr) {
        delete _impl_.read_only_info_;
    }
    _impl_.read_only_info_ = nullptr;
    ::memset(&_impl_.mmd_secs_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.log_type_) - reinterpret_cast<char*>(&_impl_.mmd_secs_)) + sizeof(_impl_.log_type_));
    _internal_metadata_.Clear<std::string>();
}

const char* CTLog::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string description = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_description();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string key = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_key();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string log_id = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                auto str = _internal_mutable_log_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // uint64 mmd_secs = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.mmd_secs_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string url = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_url();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .chrome_browser_certificate_transparency.CTLog.Interval temporal_interval = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_temporal_interval(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .chrome_browser_certificate_transparency.CTLog.Purpose purpose = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_purpose(static_cast<::chrome_browser_certificate_transparency::CTLog_Purpose>(val));
            } else
                goto handle_unusual;
            continue;
        // repeated .chrome_browser_certificate_transparency.CTLog.State state = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_state(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .chrome_browser_certificate_transparency.CTLog.OperatorChange operator_history = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_operator_history(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
            } else
                goto handle_unusual;
            continue;
        // .chrome_browser_certificate_transparency.FinalTreeHead read_only_info = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
                ptr = ctx->ParseMessage(_internal_mutable_read_only_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .chrome_browser_certificate_transparency.CTLog.LogType log_type = 18;
        case 18:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_log_type(static_cast<::chrome_browser_certificate_transparency::CTLog_LogType>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CTLog::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLog)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string description = 1;
    if (!this->_internal_description().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_description().data(),
            static_cast<int>(this->_internal_description().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "chrome_browser_certificate_transparency.CTLog.description");
        target = stream->WriteStringMaybeAliased(1, this->_internal_description(), target);
    }

    // string key = 2;
    if (!this->_internal_key().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "chrome_browser_certificate_transparency.CTLog.key");
        target = stream->WriteStringMaybeAliased(2, this->_internal_key(), target);
    }

    // string log_id = 3;
    if (!this->_internal_log_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_log_id().data(),
            static_cast<int>(this->_internal_log_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "chrome_browser_certificate_transparency.CTLog.log_id");
        target = stream->WriteStringMaybeAliased(3, this->_internal_log_id(), target);
    }

    // uint64 mmd_secs = 4;
    if (this->_internal_mmd_secs() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_mmd_secs(), target);
    }

    // string url = 5;
    if (!this->_internal_url().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "chrome_browser_certificate_transparency.CTLog.url");
        target = stream->WriteStringMaybeAliased(5, this->_internal_url(), target);
    }

    // .chrome_browser_certificate_transparency.CTLog.Interval temporal_interval = 6;
    if (this->_internal_has_temporal_interval()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::temporal_interval(this), _Internal::temporal_interval(this).GetCachedSize(), target, stream);
    }

    // .chrome_browser_certificate_transparency.CTLog.Purpose purpose = 7;
    if (this->_internal_purpose() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(7, this->_internal_purpose(), target);
    }

    // repeated .chrome_browser_certificate_transparency.CTLog.State state = 8;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_state_size()); i < n; i++) {
        const auto& repfield = this->_internal_state(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .chrome_browser_certificate_transparency.CTLog.OperatorChange operator_history = 9;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_operator_history_size()); i < n; i++) {
        const auto& repfield = this->_internal_operator_history(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
    }

    // .chrome_browser_certificate_transparency.FinalTreeHead read_only_info = 16;
    if (this->_internal_has_read_only_info()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            16, _Internal::read_only_info(this), _Internal::read_only_info(this).GetCachedSize(), target, stream);
    }

    // .chrome_browser_certificate_transparency.CTLog.LogType log_type = 18;
    if (this->_internal_log_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(18, this->_internal_log_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLog)
    return target;
}

size_t CTLog::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLog)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .chrome_browser_certificate_transparency.CTLog.State state = 8;
    total_size += 1UL * this->_internal_state_size();
    for (const auto& msg : this->_impl_.state_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .chrome_browser_certificate_transparency.CTLog.OperatorChange operator_history = 9;
    total_size += 1UL * this->_internal_operator_history_size();
    for (const auto& msg : this->_impl_.operator_history_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string description = 1;
    if (!this->_internal_description().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_description());
    }

    // string key = 2;
    if (!this->_internal_key().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_key());
    }

    // string log_id = 3;
    if (!this->_internal_log_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_log_id());
    }

    // string url = 5;
    if (!this->_internal_url().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_url());
    }

    // .chrome_browser_certificate_transparency.CTLog.Interval temporal_interval = 6;
    if (this->_internal_has_temporal_interval()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.temporal_interval_);
    }

    // .chrome_browser_certificate_transparency.FinalTreeHead read_only_info = 16;
    if (this->_internal_has_read_only_info()) {
        total_size += 2 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.read_only_info_);
    }

    // uint64 mmd_secs = 4;
    if (this->_internal_mmd_secs() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_mmd_secs());
    }

    // .chrome_browser_certificate_transparency.CTLog.Purpose purpose = 7;
    if (this->_internal_purpose() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_purpose());
    }

    // .chrome_browser_certificate_transparency.CTLog.LogType log_type = 18;
    if (this->_internal_log_type() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_log_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CTLog::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CTLog*>(&from));
}

void CTLog::MergeFrom(const CTLog& from)
{
    CTLog* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLog)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.state_.MergeFrom(from._impl_.state_);
    _this->_impl_.operator_history_.MergeFrom(from._impl_.operator_history_);
    if (!from._internal_description().empty()) {
        _this->_internal_set_description(from._internal_description());
    }
    if (!from._internal_key().empty()) {
        _this->_internal_set_key(from._internal_key());
    }
    if (!from._internal_log_id().empty()) {
        _this->_internal_set_log_id(from._internal_log_id());
    }
    if (!from._internal_url().empty()) {
        _this->_internal_set_url(from._internal_url());
    }
    if (from._internal_has_temporal_interval()) {
        _this->_internal_mutable_temporal_interval()->::chrome_browser_certificate_transparency::CTLog_Interval::MergeFrom(from._internal_temporal_interval());
    }
    if (from._internal_has_read_only_info()) {
        _this->_internal_mutable_read_only_info()->::chrome_browser_certificate_transparency::FinalTreeHead::MergeFrom(from._internal_read_only_info());
    }
    if (from._internal_mmd_secs() != 0) {
        _this->_internal_set_mmd_secs(from._internal_mmd_secs());
    }
    if (from._internal_purpose() != 0) {
        _this->_internal_set_purpose(from._internal_purpose());
    }
    if (from._internal_log_type() != 0) {
        _this->_internal_set_log_type(from._internal_log_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLog::CopyFrom(const CTLog& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLog)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CTLog::IsInitialized() const
{
    return true;
}

void CTLog::InternalSwap(CTLog* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.state_.InternalSwap(&other->_impl_.state_);
    _impl_.operator_history_.InternalSwap(&other->_impl_.operator_history_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.description_, lhs_arena, &other->_impl_.description_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.key_, lhs_arena, &other->_impl_.key_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.log_id_, lhs_arena, &other->_impl_.log_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.url_, lhs_arena, &other->_impl_.url_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CTLog, _impl_.log_type_) + sizeof(CTLog::_impl_.log_type_)
        - PROTOBUF_FIELD_OFFSET(CTLog, _impl_.temporal_interval_)>(
        reinterpret_cast<char*>(&_impl_.temporal_interval_), reinterpret_cast<char*>(&other->_impl_.temporal_interval_));
}

std::string CTLog::GetTypeName() const
{
    return "chrome_browser_certificate_transparency.CTLog";
}

// ===================================================================

class LogOperator::_Internal {
public:
};

LogOperator::LogOperator(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.LogOperator)
}
LogOperator::LogOperator(const LogOperator& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    LogOperator* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.email_) { from._impl_.email_ }, decltype(_impl_.name_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_name().empty()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.LogOperator)
}

inline void LogOperator::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.email_) { arena }, decltype(_impl_.name_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

LogOperator::~LogOperator()
{
    // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.LogOperator)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void LogOperator::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.email_.~RepeatedPtrField();
    _impl_.name_.Destroy();
}

void LogOperator::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void LogOperator::Clear()
{
    // @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.LogOperator)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.email_.Clear();
    _impl_.name_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* LogOperator::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string email = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_email();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    CHK_(::_pbi::VerifyUTF8(str, nullptr));
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* LogOperator::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.LogOperator)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string name = 1;
    if (!this->_internal_name().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "chrome_browser_certificate_transparency.LogOperator.name");
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    // repeated string email = 2;
    for (int i = 0, n = this->_internal_email_size(); i < n; i++) {
        const auto& s = this->_internal_email(i);
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s.data(), static_cast<int>(s.length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "chrome_browser_certificate_transparency.LogOperator.email");
        target = stream->WriteString(2, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.LogOperator)
    return target;
}

size_t LogOperator::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.LogOperator)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string email = 2;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.email_.size());
    for (int i = 0, n = _impl_.email_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.email_.Get(i));
    }

    // string name = 1;
    if (!this->_internal_name().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void LogOperator::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const LogOperator*>(&from));
}

void LogOperator::MergeFrom(const LogOperator& from)
{
    LogOperator* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.LogOperator)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.email_.MergeFrom(from._impl_.email_);
    if (!from._internal_name().empty()) {
        _this->_internal_set_name(from._internal_name());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void LogOperator::CopyFrom(const LogOperator& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.LogOperator)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool LogOperator::IsInitialized() const
{
    return true;
}

void LogOperator::InternalSwap(LogOperator* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.email_.InternalSwap(&other->_impl_.email_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
}

std::string LogOperator::GetTypeName() const
{
    return "chrome_browser_certificate_transparency.LogOperator";
}

// ===================================================================

class CTLogList::_Internal {
public:
    static const ::chrome_browser_certificate_transparency::CTTimestamp& timestamp(const CTLogList* msg);
};

const ::chrome_browser_certificate_transparency::CTTimestamp& CTLogList::_Internal::timestamp(const CTLogList* msg)
{
    return *msg->_impl_.timestamp_;
}
void CTLogList::clear_timestamp()
{
    if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
        delete _impl_.timestamp_;
    }
    _impl_.timestamp_ = nullptr;
}
CTLogList::CTLogList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:chrome_browser_certificate_transparency.CTLogList)
}
CTLogList::CTLogList(const CTLogList& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    CTLogList* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.operators_) { from._impl_.operators_ }, decltype(_impl_.logs_) { from._impl_.logs_ },
        decltype(_impl_.timestamp_) { nullptr }, decltype(_impl_.list_version_major_) {}, decltype(_impl_.list_version_minor_) {},
        decltype(_impl_.compatibility_version_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_timestamp()) {
        _this->_impl_.timestamp_ = new ::chrome_browser_certificate_transparency::CTTimestamp(*from._impl_.timestamp_);
    }
    ::memcpy(&_impl_.list_version_major_, &from._impl_.list_version_major_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.compatibility_version_) - reinterpret_cast<char*>(&_impl_.list_version_major_))
            + sizeof(_impl_.compatibility_version_));
    // @@protoc_insertion_point(copy_constructor:chrome_browser_certificate_transparency.CTLogList)
}

inline void CTLogList::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.operators_) { arena }, decltype(_impl_.logs_) { arena }, decltype(_impl_.timestamp_) { nullptr },
        decltype(_impl_.list_version_major_) { uint64_t { 0u } }, decltype(_impl_.list_version_minor_) { uint64_t { 0u } },
        decltype(_impl_.compatibility_version_) { uint64_t { 0u } }, /*decltype(_impl_._cached_size_)*/ {} };
}

CTLogList::~CTLogList()
{
    // @@protoc_insertion_point(destructor:chrome_browser_certificate_transparency.CTLogList)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void CTLogList::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.operators_.~RepeatedPtrField();
    _impl_.logs_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.timestamp_;
}

void CTLogList::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void CTLogList::Clear()
{
    // @@protoc_insertion_point(message_clear_start:chrome_browser_certificate_transparency.CTLogList)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.operators_.Clear();
    _impl_.logs_.Clear();
    if (GetArenaForAllocation() == nullptr && _impl_.timestamp_ != nullptr) {
        delete _impl_.timestamp_;
    }
    _impl_.timestamp_ = nullptr;
    ::memset(&_impl_.list_version_major_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.compatibility_version_) - reinterpret_cast<char*>(&_impl_.list_version_major_))
            + sizeof(_impl_.compatibility_version_));
    _internal_metadata_.Clear<std::string>();
}

const char* CTLogList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // uint64 list_version_major = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.list_version_major_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // uint64 list_version_minor = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.list_version_minor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .chrome_browser_certificate_transparency.CTTimestamp timestamp = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_timestamp(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // uint64 compatibility_version = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.compatibility_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .chrome_browser_certificate_transparency.LogOperator operators = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_operators(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .chrome_browser_certificate_transparency.CTLog logs = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_logs(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* CTLogList::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_certificate_transparency.CTLogList)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // uint64 list_version_major = 1;
    if (this->_internal_list_version_major() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_list_version_major(), target);
    }

    // uint64 list_version_minor = 2;
    if (this->_internal_list_version_minor() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_list_version_minor(), target);
    }

    // .chrome_browser_certificate_transparency.CTTimestamp timestamp = 3;
    if (this->_internal_has_timestamp()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::timestamp(this), _Internal::timestamp(this).GetCachedSize(), target, stream);
    }

    // uint64 compatibility_version = 4;
    if (this->_internal_compatibility_version() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_compatibility_version(), target);
    }

    // repeated .chrome_browser_certificate_transparency.LogOperator operators = 5;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_operators_size()); i < n; i++) {
        const auto& repfield = this->_internal_operators(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
    }

    // repeated .chrome_browser_certificate_transparency.CTLog logs = 6;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_logs_size()); i < n; i++) {
        const auto& repfield = this->_internal_logs(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_certificate_transparency.CTLogList)
    return target;
}

size_t CTLogList::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:chrome_browser_certificate_transparency.CTLogList)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .chrome_browser_certificate_transparency.LogOperator operators = 5;
    total_size += 1UL * this->_internal_operators_size();
    for (const auto& msg : this->_impl_.operators_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // repeated .chrome_browser_certificate_transparency.CTLog logs = 6;
    total_size += 1UL * this->_internal_logs_size();
    for (const auto& msg : this->_impl_.logs_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // .chrome_browser_certificate_transparency.CTTimestamp timestamp = 3;
    if (this->_internal_has_timestamp()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.timestamp_);
    }

    // uint64 list_version_major = 1;
    if (this->_internal_list_version_major() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_list_version_major());
    }

    // uint64 list_version_minor = 2;
    if (this->_internal_list_version_minor() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_list_version_minor());
    }

    // uint64 compatibility_version = 4;
    if (this->_internal_compatibility_version() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_compatibility_version());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void CTLogList::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const CTLogList*>(&from));
}

void CTLogList::MergeFrom(const CTLogList& from)
{
    CTLogList* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_certificate_transparency.CTLogList)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.operators_.MergeFrom(from._impl_.operators_);
    _this->_impl_.logs_.MergeFrom(from._impl_.logs_);
    if (from._internal_has_timestamp()) {
        _this->_internal_mutable_timestamp()->::chrome_browser_certificate_transparency::CTTimestamp::MergeFrom(from._internal_timestamp());
    }
    if (from._internal_list_version_major() != 0) {
        _this->_internal_set_list_version_major(from._internal_list_version_major());
    }
    if (from._internal_list_version_minor() != 0) {
        _this->_internal_set_list_version_minor(from._internal_list_version_minor());
    }
    if (from._internal_compatibility_version() != 0) {
        _this->_internal_set_compatibility_version(from._internal_compatibility_version());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CTLogList::CopyFrom(const CTLogList& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_certificate_transparency.CTLogList)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool CTLogList::IsInitialized() const
{
    return true;
}

void CTLogList::InternalSwap(CTLogList* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.operators_.InternalSwap(&other->_impl_.operators_);
    _impl_.logs_.InternalSwap(&other->_impl_.logs_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(CTLogList, _impl_.compatibility_version_)
        + sizeof(CTLogList::_impl_.compatibility_version_) - PROTOBUF_FIELD_OFFSET(CTLogList, _impl_.timestamp_)>(
        reinterpret_cast<char*>(&_impl_.timestamp_), reinterpret_cast<char*>(&other->_impl_.timestamp_));
}

std::string CTLogList::GetTypeName() const
{
    return "chrome_browser_certificate_transparency.CTLogList";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace chrome_browser_certificate_transparency
PROTOBUF_NAMESPACE_OPEN
template <>
PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::FinalTreeHead* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::FinalTreeHead>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::chrome_browser_certificate_transparency::FinalTreeHead>(arena);
}
template <>
PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLog_Interval*
Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog_Interval>(Arena* arena)
{
    return Arena::CreateMessageInternal<::chrome_browser_certificate_transparency::CTLog_Interval>(arena);
}
template <>
PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLog_State* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog_State>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::chrome_browser_certificate_transparency::CTLog_State>(arena);
}
template <>
PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLog_OperatorChange*
Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog_OperatorChange>(Arena* arena)
{
    return Arena::CreateMessageInternal<::chrome_browser_certificate_transparency::CTLog_OperatorChange>(arena);
}
template <>
PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLog* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog>(Arena* arena)
{
    return Arena::CreateMessageInternal<::chrome_browser_certificate_transparency::CTLog>(arena);
}
template <>
PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::LogOperator* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::LogOperator>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::chrome_browser_certificate_transparency::LogOperator>(arena);
}
template <>
PROTOBUF_NOINLINE ::chrome_browser_certificate_transparency::CTLogList* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLogList>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::chrome_browser_certificate_transparency::CTLogList>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
