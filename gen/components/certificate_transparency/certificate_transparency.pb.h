// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: certificate_transparency.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_certificate_5ftransparency_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_certificate_5ftransparency_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "ct_timestamp.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_certificate_5ftransparency_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_certificate_5ftransparency_2eproto {
    static const uint32_t offsets[];
};
namespace chrome_browser_certificate_transparency {
class CTLog;
struct CTLogDefaultTypeInternal;
extern CTLogDefaultTypeInternal _CTLog_default_instance_;
class CTLogList;
struct CTLogListDefaultTypeInternal;
extern CTLogListDefaultTypeInternal _CTLogList_default_instance_;
class CTLog_Interval;
struct CTLog_IntervalDefaultTypeInternal;
extern CTLog_IntervalDefaultTypeInternal _CTLog_Interval_default_instance_;
class CTLog_OperatorChange;
struct CTLog_OperatorChangeDefaultTypeInternal;
extern CTLog_OperatorChangeDefaultTypeInternal _CTLog_OperatorChange_default_instance_;
class CTLog_State;
struct CTLog_StateDefaultTypeInternal;
extern CTLog_StateDefaultTypeInternal _CTLog_State_default_instance_;
class FinalTreeHead;
struct FinalTreeHeadDefaultTypeInternal;
extern FinalTreeHeadDefaultTypeInternal _FinalTreeHead_default_instance_;
class LogOperator;
struct LogOperatorDefaultTypeInternal;
extern LogOperatorDefaultTypeInternal _LogOperator_default_instance_;
} // namespace chrome_browser_certificate_transparency
PROTOBUF_NAMESPACE_OPEN
template <>::chrome_browser_certificate_transparency::CTLog* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog>(Arena*);
template <>::chrome_browser_certificate_transparency::CTLogList* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLogList>(Arena*);
template <>
::chrome_browser_certificate_transparency::CTLog_Interval* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog_Interval>(Arena*);
template <>
::chrome_browser_certificate_transparency::CTLog_OperatorChange* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog_OperatorChange>(
    Arena*);
template <>::chrome_browser_certificate_transparency::CTLog_State* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog_State>(Arena*);
template <>
::chrome_browser_certificate_transparency::FinalTreeHead* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::FinalTreeHead>(Arena*);
template <>::chrome_browser_certificate_transparency::LogOperator* Arena::CreateMaybeMessage<::chrome_browser_certificate_transparency::LogOperator>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chrome_browser_certificate_transparency {

enum CTLog_Purpose : int {
    CTLog_Purpose_UNSET_PURPOSE = 0,
    CTLog_Purpose_PROD = 1,
    CTLog_Purpose_TEST = 2,
    CTLog_Purpose_CTLog_Purpose_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    CTLog_Purpose_CTLog_Purpose_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CTLog_Purpose_IsValid(int value);
constexpr CTLog_Purpose CTLog_Purpose_Purpose_MIN = CTLog_Purpose_UNSET_PURPOSE;
constexpr CTLog_Purpose CTLog_Purpose_Purpose_MAX = CTLog_Purpose_TEST;
constexpr int CTLog_Purpose_Purpose_ARRAYSIZE = CTLog_Purpose_Purpose_MAX + 1;

const std::string& CTLog_Purpose_Name(CTLog_Purpose value);
template <typename T> inline const std::string& CTLog_Purpose_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, CTLog_Purpose>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CTLog_Purpose_Name.");
    return CTLog_Purpose_Name(static_cast<CTLog_Purpose>(enum_t_value));
}
bool CTLog_Purpose_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CTLog_Purpose* value);
enum CTLog_CurrentState : int {
    CTLog_CurrentState_UNSET_STATE = 0,
    CTLog_CurrentState_PENDING = 1,
    CTLog_CurrentState_QUALIFIED = 2,
    CTLog_CurrentState_USABLE = 3,
    CTLog_CurrentState_READ_ONLY = 4,
    CTLog_CurrentState_RETIRED = 5,
    CTLog_CurrentState_REJECTED = 6,
    CTLog_CurrentState_CTLog_CurrentState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    CTLog_CurrentState_CTLog_CurrentState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CTLog_CurrentState_IsValid(int value);
constexpr CTLog_CurrentState CTLog_CurrentState_CurrentState_MIN = CTLog_CurrentState_UNSET_STATE;
constexpr CTLog_CurrentState CTLog_CurrentState_CurrentState_MAX = CTLog_CurrentState_REJECTED;
constexpr int CTLog_CurrentState_CurrentState_ARRAYSIZE = CTLog_CurrentState_CurrentState_MAX + 1;

const std::string& CTLog_CurrentState_Name(CTLog_CurrentState value);
template <typename T> inline const std::string& CTLog_CurrentState_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, CTLog_CurrentState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CTLog_CurrentState_Name.");
    return CTLog_CurrentState_Name(static_cast<CTLog_CurrentState>(enum_t_value));
}
bool CTLog_CurrentState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CTLog_CurrentState* value);
enum CTLog_LogType : int {
    CTLog_LogType_LOG_TYPE_UNSPECIFIED = 0,
    CTLog_LogType_RFC6962 = 1,
    CTLog_LogType_STATIC_CT_API = 2,
    CTLog_LogType_CTLog_LogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    CTLog_LogType_CTLog_LogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CTLog_LogType_IsValid(int value);
constexpr CTLog_LogType CTLog_LogType_LogType_MIN = CTLog_LogType_LOG_TYPE_UNSPECIFIED;
constexpr CTLog_LogType CTLog_LogType_LogType_MAX = CTLog_LogType_STATIC_CT_API;
constexpr int CTLog_LogType_LogType_ARRAYSIZE = CTLog_LogType_LogType_MAX + 1;

const std::string& CTLog_LogType_Name(CTLog_LogType value);
template <typename T> inline const std::string& CTLog_LogType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, CTLog_LogType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CTLog_LogType_Name.");
    return CTLog_LogType_Name(static_cast<CTLog_LogType>(enum_t_value));
}
bool CTLog_LogType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CTLog_LogType* value);
// ===================================================================

class FinalTreeHead final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_certificate_transparency.FinalTreeHead) */ {
public:
    inline FinalTreeHead()
        : FinalTreeHead(nullptr)
    {
    }
    ~FinalTreeHead() override;
    explicit PROTOBUF_CONSTEXPR FinalTreeHead(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    FinalTreeHead(const FinalTreeHead& from);
    FinalTreeHead(FinalTreeHead&& from) noexcept
        : FinalTreeHead()
    {
        *this = ::std::move(from);
    }

    inline FinalTreeHead& operator=(const FinalTreeHead& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline FinalTreeHead& operator=(FinalTreeHead&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const FinalTreeHead& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const FinalTreeHead* internal_default_instance()
    {
        return reinterpret_cast<const FinalTreeHead*>(&_FinalTreeHead_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(FinalTreeHead& a, FinalTreeHead& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(FinalTreeHead* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(FinalTreeHead* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    FinalTreeHead* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<FinalTreeHead>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const FinalTreeHead& from);
    void MergeFrom(const FinalTreeHead& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(FinalTreeHead* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_browser_certificate_transparency.FinalTreeHead";
    }

protected:
    explicit FinalTreeHead(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSha256RootHashFieldNumber = 2,
        kTreeSizeFieldNumber = 1,
    };
    // string sha256_root_hash = 2;
    void clear_sha256_root_hash();
    const std::string& sha256_root_hash() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_sha256_root_hash(ArgT0&& arg0, ArgT... args);
    std::string* mutable_sha256_root_hash();
    PROTOBUF_NODISCARD std::string* release_sha256_root_hash();
    void set_allocated_sha256_root_hash(std::string* sha256_root_hash);

private:
    const std::string& _internal_sha256_root_hash() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha256_root_hash(const std::string& value);
    std::string* _internal_mutable_sha256_root_hash();

public:
    // uint64 tree_size = 1;
    void clear_tree_size();
    uint64_t tree_size() const;
    void set_tree_size(uint64_t value);

private:
    uint64_t _internal_tree_size() const;
    void _internal_set_tree_size(uint64_t value);

public:
    // @@protoc_insertion_point(class_scope:chrome_browser_certificate_transparency.FinalTreeHead)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha256_root_hash_;
        uint64_t tree_size_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_certificate_5ftransparency_2eproto;
};
// -------------------------------------------------------------------

class CTLog_Interval final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_certificate_transparency.CTLog.Interval) */ {
public:
    inline CTLog_Interval()
        : CTLog_Interval(nullptr)
    {
    }
    ~CTLog_Interval() override;
    explicit PROTOBUF_CONSTEXPR CTLog_Interval(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CTLog_Interval(const CTLog_Interval& from);
    CTLog_Interval(CTLog_Interval&& from) noexcept
        : CTLog_Interval()
    {
        *this = ::std::move(from);
    }

    inline CTLog_Interval& operator=(const CTLog_Interval& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CTLog_Interval& operator=(CTLog_Interval&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const CTLog_Interval& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CTLog_Interval* internal_default_instance()
    {
        return reinterpret_cast<const CTLog_Interval*>(&_CTLog_Interval_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(CTLog_Interval& a, CTLog_Interval& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CTLog_Interval* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CTLog_Interval* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CTLog_Interval* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CTLog_Interval>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CTLog_Interval& from);
    void MergeFrom(const CTLog_Interval& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CTLog_Interval* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_browser_certificate_transparency.CTLog.Interval";
    }

protected:
    explicit CTLog_Interval(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStartFieldNumber = 1,
        kEndFieldNumber = 2,
    };
    // .chrome_browser_certificate_transparency.CTTimestamp start = 1;
    bool has_start() const;

private:
    bool _internal_has_start() const;

public:
    void clear_start();
    const ::chrome_browser_certificate_transparency::CTTimestamp& start() const;
    PROTOBUF_NODISCARD ::chrome_browser_certificate_transparency::CTTimestamp* release_start();
    ::chrome_browser_certificate_transparency::CTTimestamp* mutable_start();
    void set_allocated_start(::chrome_browser_certificate_transparency::CTTimestamp* start);

private:
    const ::chrome_browser_certificate_transparency::CTTimestamp& _internal_start() const;
    ::chrome_browser_certificate_transparency::CTTimestamp* _internal_mutable_start();

public:
    void unsafe_arena_set_allocated_start(::chrome_browser_certificate_transparency::CTTimestamp* start);
    ::chrome_browser_certificate_transparency::CTTimestamp* unsafe_arena_release_start();

    // .chrome_browser_certificate_transparency.CTTimestamp end = 2;
    bool has_end() const;

private:
    bool _internal_has_end() const;

public:
    void clear_end();
    const ::chrome_browser_certificate_transparency::CTTimestamp& end() const;
    PROTOBUF_NODISCARD ::chrome_browser_certificate_transparency::CTTimestamp* release_end();
    ::chrome_browser_certificate_transparency::CTTimestamp* mutable_end();
    void set_allocated_end(::chrome_browser_certificate_transparency::CTTimestamp* end);

private:
    const ::chrome_browser_certificate_transparency::CTTimestamp& _internal_end() const;
    ::chrome_browser_certificate_transparency::CTTimestamp* _internal_mutable_end();

public:
    void unsafe_arena_set_allocated_end(::chrome_browser_certificate_transparency::CTTimestamp* end);
    ::chrome_browser_certificate_transparency::CTTimestamp* unsafe_arena_release_end();

    // @@protoc_insertion_point(class_scope:chrome_browser_certificate_transparency.CTLog.Interval)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::chrome_browser_certificate_transparency::CTTimestamp* start_;
        ::chrome_browser_certificate_transparency::CTTimestamp* end_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_certificate_5ftransparency_2eproto;
};
// -------------------------------------------------------------------

class CTLog_State final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_certificate_transparency.CTLog.State) */ {
public:
    inline CTLog_State()
        : CTLog_State(nullptr)
    {
    }
    ~CTLog_State() override;
    explicit PROTOBUF_CONSTEXPR CTLog_State(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CTLog_State(const CTLog_State& from);
    CTLog_State(CTLog_State&& from) noexcept
        : CTLog_State()
    {
        *this = ::std::move(from);
    }

    inline CTLog_State& operator=(const CTLog_State& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CTLog_State& operator=(CTLog_State&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const CTLog_State& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CTLog_State* internal_default_instance()
    {
        return reinterpret_cast<const CTLog_State*>(&_CTLog_State_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(CTLog_State& a, CTLog_State& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CTLog_State* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CTLog_State* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CTLog_State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CTLog_State>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CTLog_State& from);
    void MergeFrom(const CTLog_State& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CTLog_State* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_browser_certificate_transparency.CTLog.State";
    }

protected:
    explicit CTLog_State(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kStateStartFieldNumber = 2,
        kCurrentStateFieldNumber = 1,
    };
    // .chrome_browser_certificate_transparency.CTTimestamp state_start = 2;
    bool has_state_start() const;

private:
    bool _internal_has_state_start() const;

public:
    void clear_state_start();
    const ::chrome_browser_certificate_transparency::CTTimestamp& state_start() const;
    PROTOBUF_NODISCARD ::chrome_browser_certificate_transparency::CTTimestamp* release_state_start();
    ::chrome_browser_certificate_transparency::CTTimestamp* mutable_state_start();
    void set_allocated_state_start(::chrome_browser_certificate_transparency::CTTimestamp* state_start);

private:
    const ::chrome_browser_certificate_transparency::CTTimestamp& _internal_state_start() const;
    ::chrome_browser_certificate_transparency::CTTimestamp* _internal_mutable_state_start();

public:
    void unsafe_arena_set_allocated_state_start(::chrome_browser_certificate_transparency::CTTimestamp* state_start);
    ::chrome_browser_certificate_transparency::CTTimestamp* unsafe_arena_release_state_start();

    // .chrome_browser_certificate_transparency.CTLog.CurrentState current_state = 1;
    void clear_current_state();
    ::chrome_browser_certificate_transparency::CTLog_CurrentState current_state() const;
    void set_current_state(::chrome_browser_certificate_transparency::CTLog_CurrentState value);

private:
    ::chrome_browser_certificate_transparency::CTLog_CurrentState _internal_current_state() const;
    void _internal_set_current_state(::chrome_browser_certificate_transparency::CTLog_CurrentState value);

public:
    // @@protoc_insertion_point(class_scope:chrome_browser_certificate_transparency.CTLog.State)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::chrome_browser_certificate_transparency::CTTimestamp* state_start_;
        int current_state_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_certificate_5ftransparency_2eproto;
};
// -------------------------------------------------------------------

class CTLog_OperatorChange final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_certificate_transparency.CTLog.OperatorChange) */ {
public:
    inline CTLog_OperatorChange()
        : CTLog_OperatorChange(nullptr)
    {
    }
    ~CTLog_OperatorChange() override;
    explicit PROTOBUF_CONSTEXPR CTLog_OperatorChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CTLog_OperatorChange(const CTLog_OperatorChange& from);
    CTLog_OperatorChange(CTLog_OperatorChange&& from) noexcept
        : CTLog_OperatorChange()
    {
        *this = ::std::move(from);
    }

    inline CTLog_OperatorChange& operator=(const CTLog_OperatorChange& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CTLog_OperatorChange& operator=(CTLog_OperatorChange&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const CTLog_OperatorChange& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CTLog_OperatorChange* internal_default_instance()
    {
        return reinterpret_cast<const CTLog_OperatorChange*>(&_CTLog_OperatorChange_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(CTLog_OperatorChange& a, CTLog_OperatorChange& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CTLog_OperatorChange* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CTLog_OperatorChange* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CTLog_OperatorChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CTLog_OperatorChange>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CTLog_OperatorChange& from);
    void MergeFrom(const CTLog_OperatorChange& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CTLog_OperatorChange* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_browser_certificate_transparency.CTLog.OperatorChange";
    }

protected:
    explicit CTLog_OperatorChange(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNameFieldNumber = 1,
        kOperatorStartFieldNumber = 2,
    };
    // string name = 1;
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // .chrome_browser_certificate_transparency.CTTimestamp operator_start = 2;
    bool has_operator_start() const;

private:
    bool _internal_has_operator_start() const;

public:
    void clear_operator_start();
    const ::chrome_browser_certificate_transparency::CTTimestamp& operator_start() const;
    PROTOBUF_NODISCARD ::chrome_browser_certificate_transparency::CTTimestamp* release_operator_start();
    ::chrome_browser_certificate_transparency::CTTimestamp* mutable_operator_start();
    void set_allocated_operator_start(::chrome_browser_certificate_transparency::CTTimestamp* operator_start);

private:
    const ::chrome_browser_certificate_transparency::CTTimestamp& _internal_operator_start() const;
    ::chrome_browser_certificate_transparency::CTTimestamp* _internal_mutable_operator_start();

public:
    void unsafe_arena_set_allocated_operator_start(::chrome_browser_certificate_transparency::CTTimestamp* operator_start);
    ::chrome_browser_certificate_transparency::CTTimestamp* unsafe_arena_release_operator_start();

    // @@protoc_insertion_point(class_scope:chrome_browser_certificate_transparency.CTLog.OperatorChange)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::chrome_browser_certificate_transparency::CTTimestamp* operator_start_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_certificate_5ftransparency_2eproto;
};
// -------------------------------------------------------------------

class CTLog final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_certificate_transparency.CTLog) */ {
public:
    inline CTLog()
        : CTLog(nullptr)
    {
    }
    ~CTLog() override;
    explicit PROTOBUF_CONSTEXPR CTLog(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CTLog(const CTLog& from);
    CTLog(CTLog&& from) noexcept
        : CTLog()
    {
        *this = ::std::move(from);
    }

    inline CTLog& operator=(const CTLog& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CTLog& operator=(CTLog&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const CTLog& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CTLog* internal_default_instance()
    {
        return reinterpret_cast<const CTLog*>(&_CTLog_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(CTLog& a, CTLog& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CTLog* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CTLog* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CTLog* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CTLog>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CTLog& from);
    void MergeFrom(const CTLog& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CTLog* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_browser_certificate_transparency.CTLog";
    }

protected:
    explicit CTLog(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef CTLog_Interval Interval;
    typedef CTLog_State State;
    typedef CTLog_OperatorChange OperatorChange;

    typedef CTLog_Purpose Purpose;
    static constexpr Purpose UNSET_PURPOSE = CTLog_Purpose_UNSET_PURPOSE;
    static constexpr Purpose PROD = CTLog_Purpose_PROD;
    static constexpr Purpose TEST = CTLog_Purpose_TEST;
    static inline bool Purpose_IsValid(int value)
    {
        return CTLog_Purpose_IsValid(value);
    }
    static constexpr Purpose Purpose_MIN = CTLog_Purpose_Purpose_MIN;
    static constexpr Purpose Purpose_MAX = CTLog_Purpose_Purpose_MAX;
    static constexpr int Purpose_ARRAYSIZE = CTLog_Purpose_Purpose_ARRAYSIZE;
    template <typename T> static inline const std::string& Purpose_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, Purpose>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Purpose_Name.");
        return CTLog_Purpose_Name(enum_t_value);
    }
    static inline bool Purpose_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Purpose* value)
    {
        return CTLog_Purpose_Parse(name, value);
    }

    typedef CTLog_CurrentState CurrentState;
    static constexpr CurrentState UNSET_STATE = CTLog_CurrentState_UNSET_STATE;
    static constexpr CurrentState PENDING = CTLog_CurrentState_PENDING;
    static constexpr CurrentState QUALIFIED = CTLog_CurrentState_QUALIFIED;
    static constexpr CurrentState USABLE = CTLog_CurrentState_USABLE;
    static constexpr CurrentState READ_ONLY = CTLog_CurrentState_READ_ONLY;
    static constexpr CurrentState RETIRED = CTLog_CurrentState_RETIRED;
    static constexpr CurrentState REJECTED = CTLog_CurrentState_REJECTED;
    static inline bool CurrentState_IsValid(int value)
    {
        return CTLog_CurrentState_IsValid(value);
    }
    static constexpr CurrentState CurrentState_MIN = CTLog_CurrentState_CurrentState_MIN;
    static constexpr CurrentState CurrentState_MAX = CTLog_CurrentState_CurrentState_MAX;
    static constexpr int CurrentState_ARRAYSIZE = CTLog_CurrentState_CurrentState_ARRAYSIZE;
    template <typename T> static inline const std::string& CurrentState_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, CurrentState>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CurrentState_Name.");
        return CTLog_CurrentState_Name(enum_t_value);
    }
    static inline bool CurrentState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CurrentState* value)
    {
        return CTLog_CurrentState_Parse(name, value);
    }

    typedef CTLog_LogType LogType;
    static constexpr LogType LOG_TYPE_UNSPECIFIED = CTLog_LogType_LOG_TYPE_UNSPECIFIED;
    static constexpr LogType RFC6962 = CTLog_LogType_RFC6962;
    static constexpr LogType STATIC_CT_API = CTLog_LogType_STATIC_CT_API;
    static inline bool LogType_IsValid(int value)
    {
        return CTLog_LogType_IsValid(value);
    }
    static constexpr LogType LogType_MIN = CTLog_LogType_LogType_MIN;
    static constexpr LogType LogType_MAX = CTLog_LogType_LogType_MAX;
    static constexpr int LogType_ARRAYSIZE = CTLog_LogType_LogType_ARRAYSIZE;
    template <typename T> static inline const std::string& LogType_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, LogType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function LogType_Name.");
        return CTLog_LogType_Name(enum_t_value);
    }
    static inline bool LogType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LogType* value)
    {
        return CTLog_LogType_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kStateFieldNumber = 8,
        kOperatorHistoryFieldNumber = 9,
        kDescriptionFieldNumber = 1,
        kKeyFieldNumber = 2,
        kLogIdFieldNumber = 3,
        kUrlFieldNumber = 5,
        kTemporalIntervalFieldNumber = 6,
        kReadOnlyInfoFieldNumber = 16,
        kMmdSecsFieldNumber = 4,
        kPurposeFieldNumber = 7,
        kLogTypeFieldNumber = 18,
    };
    // repeated .chrome_browser_certificate_transparency.CTLog.State state = 8;
    int state_size() const;

private:
    int _internal_state_size() const;

public:
    void clear_state();
    ::chrome_browser_certificate_transparency::CTLog_State* mutable_state(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_State>* mutable_state();

private:
    const ::chrome_browser_certificate_transparency::CTLog_State& _internal_state(int index) const;
    ::chrome_browser_certificate_transparency::CTLog_State* _internal_add_state();

public:
    const ::chrome_browser_certificate_transparency::CTLog_State& state(int index) const;
    ::chrome_browser_certificate_transparency::CTLog_State* add_state();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_State>& state() const;

    // repeated .chrome_browser_certificate_transparency.CTLog.OperatorChange operator_history = 9;
    int operator_history_size() const;

private:
    int _internal_operator_history_size() const;

public:
    void clear_operator_history();
    ::chrome_browser_certificate_transparency::CTLog_OperatorChange* mutable_operator_history(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_OperatorChange>* mutable_operator_history();

private:
    const ::chrome_browser_certificate_transparency::CTLog_OperatorChange& _internal_operator_history(int index) const;
    ::chrome_browser_certificate_transparency::CTLog_OperatorChange* _internal_add_operator_history();

public:
    const ::chrome_browser_certificate_transparency::CTLog_OperatorChange& operator_history(int index) const;
    ::chrome_browser_certificate_transparency::CTLog_OperatorChange* add_operator_history();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_OperatorChange>& operator_history() const;

    // string description = 1;
    void clear_description();
    const std::string& description() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_description(ArgT0&& arg0, ArgT... args);
    std::string* mutable_description();
    PROTOBUF_NODISCARD std::string* release_description();
    void set_allocated_description(std::string* description);

private:
    const std::string& _internal_description() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
    std::string* _internal_mutable_description();

public:
    // string key = 2;
    void clear_key();
    const std::string& key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_key();
    PROTOBUF_NODISCARD std::string* release_key();
    void set_allocated_key(std::string* key);

private:
    const std::string& _internal_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
    std::string* _internal_mutable_key();

public:
    // string log_id = 3;
    void clear_log_id();
    const std::string& log_id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_log_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_log_id();
    PROTOBUF_NODISCARD std::string* release_log_id();
    void set_allocated_log_id(std::string* log_id);

private:
    const std::string& _internal_log_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_id(const std::string& value);
    std::string* _internal_mutable_log_id();

public:
    // string url = 5;
    void clear_url();
    const std::string& url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_url();
    PROTOBUF_NODISCARD std::string* release_url();
    void set_allocated_url(std::string* url);

private:
    const std::string& _internal_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
    std::string* _internal_mutable_url();

public:
    // .chrome_browser_certificate_transparency.CTLog.Interval temporal_interval = 6;
    bool has_temporal_interval() const;

private:
    bool _internal_has_temporal_interval() const;

public:
    void clear_temporal_interval();
    const ::chrome_browser_certificate_transparency::CTLog_Interval& temporal_interval() const;
    PROTOBUF_NODISCARD ::chrome_browser_certificate_transparency::CTLog_Interval* release_temporal_interval();
    ::chrome_browser_certificate_transparency::CTLog_Interval* mutable_temporal_interval();
    void set_allocated_temporal_interval(::chrome_browser_certificate_transparency::CTLog_Interval* temporal_interval);

private:
    const ::chrome_browser_certificate_transparency::CTLog_Interval& _internal_temporal_interval() const;
    ::chrome_browser_certificate_transparency::CTLog_Interval* _internal_mutable_temporal_interval();

public:
    void unsafe_arena_set_allocated_temporal_interval(::chrome_browser_certificate_transparency::CTLog_Interval* temporal_interval);
    ::chrome_browser_certificate_transparency::CTLog_Interval* unsafe_arena_release_temporal_interval();

    // .chrome_browser_certificate_transparency.FinalTreeHead read_only_info = 16;
    bool has_read_only_info() const;

private:
    bool _internal_has_read_only_info() const;

public:
    void clear_read_only_info();
    const ::chrome_browser_certificate_transparency::FinalTreeHead& read_only_info() const;
    PROTOBUF_NODISCARD ::chrome_browser_certificate_transparency::FinalTreeHead* release_read_only_info();
    ::chrome_browser_certificate_transparency::FinalTreeHead* mutable_read_only_info();
    void set_allocated_read_only_info(::chrome_browser_certificate_transparency::FinalTreeHead* read_only_info);

private:
    const ::chrome_browser_certificate_transparency::FinalTreeHead& _internal_read_only_info() const;
    ::chrome_browser_certificate_transparency::FinalTreeHead* _internal_mutable_read_only_info();

public:
    void unsafe_arena_set_allocated_read_only_info(::chrome_browser_certificate_transparency::FinalTreeHead* read_only_info);
    ::chrome_browser_certificate_transparency::FinalTreeHead* unsafe_arena_release_read_only_info();

    // uint64 mmd_secs = 4;
    void clear_mmd_secs();
    uint64_t mmd_secs() const;
    void set_mmd_secs(uint64_t value);

private:
    uint64_t _internal_mmd_secs() const;
    void _internal_set_mmd_secs(uint64_t value);

public:
    // .chrome_browser_certificate_transparency.CTLog.Purpose purpose = 7;
    void clear_purpose();
    ::chrome_browser_certificate_transparency::CTLog_Purpose purpose() const;
    void set_purpose(::chrome_browser_certificate_transparency::CTLog_Purpose value);

private:
    ::chrome_browser_certificate_transparency::CTLog_Purpose _internal_purpose() const;
    void _internal_set_purpose(::chrome_browser_certificate_transparency::CTLog_Purpose value);

public:
    // .chrome_browser_certificate_transparency.CTLog.LogType log_type = 18;
    void clear_log_type();
    ::chrome_browser_certificate_transparency::CTLog_LogType log_type() const;
    void set_log_type(::chrome_browser_certificate_transparency::CTLog_LogType value);

private:
    ::chrome_browser_certificate_transparency::CTLog_LogType _internal_log_type() const;
    void _internal_set_log_type(::chrome_browser_certificate_transparency::CTLog_LogType value);

public:
    // @@protoc_insertion_point(class_scope:chrome_browser_certificate_transparency.CTLog)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_State> state_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_OperatorChange> operator_history_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
        ::chrome_browser_certificate_transparency::CTLog_Interval* temporal_interval_;
        ::chrome_browser_certificate_transparency::FinalTreeHead* read_only_info_;
        uint64_t mmd_secs_;
        int purpose_;
        int log_type_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_certificate_5ftransparency_2eproto;
};
// -------------------------------------------------------------------

class LogOperator final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_certificate_transparency.LogOperator) */ {
public:
    inline LogOperator()
        : LogOperator(nullptr)
    {
    }
    ~LogOperator() override;
    explicit PROTOBUF_CONSTEXPR LogOperator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    LogOperator(const LogOperator& from);
    LogOperator(LogOperator&& from) noexcept
        : LogOperator()
    {
        *this = ::std::move(from);
    }

    inline LogOperator& operator=(const LogOperator& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline LogOperator& operator=(LogOperator&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const LogOperator& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const LogOperator* internal_default_instance()
    {
        return reinterpret_cast<const LogOperator*>(&_LogOperator_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;

    friend void swap(LogOperator& a, LogOperator& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(LogOperator* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(LogOperator* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    LogOperator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<LogOperator>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const LogOperator& from);
    void MergeFrom(const LogOperator& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LogOperator* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_browser_certificate_transparency.LogOperator";
    }

protected:
    explicit LogOperator(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kEmailFieldNumber = 2,
        kNameFieldNumber = 1,
    };
    // repeated string email = 2;
    int email_size() const;

private:
    int _internal_email_size() const;

public:
    void clear_email();
    const std::string& email(int index) const;
    std::string* mutable_email(int index);
    void set_email(int index, const std::string& value);
    void set_email(int index, std::string&& value);
    void set_email(int index, const char* value);
    void set_email(int index, const char* value, size_t size);
    std::string* add_email();
    void add_email(const std::string& value);
    void add_email(std::string&& value);
    void add_email(const char* value);
    void add_email(const char* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& email() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_email();

private:
    const std::string& _internal_email(int index) const;
    std::string* _internal_add_email();

public:
    // string name = 1;
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // @@protoc_insertion_point(class_scope:chrome_browser_certificate_transparency.LogOperator)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> email_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_certificate_5ftransparency_2eproto;
};
// -------------------------------------------------------------------

class CTLogList final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_browser_certificate_transparency.CTLogList) */ {
public:
    inline CTLogList()
        : CTLogList(nullptr)
    {
    }
    ~CTLogList() override;
    explicit PROTOBUF_CONSTEXPR CTLogList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CTLogList(const CTLogList& from);
    CTLogList(CTLogList&& from) noexcept
        : CTLogList()
    {
        *this = ::std::move(from);
    }

    inline CTLogList& operator=(const CTLogList& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CTLogList& operator=(CTLogList&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const CTLogList& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CTLogList* internal_default_instance()
    {
        return reinterpret_cast<const CTLogList*>(&_CTLogList_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(CTLogList& a, CTLogList& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CTLogList* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CTLogList* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CTLogList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CTLogList>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CTLogList& from);
    void MergeFrom(const CTLogList& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CTLogList* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_browser_certificate_transparency.CTLogList";
    }

protected:
    explicit CTLogList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kOperatorsFieldNumber = 5,
        kLogsFieldNumber = 6,
        kTimestampFieldNumber = 3,
        kListVersionMajorFieldNumber = 1,
        kListVersionMinorFieldNumber = 2,
        kCompatibilityVersionFieldNumber = 4,
    };
    // repeated .chrome_browser_certificate_transparency.LogOperator operators = 5;
    int operators_size() const;

private:
    int _internal_operators_size() const;

public:
    void clear_operators();
    ::chrome_browser_certificate_transparency::LogOperator* mutable_operators(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::LogOperator>* mutable_operators();

private:
    const ::chrome_browser_certificate_transparency::LogOperator& _internal_operators(int index) const;
    ::chrome_browser_certificate_transparency::LogOperator* _internal_add_operators();

public:
    const ::chrome_browser_certificate_transparency::LogOperator& operators(int index) const;
    ::chrome_browser_certificate_transparency::LogOperator* add_operators();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::LogOperator>& operators() const;

    // repeated .chrome_browser_certificate_transparency.CTLog logs = 6;
    int logs_size() const;

private:
    int _internal_logs_size() const;

public:
    void clear_logs();
    ::chrome_browser_certificate_transparency::CTLog* mutable_logs(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog>* mutable_logs();

private:
    const ::chrome_browser_certificate_transparency::CTLog& _internal_logs(int index) const;
    ::chrome_browser_certificate_transparency::CTLog* _internal_add_logs();

public:
    const ::chrome_browser_certificate_transparency::CTLog& logs(int index) const;
    ::chrome_browser_certificate_transparency::CTLog* add_logs();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog>& logs() const;

    // .chrome_browser_certificate_transparency.CTTimestamp timestamp = 3;
    bool has_timestamp() const;

private:
    bool _internal_has_timestamp() const;

public:
    void clear_timestamp();
    const ::chrome_browser_certificate_transparency::CTTimestamp& timestamp() const;
    PROTOBUF_NODISCARD ::chrome_browser_certificate_transparency::CTTimestamp* release_timestamp();
    ::chrome_browser_certificate_transparency::CTTimestamp* mutable_timestamp();
    void set_allocated_timestamp(::chrome_browser_certificate_transparency::CTTimestamp* timestamp);

private:
    const ::chrome_browser_certificate_transparency::CTTimestamp& _internal_timestamp() const;
    ::chrome_browser_certificate_transparency::CTTimestamp* _internal_mutable_timestamp();

public:
    void unsafe_arena_set_allocated_timestamp(::chrome_browser_certificate_transparency::CTTimestamp* timestamp);
    ::chrome_browser_certificate_transparency::CTTimestamp* unsafe_arena_release_timestamp();

    // uint64 list_version_major = 1;
    void clear_list_version_major();
    uint64_t list_version_major() const;
    void set_list_version_major(uint64_t value);

private:
    uint64_t _internal_list_version_major() const;
    void _internal_set_list_version_major(uint64_t value);

public:
    // uint64 list_version_minor = 2;
    void clear_list_version_minor();
    uint64_t list_version_minor() const;
    void set_list_version_minor(uint64_t value);

private:
    uint64_t _internal_list_version_minor() const;
    void _internal_set_list_version_minor(uint64_t value);

public:
    // uint64 compatibility_version = 4;
    void clear_compatibility_version();
    uint64_t compatibility_version() const;
    void set_compatibility_version(uint64_t value);

private:
    uint64_t _internal_compatibility_version() const;
    void _internal_set_compatibility_version(uint64_t value);

public:
    // @@protoc_insertion_point(class_scope:chrome_browser_certificate_transparency.CTLogList)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::LogOperator> operators_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog> logs_;
        ::chrome_browser_certificate_transparency::CTTimestamp* timestamp_;
        uint64_t list_version_major_;
        uint64_t list_version_minor_;
        uint64_t compatibility_version_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_certificate_5ftransparency_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// FinalTreeHead

// uint64 tree_size = 1;
inline void FinalTreeHead::clear_tree_size()
{
    _impl_.tree_size_ = uint64_t { 0u };
}
inline uint64_t FinalTreeHead::_internal_tree_size() const
{
    return _impl_.tree_size_;
}
inline uint64_t FinalTreeHead::tree_size() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.FinalTreeHead.tree_size)
    return _internal_tree_size();
}
inline void FinalTreeHead::_internal_set_tree_size(uint64_t value)
{

    _impl_.tree_size_ = value;
}
inline void FinalTreeHead::set_tree_size(uint64_t value)
{
    _internal_set_tree_size(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.FinalTreeHead.tree_size)
}

// string sha256_root_hash = 2;
inline void FinalTreeHead::clear_sha256_root_hash()
{
    _impl_.sha256_root_hash_.ClearToEmpty();
}
inline const std::string& FinalTreeHead::sha256_root_hash() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.FinalTreeHead.sha256_root_hash)
    return _internal_sha256_root_hash();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void FinalTreeHead::set_sha256_root_hash(ArgT0&& arg0, ArgT... args)
{

    _impl_.sha256_root_hash_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.FinalTreeHead.sha256_root_hash)
}
inline std::string* FinalTreeHead::mutable_sha256_root_hash()
{
    std::string* _s = _internal_mutable_sha256_root_hash();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.FinalTreeHead.sha256_root_hash)
    return _s;
}
inline const std::string& FinalTreeHead::_internal_sha256_root_hash() const
{
    return _impl_.sha256_root_hash_.Get();
}
inline void FinalTreeHead::_internal_set_sha256_root_hash(const std::string& value)
{

    _impl_.sha256_root_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* FinalTreeHead::_internal_mutable_sha256_root_hash()
{

    return _impl_.sha256_root_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* FinalTreeHead::release_sha256_root_hash()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.FinalTreeHead.sha256_root_hash)
    return _impl_.sha256_root_hash_.Release();
}
inline void FinalTreeHead::set_allocated_sha256_root_hash(std::string* sha256_root_hash)
{
    if (sha256_root_hash != nullptr) {

    } else {
    }
    _impl_.sha256_root_hash_.SetAllocated(sha256_root_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.sha256_root_hash_.IsDefault()) {
        _impl_.sha256_root_hash_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.FinalTreeHead.sha256_root_hash)
}

// -------------------------------------------------------------------

// CTLog_Interval

// .chrome_browser_certificate_transparency.CTTimestamp start = 1;
inline bool CTLog_Interval::_internal_has_start() const
{
    return this != internal_default_instance() && _impl_.start_ != nullptr;
}
inline bool CTLog_Interval::has_start() const
{
    return _internal_has_start();
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_Interval::_internal_start() const
{
    const ::chrome_browser_certificate_transparency::CTTimestamp* p = _impl_.start_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::chrome_browser_certificate_transparency::CTTimestamp&>(
                            ::chrome_browser_certificate_transparency::_CTTimestamp_default_instance_);
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_Interval::start() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.Interval.start)
    return _internal_start();
}
inline void CTLog_Interval::unsafe_arena_set_allocated_start(::chrome_browser_certificate_transparency::CTTimestamp* start)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
    }
    _impl_.start_ = start;
    if (start) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_certificate_transparency.CTLog.Interval.start)
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_Interval::release_start()
{

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.start_;
    _impl_.start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_Interval::unsafe_arena_release_start()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.Interval.start)

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.start_;
    _impl_.start_ = nullptr;
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_Interval::_internal_mutable_start()
{

    if (_impl_.start_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_browser_certificate_transparency::CTTimestamp>(GetArenaForAllocation());
        _impl_.start_ = p;
    }
    return _impl_.start_;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_Interval::mutable_start()
{
    ::chrome_browser_certificate_transparency::CTTimestamp* _msg = _internal_mutable_start();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.Interval.start)
    return _msg;
}
inline void CTLog_Interval::set_allocated_start(::chrome_browser_certificate_transparency::CTTimestamp* start)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_);
    }
    if (start) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start));
        if (message_arena != submessage_arena) {
            start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, start, submessage_arena);
        }

    } else {
    }
    _impl_.start_ = start;
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.Interval.start)
}

// .chrome_browser_certificate_transparency.CTTimestamp end = 2;
inline bool CTLog_Interval::_internal_has_end() const
{
    return this != internal_default_instance() && _impl_.end_ != nullptr;
}
inline bool CTLog_Interval::has_end() const
{
    return _internal_has_end();
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_Interval::_internal_end() const
{
    const ::chrome_browser_certificate_transparency::CTTimestamp* p = _impl_.end_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::chrome_browser_certificate_transparency::CTTimestamp&>(
                            ::chrome_browser_certificate_transparency::_CTTimestamp_default_instance_);
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_Interval::end() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.Interval.end)
    return _internal_end();
}
inline void CTLog_Interval::unsafe_arena_set_allocated_end(::chrome_browser_certificate_transparency::CTTimestamp* end)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
    }
    _impl_.end_ = end;
    if (end) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_certificate_transparency.CTLog.Interval.end)
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_Interval::release_end()
{

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.end_;
    _impl_.end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_Interval::unsafe_arena_release_end()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.Interval.end)

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.end_;
    _impl_.end_ = nullptr;
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_Interval::_internal_mutable_end()
{

    if (_impl_.end_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_browser_certificate_transparency::CTTimestamp>(GetArenaForAllocation());
        _impl_.end_ = p;
    }
    return _impl_.end_;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_Interval::mutable_end()
{
    ::chrome_browser_certificate_transparency::CTTimestamp* _msg = _internal_mutable_end();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.Interval.end)
    return _msg;
}
inline void CTLog_Interval::set_allocated_end(::chrome_browser_certificate_transparency::CTTimestamp* end)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.end_);
    }
    if (end) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end));
        if (message_arena != submessage_arena) {
            end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, end, submessage_arena);
        }

    } else {
    }
    _impl_.end_ = end;
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.Interval.end)
}

// -------------------------------------------------------------------

// CTLog_State

// .chrome_browser_certificate_transparency.CTLog.CurrentState current_state = 1;
inline void CTLog_State::clear_current_state()
{
    _impl_.current_state_ = 0;
}
inline ::chrome_browser_certificate_transparency::CTLog_CurrentState CTLog_State::_internal_current_state() const
{
    return static_cast<::chrome_browser_certificate_transparency::CTLog_CurrentState>(_impl_.current_state_);
}
inline ::chrome_browser_certificate_transparency::CTLog_CurrentState CTLog_State::current_state() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.State.current_state)
    return _internal_current_state();
}
inline void CTLog_State::_internal_set_current_state(::chrome_browser_certificate_transparency::CTLog_CurrentState value)
{

    _impl_.current_state_ = value;
}
inline void CTLog_State::set_current_state(::chrome_browser_certificate_transparency::CTLog_CurrentState value)
{
    _internal_set_current_state(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.State.current_state)
}

// .chrome_browser_certificate_transparency.CTTimestamp state_start = 2;
inline bool CTLog_State::_internal_has_state_start() const
{
    return this != internal_default_instance() && _impl_.state_start_ != nullptr;
}
inline bool CTLog_State::has_state_start() const
{
    return _internal_has_state_start();
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_State::_internal_state_start() const
{
    const ::chrome_browser_certificate_transparency::CTTimestamp* p = _impl_.state_start_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::chrome_browser_certificate_transparency::CTTimestamp&>(
                            ::chrome_browser_certificate_transparency::_CTTimestamp_default_instance_);
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_State::state_start() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.State.state_start)
    return _internal_state_start();
}
inline void CTLog_State::unsafe_arena_set_allocated_state_start(::chrome_browser_certificate_transparency::CTTimestamp* state_start)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_start_);
    }
    _impl_.state_start_ = state_start;
    if (state_start) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_certificate_transparency.CTLog.State.state_start)
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_State::release_state_start()
{

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.state_start_;
    _impl_.state_start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_State::unsafe_arena_release_state_start()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.State.state_start)

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.state_start_;
    _impl_.state_start_ = nullptr;
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_State::_internal_mutable_state_start()
{

    if (_impl_.state_start_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_browser_certificate_transparency::CTTimestamp>(GetArenaForAllocation());
        _impl_.state_start_ = p;
    }
    return _impl_.state_start_;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_State::mutable_state_start()
{
    ::chrome_browser_certificate_transparency::CTTimestamp* _msg = _internal_mutable_state_start();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.State.state_start)
    return _msg;
}
inline void CTLog_State::set_allocated_state_start(::chrome_browser_certificate_transparency::CTTimestamp* state_start)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.state_start_);
    }
    if (state_start) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_start));
        if (message_arena != submessage_arena) {
            state_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, state_start, submessage_arena);
        }

    } else {
    }
    _impl_.state_start_ = state_start;
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.State.state_start)
}

// -------------------------------------------------------------------

// CTLog_OperatorChange

// string name = 1;
inline void CTLog_OperatorChange::clear_name()
{
    _impl_.name_.ClearToEmpty();
}
inline const std::string& CTLog_OperatorChange::name() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.OperatorChange.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CTLog_OperatorChange::set_name(ArgT0&& arg0, ArgT... args)
{

    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.OperatorChange.name)
}
inline std::string* CTLog_OperatorChange::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.OperatorChange.name)
    return _s;
}
inline const std::string& CTLog_OperatorChange::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void CTLog_OperatorChange::_internal_set_name(const std::string& value)
{

    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CTLog_OperatorChange::_internal_mutable_name()
{

    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CTLog_OperatorChange::release_name()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.OperatorChange.name)
    return _impl_.name_.Release();
}
inline void CTLog_OperatorChange::set_allocated_name(std::string* name)
{
    if (name != nullptr) {

    } else {
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.OperatorChange.name)
}

// .chrome_browser_certificate_transparency.CTTimestamp operator_start = 2;
inline bool CTLog_OperatorChange::_internal_has_operator_start() const
{
    return this != internal_default_instance() && _impl_.operator_start_ != nullptr;
}
inline bool CTLog_OperatorChange::has_operator_start() const
{
    return _internal_has_operator_start();
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_OperatorChange::_internal_operator_start() const
{
    const ::chrome_browser_certificate_transparency::CTTimestamp* p = _impl_.operator_start_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::chrome_browser_certificate_transparency::CTTimestamp&>(
                            ::chrome_browser_certificate_transparency::_CTTimestamp_default_instance_);
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLog_OperatorChange::operator_start() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.OperatorChange.operator_start)
    return _internal_operator_start();
}
inline void CTLog_OperatorChange::unsafe_arena_set_allocated_operator_start(::chrome_browser_certificate_transparency::CTTimestamp* operator_start)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operator_start_);
    }
    _impl_.operator_start_ = operator_start;
    if (operator_start) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_certificate_transparency.CTLog.OperatorChange.operator_start)
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_OperatorChange::release_operator_start()
{

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.operator_start_;
    _impl_.operator_start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_OperatorChange::unsafe_arena_release_operator_start()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.OperatorChange.operator_start)

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.operator_start_;
    _impl_.operator_start_ = nullptr;
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_OperatorChange::_internal_mutable_operator_start()
{

    if (_impl_.operator_start_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_browser_certificate_transparency::CTTimestamp>(GetArenaForAllocation());
        _impl_.operator_start_ = p;
    }
    return _impl_.operator_start_;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLog_OperatorChange::mutable_operator_start()
{
    ::chrome_browser_certificate_transparency::CTTimestamp* _msg = _internal_mutable_operator_start();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.OperatorChange.operator_start)
    return _msg;
}
inline void CTLog_OperatorChange::set_allocated_operator_start(::chrome_browser_certificate_transparency::CTTimestamp* operator_start)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.operator_start_);
    }
    if (operator_start) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(operator_start));
        if (message_arena != submessage_arena) {
            operator_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, operator_start, submessage_arena);
        }

    } else {
    }
    _impl_.operator_start_ = operator_start;
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.OperatorChange.operator_start)
}

// -------------------------------------------------------------------

// CTLog

// string description = 1;
inline void CTLog::clear_description()
{
    _impl_.description_.ClearToEmpty();
}
inline const std::string& CTLog::description() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.description)
    return _internal_description();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CTLog::set_description(ArgT0&& arg0, ArgT... args)
{

    _impl_.description_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.description)
}
inline std::string* CTLog::mutable_description()
{
    std::string* _s = _internal_mutable_description();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.description)
    return _s;
}
inline const std::string& CTLog::_internal_description() const
{
    return _impl_.description_.Get();
}
inline void CTLog::_internal_set_description(const std::string& value)
{

    _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* CTLog::_internal_mutable_description()
{

    return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* CTLog::release_description()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.description)
    return _impl_.description_.Release();
}
inline void CTLog::set_allocated_description(std::string* description)
{
    if (description != nullptr) {

    } else {
    }
    _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.description_.IsDefault()) {
        _impl_.description_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.description)
}

// string key = 2;
inline void CTLog::clear_key()
{
    _impl_.key_.ClearToEmpty();
}
inline const std::string& CTLog::key() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.key)
    return _internal_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CTLog::set_key(ArgT0&& arg0, ArgT... args)
{

    _impl_.key_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.key)
}
inline std::string* CTLog::mutable_key()
{
    std::string* _s = _internal_mutable_key();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.key)
    return _s;
}
inline const std::string& CTLog::_internal_key() const
{
    return _impl_.key_.Get();
}
inline void CTLog::_internal_set_key(const std::string& value)
{

    _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* CTLog::_internal_mutable_key()
{

    return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* CTLog::release_key()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.key)
    return _impl_.key_.Release();
}
inline void CTLog::set_allocated_key(std::string* key)
{
    if (key != nullptr) {

    } else {
    }
    _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.key_.IsDefault()) {
        _impl_.key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.key)
}

// string log_id = 3;
inline void CTLog::clear_log_id()
{
    _impl_.log_id_.ClearToEmpty();
}
inline const std::string& CTLog::log_id() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.log_id)
    return _internal_log_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CTLog::set_log_id(ArgT0&& arg0, ArgT... args)
{

    _impl_.log_id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.log_id)
}
inline std::string* CTLog::mutable_log_id()
{
    std::string* _s = _internal_mutable_log_id();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.log_id)
    return _s;
}
inline const std::string& CTLog::_internal_log_id() const
{
    return _impl_.log_id_.Get();
}
inline void CTLog::_internal_set_log_id(const std::string& value)
{

    _impl_.log_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CTLog::_internal_mutable_log_id()
{

    return _impl_.log_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CTLog::release_log_id()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.log_id)
    return _impl_.log_id_.Release();
}
inline void CTLog::set_allocated_log_id(std::string* log_id)
{
    if (log_id != nullptr) {

    } else {
    }
    _impl_.log_id_.SetAllocated(log_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.log_id_.IsDefault()) {
        _impl_.log_id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.log_id)
}

// uint64 mmd_secs = 4;
inline void CTLog::clear_mmd_secs()
{
    _impl_.mmd_secs_ = uint64_t { 0u };
}
inline uint64_t CTLog::_internal_mmd_secs() const
{
    return _impl_.mmd_secs_;
}
inline uint64_t CTLog::mmd_secs() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.mmd_secs)
    return _internal_mmd_secs();
}
inline void CTLog::_internal_set_mmd_secs(uint64_t value)
{

    _impl_.mmd_secs_ = value;
}
inline void CTLog::set_mmd_secs(uint64_t value)
{
    _internal_set_mmd_secs(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.mmd_secs)
}

// string url = 5;
inline void CTLog::clear_url()
{
    _impl_.url_.ClearToEmpty();
}
inline const std::string& CTLog::url() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.url)
    return _internal_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CTLog::set_url(ArgT0&& arg0, ArgT... args)
{

    _impl_.url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.url)
}
inline std::string* CTLog::mutable_url()
{
    std::string* _s = _internal_mutable_url();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.url)
    return _s;
}
inline const std::string& CTLog::_internal_url() const
{
    return _impl_.url_.Get();
}
inline void CTLog::_internal_set_url(const std::string& value)
{

    _impl_.url_.Set(value, GetArenaForAllocation());
}
inline std::string* CTLog::_internal_mutable_url()
{

    return _impl_.url_.Mutable(GetArenaForAllocation());
}
inline std::string* CTLog::release_url()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.url)
    return _impl_.url_.Release();
}
inline void CTLog::set_allocated_url(std::string* url)
{
    if (url != nullptr) {

    } else {
    }
    _impl_.url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.url_.IsDefault()) {
        _impl_.url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.url)
}

// .chrome_browser_certificate_transparency.CTLog.Interval temporal_interval = 6;
inline bool CTLog::_internal_has_temporal_interval() const
{
    return this != internal_default_instance() && _impl_.temporal_interval_ != nullptr;
}
inline bool CTLog::has_temporal_interval() const
{
    return _internal_has_temporal_interval();
}
inline void CTLog::clear_temporal_interval()
{
    if (GetArenaForAllocation() == nullptr && _impl_.temporal_interval_ != nullptr) {
        delete _impl_.temporal_interval_;
    }
    _impl_.temporal_interval_ = nullptr;
}
inline const ::chrome_browser_certificate_transparency::CTLog_Interval& CTLog::_internal_temporal_interval() const
{
    const ::chrome_browser_certificate_transparency::CTLog_Interval* p = _impl_.temporal_interval_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::chrome_browser_certificate_transparency::CTLog_Interval&>(
                            ::chrome_browser_certificate_transparency::_CTLog_Interval_default_instance_);
}
inline const ::chrome_browser_certificate_transparency::CTLog_Interval& CTLog::temporal_interval() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.temporal_interval)
    return _internal_temporal_interval();
}
inline void CTLog::unsafe_arena_set_allocated_temporal_interval(::chrome_browser_certificate_transparency::CTLog_Interval* temporal_interval)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.temporal_interval_);
    }
    _impl_.temporal_interval_ = temporal_interval;
    if (temporal_interval) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_certificate_transparency.CTLog.temporal_interval)
}
inline ::chrome_browser_certificate_transparency::CTLog_Interval* CTLog::release_temporal_interval()
{

    ::chrome_browser_certificate_transparency::CTLog_Interval* temp = _impl_.temporal_interval_;
    _impl_.temporal_interval_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTLog_Interval* CTLog::unsafe_arena_release_temporal_interval()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.temporal_interval)

    ::chrome_browser_certificate_transparency::CTLog_Interval* temp = _impl_.temporal_interval_;
    _impl_.temporal_interval_ = nullptr;
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTLog_Interval* CTLog::_internal_mutable_temporal_interval()
{

    if (_impl_.temporal_interval_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_browser_certificate_transparency::CTLog_Interval>(GetArenaForAllocation());
        _impl_.temporal_interval_ = p;
    }
    return _impl_.temporal_interval_;
}
inline ::chrome_browser_certificate_transparency::CTLog_Interval* CTLog::mutable_temporal_interval()
{
    ::chrome_browser_certificate_transparency::CTLog_Interval* _msg = _internal_mutable_temporal_interval();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.temporal_interval)
    return _msg;
}
inline void CTLog::set_allocated_temporal_interval(::chrome_browser_certificate_transparency::CTLog_Interval* temporal_interval)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.temporal_interval_;
    }
    if (temporal_interval) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(temporal_interval);
        if (message_arena != submessage_arena) {
            temporal_interval = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, temporal_interval, submessage_arena);
        }

    } else {
    }
    _impl_.temporal_interval_ = temporal_interval;
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.temporal_interval)
}

// .chrome_browser_certificate_transparency.CTLog.Purpose purpose = 7;
inline void CTLog::clear_purpose()
{
    _impl_.purpose_ = 0;
}
inline ::chrome_browser_certificate_transparency::CTLog_Purpose CTLog::_internal_purpose() const
{
    return static_cast<::chrome_browser_certificate_transparency::CTLog_Purpose>(_impl_.purpose_);
}
inline ::chrome_browser_certificate_transparency::CTLog_Purpose CTLog::purpose() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.purpose)
    return _internal_purpose();
}
inline void CTLog::_internal_set_purpose(::chrome_browser_certificate_transparency::CTLog_Purpose value)
{

    _impl_.purpose_ = value;
}
inline void CTLog::set_purpose(::chrome_browser_certificate_transparency::CTLog_Purpose value)
{
    _internal_set_purpose(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.purpose)
}

// repeated .chrome_browser_certificate_transparency.CTLog.State state = 8;
inline int CTLog::_internal_state_size() const
{
    return _impl_.state_.size();
}
inline int CTLog::state_size() const
{
    return _internal_state_size();
}
inline void CTLog::clear_state()
{
    _impl_.state_.Clear();
}
inline ::chrome_browser_certificate_transparency::CTLog_State* CTLog::mutable_state(int index)
{
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.state)
    return _impl_.state_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_State>* CTLog::mutable_state()
{
    // @@protoc_insertion_point(field_mutable_list:chrome_browser_certificate_transparency.CTLog.state)
    return &_impl_.state_;
}
inline const ::chrome_browser_certificate_transparency::CTLog_State& CTLog::_internal_state(int index) const
{
    return _impl_.state_.Get(index);
}
inline const ::chrome_browser_certificate_transparency::CTLog_State& CTLog::state(int index) const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.state)
    return _internal_state(index);
}
inline ::chrome_browser_certificate_transparency::CTLog_State* CTLog::_internal_add_state()
{
    return _impl_.state_.Add();
}
inline ::chrome_browser_certificate_transparency::CTLog_State* CTLog::add_state()
{
    ::chrome_browser_certificate_transparency::CTLog_State* _add = _internal_add_state();
    // @@protoc_insertion_point(field_add:chrome_browser_certificate_transparency.CTLog.state)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_State>& CTLog::state() const
{
    // @@protoc_insertion_point(field_list:chrome_browser_certificate_transparency.CTLog.state)
    return _impl_.state_;
}

// repeated .chrome_browser_certificate_transparency.CTLog.OperatorChange operator_history = 9;
inline int CTLog::_internal_operator_history_size() const
{
    return _impl_.operator_history_.size();
}
inline int CTLog::operator_history_size() const
{
    return _internal_operator_history_size();
}
inline void CTLog::clear_operator_history()
{
    _impl_.operator_history_.Clear();
}
inline ::chrome_browser_certificate_transparency::CTLog_OperatorChange* CTLog::mutable_operator_history(int index)
{
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.operator_history)
    return _impl_.operator_history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_OperatorChange>* CTLog::mutable_operator_history()
{
    // @@protoc_insertion_point(field_mutable_list:chrome_browser_certificate_transparency.CTLog.operator_history)
    return &_impl_.operator_history_;
}
inline const ::chrome_browser_certificate_transparency::CTLog_OperatorChange& CTLog::_internal_operator_history(int index) const
{
    return _impl_.operator_history_.Get(index);
}
inline const ::chrome_browser_certificate_transparency::CTLog_OperatorChange& CTLog::operator_history(int index) const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.operator_history)
    return _internal_operator_history(index);
}
inline ::chrome_browser_certificate_transparency::CTLog_OperatorChange* CTLog::_internal_add_operator_history()
{
    return _impl_.operator_history_.Add();
}
inline ::chrome_browser_certificate_transparency::CTLog_OperatorChange* CTLog::add_operator_history()
{
    ::chrome_browser_certificate_transparency::CTLog_OperatorChange* _add = _internal_add_operator_history();
    // @@protoc_insertion_point(field_add:chrome_browser_certificate_transparency.CTLog.operator_history)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog_OperatorChange>& CTLog::operator_history() const
{
    // @@protoc_insertion_point(field_list:chrome_browser_certificate_transparency.CTLog.operator_history)
    return _impl_.operator_history_;
}

// .chrome_browser_certificate_transparency.FinalTreeHead read_only_info = 16;
inline bool CTLog::_internal_has_read_only_info() const
{
    return this != internal_default_instance() && _impl_.read_only_info_ != nullptr;
}
inline bool CTLog::has_read_only_info() const
{
    return _internal_has_read_only_info();
}
inline void CTLog::clear_read_only_info()
{
    if (GetArenaForAllocation() == nullptr && _impl_.read_only_info_ != nullptr) {
        delete _impl_.read_only_info_;
    }
    _impl_.read_only_info_ = nullptr;
}
inline const ::chrome_browser_certificate_transparency::FinalTreeHead& CTLog::_internal_read_only_info() const
{
    const ::chrome_browser_certificate_transparency::FinalTreeHead* p = _impl_.read_only_info_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::chrome_browser_certificate_transparency::FinalTreeHead&>(
                            ::chrome_browser_certificate_transparency::_FinalTreeHead_default_instance_);
}
inline const ::chrome_browser_certificate_transparency::FinalTreeHead& CTLog::read_only_info() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.read_only_info)
    return _internal_read_only_info();
}
inline void CTLog::unsafe_arena_set_allocated_read_only_info(::chrome_browser_certificate_transparency::FinalTreeHead* read_only_info)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.read_only_info_);
    }
    _impl_.read_only_info_ = read_only_info;
    if (read_only_info) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_certificate_transparency.CTLog.read_only_info)
}
inline ::chrome_browser_certificate_transparency::FinalTreeHead* CTLog::release_read_only_info()
{

    ::chrome_browser_certificate_transparency::FinalTreeHead* temp = _impl_.read_only_info_;
    _impl_.read_only_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_browser_certificate_transparency::FinalTreeHead* CTLog::unsafe_arena_release_read_only_info()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLog.read_only_info)

    ::chrome_browser_certificate_transparency::FinalTreeHead* temp = _impl_.read_only_info_;
    _impl_.read_only_info_ = nullptr;
    return temp;
}
inline ::chrome_browser_certificate_transparency::FinalTreeHead* CTLog::_internal_mutable_read_only_info()
{

    if (_impl_.read_only_info_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_browser_certificate_transparency::FinalTreeHead>(GetArenaForAllocation());
        _impl_.read_only_info_ = p;
    }
    return _impl_.read_only_info_;
}
inline ::chrome_browser_certificate_transparency::FinalTreeHead* CTLog::mutable_read_only_info()
{
    ::chrome_browser_certificate_transparency::FinalTreeHead* _msg = _internal_mutable_read_only_info();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLog.read_only_info)
    return _msg;
}
inline void CTLog::set_allocated_read_only_info(::chrome_browser_certificate_transparency::FinalTreeHead* read_only_info)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.read_only_info_;
    }
    if (read_only_info) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(read_only_info);
        if (message_arena != submessage_arena) {
            read_only_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, read_only_info, submessage_arena);
        }

    } else {
    }
    _impl_.read_only_info_ = read_only_info;
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLog.read_only_info)
}

// .chrome_browser_certificate_transparency.CTLog.LogType log_type = 18;
inline void CTLog::clear_log_type()
{
    _impl_.log_type_ = 0;
}
inline ::chrome_browser_certificate_transparency::CTLog_LogType CTLog::_internal_log_type() const
{
    return static_cast<::chrome_browser_certificate_transparency::CTLog_LogType>(_impl_.log_type_);
}
inline ::chrome_browser_certificate_transparency::CTLog_LogType CTLog::log_type() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLog.log_type)
    return _internal_log_type();
}
inline void CTLog::_internal_set_log_type(::chrome_browser_certificate_transparency::CTLog_LogType value)
{

    _impl_.log_type_ = value;
}
inline void CTLog::set_log_type(::chrome_browser_certificate_transparency::CTLog_LogType value)
{
    _internal_set_log_type(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLog.log_type)
}

// -------------------------------------------------------------------

// LogOperator

// string name = 1;
inline void LogOperator::clear_name()
{
    _impl_.name_.ClearToEmpty();
}
inline const std::string& LogOperator::name() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.LogOperator.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void LogOperator::set_name(ArgT0&& arg0, ArgT... args)
{

    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.LogOperator.name)
}
inline std::string* LogOperator::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.LogOperator.name)
    return _s;
}
inline const std::string& LogOperator::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void LogOperator::_internal_set_name(const std::string& value)
{

    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* LogOperator::_internal_mutable_name()
{

    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* LogOperator::release_name()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.LogOperator.name)
    return _impl_.name_.Release();
}
inline void LogOperator::set_allocated_name(std::string* name)
{
    if (name != nullptr) {

    } else {
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.LogOperator.name)
}

// repeated string email = 2;
inline int LogOperator::_internal_email_size() const
{
    return _impl_.email_.size();
}
inline int LogOperator::email_size() const
{
    return _internal_email_size();
}
inline void LogOperator::clear_email()
{
    _impl_.email_.Clear();
}
inline std::string* LogOperator::add_email()
{
    std::string* _s = _internal_add_email();
    // @@protoc_insertion_point(field_add_mutable:chrome_browser_certificate_transparency.LogOperator.email)
    return _s;
}
inline const std::string& LogOperator::_internal_email(int index) const
{
    return _impl_.email_.Get(index);
}
inline const std::string& LogOperator::email(int index) const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.LogOperator.email)
    return _internal_email(index);
}
inline std::string* LogOperator::mutable_email(int index)
{
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.LogOperator.email)
    return _impl_.email_.Mutable(index);
}
inline void LogOperator::set_email(int index, const std::string& value)
{
    _impl_.email_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.LogOperator.email)
}
inline void LogOperator::set_email(int index, std::string&& value)
{
    _impl_.email_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.LogOperator.email)
}
inline void LogOperator::set_email(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.email_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:chrome_browser_certificate_transparency.LogOperator.email)
}
inline void LogOperator::set_email(int index, const char* value, size_t size)
{
    _impl_.email_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:chrome_browser_certificate_transparency.LogOperator.email)
}
inline std::string* LogOperator::_internal_add_email()
{
    return _impl_.email_.Add();
}
inline void LogOperator::add_email(const std::string& value)
{
    _impl_.email_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:chrome_browser_certificate_transparency.LogOperator.email)
}
inline void LogOperator::add_email(std::string&& value)
{
    _impl_.email_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:chrome_browser_certificate_transparency.LogOperator.email)
}
inline void LogOperator::add_email(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.email_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:chrome_browser_certificate_transparency.LogOperator.email)
}
inline void LogOperator::add_email(const char* value, size_t size)
{
    _impl_.email_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:chrome_browser_certificate_transparency.LogOperator.email)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& LogOperator::email() const
{
    // @@protoc_insertion_point(field_list:chrome_browser_certificate_transparency.LogOperator.email)
    return _impl_.email_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* LogOperator::mutable_email()
{
    // @@protoc_insertion_point(field_mutable_list:chrome_browser_certificate_transparency.LogOperator.email)
    return &_impl_.email_;
}

// -------------------------------------------------------------------

// CTLogList

// uint64 list_version_major = 1;
inline void CTLogList::clear_list_version_major()
{
    _impl_.list_version_major_ = uint64_t { 0u };
}
inline uint64_t CTLogList::_internal_list_version_major() const
{
    return _impl_.list_version_major_;
}
inline uint64_t CTLogList::list_version_major() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLogList.list_version_major)
    return _internal_list_version_major();
}
inline void CTLogList::_internal_set_list_version_major(uint64_t value)
{

    _impl_.list_version_major_ = value;
}
inline void CTLogList::set_list_version_major(uint64_t value)
{
    _internal_set_list_version_major(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLogList.list_version_major)
}

// uint64 list_version_minor = 2;
inline void CTLogList::clear_list_version_minor()
{
    _impl_.list_version_minor_ = uint64_t { 0u };
}
inline uint64_t CTLogList::_internal_list_version_minor() const
{
    return _impl_.list_version_minor_;
}
inline uint64_t CTLogList::list_version_minor() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLogList.list_version_minor)
    return _internal_list_version_minor();
}
inline void CTLogList::_internal_set_list_version_minor(uint64_t value)
{

    _impl_.list_version_minor_ = value;
}
inline void CTLogList::set_list_version_minor(uint64_t value)
{
    _internal_set_list_version_minor(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLogList.list_version_minor)
}

// .chrome_browser_certificate_transparency.CTTimestamp timestamp = 3;
inline bool CTLogList::_internal_has_timestamp() const
{
    return this != internal_default_instance() && _impl_.timestamp_ != nullptr;
}
inline bool CTLogList::has_timestamp() const
{
    return _internal_has_timestamp();
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLogList::_internal_timestamp() const
{
    const ::chrome_browser_certificate_transparency::CTTimestamp* p = _impl_.timestamp_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::chrome_browser_certificate_transparency::CTTimestamp&>(
                            ::chrome_browser_certificate_transparency::_CTTimestamp_default_instance_);
}
inline const ::chrome_browser_certificate_transparency::CTTimestamp& CTLogList::timestamp() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLogList.timestamp)
    return _internal_timestamp();
}
inline void CTLogList::unsafe_arena_set_allocated_timestamp(::chrome_browser_certificate_transparency::CTTimestamp* timestamp)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
    }
    _impl_.timestamp_ = timestamp;
    if (timestamp) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_browser_certificate_transparency.CTLogList.timestamp)
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLogList::release_timestamp()
{

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.timestamp_;
    _impl_.timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLogList::unsafe_arena_release_timestamp()
{
    // @@protoc_insertion_point(field_release:chrome_browser_certificate_transparency.CTLogList.timestamp)

    ::chrome_browser_certificate_transparency::CTTimestamp* temp = _impl_.timestamp_;
    _impl_.timestamp_ = nullptr;
    return temp;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLogList::_internal_mutable_timestamp()
{

    if (_impl_.timestamp_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_browser_certificate_transparency::CTTimestamp>(GetArenaForAllocation());
        _impl_.timestamp_ = p;
    }
    return _impl_.timestamp_;
}
inline ::chrome_browser_certificate_transparency::CTTimestamp* CTLogList::mutable_timestamp()
{
    ::chrome_browser_certificate_transparency::CTTimestamp* _msg = _internal_mutable_timestamp();
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLogList.timestamp)
    return _msg;
}
inline void CTLogList::set_allocated_timestamp(::chrome_browser_certificate_transparency::CTTimestamp* timestamp)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.timestamp_);
    }
    if (timestamp) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp));
        if (message_arena != submessage_arena) {
            timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, timestamp, submessage_arena);
        }

    } else {
    }
    _impl_.timestamp_ = timestamp;
    // @@protoc_insertion_point(field_set_allocated:chrome_browser_certificate_transparency.CTLogList.timestamp)
}

// uint64 compatibility_version = 4;
inline void CTLogList::clear_compatibility_version()
{
    _impl_.compatibility_version_ = uint64_t { 0u };
}
inline uint64_t CTLogList::_internal_compatibility_version() const
{
    return _impl_.compatibility_version_;
}
inline uint64_t CTLogList::compatibility_version() const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLogList.compatibility_version)
    return _internal_compatibility_version();
}
inline void CTLogList::_internal_set_compatibility_version(uint64_t value)
{

    _impl_.compatibility_version_ = value;
}
inline void CTLogList::set_compatibility_version(uint64_t value)
{
    _internal_set_compatibility_version(value);
    // @@protoc_insertion_point(field_set:chrome_browser_certificate_transparency.CTLogList.compatibility_version)
}

// repeated .chrome_browser_certificate_transparency.LogOperator operators = 5;
inline int CTLogList::_internal_operators_size() const
{
    return _impl_.operators_.size();
}
inline int CTLogList::operators_size() const
{
    return _internal_operators_size();
}
inline void CTLogList::clear_operators()
{
    _impl_.operators_.Clear();
}
inline ::chrome_browser_certificate_transparency::LogOperator* CTLogList::mutable_operators(int index)
{
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLogList.operators)
    return _impl_.operators_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::LogOperator>* CTLogList::mutable_operators()
{
    // @@protoc_insertion_point(field_mutable_list:chrome_browser_certificate_transparency.CTLogList.operators)
    return &_impl_.operators_;
}
inline const ::chrome_browser_certificate_transparency::LogOperator& CTLogList::_internal_operators(int index) const
{
    return _impl_.operators_.Get(index);
}
inline const ::chrome_browser_certificate_transparency::LogOperator& CTLogList::operators(int index) const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLogList.operators)
    return _internal_operators(index);
}
inline ::chrome_browser_certificate_transparency::LogOperator* CTLogList::_internal_add_operators()
{
    return _impl_.operators_.Add();
}
inline ::chrome_browser_certificate_transparency::LogOperator* CTLogList::add_operators()
{
    ::chrome_browser_certificate_transparency::LogOperator* _add = _internal_add_operators();
    // @@protoc_insertion_point(field_add:chrome_browser_certificate_transparency.CTLogList.operators)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::LogOperator>& CTLogList::operators() const
{
    // @@protoc_insertion_point(field_list:chrome_browser_certificate_transparency.CTLogList.operators)
    return _impl_.operators_;
}

// repeated .chrome_browser_certificate_transparency.CTLog logs = 6;
inline int CTLogList::_internal_logs_size() const
{
    return _impl_.logs_.size();
}
inline int CTLogList::logs_size() const
{
    return _internal_logs_size();
}
inline void CTLogList::clear_logs()
{
    _impl_.logs_.Clear();
}
inline ::chrome_browser_certificate_transparency::CTLog* CTLogList::mutable_logs(int index)
{
    // @@protoc_insertion_point(field_mutable:chrome_browser_certificate_transparency.CTLogList.logs)
    return _impl_.logs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog>* CTLogList::mutable_logs()
{
    // @@protoc_insertion_point(field_mutable_list:chrome_browser_certificate_transparency.CTLogList.logs)
    return &_impl_.logs_;
}
inline const ::chrome_browser_certificate_transparency::CTLog& CTLogList::_internal_logs(int index) const
{
    return _impl_.logs_.Get(index);
}
inline const ::chrome_browser_certificate_transparency::CTLog& CTLogList::logs(int index) const
{
    // @@protoc_insertion_point(field_get:chrome_browser_certificate_transparency.CTLogList.logs)
    return _internal_logs(index);
}
inline ::chrome_browser_certificate_transparency::CTLog* CTLogList::_internal_add_logs()
{
    return _impl_.logs_.Add();
}
inline ::chrome_browser_certificate_transparency::CTLog* CTLogList::add_logs()
{
    ::chrome_browser_certificate_transparency::CTLog* _add = _internal_add_logs();
    // @@protoc_insertion_point(field_add:chrome_browser_certificate_transparency.CTLogList.logs)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_browser_certificate_transparency::CTLog>& CTLogList::logs() const
{
    // @@protoc_insertion_point(field_list:chrome_browser_certificate_transparency.CTLogList.logs)
    return _impl_.logs_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace chrome_browser_certificate_transparency

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::chrome_browser_certificate_transparency::CTLog_Purpose> : ::std::true_type { };
template <> struct is_proto_enum<::chrome_browser_certificate_transparency::CTLog_CurrentState> : ::std::true_type { };
template <> struct is_proto_enum<::chrome_browser_certificate_transparency::CTLog_LogType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_certificate_5ftransparency_2eproto
