// ui/gfx/geometry/mojom/geometry.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_GFX_GEOMETRY_MOJOM_GEOMETRY_MOJOM_SHARED_H_
#define UI_GFX_GEOMETRY_MOJOM_GEOMETRY_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "ui/gfx/geometry/mojom/geometry.mojom-shared-internal.h"

namespace gfx::mojom {
class PointDataView;

class PointFDataView;

class Point3FDataView;

class SizeDataView;

class SizeFDataView;

class RectDataView;

class RectFDataView;

class InsetsDataView;

class InsetsFDataView;

class Vector2dDataView;

class Vector2dFDataView;

class Vector3dFDataView;

class QuaternionDataView;

class QuadFDataView;

} // gfx::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::gfx::mojom::PointDataView> {
    using Data = ::gfx::mojom::internal::Point_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::PointFDataView> {
    using Data = ::gfx::mojom::internal::PointF_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::Point3FDataView> {
    using Data = ::gfx::mojom::internal::Point3F_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::SizeDataView> {
    using Data = ::gfx::mojom::internal::Size_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::SizeFDataView> {
    using Data = ::gfx::mojom::internal::SizeF_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::RectDataView> {
    using Data = ::gfx::mojom::internal::Rect_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::RectFDataView> {
    using Data = ::gfx::mojom::internal::RectF_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::InsetsDataView> {
    using Data = ::gfx::mojom::internal::Insets_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::InsetsFDataView> {
    using Data = ::gfx::mojom::internal::InsetsF_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::Vector2dDataView> {
    using Data = ::gfx::mojom::internal::Vector2d_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::Vector2dFDataView> {
    using Data = ::gfx::mojom::internal::Vector2dF_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::Vector3dFDataView> {
    using Data = ::gfx::mojom::internal::Vector3dF_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::QuaternionDataView> {
    using Data = ::gfx::mojom::internal::Quaternion_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::gfx::mojom::QuadFDataView> {
    using Data = ::gfx::mojom::internal::QuadF_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace gfx::mojom {

class PointDataView {
public:
    PointDataView() = default;

    PointDataView(internal::Point_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t x() const
    {
        return data_->x;
    }
    int32_t y() const
    {
        return data_->y;
    }

private:
    internal::Point_Data* data_ = nullptr;
};

class PointFDataView {
public:
    PointFDataView() = default;

    PointFDataView(internal::PointF_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    float x() const
    {
        return data_->x;
    }
    float y() const
    {
        return data_->y;
    }

private:
    internal::PointF_Data* data_ = nullptr;
};

class Point3FDataView {
public:
    Point3FDataView() = default;

    Point3FDataView(internal::Point3F_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    float x() const
    {
        return data_->x;
    }
    float y() const
    {
        return data_->y;
    }
    float z() const
    {
        return data_->z;
    }

private:
    internal::Point3F_Data* data_ = nullptr;
};

class SizeDataView {
public:
    SizeDataView() = default;

    SizeDataView(internal::Size_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t width() const
    {
        return data_->width;
    }
    int32_t height() const
    {
        return data_->height;
    }

private:
    internal::Size_Data* data_ = nullptr;
};

class SizeFDataView {
public:
    SizeFDataView() = default;

    SizeFDataView(internal::SizeF_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    float width() const
    {
        return data_->width;
    }
    float height() const
    {
        return data_->height;
    }

private:
    internal::SizeF_Data* data_ = nullptr;
};

class RectDataView {
public:
    RectDataView() = default;

    RectDataView(internal::Rect_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t x() const
    {
        return data_->x;
    }
    int32_t y() const
    {
        return data_->y;
    }
    int32_t width() const
    {
        return data_->width;
    }
    int32_t height() const
    {
        return data_->height;
    }

private:
    internal::Rect_Data* data_ = nullptr;
};

class RectFDataView {
public:
    RectFDataView() = default;

    RectFDataView(internal::RectF_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    float x() const
    {
        return data_->x;
    }
    float y() const
    {
        return data_->y;
    }
    float width() const
    {
        return data_->width;
    }
    float height() const
    {
        return data_->height;
    }

private:
    internal::RectF_Data* data_ = nullptr;
};

class InsetsDataView {
public:
    InsetsDataView() = default;

    InsetsDataView(internal::Insets_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t top() const
    {
        return data_->top;
    }
    int32_t left() const
    {
        return data_->left;
    }
    int32_t bottom() const
    {
        return data_->bottom;
    }
    int32_t right() const
    {
        return data_->right;
    }

private:
    internal::Insets_Data* data_ = nullptr;
};

class InsetsFDataView {
public:
    InsetsFDataView() = default;

    InsetsFDataView(internal::InsetsF_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    float top() const
    {
        return data_->top;
    }
    float left() const
    {
        return data_->left;
    }
    float bottom() const
    {
        return data_->bottom;
    }
    float right() const
    {
        return data_->right;
    }

private:
    internal::InsetsF_Data* data_ = nullptr;
};

class Vector2dDataView {
public:
    Vector2dDataView() = default;

    Vector2dDataView(internal::Vector2d_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t x() const
    {
        return data_->x;
    }
    int32_t y() const
    {
        return data_->y;
    }

private:
    internal::Vector2d_Data* data_ = nullptr;
};

class Vector2dFDataView {
public:
    Vector2dFDataView() = default;

    Vector2dFDataView(internal::Vector2dF_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    float x() const
    {
        return data_->x;
    }
    float y() const
    {
        return data_->y;
    }

private:
    internal::Vector2dF_Data* data_ = nullptr;
};

class Vector3dFDataView {
public:
    Vector3dFDataView() = default;

    Vector3dFDataView(internal::Vector3dF_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    float x() const
    {
        return data_->x;
    }
    float y() const
    {
        return data_->y;
    }
    float z() const
    {
        return data_->z;
    }

private:
    internal::Vector3dF_Data* data_ = nullptr;
};

class QuaternionDataView {
public:
    QuaternionDataView() = default;

    QuaternionDataView(internal::Quaternion_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    double x() const
    {
        return data_->x;
    }
    double y() const
    {
        return data_->y;
    }
    double z() const
    {
        return data_->z;
    }
    double w() const
    {
        return data_->w;
    }

private:
    internal::Quaternion_Data* data_ = nullptr;
};

class QuadFDataView {
public:
    QuadFDataView() = default;

    QuadFDataView(internal::QuadF_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetP1DataView(PointFDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadP1(UserType* output)
    {

        auto* pointer = data_->p1.Get();
        return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(pointer, output, message_);
    }
    inline void GetP2DataView(PointFDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadP2(UserType* output)
    {

        auto* pointer = data_->p2.Get();
        return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(pointer, output, message_);
    }
    inline void GetP3DataView(PointFDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadP3(UserType* output)
    {

        auto* pointer = data_->p3.Get();
        return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(pointer, output, message_);
    }
    inline void GetP4DataView(PointFDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadP4(UserType* output)
    {

        auto* pointer = data_->p4.Get();
        return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(pointer, output, message_);
    }

private:
    internal::QuadF_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // gfx::mojom

namespace std {

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::PointDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::PointDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Point_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Point_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::PointDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::PointFDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::PointFDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::PointF_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
    }

    static bool Deserialize(::gfx::mojom::internal::PointF_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::PointFDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::Point3FDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::Point3FDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Point3F_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
        fragment->z = Traits::z(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Point3F_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::Point3FDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::SizeDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::SizeDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Size_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->width = Traits::width(input);
        fragment->height = Traits::height(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Size_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::SizeDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::SizeFDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::SizeFDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::SizeF_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->width = Traits::width(input);
        fragment->height = Traits::height(input);
    }

    static bool Deserialize(::gfx::mojom::internal::SizeF_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::SizeFDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::RectDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::RectDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Rect_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
        fragment->width = Traits::width(input);
        fragment->height = Traits::height(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Rect_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::RectDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::RectFDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::RectFDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::RectF_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
        fragment->width = Traits::width(input);
        fragment->height = Traits::height(input);
    }

    static bool Deserialize(::gfx::mojom::internal::RectF_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::RectFDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::InsetsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::InsetsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Insets_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->top = Traits::top(input);
        fragment->left = Traits::left(input);
        fragment->bottom = Traits::bottom(input);
        fragment->right = Traits::right(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Insets_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::InsetsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::InsetsFDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::InsetsFDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::InsetsF_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->top = Traits::top(input);
        fragment->left = Traits::left(input);
        fragment->bottom = Traits::bottom(input);
        fragment->right = Traits::right(input);
    }

    static bool Deserialize(::gfx::mojom::internal::InsetsF_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::InsetsFDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::Vector2dDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::Vector2dDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Vector2d_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Vector2d_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::Vector2dDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::Vector2dFDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::Vector2dFDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Vector2dF_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Vector2dF_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::Vector2dFDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::Vector3dFDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::Vector3dFDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Vector3dF_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
        fragment->z = Traits::z(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Vector3dF_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::Vector3dFDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::QuaternionDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::QuaternionDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::Quaternion_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->x = Traits::x(input);
        fragment->y = Traits::y(input);
        fragment->z = Traits::z(input);
        fragment->w = Traits::w(input);
    }

    static bool Deserialize(::gfx::mojom::internal::Quaternion_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::QuaternionDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::gfx::mojom::QuadFDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::gfx::mojom::QuadFDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::gfx::mojom::internal::QuadF_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::p1(input)) in_p1 = Traits::p1(input);
        mojo::internal::MessageFragment<typename decltype(fragment->p1)::BaseType> p1_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::PointFDataView>(in_p1, p1_fragment);
        fragment->p1.Set(p1_fragment.is_null() ? nullptr : p1_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->p1.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null p1 in QuadF struct");
        decltype(Traits::p2(input)) in_p2 = Traits::p2(input);
        mojo::internal::MessageFragment<typename decltype(fragment->p2)::BaseType> p2_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::PointFDataView>(in_p2, p2_fragment);
        fragment->p2.Set(p2_fragment.is_null() ? nullptr : p2_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->p2.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null p2 in QuadF struct");
        decltype(Traits::p3(input)) in_p3 = Traits::p3(input);
        mojo::internal::MessageFragment<typename decltype(fragment->p3)::BaseType> p3_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::PointFDataView>(in_p3, p3_fragment);
        fragment->p3.Set(p3_fragment.is_null() ? nullptr : p3_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->p3.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null p3 in QuadF struct");
        decltype(Traits::p4(input)) in_p4 = Traits::p4(input);
        mojo::internal::MessageFragment<typename decltype(fragment->p4)::BaseType> p4_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::PointFDataView>(in_p4, p4_fragment);
        fragment->p4.Set(p4_fragment.is_null() ? nullptr : p4_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->p4.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null p4 in QuadF struct");
    }

    static bool Deserialize(::gfx::mojom::internal::QuadF_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::gfx::mojom::QuadFDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace gfx::mojom {

inline void QuadFDataView::GetP1DataView(PointFDataView* output)
{
    auto pointer = data_->p1.Get();
    *output = PointFDataView(pointer, message_);
}
inline void QuadFDataView::GetP2DataView(PointFDataView* output)
{
    auto pointer = data_->p2.Get();
    *output = PointFDataView(pointer, message_);
}
inline void QuadFDataView::GetP3DataView(PointFDataView* output)
{
    auto pointer = data_->p3.Get();
    *output = PointFDataView(pointer, message_);
}
inline void QuadFDataView::GetP4DataView(PointFDataView* output)
{
    auto pointer = data_->p4.Get();
    *output = PointFDataView(pointer, message_);
}

} // gfx::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

#endif // UI_GFX_GEOMETRY_MOJOM_GEOMETRY_MOJOM_SHARED_H_
