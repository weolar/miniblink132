// ui/webui/resources/cr_components/searchbox/searchbox.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "ui/webui/resources/cr_components/searchbox/searchbox.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "ui/webui/resources/cr_components/searchbox/searchbox.mojom-params-data.h"
#include "ui/webui/resources/cr_components/searchbox/searchbox.mojom-shared-message-ids.h"

#include "ui/webui/resources/cr_components/searchbox/searchbox.mojom-import-headers.h"
#include "ui/webui/resources/cr_components/searchbox/searchbox.mojom-test-utils.h"

namespace searchbox::mojom {
ACMatchClassification::ACMatchClassification()
    : offset()
    , style()
{
}

ACMatchClassification::ACMatchClassification(uint32_t offset_in, int32_t style_in)
    : offset(std::move(offset_in))
    , style(std::move(style_in))
{
}

ACMatchClassification::~ACMatchClassification() = default;
size_t ACMatchClassification::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->offset);
    seed = mojo::internal::Hash(seed, this->style);
    return seed;
}

void ACMatchClassification::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("offset"), this->offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("style"), this->style,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ACMatchClassification::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Action::Action()
    : a11y_label()
    , hint()
    , suggestion_contents()
    , icon_url()
{
}

Action::Action(
    const ::std::u16string& a11y_label_in, const ::std::u16string& hint_in, const ::std::u16string& suggestion_contents_in, const std::string& icon_url_in)
    : a11y_label(std::move(a11y_label_in))
    , hint(std::move(hint_in))
    , suggestion_contents(std::move(suggestion_contents_in))
    , icon_url(std::move(icon_url_in))
{
}

Action::~Action() = default;

void Action::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("a11y_label"), this->a11y_label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hint"), this->hint,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("suggestion_contents"), this->suggestion_contents,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("icon_url"), this->icon_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Action::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
SuggestionAnswer::SuggestionAnswer()
    : first_line()
    , second_line()
{
}

SuggestionAnswer::SuggestionAnswer(const ::std::u16string& first_line_in, const ::std::u16string& second_line_in)
    : first_line(std::move(first_line_in))
    , second_line(std::move(second_line_in))
{
}

SuggestionAnswer::~SuggestionAnswer() = default;

void SuggestionAnswer::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("first_line"), this->first_line,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("second_line"), this->second_line,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SuggestionAnswer::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
AutocompleteMatch::AutocompleteMatch()
    : a11y_label()
    , allowed_to_be_default_match()
    , actions()
    , answer()
    , contents()
    , contents_class()
    , description()
    , description_class()
    , destination_url()
    , inline_autocompletion()
    , fill_into_edit()
    , is_weather_answer_suggestion()
    , icon_url()
    , image_dominant_color()
    , image_url()
    , is_rich_suggestion()
    , is_search_type()
    , type()
    , remove_button_a11y_label()
    , swap_contents_and_description()
    , suggestion_group_id()
    , supports_deletion()
    , tail_suggest_common_prefix()
{
}

AutocompleteMatch::AutocompleteMatch(const ::std::u16string& a11y_label_in, bool allowed_to_be_default_match_in, std::vector<ActionPtr> actions_in,
    SuggestionAnswerPtr answer_in, const ::std::u16string& contents_in, std::vector<ACMatchClassificationPtr> contents_class_in,
    const ::std::u16string& description_in, std::vector<ACMatchClassificationPtr> description_class_in, const ::GURL& destination_url_in,
    const ::std::u16string& inline_autocompletion_in, const ::std::u16string& fill_into_edit_in, std::optional<bool> is_weather_answer_suggestion_in,
    const std::string& icon_url_in, const std::string& image_dominant_color_in, const std::string& image_url_in, bool is_rich_suggestion_in,
    bool is_search_type_in, const std::string& type_in, const ::std::u16string& remove_button_a11y_label_in, bool swap_contents_and_description_in,
    int32_t suggestion_group_id_in, bool supports_deletion_in, const std::optional<::std::u16string>& tail_suggest_common_prefix_in)
    : a11y_label(std::move(a11y_label_in))
    , allowed_to_be_default_match(std::move(allowed_to_be_default_match_in))
    , actions(std::move(actions_in))
    , answer(std::move(answer_in))
    , contents(std::move(contents_in))
    , contents_class(std::move(contents_class_in))
    , description(std::move(description_in))
    , description_class(std::move(description_class_in))
    , destination_url(std::move(destination_url_in))
    , inline_autocompletion(std::move(inline_autocompletion_in))
    , fill_into_edit(std::move(fill_into_edit_in))
    , is_weather_answer_suggestion(std::move(is_weather_answer_suggestion_in))
    , icon_url(std::move(icon_url_in))
    , image_dominant_color(std::move(image_dominant_color_in))
    , image_url(std::move(image_url_in))
    , is_rich_suggestion(std::move(is_rich_suggestion_in))
    , is_search_type(std::move(is_search_type_in))
    , type(std::move(type_in))
    , remove_button_a11y_label(std::move(remove_button_a11y_label_in))
    , swap_contents_and_description(std::move(swap_contents_and_description_in))
    , suggestion_group_id(std::move(suggestion_group_id_in))
    , supports_deletion(std::move(supports_deletion_in))
    , tail_suggest_common_prefix(std::move(tail_suggest_common_prefix_in))
{
}

AutocompleteMatch::~AutocompleteMatch() = default;

void AutocompleteMatch::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("a11y_label"), this->a11y_label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("allowed_to_be_default_match"), this->allowed_to_be_default_match,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("actions"), this->actions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::vector<ActionPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("answer"), this->answer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type SuggestionAnswerPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("contents"), this->contents,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("contents_class"), this->contents_class,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::vector<ACMatchClassificationPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("description"), this->description,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("description_class"), this->description_class,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::vector<ACMatchClassificationPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("destination_url"), this->destination_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::GURL&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("inline_autocompletion"), this->inline_autocompletion,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("fill_into_edit"), this->fill_into_edit,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_weather_answer_suggestion"), this->is_weather_answer_suggestion,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<bool>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("icon_url"), this->icon_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("image_dominant_color"), this->image_dominant_color,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("image_url"), this->image_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_rich_suggestion"), this->is_rich_suggestion,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("is_search_type"), this->is_search_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("type"), this->type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("remove_button_a11y_label"), this->remove_button_a11y_label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("swap_contents_and_description"), this->swap_contents_and_description,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("suggestion_group_id"), this->suggestion_group_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("supports_deletion"), this->supports_deletion,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("tail_suggest_common_prefix"), this->tail_suggest_common_prefix,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<::std::u16string>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AutocompleteMatch::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
SuggestionGroup::SuggestionGroup()
    : header()
    , hide_group_a11y_label()
    , show_group_a11y_label()
    , hidden()
    , render_type(RenderType::kDefaultVertical)
    , side_type(SideType::kDefaultPrimary)
{
}

SuggestionGroup::SuggestionGroup(const ::std::u16string& header_in, const ::std::u16string& hide_group_a11y_label_in,
    const ::std::u16string& show_group_a11y_label_in, bool hidden_in, RenderType render_type_in, SideType side_type_in)
    : header(std::move(header_in))
    , hide_group_a11y_label(std::move(hide_group_a11y_label_in))
    , show_group_a11y_label(std::move(show_group_a11y_label_in))
    , hidden(std::move(hidden_in))
    , render_type(std::move(render_type_in))
    , side_type(std::move(side_type_in))
{
}

SuggestionGroup::~SuggestionGroup() = default;

void SuggestionGroup::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("header"), this->header,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hide_group_a11y_label"), this->hide_group_a11y_label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("show_group_a11y_label"), this->show_group_a11y_label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hidden"), this->hidden,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("render_type"), this->render_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RenderType>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("side_type"), this->side_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type SideType>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SuggestionGroup::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
AutocompleteResult::AutocompleteResult()
    : input()
    , suggestion_groups_map()
    , matches()
{
}

AutocompleteResult::AutocompleteResult(
    const ::std::u16string& input_in, base::flat_map<int32_t, SuggestionGroupPtr> suggestion_groups_map_in, std::vector<AutocompleteMatchPtr> matches_in)
    : input(std::move(input_in))
    , suggestion_groups_map(std::move(suggestion_groups_map_in))
    , matches(std::move(matches_in))
{
}

AutocompleteResult::~AutocompleteResult() = default;

void AutocompleteResult::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input"), this->input,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::std::u16string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("suggestion_groups_map"), this->suggestion_groups_map,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type base::flat_map<int32_t, SuggestionGroupPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("matches"), this->matches,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::vector<AutocompleteMatchPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AutocompleteResult::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
OmniboxPopupSelection::OmniboxPopupSelection()
    : line()
    , state()
    , action_index()
{
}

OmniboxPopupSelection::OmniboxPopupSelection(uint8_t line_in, SelectionLineState state_in, uint8_t action_index_in)
    : line(std::move(line_in))
    , state(std::move(state_in))
    , action_index(std::move(action_index_in))
{
}

OmniboxPopupSelection::~OmniboxPopupSelection() = default;
size_t OmniboxPopupSelection::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->line);
    seed = mojo::internal::Hash(seed, this->state);
    seed = mojo::internal::Hash(seed, this->action_index);
    return seed;
}

void OmniboxPopupSelection::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("line"), this->line,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint8_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("state"), this->state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type SelectionLineState>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("action_index"), this->action_index,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint8_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool OmniboxPopupSelection::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
const char PageHandler::Name_[] = "searchbox.mojom.PageHandler";

PageHandler::IPCStableHashFunction PageHandler::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::PageHandler>(message.name())) {
    case messages::PageHandler::kSetPage: {
        return &PageHandler::SetPage_Sym::IPCStableHash;
    }
    case messages::PageHandler::kOnFocusChanged: {
        return &PageHandler::OnFocusChanged_Sym::IPCStableHash;
    }
    case messages::PageHandler::kQueryAutocomplete: {
        return &PageHandler::QueryAutocomplete_Sym::IPCStableHash;
    }
    case messages::PageHandler::kStopAutocomplete: {
        return &PageHandler::StopAutocomplete_Sym::IPCStableHash;
    }
    case messages::PageHandler::kOpenAutocompleteMatch: {
        return &PageHandler::OpenAutocompleteMatch_Sym::IPCStableHash;
    }
    case messages::PageHandler::kOnNavigationLikely: {
        return &PageHandler::OnNavigationLikely_Sym::IPCStableHash;
    }
    case messages::PageHandler::kDeleteAutocompleteMatch: {
        return &PageHandler::DeleteAutocompleteMatch_Sym::IPCStableHash;
    }
    case messages::PageHandler::kToggleSuggestionGroupIdVisibility: {
        return &PageHandler::ToggleSuggestionGroupIdVisibility_Sym::IPCStableHash;
    }
    case messages::PageHandler::kExecuteAction: {
        return &PageHandler::ExecuteAction_Sym::IPCStableHash;
    }
    case messages::PageHandler::kPopupElementSizeChanged: {
        return &PageHandler::PopupElementSizeChanged_Sym::IPCStableHash;
    }
    case messages::PageHandler::kOnThumbnailRemoved: {
        return &PageHandler::OnThumbnailRemoved_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* PageHandler::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::PageHandler>(message.name())) {
        case messages::PageHandler::kSetPage:
            return "Receive searchbox::mojom::PageHandler::SetPage";
        case messages::PageHandler::kOnFocusChanged:
            return "Receive searchbox::mojom::PageHandler::OnFocusChanged";
        case messages::PageHandler::kQueryAutocomplete:
            return "Receive searchbox::mojom::PageHandler::QueryAutocomplete";
        case messages::PageHandler::kStopAutocomplete:
            return "Receive searchbox::mojom::PageHandler::StopAutocomplete";
        case messages::PageHandler::kOpenAutocompleteMatch:
            return "Receive searchbox::mojom::PageHandler::OpenAutocompleteMatch";
        case messages::PageHandler::kOnNavigationLikely:
            return "Receive searchbox::mojom::PageHandler::OnNavigationLikely";
        case messages::PageHandler::kDeleteAutocompleteMatch:
            return "Receive searchbox::mojom::PageHandler::DeleteAutocompleteMatch";
        case messages::PageHandler::kToggleSuggestionGroupIdVisibility:
            return "Receive searchbox::mojom::PageHandler::ToggleSuggestionGroupIdVisibility";
        case messages::PageHandler::kExecuteAction:
            return "Receive searchbox::mojom::PageHandler::ExecuteAction";
        case messages::PageHandler::kPopupElementSizeChanged:
            return "Receive searchbox::mojom::PageHandler::PopupElementSizeChanged";
        case messages::PageHandler::kOnThumbnailRemoved:
            return "Receive searchbox::mojom::PageHandler::OnThumbnailRemoved";
        }
    } else {
        switch (static_cast<messages::PageHandler>(message.name())) {
        case messages::PageHandler::kSetPage:
            return "Receive reply searchbox::mojom::PageHandler::SetPage";
        case messages::PageHandler::kOnFocusChanged:
            return "Receive reply searchbox::mojom::PageHandler::OnFocusChanged";
        case messages::PageHandler::kQueryAutocomplete:
            return "Receive reply searchbox::mojom::PageHandler::QueryAutocomplete";
        case messages::PageHandler::kStopAutocomplete:
            return "Receive reply searchbox::mojom::PageHandler::StopAutocomplete";
        case messages::PageHandler::kOpenAutocompleteMatch:
            return "Receive reply searchbox::mojom::PageHandler::OpenAutocompleteMatch";
        case messages::PageHandler::kOnNavigationLikely:
            return "Receive reply searchbox::mojom::PageHandler::OnNavigationLikely";
        case messages::PageHandler::kDeleteAutocompleteMatch:
            return "Receive reply searchbox::mojom::PageHandler::DeleteAutocompleteMatch";
        case messages::PageHandler::kToggleSuggestionGroupIdVisibility:
            return "Receive reply searchbox::mojom::PageHandler::ToggleSuggestionGroupIdVisibility";
        case messages::PageHandler::kExecuteAction:
            return "Receive reply searchbox::mojom::PageHandler::ExecuteAction";
        case messages::PageHandler::kPopupElementSizeChanged:
            return "Receive reply searchbox::mojom::PageHandler::PopupElementSizeChanged";
        case messages::PageHandler::kOnThumbnailRemoved:
            return "Receive reply searchbox::mojom::PageHandler::OnThumbnailRemoved";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PageHandler::SetPage_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::SetPage");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::OnFocusChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::OnFocusChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::QueryAutocomplete_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::QueryAutocomplete");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::StopAutocomplete_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::StopAutocomplete");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::OpenAutocompleteMatch_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::OpenAutocompleteMatch");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::OnNavigationLikely_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::OnNavigationLikely");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::DeleteAutocompleteMatch_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::DeleteAutocompleteMatch");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::ToggleSuggestionGroupIdVisibility_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::ToggleSuggestionGroupIdVisibility");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::ExecuteAction_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::ExecuteAction");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::PopupElementSizeChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::PopupElementSizeChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t PageHandler::OnThumbnailRemoved_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::PageHandler::OnThumbnailRemoved");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

PageHandlerProxy::PageHandlerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void PageHandlerProxy::SetPage(::mojo::PendingRemote<Page> in_page)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::SetPage", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("page"), in_page, "<value of type ::mojo::PendingRemote<Page>>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kSetPage), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_SetPage_Params_Data> params(message);
    params.Allocate();
    mojo::internal::Serialize<mojo::InterfacePtrDataView<::searchbox::mojom::PageInterfaceBase>>(in_page, &params->page, &params.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(!mojo::internal::IsHandleOrInterfaceValid(params->page),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE, "invalid page in PageHandler.SetPage request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("SetPage");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::OnFocusChanged(bool in_focused)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::OnFocusChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("focused"), in_focused, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kOnFocusChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_OnFocusChanged_Params_Data> params(message);
    params.Allocate();
    params->focused = in_focused;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("OnFocusChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::QueryAutocomplete(const ::std::u16string& in_input, bool in_prevent_inline_autocomplete)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::QueryAutocomplete", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input"), in_input, "<value of type const ::std::u16string&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("prevent_inline_autocomplete"), in_prevent_inline_autocomplete, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kQueryAutocomplete), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_QueryAutocomplete_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->input)::BaseType> input_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_input, input_fragment);
    params->input.Set(input_fragment.is_null() ? nullptr : input_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->input.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null input in PageHandler.QueryAutocomplete request");
    params->prevent_inline_autocomplete = in_prevent_inline_autocomplete;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("QueryAutocomplete");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::StopAutocomplete(bool in_clear_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::StopAutocomplete", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("clear_result"), in_clear_result, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kStopAutocomplete), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_StopAutocomplete_Params_Data> params(message);
    params.Allocate();
    params->clear_result = in_clear_result;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("StopAutocomplete");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::OpenAutocompleteMatch(uint8_t in_line, const ::GURL& in_url, bool in_are_matches_showing, uint8_t in_mouse_button, bool in_alt_key,
    bool in_ctrl_key, bool in_meta_key, bool in_shift_key)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::OpenAutocompleteMatch", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("line"), in_line, "<value of type uint8_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::GURL&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("are_matches_showing"), in_are_matches_showing, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mouse_button"), in_mouse_button, "<value of type uint8_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alt_key"), in_alt_key, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ctrl_key"), in_ctrl_key, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("meta_key"), in_meta_key, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("shift_key"), in_shift_key, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kOpenAutocompleteMatch), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_OpenAutocompleteMatch_Params_Data> params(message);
    params.Allocate();
    params->line = in_line;
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in PageHandler.OpenAutocompleteMatch request");
    params->are_matches_showing = in_are_matches_showing;
    params->mouse_button = in_mouse_button;
    params->alt_key = in_alt_key;
    params->ctrl_key = in_ctrl_key;
    params->meta_key = in_meta_key;
    params->shift_key = in_shift_key;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("OpenAutocompleteMatch");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::OnNavigationLikely(uint8_t in_line, const ::GURL& in_url, ::omnibox::mojom::NavigationPredictor in_navigation_predictor)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::OnNavigationLikely", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("line"), in_line, "<value of type uint8_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::GURL&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("navigation_predictor"), in_navigation_predictor, "<value of type ::omnibox::mojom::NavigationPredictor>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kOnNavigationLikely), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_OnNavigationLikely_Params_Data> params(message);
    params.Allocate();
    params->line = in_line;
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in PageHandler.OnNavigationLikely request");
    mojo::internal::Serialize<::omnibox::mojom::NavigationPredictor>(in_navigation_predictor, &params->navigation_predictor);

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("OnNavigationLikely");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::DeleteAutocompleteMatch(uint8_t in_line, const ::GURL& in_url)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::DeleteAutocompleteMatch", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("line"), in_line, "<value of type uint8_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::GURL&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kDeleteAutocompleteMatch), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_DeleteAutocompleteMatch_Params_Data> params(message);
    params.Allocate();
    params->line = in_line;
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in PageHandler.DeleteAutocompleteMatch request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("DeleteAutocompleteMatch");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::ToggleSuggestionGroupIdVisibility(int32_t in_suggestion_group_id)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::ToggleSuggestionGroupIdVisibility", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("suggestion_group_id"), in_suggestion_group_id, "<value of type int32_t>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kToggleSuggestionGroupIdVisibility), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_ToggleSuggestionGroupIdVisibility_Params_Data> params(message);
    params.Allocate();
    params->suggestion_group_id = in_suggestion_group_id;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("ToggleSuggestionGroupIdVisibility");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::ExecuteAction(uint8_t in_line, uint8_t in_action_index, const ::GURL& in_url, ::base::TimeTicks in_match_selection_timestamp,
    uint8_t in_mouse_button, bool in_alt_key, bool in_ctrl_key, bool in_meta_key, bool in_shift_key)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::ExecuteAction", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("line"), in_line, "<value of type uint8_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("action_index"), in_action_index, "<value of type uint8_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("url"), in_url, "<value of type const ::GURL&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("match_selection_timestamp"), in_match_selection_timestamp, "<value of type ::base::TimeTicks>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mouse_button"), in_mouse_button, "<value of type uint8_t>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alt_key"), in_alt_key, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ctrl_key"), in_ctrl_key, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("meta_key"), in_meta_key, "<value of type bool>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("shift_key"), in_shift_key, "<value of type bool>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kExecuteAction), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_ExecuteAction_Params_Data> params(message);
    params.Allocate();
    params->line = in_line;
    params->action_index = in_action_index;
    mojo::internal::MessageFragment<typename decltype(params->url)::BaseType> url_fragment(params.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
    params->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null url in PageHandler.ExecuteAction request");
    mojo::internal::MessageFragment<typename decltype(params->match_selection_timestamp)::BaseType> match_selection_timestamp_fragment(params.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(in_match_selection_timestamp, match_selection_timestamp_fragment);
    params->match_selection_timestamp.Set(match_selection_timestamp_fragment.is_null() ? nullptr : match_selection_timestamp_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->match_selection_timestamp.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null match_selection_timestamp in PageHandler.ExecuteAction request");
    params->mouse_button = in_mouse_button;
    params->alt_key = in_alt_key;
    params->ctrl_key = in_ctrl_key;
    params->meta_key = in_meta_key;
    params->shift_key = in_shift_key;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("ExecuteAction");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::PopupElementSizeChanged(const ::gfx::Size& in_size)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::PageHandler::PopupElementSizeChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("size"), in_size, "<value of type const ::gfx::Size&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kPopupElementSizeChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_PopupElementSizeChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->size)::BaseType> size_fragment(params.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_size, size_fragment);
    params->size.Set(size_fragment.is_null() ? nullptr : size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null size in PageHandler.PopupElementSizeChanged request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("PopupElementSizeChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageHandlerProxy::OnThumbnailRemoved()
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT0("mojom", "Send searchbox::mojom::PageHandler::OnThumbnailRemoved");
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::PageHandler::kOnThumbnailRemoved), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::PageHandler_OnThumbnailRemoved_Params_Data> params(message);
    params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(PageHandler::Name_);
    message.set_method_name("OnThumbnailRemoved");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool PageHandlerStubDispatch::Accept(PageHandler* impl, mojo::Message* message)
{
    switch (static_cast<messages::PageHandler>(message->header()->name)) {
    case messages::PageHandler::kSetPage: {
        DCHECK(message->is_serialized());
        internal::PageHandler_SetPage_Params_Data* params = reinterpret_cast<internal::PageHandler_SetPage_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.0
        bool success = true;
        ::mojo::PendingRemote<Page> p_page {};
        PageHandler_SetPage_ParamsDataView input_data_view(params, message);

        if (success) {
            p_page = input_data_view.TakePage<decltype(p_page)>();
        }
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 0, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetPage(std::move(p_page));
        return true;
    }
    case messages::PageHandler::kOnFocusChanged: {
        DCHECK(message->is_serialized());
        internal::PageHandler_OnFocusChanged_Params_Data* params
            = reinterpret_cast<internal::PageHandler_OnFocusChanged_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.1
        bool success = true;
        bool p_focused {};
        PageHandler_OnFocusChanged_ParamsDataView input_data_view(params, message);

        if (success)
            p_focused = input_data_view.focused();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnFocusChanged(std::move(p_focused));
        return true;
    }
    case messages::PageHandler::kQueryAutocomplete: {
        DCHECK(message->is_serialized());
        internal::PageHandler_QueryAutocomplete_Params_Data* params
            = reinterpret_cast<internal::PageHandler_QueryAutocomplete_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.2
        bool success = true;
        ::std::u16string p_input {};
        bool p_prevent_inline_autocomplete {};
        PageHandler_QueryAutocomplete_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadInput(&p_input))
            success = false;
        if (success)
            p_prevent_inline_autocomplete = input_data_view.prevent_inline_autocomplete();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 2, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->QueryAutocomplete(std::move(p_input), std::move(p_prevent_inline_autocomplete));
        return true;
    }
    case messages::PageHandler::kStopAutocomplete: {
        DCHECK(message->is_serialized());
        internal::PageHandler_StopAutocomplete_Params_Data* params
            = reinterpret_cast<internal::PageHandler_StopAutocomplete_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.3
        bool success = true;
        bool p_clear_result {};
        PageHandler_StopAutocomplete_ParamsDataView input_data_view(params, message);

        if (success)
            p_clear_result = input_data_view.clear_result();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 3, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->StopAutocomplete(std::move(p_clear_result));
        return true;
    }
    case messages::PageHandler::kOpenAutocompleteMatch: {
        DCHECK(message->is_serialized());
        internal::PageHandler_OpenAutocompleteMatch_Params_Data* params
            = reinterpret_cast<internal::PageHandler_OpenAutocompleteMatch_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.4
        bool success = true;
        uint8_t p_line {};
        ::GURL p_url {};
        bool p_are_matches_showing {};
        uint8_t p_mouse_button {};
        bool p_alt_key {};
        bool p_ctrl_key {};
        bool p_meta_key {};
        bool p_shift_key {};
        PageHandler_OpenAutocompleteMatch_ParamsDataView input_data_view(params, message);

        if (success)
            p_line = input_data_view.line();
        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (success)
            p_are_matches_showing = input_data_view.are_matches_showing();
        if (success)
            p_mouse_button = input_data_view.mouse_button();
        if (success)
            p_alt_key = input_data_view.alt_key();
        if (success)
            p_ctrl_key = input_data_view.ctrl_key();
        if (success)
            p_meta_key = input_data_view.meta_key();
        if (success)
            p_shift_key = input_data_view.shift_key();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 4, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OpenAutocompleteMatch(std::move(p_line), std::move(p_url), std::move(p_are_matches_showing), std::move(p_mouse_button), std::move(p_alt_key),
            std::move(p_ctrl_key), std::move(p_meta_key), std::move(p_shift_key));
        return true;
    }
    case messages::PageHandler::kOnNavigationLikely: {
        DCHECK(message->is_serialized());
        internal::PageHandler_OnNavigationLikely_Params_Data* params
            = reinterpret_cast<internal::PageHandler_OnNavigationLikely_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.5
        bool success = true;
        uint8_t p_line {};
        ::GURL p_url {};
        ::omnibox::mojom::NavigationPredictor p_navigation_predictor {};
        PageHandler_OnNavigationLikely_ParamsDataView input_data_view(params, message);

        if (success)
            p_line = input_data_view.line();
        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (success && !input_data_view.ReadNavigationPredictor(&p_navigation_predictor))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 5, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnNavigationLikely(std::move(p_line), std::move(p_url), std::move(p_navigation_predictor));
        return true;
    }
    case messages::PageHandler::kDeleteAutocompleteMatch: {
        DCHECK(message->is_serialized());
        internal::PageHandler_DeleteAutocompleteMatch_Params_Data* params
            = reinterpret_cast<internal::PageHandler_DeleteAutocompleteMatch_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.6
        bool success = true;
        uint8_t p_line {};
        ::GURL p_url {};
        PageHandler_DeleteAutocompleteMatch_ParamsDataView input_data_view(params, message);

        if (success)
            p_line = input_data_view.line();
        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 6, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->DeleteAutocompleteMatch(std::move(p_line), std::move(p_url));
        return true;
    }
    case messages::PageHandler::kToggleSuggestionGroupIdVisibility: {
        DCHECK(message->is_serialized());
        internal::PageHandler_ToggleSuggestionGroupIdVisibility_Params_Data* params
            = reinterpret_cast<internal::PageHandler_ToggleSuggestionGroupIdVisibility_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.7
        bool success = true;
        int32_t p_suggestion_group_id {};
        PageHandler_ToggleSuggestionGroupIdVisibility_ParamsDataView input_data_view(params, message);

        if (success)
            p_suggestion_group_id = input_data_view.suggestion_group_id();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 7, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ToggleSuggestionGroupIdVisibility(std::move(p_suggestion_group_id));
        return true;
    }
    case messages::PageHandler::kExecuteAction: {
        DCHECK(message->is_serialized());
        internal::PageHandler_ExecuteAction_Params_Data* params
            = reinterpret_cast<internal::PageHandler_ExecuteAction_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.8
        bool success = true;
        uint8_t p_line {};
        uint8_t p_action_index {};
        ::GURL p_url {};
        ::base::TimeTicks p_match_selection_timestamp {};
        uint8_t p_mouse_button {};
        bool p_alt_key {};
        bool p_ctrl_key {};
        bool p_meta_key {};
        bool p_shift_key {};
        PageHandler_ExecuteAction_ParamsDataView input_data_view(params, message);

        if (success)
            p_line = input_data_view.line();
        if (success)
            p_action_index = input_data_view.action_index();
        if (success && !input_data_view.ReadUrl(&p_url))
            success = false;
        if (success && !input_data_view.ReadMatchSelectionTimestamp(&p_match_selection_timestamp))
            success = false;
        if (success)
            p_mouse_button = input_data_view.mouse_button();
        if (success)
            p_alt_key = input_data_view.alt_key();
        if (success)
            p_ctrl_key = input_data_view.ctrl_key();
        if (success)
            p_meta_key = input_data_view.meta_key();
        if (success)
            p_shift_key = input_data_view.shift_key();
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 8, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->ExecuteAction(std::move(p_line), std::move(p_action_index), std::move(p_url), std::move(p_match_selection_timestamp), std::move(p_mouse_button),
            std::move(p_alt_key), std::move(p_ctrl_key), std::move(p_meta_key), std::move(p_shift_key));
        return true;
    }
    case messages::PageHandler::kPopupElementSizeChanged: {
        DCHECK(message->is_serialized());
        internal::PageHandler_PopupElementSizeChanged_Params_Data* params
            = reinterpret_cast<internal::PageHandler_PopupElementSizeChanged_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.9
        bool success = true;
        ::gfx::Size p_size {};
        PageHandler_PopupElementSizeChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadSize(&p_size))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 9, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->PopupElementSizeChanged(std::move(p_size));
        return true;
    }
    case messages::PageHandler::kOnThumbnailRemoved: {
        DCHECK(message->is_serialized());
        internal::PageHandler_OnThumbnailRemoved_Params_Data* params
            = reinterpret_cast<internal::PageHandler_OnThumbnailRemoved_Params_Data*>(message->mutable_payload());

        // Validation for PageHandler.10
        bool success = true;
        PageHandler_OnThumbnailRemoved_ParamsDataView input_data_view(params, message);

        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, PageHandler::Name_, 10, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->OnThumbnailRemoved();
        return true;
    }
    }
    return false;
}

// static
bool PageHandlerStubDispatch::AcceptWithResponder(PageHandler* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::PageHandler>(message->header()->name)) {
    case messages::PageHandler::kSetPage: {
        break;
    }
    case messages::PageHandler::kOnFocusChanged: {
        break;
    }
    case messages::PageHandler::kQueryAutocomplete: {
        break;
    }
    case messages::PageHandler::kStopAutocomplete: {
        break;
    }
    case messages::PageHandler::kOpenAutocompleteMatch: {
        break;
    }
    case messages::PageHandler::kOnNavigationLikely: {
        break;
    }
    case messages::PageHandler::kDeleteAutocompleteMatch: {
        break;
    }
    case messages::PageHandler::kToggleSuggestionGroupIdVisibility: {
        break;
    }
    case messages::PageHandler::kExecuteAction: {
        break;
    }
    case messages::PageHandler::kPopupElementSizeChanged: {
        break;
    }
    case messages::PageHandler::kOnThumbnailRemoved: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kPageHandlerValidationInfo[] = {
    { &internal::PageHandler_SetPage_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_OnFocusChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_QueryAutocomplete_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_StopAutocomplete_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_OpenAutocompleteMatch_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_OnNavigationLikely_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_DeleteAutocompleteMatch_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_ToggleSuggestionGroupIdVisibility_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_ExecuteAction_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_PopupElementSizeChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::PageHandler_OnThumbnailRemoved_Params_Data::Validate, nullptr /* no response */ },
};

bool PageHandlerRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::searchbox::mojom::PageHandler::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kPageHandlerValidationInfo);
}

const char Page::Name_[] = "searchbox.mojom.Page";

Page::IPCStableHashFunction Page::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::Page>(message.name())) {
    case messages::Page::kAutocompleteResultChanged: {
        return &Page::AutocompleteResultChanged_Sym::IPCStableHash;
    }
    case messages::Page::kUpdateSelection: {
        return &Page::UpdateSelection_Sym::IPCStableHash;
    }
    case messages::Page::kSetInputText: {
        return &Page::SetInputText_Sym::IPCStableHash;
    }
    case messages::Page::kSetThumbnail: {
        return &Page::SetThumbnail_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* Page::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::Page>(message.name())) {
        case messages::Page::kAutocompleteResultChanged:
            return "Receive searchbox::mojom::Page::AutocompleteResultChanged";
        case messages::Page::kUpdateSelection:
            return "Receive searchbox::mojom::Page::UpdateSelection";
        case messages::Page::kSetInputText:
            return "Receive searchbox::mojom::Page::SetInputText";
        case messages::Page::kSetThumbnail:
            return "Receive searchbox::mojom::Page::SetThumbnail";
        }
    } else {
        switch (static_cast<messages::Page>(message.name())) {
        case messages::Page::kAutocompleteResultChanged:
            return "Receive reply searchbox::mojom::Page::AutocompleteResultChanged";
        case messages::Page::kUpdateSelection:
            return "Receive reply searchbox::mojom::Page::UpdateSelection";
        case messages::Page::kSetInputText:
            return "Receive reply searchbox::mojom::Page::SetInputText";
        case messages::Page::kSetThumbnail:
            return "Receive reply searchbox::mojom::Page::SetThumbnail";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t Page::AutocompleteResultChanged_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::Page::AutocompleteResultChanged");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t Page::UpdateSelection_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::Page::UpdateSelection");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t Page::SetInputText_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::Page::SetInputText");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t Page::SetThumbnail_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)searchbox::mojom::Page::SetThumbnail");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

PageProxy::PageProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void PageProxy::AutocompleteResultChanged(AutocompleteResultPtr in_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::Page::AutocompleteResultChanged", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), in_result, "<value of type AutocompleteResultPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::Page::kAutocompleteResultChanged), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::Page_AutocompleteResultChanged_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->result)::BaseType> result_fragment(params.message());
    mojo::internal::Serialize<::searchbox::mojom::AutocompleteResultDataView>(in_result, result_fragment);
    params->result.Set(result_fragment.is_null() ? nullptr : result_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null result in Page.AutocompleteResultChanged request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(Page::Name_);
    message.set_method_name("AutocompleteResultChanged");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageProxy::UpdateSelection(OmniboxPopupSelectionPtr in_old_selection, OmniboxPopupSelectionPtr in_selection)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::Page::UpdateSelection", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("old_selection"), in_old_selection, "<value of type OmniboxPopupSelectionPtr>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("selection"), in_selection, "<value of type OmniboxPopupSelectionPtr>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::Page::kUpdateSelection), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::Page_UpdateSelection_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->old_selection)::BaseType> old_selection_fragment(params.message());
    mojo::internal::Serialize<::searchbox::mojom::OmniboxPopupSelectionDataView>(in_old_selection, old_selection_fragment);
    params->old_selection.Set(old_selection_fragment.is_null() ? nullptr : old_selection_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->old_selection.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null old_selection in Page.UpdateSelection request");
    mojo::internal::MessageFragment<typename decltype(params->selection)::BaseType> selection_fragment(params.message());
    mojo::internal::Serialize<::searchbox::mojom::OmniboxPopupSelectionDataView>(in_selection, selection_fragment);
    params->selection.Set(selection_fragment.is_null() ? nullptr : selection_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->selection.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null selection in Page.UpdateSelection request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(Page::Name_);
    message.set_method_name("UpdateSelection");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageProxy::SetInputText(const std::string& in_input)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::Page::SetInputText", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input"), in_input, "<value of type const std::string&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::Page::kSetInputText), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::Page_SetInputText_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->input)::BaseType> input_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_input, input_fragment);
    params->input.Set(input_fragment.is_null() ? nullptr : input_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->input.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null input in Page.SetInputText request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(Page::Name_);
    message.set_method_name("SetInputText");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PageProxy::SetThumbnail(const std::string& in_thumbnail_url)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send searchbox::mojom::Page::SetThumbnail", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("thumbnail_url"), in_thumbnail_url, "<value of type const std::string&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::Page::kSetThumbnail), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::searchbox::mojom::internal::Page_SetThumbnail_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->thumbnail_url)::BaseType> thumbnail_url_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_thumbnail_url, thumbnail_url_fragment);
    params->thumbnail_url.Set(thumbnail_url_fragment.is_null() ? nullptr : thumbnail_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->thumbnail_url.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null thumbnail_url in Page.SetThumbnail request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(Page::Name_);
    message.set_method_name("SetThumbnail");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool PageStubDispatch::Accept(Page* impl, mojo::Message* message)
{
    switch (static_cast<messages::Page>(message->header()->name)) {
    case messages::Page::kAutocompleteResultChanged: {
        DCHECK(message->is_serialized());
        internal::Page_AutocompleteResultChanged_Params_Data* params
            = reinterpret_cast<internal::Page_AutocompleteResultChanged_Params_Data*>(message->mutable_payload());

        // Validation for Page.0
        bool success = true;
        AutocompleteResultPtr p_result {};
        Page_AutocompleteResultChanged_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadResult(&p_result))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, Page::Name_, 0, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->AutocompleteResultChanged(std::move(p_result));
        return true;
    }
    case messages::Page::kUpdateSelection: {
        DCHECK(message->is_serialized());
        internal::Page_UpdateSelection_Params_Data* params = reinterpret_cast<internal::Page_UpdateSelection_Params_Data*>(message->mutable_payload());

        // Validation for Page.1
        bool success = true;
        OmniboxPopupSelectionPtr p_old_selection {};
        OmniboxPopupSelectionPtr p_selection {};
        Page_UpdateSelection_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadOldSelection(&p_old_selection))
            success = false;
        if (success && !input_data_view.ReadSelection(&p_selection))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, Page::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->UpdateSelection(std::move(p_old_selection), std::move(p_selection));
        return true;
    }
    case messages::Page::kSetInputText: {
        DCHECK(message->is_serialized());
        internal::Page_SetInputText_Params_Data* params = reinterpret_cast<internal::Page_SetInputText_Params_Data*>(message->mutable_payload());

        // Validation for Page.2
        bool success = true;
        std::string p_input {};
        Page_SetInputText_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadInput(&p_input))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, Page::Name_, 2, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetInputText(std::move(p_input));
        return true;
    }
    case messages::Page::kSetThumbnail: {
        DCHECK(message->is_serialized());
        internal::Page_SetThumbnail_Params_Data* params = reinterpret_cast<internal::Page_SetThumbnail_Params_Data*>(message->mutable_payload());

        // Validation for Page.3
        bool success = true;
        std::string p_thumbnail_url {};
        Page_SetThumbnail_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadThumbnailUrl(&p_thumbnail_url))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, Page::Name_, 3, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetThumbnail(std::move(p_thumbnail_url));
        return true;
    }
    }
    return false;
}

// static
bool PageStubDispatch::AcceptWithResponder(Page* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::Page>(message->header()->name)) {
    case messages::Page::kAutocompleteResultChanged: {
        break;
    }
    case messages::Page::kUpdateSelection: {
        break;
    }
    case messages::Page::kSetInputText: {
        break;
    }
    case messages::Page::kSetThumbnail: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kPageValidationInfo[] = {
    { &internal::Page_AutocompleteResultChanged_Params_Data::Validate, nullptr /* no response */ },
    { &internal::Page_UpdateSelection_Params_Data::Validate, nullptr /* no response */ },
    { &internal::Page_SetInputText_Params_Data::Validate, nullptr /* no response */ },
    { &internal::Page_SetThumbnail_Params_Data::Validate, nullptr /* no response */ },
};

bool PageRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::searchbox::mojom::Page::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kPageValidationInfo);
}

} // searchbox::mojom

namespace mojo {

// static
bool StructTraits<::searchbox::mojom::ACMatchClassification::DataView, ::searchbox::mojom::ACMatchClassificationPtr>::Read(
    ::searchbox::mojom::ACMatchClassification::DataView input, ::searchbox::mojom::ACMatchClassificationPtr* output)
{
    bool success = true;
    ::searchbox::mojom::ACMatchClassificationPtr result(::searchbox::mojom::ACMatchClassification::New());

    if (success)
        result->offset = input.offset();
    if (success)
        result->style = input.style();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::searchbox::mojom::Action::DataView, ::searchbox::mojom::ActionPtr>::Read(
    ::searchbox::mojom::Action::DataView input, ::searchbox::mojom::ActionPtr* output)
{
    bool success = true;
    ::searchbox::mojom::ActionPtr result(::searchbox::mojom::Action::New());

    if (success && !input.ReadA11yLabel(&result->a11y_label))
        success = false;
    if (success && !input.ReadHint(&result->hint))
        success = false;
    if (success && !input.ReadSuggestionContents(&result->suggestion_contents))
        success = false;
    if (success && !input.ReadIconUrl(&result->icon_url))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::searchbox::mojom::SuggestionAnswer::DataView, ::searchbox::mojom::SuggestionAnswerPtr>::Read(
    ::searchbox::mojom::SuggestionAnswer::DataView input, ::searchbox::mojom::SuggestionAnswerPtr* output)
{
    bool success = true;
    ::searchbox::mojom::SuggestionAnswerPtr result(::searchbox::mojom::SuggestionAnswer::New());

    if (success && !input.ReadFirstLine(&result->first_line))
        success = false;
    if (success && !input.ReadSecondLine(&result->second_line))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::searchbox::mojom::AutocompleteMatch::DataView, ::searchbox::mojom::AutocompleteMatchPtr>::Read(
    ::searchbox::mojom::AutocompleteMatch::DataView input, ::searchbox::mojom::AutocompleteMatchPtr* output)
{
    bool success = true;
    ::searchbox::mojom::AutocompleteMatchPtr result(::searchbox::mojom::AutocompleteMatch::New());

    if (success && !input.ReadA11yLabel(&result->a11y_label))
        success = false;
    if (success)
        result->allowed_to_be_default_match = input.allowed_to_be_default_match();
    if (success && !input.ReadActions(&result->actions))
        success = false;
    if (success && !input.ReadAnswer(&result->answer))
        success = false;
    if (success && !input.ReadContents(&result->contents))
        success = false;
    if (success && !input.ReadContentsClass(&result->contents_class))
        success = false;
    if (success && !input.ReadDescription(&result->description))
        success = false;
    if (success && !input.ReadDescriptionClass(&result->description_class))
        success = false;
    if (success && !input.ReadDestinationUrl(&result->destination_url))
        success = false;
    if (success && !input.ReadInlineAutocompletion(&result->inline_autocompletion))
        success = false;
    if (success && !input.ReadFillIntoEdit(&result->fill_into_edit))
        success = false;
    if (success) {
        result->is_weather_answer_suggestion = input.is_weather_answer_suggestion();
    }
    if (success && !input.ReadIconUrl(&result->icon_url))
        success = false;
    if (success && !input.ReadImageDominantColor(&result->image_dominant_color))
        success = false;
    if (success && !input.ReadImageUrl(&result->image_url))
        success = false;
    if (success)
        result->is_rich_suggestion = input.is_rich_suggestion();
    if (success)
        result->is_search_type = input.is_search_type();
    if (success && !input.ReadType(&result->type))
        success = false;
    if (success && !input.ReadRemoveButtonA11yLabel(&result->remove_button_a11y_label))
        success = false;
    if (success)
        result->swap_contents_and_description = input.swap_contents_and_description();
    if (success)
        result->suggestion_group_id = input.suggestion_group_id();
    if (success)
        result->supports_deletion = input.supports_deletion();
    if (success && !input.ReadTailSuggestCommonPrefix(&result->tail_suggest_common_prefix))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::searchbox::mojom::SuggestionGroup::DataView, ::searchbox::mojom::SuggestionGroupPtr>::Read(
    ::searchbox::mojom::SuggestionGroup::DataView input, ::searchbox::mojom::SuggestionGroupPtr* output)
{
    bool success = true;
    ::searchbox::mojom::SuggestionGroupPtr result(::searchbox::mojom::SuggestionGroup::New());

    if (success && !input.ReadHeader(&result->header))
        success = false;
    if (success && !input.ReadHideGroupA11yLabel(&result->hide_group_a11y_label))
        success = false;
    if (success && !input.ReadShowGroupA11yLabel(&result->show_group_a11y_label))
        success = false;
    if (success)
        result->hidden = input.hidden();
    if (success && !input.ReadRenderType(&result->render_type))
        success = false;
    if (success && !input.ReadSideType(&result->side_type))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::searchbox::mojom::AutocompleteResult::DataView, ::searchbox::mojom::AutocompleteResultPtr>::Read(
    ::searchbox::mojom::AutocompleteResult::DataView input, ::searchbox::mojom::AutocompleteResultPtr* output)
{
    bool success = true;
    ::searchbox::mojom::AutocompleteResultPtr result(::searchbox::mojom::AutocompleteResult::New());

    if (success && !input.ReadInput(&result->input))
        success = false;
    if (success && !input.ReadSuggestionGroupsMap(&result->suggestion_groups_map))
        success = false;
    if (success && !input.ReadMatches(&result->matches))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::searchbox::mojom::OmniboxPopupSelection::DataView, ::searchbox::mojom::OmniboxPopupSelectionPtr>::Read(
    ::searchbox::mojom::OmniboxPopupSelection::DataView input, ::searchbox::mojom::OmniboxPopupSelectionPtr* output)
{
    bool success = true;
    ::searchbox::mojom::OmniboxPopupSelectionPtr result(::searchbox::mojom::OmniboxPopupSelection::New());

    if (success)
        result->line = input.line();
    if (success && !input.ReadState(&result->state))
        success = false;
    if (success)
        result->action_index = input.action_index();
    *output = std::move(result);
    return success;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace searchbox::mojom {

void PageHandlerInterceptorForTesting::SetPage(::mojo::PendingRemote<Page> page)
{
    GetForwardingInterface()->SetPage(std::move(page));
}
void PageHandlerInterceptorForTesting::OnFocusChanged(bool focused)
{
    GetForwardingInterface()->OnFocusChanged(std::move(focused));
}
void PageHandlerInterceptorForTesting::QueryAutocomplete(const ::std::u16string& input, bool prevent_inline_autocomplete)
{
    GetForwardingInterface()->QueryAutocomplete(std::move(input), std::move(prevent_inline_autocomplete));
}
void PageHandlerInterceptorForTesting::StopAutocomplete(bool clear_result)
{
    GetForwardingInterface()->StopAutocomplete(std::move(clear_result));
}
void PageHandlerInterceptorForTesting::OpenAutocompleteMatch(
    uint8_t line, const ::GURL& url, bool are_matches_showing, uint8_t mouse_button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key)
{
    GetForwardingInterface()->OpenAutocompleteMatch(std::move(line), std::move(url), std::move(are_matches_showing), std::move(mouse_button),
        std::move(alt_key), std::move(ctrl_key), std::move(meta_key), std::move(shift_key));
}
void PageHandlerInterceptorForTesting::OnNavigationLikely(uint8_t line, const ::GURL& url, ::omnibox::mojom::NavigationPredictor navigation_predictor)
{
    GetForwardingInterface()->OnNavigationLikely(std::move(line), std::move(url), std::move(navigation_predictor));
}
void PageHandlerInterceptorForTesting::DeleteAutocompleteMatch(uint8_t line, const ::GURL& url)
{
    GetForwardingInterface()->DeleteAutocompleteMatch(std::move(line), std::move(url));
}
void PageHandlerInterceptorForTesting::ToggleSuggestionGroupIdVisibility(int32_t suggestion_group_id)
{
    GetForwardingInterface()->ToggleSuggestionGroupIdVisibility(std::move(suggestion_group_id));
}
void PageHandlerInterceptorForTesting::ExecuteAction(uint8_t line, uint8_t action_index, const ::GURL& url, ::base::TimeTicks match_selection_timestamp,
    uint8_t mouse_button, bool alt_key, bool ctrl_key, bool meta_key, bool shift_key)
{
    GetForwardingInterface()->ExecuteAction(std::move(line), std::move(action_index), std::move(url), std::move(match_selection_timestamp),
        std::move(mouse_button), std::move(alt_key), std::move(ctrl_key), std::move(meta_key), std::move(shift_key));
}
void PageHandlerInterceptorForTesting::PopupElementSizeChanged(const ::gfx::Size& size)
{
    GetForwardingInterface()->PopupElementSizeChanged(std::move(size));
}
void PageHandlerInterceptorForTesting::OnThumbnailRemoved()
{
    GetForwardingInterface()->OnThumbnailRemoved();
}
PageHandlerAsyncWaiter::PageHandlerAsyncWaiter(PageHandler* proxy)
    : proxy_(proxy)
{
}

PageHandlerAsyncWaiter::~PageHandlerAsyncWaiter() = default;

void PageInterceptorForTesting::AutocompleteResultChanged(AutocompleteResultPtr result)
{
    GetForwardingInterface()->AutocompleteResultChanged(std::move(result));
}
void PageInterceptorForTesting::UpdateSelection(OmniboxPopupSelectionPtr old_selection, OmniboxPopupSelectionPtr selection)
{
    GetForwardingInterface()->UpdateSelection(std::move(old_selection), std::move(selection));
}
void PageInterceptorForTesting::SetInputText(const std::string& input)
{
    GetForwardingInterface()->SetInputText(std::move(input));
}
void PageInterceptorForTesting::SetThumbnail(const std::string& thumbnail_url)
{
    GetForwardingInterface()->SetThumbnail(std::move(thumbnail_url));
}
PageAsyncWaiter::PageAsyncWaiter(Page* proxy)
    : proxy_(proxy)
{
}

PageAsyncWaiter::~PageAsyncWaiter() = default;

} // searchbox::mojom

#if defined(__clang__)
#pragma clang diagnostic pop
#endif