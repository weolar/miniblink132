// ui/display/mojom/display_snapshot.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef UI_DISPLAY_MOJOM_DISPLAY_SNAPSHOT_MOJOM_SHARED_H_
#define UI_DISPLAY_MOJOM_DISPLAY_SNAPSHOT_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "ui/display/mojom/display_snapshot.mojom-shared-internal.h"
#include "mojo/public/mojom/base/file_path.mojom-shared.h"
#include "skia/public/mojom/skcolorspace_primaries.mojom-shared.h"
#include "ui/display/mojom/display_constants.mojom-shared.h"
#include "ui/display/mojom/display_mode.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/mojom/color_space.mojom-shared.h"
#include "ui/gfx/mojom/hdr_static_metadata.mojom-shared.h"

namespace display::mojom {
class DisplaySnapshotColorInfoDataView;

class DisplaySnapshotDataView;

} // display::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::display::mojom::DisplaySnapshotColorInfoDataView> {
    using Data = ::display::mojom::internal::DisplaySnapshotColorInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::display::mojom::DisplaySnapshotDataView> {
    using Data = ::display::mojom::internal::DisplaySnapshot_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace display::mojom {

class DisplaySnapshotColorInfoDataView {
public:
    DisplaySnapshotColorInfoDataView() = default;

    DisplaySnapshotColorInfoDataView(internal::DisplaySnapshotColorInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetColorSpaceDataView(::gfx::mojom::ColorSpaceDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadColorSpace(UserType* output)
    {

        auto* pointer = data_->color_space.Get();
        return mojo::internal::Deserialize<::gfx::mojom::ColorSpaceDataView>(pointer, output, message_);
    }
    inline void GetEdidPrimariesDataView(::skia::mojom::SkColorSpacePrimariesDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadEdidPrimaries(UserType* output)
    {

        auto* pointer = data_->edid_primaries.Get();
        return mojo::internal::Deserialize<::skia::mojom::SkColorSpacePrimariesDataView>(pointer, output, message_);
    }
    float edid_gamma() const
    {
        return data_->edid_gamma;
    }
    inline void GetHdrStaticMetadataDataView(::gfx::mojom::HDRStaticMetadataDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadHdrStaticMetadata(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::gfx::mojom::HDRStaticMetadataDataView, UserType>(),
            "Attempting to read the optional `hdr_static_metadata` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadHdrStaticMetadata` instead "
            "of `ReadHdrStaticMetadata if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->hdr_static_metadata.Get();
        return mojo::internal::Deserialize<::gfx::mojom::HDRStaticMetadataDataView>(pointer, output, message_);
    }
    bool supports_color_temperature_adjustment() const
    {
        return data_->supports_color_temperature_adjustment;
    }
    uint32_t bits_per_channel() const
    {
        return data_->bits_per_channel;
    }

private:
    internal::DisplaySnapshotColorInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class DisplaySnapshotDataView {
public:
    DisplaySnapshotDataView() = default;

    DisplaySnapshotDataView(internal::DisplaySnapshot_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int64_t display_id() const
    {
        return data_->display_id;
    }
    int64_t port_display_id() const
    {
        return data_->port_display_id;
    }
    int64_t edid_display_id() const
    {
        return data_->edid_display_id;
    }
    uint16_t connector_index() const
    {
        return data_->connector_index;
    }
    inline void GetOriginDataView(::gfx::mojom::PointDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadOrigin(UserType* output)
    {

        auto* pointer = data_->origin.Get();
        return mojo::internal::Deserialize<::gfx::mojom::PointDataView>(pointer, output, message_);
    }
    inline void GetPhysicalSizeDataView(::gfx::mojom::SizeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadPhysicalSize(UserType* output)
    {

        auto* pointer = data_->physical_size.Get();
        return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadType(UserType* output) const
    {
        auto data_value = data_->type;
        return mojo::internal::Deserialize<::display::mojom::DisplayConnectionType>(data_value, output);
    }
    ::display::mojom::DisplayConnectionType type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::display::mojom::DisplayConnectionType>(data_->type));
    }
    uint64_t base_connector_id() const
    {
        return data_->base_connector_id;
    }
    inline void GetPathTopologyDataView(mojo::ArrayDataView<uint64_t>* output);

    template <typename UserType> [[nodiscard]] bool ReadPathTopology(UserType* output)
    {

        auto* pointer = data_->path_topology.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<uint64_t>>(pointer, output, message_);
    }
    bool is_aspect_preserving_scaling() const
    {
        return data_->is_aspect_preserving_scaling;
    }
    bool has_overscan() const
    {
        return data_->has_overscan;
    }
    template <typename UserType> [[nodiscard]] bool ReadPrivacyScreenState(UserType* output) const
    {
        auto data_value = data_->privacy_screen_state;
        return mojo::internal::Deserialize<::display::mojom::PrivacyScreenState>(data_value, output);
    }
    ::display::mojom::PrivacyScreenState privacy_screen_state() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::display::mojom::PrivacyScreenState>(data_->privacy_screen_state));
    }
    bool has_content_protection_key() const
    {
        return data_->has_content_protection_key;
    }
    inline void GetColorInfoDataView(DisplaySnapshotColorInfoDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadColorInfo(UserType* output)
    {

        auto* pointer = data_->color_info.Get();
        return mojo::internal::Deserialize<::display::mojom::DisplaySnapshotColorInfoDataView>(pointer, output, message_);
    }
    inline void GetDisplayNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDisplayName(UserType* output)
    {

        auto* pointer = data_->display_name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetSysPathDataView(::mojo_base::mojom::FilePathDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSysPath(UserType* output)
    {

        auto* pointer = data_->sys_path.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::FilePathDataView>(pointer, output, message_);
    }
    inline void GetModesDataView(mojo::ArrayDataView<::display::mojom::DisplayModeDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadModes(UserType* output)
    {

        auto* pointer = data_->modes.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::display::mojom::DisplayModeDataView>>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadPanelOrientation(UserType* output) const
    {
        auto data_value = data_->panel_orientation;
        return mojo::internal::Deserialize<::display::mojom::PanelOrientation>(data_value, output);
    }
    ::display::mojom::PanelOrientation panel_orientation() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::display::mojom::PanelOrientation>(data_->panel_orientation));
    }
    inline void GetEdidDataView(mojo::ArrayDataView<uint8_t>* output);

    template <typename UserType> [[nodiscard]] bool ReadEdid(UserType* output)
    {

        auto* pointer = data_->edid.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(pointer, output, message_);
    }
    uint64_t current_mode_index() const
    {
        return data_->current_mode_index;
    }
    bool has_current_mode() const
    {
        return data_->has_current_mode;
    }
    uint64_t native_mode_index() const
    {
        return data_->native_mode_index;
    }
    bool has_native_mode() const
    {
        return data_->has_native_mode;
    }
    int64_t product_code() const
    {
        return data_->product_code;
    }
    int32_t year_of_manufacture() const
    {
        return data_->year_of_manufacture;
    }
    inline void GetMaximumCursorSizeDataView(::gfx::mojom::SizeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMaximumCursorSize(UserType* output)
    {

        auto* pointer = data_->maximum_cursor_size.Get();
        return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadVariableRefreshRateState(UserType* output) const
    {
        auto data_value = data_->variable_refresh_rate_state;
        return mojo::internal::Deserialize<::display::mojom::VariableRefreshRateState>(data_value, output);
    }
    ::display::mojom::VariableRefreshRateState variable_refresh_rate_state() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::display::mojom::VariableRefreshRateState>(data_->variable_refresh_rate_state));
    }

private:
    internal::DisplaySnapshot_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // display::mojom

namespace std {

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::display::mojom::DisplaySnapshotColorInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::display::mojom::DisplaySnapshotColorInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::display::mojom::internal::DisplaySnapshotColorInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::color_space(input)) in_color_space = Traits::color_space(input);
        mojo::internal::MessageFragment<typename decltype(fragment->color_space)::BaseType> color_space_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(in_color_space, color_space_fragment);
        fragment->color_space.Set(color_space_fragment.is_null() ? nullptr : color_space_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->color_space.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null color_space in DisplaySnapshotColorInfo struct");
        decltype(Traits::edid_primaries(input)) in_edid_primaries = Traits::edid_primaries(input);
        mojo::internal::MessageFragment<typename decltype(fragment->edid_primaries)::BaseType> edid_primaries_fragment(fragment.message());
        mojo::internal::Serialize<::skia::mojom::SkColorSpacePrimariesDataView>(in_edid_primaries, edid_primaries_fragment);
        fragment->edid_primaries.Set(edid_primaries_fragment.is_null() ? nullptr : edid_primaries_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->edid_primaries.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null edid_primaries in DisplaySnapshotColorInfo struct");
        fragment->edid_gamma = Traits::edid_gamma(input);
        decltype(Traits::hdr_static_metadata(input)) in_hdr_static_metadata = Traits::hdr_static_metadata(input);
        mojo::internal::MessageFragment<typename decltype(fragment->hdr_static_metadata)::BaseType> hdr_static_metadata_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::HDRStaticMetadataDataView>(in_hdr_static_metadata, hdr_static_metadata_fragment);
        fragment->hdr_static_metadata.Set(hdr_static_metadata_fragment.is_null() ? nullptr : hdr_static_metadata_fragment.data());
        fragment->supports_color_temperature_adjustment = Traits::supports_color_temperature_adjustment(input);
        fragment->bits_per_channel = Traits::bits_per_channel(input);
    }

    static bool Deserialize(::display::mojom::internal::DisplaySnapshotColorInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::display::mojom::DisplaySnapshotColorInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::display::mojom::DisplaySnapshotDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::display::mojom::DisplaySnapshotDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::display::mojom::internal::DisplaySnapshot_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->display_id = Traits::display_id(input);
        fragment->port_display_id = Traits::port_display_id(input);
        fragment->edid_display_id = Traits::edid_display_id(input);
        fragment->connector_index = Traits::connector_index(input);
        decltype(Traits::origin(input)) in_origin = Traits::origin(input);
        mojo::internal::MessageFragment<typename decltype(fragment->origin)::BaseType> origin_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::PointDataView>(in_origin, origin_fragment);
        fragment->origin.Set(origin_fragment.is_null() ? nullptr : origin_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->origin.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null origin in DisplaySnapshot struct");
        decltype(Traits::physical_size(input)) in_physical_size = Traits::physical_size(input);
        mojo::internal::MessageFragment<typename decltype(fragment->physical_size)::BaseType> physical_size_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_physical_size, physical_size_fragment);
        fragment->physical_size.Set(physical_size_fragment.is_null() ? nullptr : physical_size_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->physical_size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null physical_size in DisplaySnapshot struct");
        mojo::internal::Serialize<::display::mojom::DisplayConnectionType>(Traits::type(input), &fragment->type);
        fragment->base_connector_id = Traits::base_connector_id(input);
        decltype(Traits::path_topology(input)) in_path_topology = Traits::path_topology(input);
        mojo::internal::MessageFragment<typename decltype(fragment->path_topology)::BaseType> path_topology_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& path_topology_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<uint64_t>>(in_path_topology, path_topology_fragment, &path_topology_validate_params);
        fragment->path_topology.Set(path_topology_fragment.is_null() ? nullptr : path_topology_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->path_topology.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null path_topology in DisplaySnapshot struct");
        fragment->is_aspect_preserving_scaling = Traits::is_aspect_preserving_scaling(input);
        fragment->has_overscan = Traits::has_overscan(input);
        mojo::internal::Serialize<::display::mojom::PrivacyScreenState>(Traits::privacy_screen_state(input), &fragment->privacy_screen_state);
        fragment->has_content_protection_key = Traits::has_content_protection_key(input);
        decltype(Traits::color_info(input)) in_color_info = Traits::color_info(input);
        mojo::internal::MessageFragment<typename decltype(fragment->color_info)::BaseType> color_info_fragment(fragment.message());
        mojo::internal::Serialize<::display::mojom::DisplaySnapshotColorInfoDataView>(in_color_info, color_info_fragment);
        fragment->color_info.Set(color_info_fragment.is_null() ? nullptr : color_info_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->color_info.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null color_info in DisplaySnapshot struct");
        decltype(Traits::display_name(input)) in_display_name = Traits::display_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->display_name)::BaseType> display_name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_display_name, display_name_fragment);
        fragment->display_name.Set(display_name_fragment.is_null() ? nullptr : display_name_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->display_name.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null display_name in DisplaySnapshot struct");
        decltype(Traits::sys_path(input)) in_sys_path = Traits::sys_path(input);
        mojo::internal::MessageFragment<typename decltype(fragment->sys_path)::BaseType> sys_path_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(in_sys_path, sys_path_fragment);
        fragment->sys_path.Set(sys_path_fragment.is_null() ? nullptr : sys_path_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->sys_path.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null sys_path in DisplaySnapshot struct");
        decltype(Traits::modes(input)) in_modes = Traits::modes(input);
        mojo::internal::MessageFragment<typename decltype(fragment->modes)::BaseType> modes_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& modes_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::display::mojom::DisplayModeDataView>>(in_modes, modes_fragment, &modes_validate_params);
        fragment->modes.Set(modes_fragment.is_null() ? nullptr : modes_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->modes.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null modes in DisplaySnapshot struct");
        mojo::internal::Serialize<::display::mojom::PanelOrientation>(Traits::panel_orientation(input), &fragment->panel_orientation);
        decltype(Traits::edid(input)) in_edid = Traits::edid(input);
        mojo::internal::MessageFragment<typename decltype(fragment->edid)::BaseType> edid_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& edid_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(in_edid, edid_fragment, &edid_validate_params);
        fragment->edid.Set(edid_fragment.is_null() ? nullptr : edid_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->edid.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null edid in DisplaySnapshot struct");
        fragment->current_mode_index = Traits::current_mode_index(input);
        fragment->has_current_mode = Traits::has_current_mode(input);
        fragment->native_mode_index = Traits::native_mode_index(input);
        fragment->has_native_mode = Traits::has_native_mode(input);
        fragment->product_code = Traits::product_code(input);
        fragment->year_of_manufacture = Traits::year_of_manufacture(input);
        decltype(Traits::maximum_cursor_size(input)) in_maximum_cursor_size = Traits::maximum_cursor_size(input);
        mojo::internal::MessageFragment<typename decltype(fragment->maximum_cursor_size)::BaseType> maximum_cursor_size_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_maximum_cursor_size, maximum_cursor_size_fragment);
        fragment->maximum_cursor_size.Set(maximum_cursor_size_fragment.is_null() ? nullptr : maximum_cursor_size_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->maximum_cursor_size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null maximum_cursor_size in DisplaySnapshot struct");
        mojo::internal::Serialize<::display::mojom::VariableRefreshRateState>(
            Traits::variable_refresh_rate_state(input), &fragment->variable_refresh_rate_state);
    }

    static bool Deserialize(::display::mojom::internal::DisplaySnapshot_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::display::mojom::DisplaySnapshotDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace display::mojom {

inline void DisplaySnapshotColorInfoDataView::GetColorSpaceDataView(::gfx::mojom::ColorSpaceDataView* output)
{
    auto pointer = data_->color_space.Get();
    *output = ::gfx::mojom::ColorSpaceDataView(pointer, message_);
}
inline void DisplaySnapshotColorInfoDataView::GetEdidPrimariesDataView(::skia::mojom::SkColorSpacePrimariesDataView* output)
{
    auto pointer = data_->edid_primaries.Get();
    *output = ::skia::mojom::SkColorSpacePrimariesDataView(pointer, message_);
}
inline void DisplaySnapshotColorInfoDataView::GetHdrStaticMetadataDataView(::gfx::mojom::HDRStaticMetadataDataView* output)
{
    auto pointer = data_->hdr_static_metadata.Get();
    *output = ::gfx::mojom::HDRStaticMetadataDataView(pointer, message_);
}

inline void DisplaySnapshotDataView::GetOriginDataView(::gfx::mojom::PointDataView* output)
{
    auto pointer = data_->origin.Get();
    *output = ::gfx::mojom::PointDataView(pointer, message_);
}
inline void DisplaySnapshotDataView::GetPhysicalSizeDataView(::gfx::mojom::SizeDataView* output)
{
    auto pointer = data_->physical_size.Get();
    *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void DisplaySnapshotDataView::GetPathTopologyDataView(mojo::ArrayDataView<uint64_t>* output)
{
    auto pointer = data_->path_topology.Get();
    *output = mojo::ArrayDataView<uint64_t>(pointer, message_);
}
inline void DisplaySnapshotDataView::GetColorInfoDataView(DisplaySnapshotColorInfoDataView* output)
{
    auto pointer = data_->color_info.Get();
    *output = DisplaySnapshotColorInfoDataView(pointer, message_);
}
inline void DisplaySnapshotDataView::GetDisplayNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->display_name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void DisplaySnapshotDataView::GetSysPathDataView(::mojo_base::mojom::FilePathDataView* output)
{
    auto pointer = data_->sys_path.Get();
    *output = ::mojo_base::mojom::FilePathDataView(pointer, message_);
}
inline void DisplaySnapshotDataView::GetModesDataView(mojo::ArrayDataView<::display::mojom::DisplayModeDataView>* output)
{
    auto pointer = data_->modes.Get();
    *output = mojo::ArrayDataView<::display::mojom::DisplayModeDataView>(pointer, message_);
}
inline void DisplaySnapshotDataView::GetEdidDataView(mojo::ArrayDataView<uint8_t>* output)
{
    auto pointer = data_->edid.Get();
    *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void DisplaySnapshotDataView::GetMaximumCursorSizeDataView(::gfx::mojom::SizeDataView* output)
{
    auto pointer = data_->maximum_cursor_size.Get();
    *output = ::gfx::mojom::SizeDataView(pointer, message_);
}

} // display::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

#endif // UI_DISPLAY_MOJOM_DISPLAY_SNAPSHOT_MOJOM_SHARED_H_
