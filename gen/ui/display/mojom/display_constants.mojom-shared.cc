// ui/display/mojom/display_constants.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "ui/display/mojom/display_constants.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "ui/display/mojom/display_constants.mojom-params-data.h"
namespace display {
namespace mojom {

NOINLINE static const char* DisplayConnectionTypeToStringHelper(DisplayConnectionType value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case DisplayConnectionType::DISPLAY_CONNECTION_TYPE_NONE:
        return "DISPLAY_CONNECTION_TYPE_NONE";
    case DisplayConnectionType::DISPLAY_CONNECTION_TYPE_UNKNOWN:
        return "DISPLAY_CONNECTION_TYPE_UNKNOWN";
    case DisplayConnectionType::DISPLAY_CONNECTION_TYPE_INTERNAL:
        return "DISPLAY_CONNECTION_TYPE_INTERNAL";
    case DisplayConnectionType::DISPLAY_CONNECTION_TYPE_VGA:
        return "DISPLAY_CONNECTION_TYPE_VGA";
    case DisplayConnectionType::DISPLAY_CONNECTION_TYPE_HDMI:
        return "DISPLAY_CONNECTION_TYPE_HDMI";
    case DisplayConnectionType::DISPLAY_CONNECTION_TYPE_DVI:
        return "DISPLAY_CONNECTION_TYPE_DVI";
    case DisplayConnectionType::DISPLAY_CONNECTION_TYPE_DISPLAYPORT:
        return "DISPLAY_CONNECTION_TYPE_DISPLAYPORT";
    case DisplayConnectionType::DISPLAY_CONNECTION_TYPE_NETWORK:
        return "DISPLAY_CONNECTION_TYPE_NETWORK";
    default:
        return nullptr;
    }
}

std::string DisplayConnectionTypeToString(DisplayConnectionType value)
{
    const char* str = DisplayConnectionTypeToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown DisplayConnectionType value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, DisplayConnectionType value)
{
    return os << DisplayConnectionTypeToString(value);
}

NOINLINE static const char* HDCPStateToStringHelper(HDCPState value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case HDCPState::HDCP_STATE_UNDESIRED:
        return "HDCP_STATE_UNDESIRED";
    case HDCPState::HDCP_STATE_DESIRED:
        return "HDCP_STATE_DESIRED";
    case HDCPState::HDCP_STATE_ENABLED:
        return "HDCP_STATE_ENABLED";
    default:
        return nullptr;
    }
}

std::string HDCPStateToString(HDCPState value)
{
    const char* str = HDCPStateToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown HDCPState value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, HDCPState value)
{
    return os << HDCPStateToString(value);
}

NOINLINE static const char* ContentProtectionMethodToStringHelper(ContentProtectionMethod value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case ContentProtectionMethod::CONTENT_PROTECTION_METHOD_NONE:
        return "CONTENT_PROTECTION_METHOD_NONE";
    case ContentProtectionMethod::CONTENT_PROTECTION_METHOD_HDCP_TYPE_0:
        return "CONTENT_PROTECTION_METHOD_HDCP_TYPE_0";
    case ContentProtectionMethod::CONTENT_PROTECTION_METHOD_HDCP_TYPE_1:
        return "CONTENT_PROTECTION_METHOD_HDCP_TYPE_1";
    default:
        return nullptr;
    }
}

std::string ContentProtectionMethodToString(ContentProtectionMethod value)
{
    const char* str = ContentProtectionMethodToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown ContentProtectionMethod value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, ContentProtectionMethod value)
{
    return os << ContentProtectionMethodToString(value);
}

NOINLINE static const char* PanelOrientationToStringHelper(PanelOrientation value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case PanelOrientation::NORMAL:
        return "NORMAL";
    case PanelOrientation::BOTTOM_UP:
        return "BOTTOM_UP";
    case PanelOrientation::LEFT_UP:
        return "LEFT_UP";
    case PanelOrientation::RIGHT_UP:
        return "RIGHT_UP";
    default:
        return nullptr;
    }
}

std::string PanelOrientationToString(PanelOrientation value)
{
    const char* str = PanelOrientationToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown PanelOrientation value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, PanelOrientation value)
{
    return os << PanelOrientationToString(value);
}

NOINLINE static const char* PrivacyScreenStateToStringHelper(PrivacyScreenState value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case PrivacyScreenState::DISABLED:
        return "DISABLED";
    case PrivacyScreenState::ENABLED:
        return "ENABLED";
    case PrivacyScreenState::DISABLED_LOCKED:
        return "DISABLED_LOCKED";
    case PrivacyScreenState::ENABLED_LOCKED:
        return "ENABLED_LOCKED";
    case PrivacyScreenState::NOT_SUPPORTED:
        return "NOT_SUPPORTED";
    default:
        return nullptr;
    }
}

std::string PrivacyScreenStateToString(PrivacyScreenState value)
{
    const char* str = PrivacyScreenStateToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown PrivacyScreenState value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, PrivacyScreenState value)
{
    return os << PrivacyScreenStateToString(value);
}

NOINLINE static const char* VariableRefreshRateStateToStringHelper(VariableRefreshRateState value)
{
    // Defined in a helper function to ensure that Clang generates a lookup table.
    switch (value) {
    case VariableRefreshRateState::kVrrDisabled:
        return "kVrrDisabled";
    case VariableRefreshRateState::kVrrEnabled:
        return "kVrrEnabled";
    case VariableRefreshRateState::kVrrNotCapable:
        return "kVrrNotCapable";
    default:
        return nullptr;
    }
}

std::string VariableRefreshRateStateToString(VariableRefreshRateState value)
{
    const char* str = VariableRefreshRateStateToStringHelper(value);
    if (!str) {
        return base::StringPrintf("Unknown VariableRefreshRateState value: %i", static_cast<int32_t>(value));
    }
    return str;
}

std::ostream& operator<<(std::ostream& os, VariableRefreshRateState value)
{
    return os << VariableRefreshRateStateToString(value);
}

namespace internal {

// static
bool ModesetFlags_Data::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    if (!data)
        return true;
    if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(data, 16, validation_context)) {
        return false;
    }

    // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
    // the message comes from an older version.
    [[maybe_unused]] const ModesetFlags_Data* object = static_cast<const ModesetFlags_Data*>(data);

    return true;
}

ModesetFlags_Data::ModesetFlags_Data()
    : header_({ sizeof(*this), 0 })
{
}

} // namespace internal
} // namespace mojom
} // namespace display

namespace perfetto {

// static
void TraceFormatTraits<::display::mojom::DisplayConnectionType>::WriteIntoTrace(perfetto::TracedValue context, ::display::mojom::DisplayConnectionType value)
{
    return std::move(context).WriteString(::display::mojom::DisplayConnectionTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::display::mojom::HDCPState>::WriteIntoTrace(perfetto::TracedValue context, ::display::mojom::HDCPState value)
{
    return std::move(context).WriteString(::display::mojom::HDCPStateToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::display::mojom::ContentProtectionMethod>::WriteIntoTrace(
    perfetto::TracedValue context, ::display::mojom::ContentProtectionMethod value)
{
    return std::move(context).WriteString(::display::mojom::ContentProtectionMethodToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::display::mojom::PanelOrientation>::WriteIntoTrace(perfetto::TracedValue context, ::display::mojom::PanelOrientation value)
{
    return std::move(context).WriteString(::display::mojom::PanelOrientationToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::display::mojom::PrivacyScreenState>::WriteIntoTrace(perfetto::TracedValue context, ::display::mojom::PrivacyScreenState value)
{
    return std::move(context).WriteString(::display::mojom::PrivacyScreenStateToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::display::mojom::VariableRefreshRateState>::WriteIntoTrace(
    perfetto::TracedValue context, ::display::mojom::VariableRefreshRateState value)
{
    return std::move(context).WriteString(::display::mojom::VariableRefreshRateStateToString(value));
}

} // namespace perfetto