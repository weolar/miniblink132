// media/capture/mojom/image_capture.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "media/capture/mojom/image_capture.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "media/capture/mojom/image_capture.mojom-params-data.h"
#include "media/capture/mojom/image_capture.mojom-shared-message-ids.h"

#include "media/capture/mojom/image_capture.mojom-blink-import-headers.h"
#include "media/capture/mojom/image_capture.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"

namespace media::mojom::blink {
Range::Range()
    : max()
    , min()
    , current()
    , step()
{
}

Range::Range(double max_in, double min_in, double current_in, double step_in)
    : max(std::move(max_in))
    , min(std::move(min_in))
    , current(std::move(current_in))
    , step(std::move(step_in))
{
}

Range::~Range() = default;
size_t Range::Hash(size_t seed) const
{
    seed = mojo::internal::WTFHash(seed, this->max);
    seed = mojo::internal::WTFHash(seed, this->min);
    seed = mojo::internal::WTFHash(seed, this->current);
    seed = mojo::internal::WTFHash(seed, this->step);
    return seed;
}

void Range::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("max"), this->max,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("min"), this->min,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("current"), this->current,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("step"), this->step,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Range::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
PhotoState::PhotoState()
    : supported_white_balance_modes()
    , current_white_balance_mode()
    , supported_exposure_modes()
    , current_exposure_mode()
    , supported_focus_modes()
    , current_focus_mode()
    , points_of_interest()
    , exposure_compensation()
    , exposure_time()
    , color_temperature()
    , iso()
    , brightness()
    , contrast()
    , saturation()
    , sharpness()
    , focus_distance()
    , pan()
    , tilt()
    , zoom()
    , supports_torch()
    , torch()
    , red_eye_reduction()
    , height()
    , width()
    , fill_light_mode()
    , supported_background_blur_modes()
    , background_blur_mode()
    , supported_face_framing_modes()
    , current_face_framing_mode()
    , supported_eye_gaze_correction_modes()
    , current_eye_gaze_correction_mode()
    , supported_background_segmentation_mask_states()
    , current_background_segmentation_mask_state()
{
}

PhotoState::PhotoState(WTF::Vector<MeteringMode> supported_white_balance_modes_in, MeteringMode current_white_balance_mode_in,
    WTF::Vector<MeteringMode> supported_exposure_modes_in, MeteringMode current_exposure_mode_in, WTF::Vector<MeteringMode> supported_focus_modes_in,
    MeteringMode current_focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, RangePtr exposure_compensation_in, RangePtr exposure_time_in,
    RangePtr color_temperature_in, RangePtr iso_in, RangePtr brightness_in, RangePtr contrast_in, RangePtr saturation_in, RangePtr sharpness_in,
    RangePtr focus_distance_in, RangePtr pan_in, RangePtr tilt_in, RangePtr zoom_in, bool supports_torch_in, bool torch_in,
    RedEyeReduction red_eye_reduction_in, RangePtr height_in, RangePtr width_in, WTF::Vector<FillLightMode> fill_light_mode_in)
    : supported_white_balance_modes(std::move(supported_white_balance_modes_in))
    , current_white_balance_mode(std::move(current_white_balance_mode_in))
    , supported_exposure_modes(std::move(supported_exposure_modes_in))
    , current_exposure_mode(std::move(current_exposure_mode_in))
    , supported_focus_modes(std::move(supported_focus_modes_in))
    , current_focus_mode(std::move(current_focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , exposure_time(std::move(exposure_time_in))
    , color_temperature(std::move(color_temperature_in))
    , iso(std::move(iso_in))
    , brightness(std::move(brightness_in))
    , contrast(std::move(contrast_in))
    , saturation(std::move(saturation_in))
    , sharpness(std::move(sharpness_in))
    , focus_distance(std::move(focus_distance_in))
    , pan(std::move(pan_in))
    , tilt(std::move(tilt_in))
    , zoom(std::move(zoom_in))
    , supports_torch(std::move(supports_torch_in))
    , torch(std::move(torch_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , height(std::move(height_in))
    , width(std::move(width_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , supported_background_blur_modes()
    , background_blur_mode()
    , supported_face_framing_modes()
    , current_face_framing_mode()
    , supported_eye_gaze_correction_modes()
    , current_eye_gaze_correction_mode()
    , supported_background_segmentation_mask_states()
    , current_background_segmentation_mask_state()
{
}

PhotoState::PhotoState(WTF::Vector<MeteringMode> supported_white_balance_modes_in, MeteringMode current_white_balance_mode_in,
    WTF::Vector<MeteringMode> supported_exposure_modes_in, MeteringMode current_exposure_mode_in, WTF::Vector<MeteringMode> supported_focus_modes_in,
    MeteringMode current_focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, RangePtr exposure_compensation_in, RangePtr exposure_time_in,
    RangePtr color_temperature_in, RangePtr iso_in, RangePtr brightness_in, RangePtr contrast_in, RangePtr saturation_in, RangePtr sharpness_in,
    RangePtr focus_distance_in, RangePtr pan_in, RangePtr tilt_in, RangePtr zoom_in, bool supports_torch_in, bool torch_in,
    RedEyeReduction red_eye_reduction_in, RangePtr height_in, RangePtr width_in, WTF::Vector<FillLightMode> fill_light_mode_in,
    std::optional<WTF::Vector<BackgroundBlurMode>> supported_background_blur_modes_in, BackgroundBlurMode background_blur_mode_in)
    : supported_white_balance_modes(std::move(supported_white_balance_modes_in))
    , current_white_balance_mode(std::move(current_white_balance_mode_in))
    , supported_exposure_modes(std::move(supported_exposure_modes_in))
    , current_exposure_mode(std::move(current_exposure_mode_in))
    , supported_focus_modes(std::move(supported_focus_modes_in))
    , current_focus_mode(std::move(current_focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , exposure_time(std::move(exposure_time_in))
    , color_temperature(std::move(color_temperature_in))
    , iso(std::move(iso_in))
    , brightness(std::move(brightness_in))
    , contrast(std::move(contrast_in))
    , saturation(std::move(saturation_in))
    , sharpness(std::move(sharpness_in))
    , focus_distance(std::move(focus_distance_in))
    , pan(std::move(pan_in))
    , tilt(std::move(tilt_in))
    , zoom(std::move(zoom_in))
    , supports_torch(std::move(supports_torch_in))
    , torch(std::move(torch_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , height(std::move(height_in))
    , width(std::move(width_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , supported_background_blur_modes(std::move(supported_background_blur_modes_in))
    , background_blur_mode(std::move(background_blur_mode_in))
    , supported_face_framing_modes()
    , current_face_framing_mode()
    , supported_eye_gaze_correction_modes()
    , current_eye_gaze_correction_mode()
    , supported_background_segmentation_mask_states()
    , current_background_segmentation_mask_state()
{
}

PhotoState::PhotoState(WTF::Vector<MeteringMode> supported_white_balance_modes_in, MeteringMode current_white_balance_mode_in,
    WTF::Vector<MeteringMode> supported_exposure_modes_in, MeteringMode current_exposure_mode_in, WTF::Vector<MeteringMode> supported_focus_modes_in,
    MeteringMode current_focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, RangePtr exposure_compensation_in, RangePtr exposure_time_in,
    RangePtr color_temperature_in, RangePtr iso_in, RangePtr brightness_in, RangePtr contrast_in, RangePtr saturation_in, RangePtr sharpness_in,
    RangePtr focus_distance_in, RangePtr pan_in, RangePtr tilt_in, RangePtr zoom_in, bool supports_torch_in, bool torch_in,
    RedEyeReduction red_eye_reduction_in, RangePtr height_in, RangePtr width_in, WTF::Vector<FillLightMode> fill_light_mode_in,
    std::optional<WTF::Vector<BackgroundBlurMode>> supported_background_blur_modes_in, BackgroundBlurMode background_blur_mode_in,
    std::optional<WTF::Vector<MeteringMode>> supported_face_framing_modes_in, MeteringMode current_face_framing_mode_in)
    : supported_white_balance_modes(std::move(supported_white_balance_modes_in))
    , current_white_balance_mode(std::move(current_white_balance_mode_in))
    , supported_exposure_modes(std::move(supported_exposure_modes_in))
    , current_exposure_mode(std::move(current_exposure_mode_in))
    , supported_focus_modes(std::move(supported_focus_modes_in))
    , current_focus_mode(std::move(current_focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , exposure_time(std::move(exposure_time_in))
    , color_temperature(std::move(color_temperature_in))
    , iso(std::move(iso_in))
    , brightness(std::move(brightness_in))
    , contrast(std::move(contrast_in))
    , saturation(std::move(saturation_in))
    , sharpness(std::move(sharpness_in))
    , focus_distance(std::move(focus_distance_in))
    , pan(std::move(pan_in))
    , tilt(std::move(tilt_in))
    , zoom(std::move(zoom_in))
    , supports_torch(std::move(supports_torch_in))
    , torch(std::move(torch_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , height(std::move(height_in))
    , width(std::move(width_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , supported_background_blur_modes(std::move(supported_background_blur_modes_in))
    , background_blur_mode(std::move(background_blur_mode_in))
    , supported_face_framing_modes(std::move(supported_face_framing_modes_in))
    , current_face_framing_mode(std::move(current_face_framing_mode_in))
    , supported_eye_gaze_correction_modes()
    , current_eye_gaze_correction_mode()
    , supported_background_segmentation_mask_states()
    , current_background_segmentation_mask_state()
{
}

PhotoState::PhotoState(WTF::Vector<MeteringMode> supported_white_balance_modes_in, MeteringMode current_white_balance_mode_in,
    WTF::Vector<MeteringMode> supported_exposure_modes_in, MeteringMode current_exposure_mode_in, WTF::Vector<MeteringMode> supported_focus_modes_in,
    MeteringMode current_focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, RangePtr exposure_compensation_in, RangePtr exposure_time_in,
    RangePtr color_temperature_in, RangePtr iso_in, RangePtr brightness_in, RangePtr contrast_in, RangePtr saturation_in, RangePtr sharpness_in,
    RangePtr focus_distance_in, RangePtr pan_in, RangePtr tilt_in, RangePtr zoom_in, bool supports_torch_in, bool torch_in,
    RedEyeReduction red_eye_reduction_in, RangePtr height_in, RangePtr width_in, WTF::Vector<FillLightMode> fill_light_mode_in,
    std::optional<WTF::Vector<BackgroundBlurMode>> supported_background_blur_modes_in, BackgroundBlurMode background_blur_mode_in,
    std::optional<WTF::Vector<MeteringMode>> supported_face_framing_modes_in, MeteringMode current_face_framing_mode_in,
    std::optional<WTF::Vector<EyeGazeCorrectionMode>> supported_eye_gaze_correction_modes_in, EyeGazeCorrectionMode current_eye_gaze_correction_mode_in)
    : supported_white_balance_modes(std::move(supported_white_balance_modes_in))
    , current_white_balance_mode(std::move(current_white_balance_mode_in))
    , supported_exposure_modes(std::move(supported_exposure_modes_in))
    , current_exposure_mode(std::move(current_exposure_mode_in))
    , supported_focus_modes(std::move(supported_focus_modes_in))
    , current_focus_mode(std::move(current_focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , exposure_time(std::move(exposure_time_in))
    , color_temperature(std::move(color_temperature_in))
    , iso(std::move(iso_in))
    , brightness(std::move(brightness_in))
    , contrast(std::move(contrast_in))
    , saturation(std::move(saturation_in))
    , sharpness(std::move(sharpness_in))
    , focus_distance(std::move(focus_distance_in))
    , pan(std::move(pan_in))
    , tilt(std::move(tilt_in))
    , zoom(std::move(zoom_in))
    , supports_torch(std::move(supports_torch_in))
    , torch(std::move(torch_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , height(std::move(height_in))
    , width(std::move(width_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , supported_background_blur_modes(std::move(supported_background_blur_modes_in))
    , background_blur_mode(std::move(background_blur_mode_in))
    , supported_face_framing_modes(std::move(supported_face_framing_modes_in))
    , current_face_framing_mode(std::move(current_face_framing_mode_in))
    , supported_eye_gaze_correction_modes(std::move(supported_eye_gaze_correction_modes_in))
    , current_eye_gaze_correction_mode(std::move(current_eye_gaze_correction_mode_in))
    , supported_background_segmentation_mask_states()
    , current_background_segmentation_mask_state()
{
}

PhotoState::PhotoState(WTF::Vector<MeteringMode> supported_white_balance_modes_in, MeteringMode current_white_balance_mode_in,
    WTF::Vector<MeteringMode> supported_exposure_modes_in, MeteringMode current_exposure_mode_in, WTF::Vector<MeteringMode> supported_focus_modes_in,
    MeteringMode current_focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, RangePtr exposure_compensation_in, RangePtr exposure_time_in,
    RangePtr color_temperature_in, RangePtr iso_in, RangePtr brightness_in, RangePtr contrast_in, RangePtr saturation_in, RangePtr sharpness_in,
    RangePtr focus_distance_in, RangePtr pan_in, RangePtr tilt_in, RangePtr zoom_in, bool supports_torch_in, bool torch_in,
    RedEyeReduction red_eye_reduction_in, RangePtr height_in, RangePtr width_in, WTF::Vector<FillLightMode> fill_light_mode_in,
    std::optional<WTF::Vector<BackgroundBlurMode>> supported_background_blur_modes_in, BackgroundBlurMode background_blur_mode_in,
    std::optional<WTF::Vector<MeteringMode>> supported_face_framing_modes_in, MeteringMode current_face_framing_mode_in,
    std::optional<WTF::Vector<EyeGazeCorrectionMode>> supported_eye_gaze_correction_modes_in, EyeGazeCorrectionMode current_eye_gaze_correction_mode_in,
    std::optional<WTF::Vector<bool>> supported_background_segmentation_mask_states_in, bool current_background_segmentation_mask_state_in)
    : supported_white_balance_modes(std::move(supported_white_balance_modes_in))
    , current_white_balance_mode(std::move(current_white_balance_mode_in))
    , supported_exposure_modes(std::move(supported_exposure_modes_in))
    , current_exposure_mode(std::move(current_exposure_mode_in))
    , supported_focus_modes(std::move(supported_focus_modes_in))
    , current_focus_mode(std::move(current_focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , exposure_time(std::move(exposure_time_in))
    , color_temperature(std::move(color_temperature_in))
    , iso(std::move(iso_in))
    , brightness(std::move(brightness_in))
    , contrast(std::move(contrast_in))
    , saturation(std::move(saturation_in))
    , sharpness(std::move(sharpness_in))
    , focus_distance(std::move(focus_distance_in))
    , pan(std::move(pan_in))
    , tilt(std::move(tilt_in))
    , zoom(std::move(zoom_in))
    , supports_torch(std::move(supports_torch_in))
    , torch(std::move(torch_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , height(std::move(height_in))
    , width(std::move(width_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , supported_background_blur_modes(std::move(supported_background_blur_modes_in))
    , background_blur_mode(std::move(background_blur_mode_in))
    , supported_face_framing_modes(std::move(supported_face_framing_modes_in))
    , current_face_framing_mode(std::move(current_face_framing_mode_in))
    , supported_eye_gaze_correction_modes(std::move(supported_eye_gaze_correction_modes_in))
    , current_eye_gaze_correction_mode(std::move(current_eye_gaze_correction_mode_in))
    , supported_background_segmentation_mask_states(std::move(supported_background_segmentation_mask_states_in))
    , current_background_segmentation_mask_state(std::move(current_background_segmentation_mask_state_in))
{
}

PhotoState::~PhotoState() = default;

void PhotoState::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("supported_white_balance_modes"), this->supported_white_balance_modes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::Vector<MeteringMode>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("current_white_balance_mode"), this->current_white_balance_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type MeteringMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("supported_exposure_modes"), this->supported_exposure_modes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::Vector<MeteringMode>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("current_exposure_mode"), this->current_exposure_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type MeteringMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("supported_focus_modes"), this->supported_focus_modes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::Vector<MeteringMode>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("current_focus_mode"), this->current_focus_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type MeteringMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("points_of_interest"), this->points_of_interest,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type WTF::Vector<Point2DPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("exposure_compensation"), this->exposure_compensation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("exposure_time"), this->exposure_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("color_temperature"), this->color_temperature,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("iso"), this->iso,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("brightness"), this->brightness,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("contrast"), this->contrast,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("saturation"), this->saturation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("sharpness"), this->sharpness,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("focus_distance"), this->focus_distance,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("pan"), this->pan,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("tilt"), this->tilt,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("zoom"), this->zoom,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("supports_torch"), this->supports_torch,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("torch"), this->torch,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("red_eye_reduction"), this->red_eye_reduction,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RedEyeReduction>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("height"), this->height,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("width"), this->width,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RangePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("fill_light_mode"), this->fill_light_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::Vector<FillLightMode>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("supported_background_blur_modes"), this->supported_background_blur_modes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<WTF::Vector<BackgroundBlurMode>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("background_blur_mode"), this->background_blur_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type BackgroundBlurMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("supported_face_framing_modes"), this->supported_face_framing_modes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<WTF::Vector<MeteringMode>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("current_face_framing_mode"), this->current_face_framing_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type MeteringMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("supported_eye_gaze_correction_modes"), this->supported_eye_gaze_correction_modes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<WTF::Vector<EyeGazeCorrectionMode>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("current_eye_gaze_correction_mode"), this->current_eye_gaze_correction_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type EyeGazeCorrectionMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(
        dict.AddItem("supported_background_segmentation_mask_states"), this->supported_background_segmentation_mask_states,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<WTF::Vector<bool>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("current_background_segmentation_mask_state"), this->current_background_segmentation_mask_state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PhotoState::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Point2D::Point2D()
    : x()
    , y()
{
}

Point2D::Point2D(double x_in, double y_in)
    : x(std::move(x_in))
    , y(std::move(y_in))
{
}

Point2D::~Point2D() = default;
size_t Point2D::Hash(size_t seed) const
{
    seed = mojo::internal::WTFHash(seed, this->x);
    seed = mojo::internal::WTFHash(seed, this->y);
    return seed;
}

void Point2D::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("x"), this->x,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("y"), this->y,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Point2D::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
PhotoSettings::PhotoSettings()
    : has_white_balance_mode()
    , white_balance_mode()
    , has_exposure_mode()
    , exposure_mode()
    , has_focus_mode()
    , focus_mode()
    , points_of_interest()
    , has_exposure_compensation()
    , exposure_compensation()
    , has_exposure_time()
    , exposure_time()
    , has_color_temperature()
    , color_temperature()
    , has_iso()
    , iso()
    , has_brightness()
    , brightness()
    , has_contrast()
    , contrast()
    , has_saturation()
    , saturation()
    , has_sharpness()
    , sharpness()
    , has_focus_distance()
    , focus_distance()
    , has_pan()
    , pan()
    , has_tilt()
    , tilt()
    , has_zoom()
    , zoom()
    , has_torch()
    , torch()
    , has_fill_light_mode()
    , fill_light_mode()
    , has_width()
    , width()
    , has_height()
    , height()
    , has_red_eye_reduction()
    , red_eye_reduction()
    , has_background_blur_mode()
    , background_blur_mode()
    , has_face_framing_mode()
    , face_framing_mode()
    , eye_gaze_correction_mode()
    , background_segmentation_mask_state()
{
}

PhotoSettings::PhotoSettings(bool has_white_balance_mode_in, MeteringMode white_balance_mode_in, bool has_exposure_mode_in, MeteringMode exposure_mode_in,
    bool has_focus_mode_in, MeteringMode focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, bool has_exposure_compensation_in,
    double exposure_compensation_in, bool has_exposure_time_in, double exposure_time_in, bool has_color_temperature_in, double color_temperature_in,
    bool has_iso_in, double iso_in, bool has_brightness_in, double brightness_in, bool has_contrast_in, double contrast_in, bool has_saturation_in,
    double saturation_in, bool has_sharpness_in, double sharpness_in, bool has_focus_distance_in, double focus_distance_in, bool has_pan_in, double pan_in,
    bool has_tilt_in, double tilt_in, bool has_zoom_in, double zoom_in, bool has_torch_in, bool torch_in, bool has_fill_light_mode_in,
    FillLightMode fill_light_mode_in, bool has_width_in, double width_in, bool has_height_in, double height_in, bool has_red_eye_reduction_in,
    bool red_eye_reduction_in)
    : has_white_balance_mode(std::move(has_white_balance_mode_in))
    , white_balance_mode(std::move(white_balance_mode_in))
    , has_exposure_mode(std::move(has_exposure_mode_in))
    , exposure_mode(std::move(exposure_mode_in))
    , has_focus_mode(std::move(has_focus_mode_in))
    , focus_mode(std::move(focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , has_exposure_compensation(std::move(has_exposure_compensation_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , has_exposure_time(std::move(has_exposure_time_in))
    , exposure_time(std::move(exposure_time_in))
    , has_color_temperature(std::move(has_color_temperature_in))
    , color_temperature(std::move(color_temperature_in))
    , has_iso(std::move(has_iso_in))
    , iso(std::move(iso_in))
    , has_brightness(std::move(has_brightness_in))
    , brightness(std::move(brightness_in))
    , has_contrast(std::move(has_contrast_in))
    , contrast(std::move(contrast_in))
    , has_saturation(std::move(has_saturation_in))
    , saturation(std::move(saturation_in))
    , has_sharpness(std::move(has_sharpness_in))
    , sharpness(std::move(sharpness_in))
    , has_focus_distance(std::move(has_focus_distance_in))
    , focus_distance(std::move(focus_distance_in))
    , has_pan(std::move(has_pan_in))
    , pan(std::move(pan_in))
    , has_tilt(std::move(has_tilt_in))
    , tilt(std::move(tilt_in))
    , has_zoom(std::move(has_zoom_in))
    , zoom(std::move(zoom_in))
    , has_torch(std::move(has_torch_in))
    , torch(std::move(torch_in))
    , has_fill_light_mode(std::move(has_fill_light_mode_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , has_width(std::move(has_width_in))
    , width(std::move(width_in))
    , has_height(std::move(has_height_in))
    , height(std::move(height_in))
    , has_red_eye_reduction(std::move(has_red_eye_reduction_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , has_background_blur_mode()
    , background_blur_mode()
    , has_face_framing_mode()
    , face_framing_mode()
    , eye_gaze_correction_mode()
    , background_segmentation_mask_state()
{
}

PhotoSettings::PhotoSettings(bool has_white_balance_mode_in, MeteringMode white_balance_mode_in, bool has_exposure_mode_in, MeteringMode exposure_mode_in,
    bool has_focus_mode_in, MeteringMode focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, bool has_exposure_compensation_in,
    double exposure_compensation_in, bool has_exposure_time_in, double exposure_time_in, bool has_color_temperature_in, double color_temperature_in,
    bool has_iso_in, double iso_in, bool has_brightness_in, double brightness_in, bool has_contrast_in, double contrast_in, bool has_saturation_in,
    double saturation_in, bool has_sharpness_in, double sharpness_in, bool has_focus_distance_in, double focus_distance_in, bool has_pan_in, double pan_in,
    bool has_tilt_in, double tilt_in, bool has_zoom_in, double zoom_in, bool has_torch_in, bool torch_in, bool has_fill_light_mode_in,
    FillLightMode fill_light_mode_in, bool has_width_in, double width_in, bool has_height_in, double height_in, bool has_red_eye_reduction_in,
    bool red_eye_reduction_in, bool has_background_blur_mode_in, BackgroundBlurMode background_blur_mode_in)
    : has_white_balance_mode(std::move(has_white_balance_mode_in))
    , white_balance_mode(std::move(white_balance_mode_in))
    , has_exposure_mode(std::move(has_exposure_mode_in))
    , exposure_mode(std::move(exposure_mode_in))
    , has_focus_mode(std::move(has_focus_mode_in))
    , focus_mode(std::move(focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , has_exposure_compensation(std::move(has_exposure_compensation_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , has_exposure_time(std::move(has_exposure_time_in))
    , exposure_time(std::move(exposure_time_in))
    , has_color_temperature(std::move(has_color_temperature_in))
    , color_temperature(std::move(color_temperature_in))
    , has_iso(std::move(has_iso_in))
    , iso(std::move(iso_in))
    , has_brightness(std::move(has_brightness_in))
    , brightness(std::move(brightness_in))
    , has_contrast(std::move(has_contrast_in))
    , contrast(std::move(contrast_in))
    , has_saturation(std::move(has_saturation_in))
    , saturation(std::move(saturation_in))
    , has_sharpness(std::move(has_sharpness_in))
    , sharpness(std::move(sharpness_in))
    , has_focus_distance(std::move(has_focus_distance_in))
    , focus_distance(std::move(focus_distance_in))
    , has_pan(std::move(has_pan_in))
    , pan(std::move(pan_in))
    , has_tilt(std::move(has_tilt_in))
    , tilt(std::move(tilt_in))
    , has_zoom(std::move(has_zoom_in))
    , zoom(std::move(zoom_in))
    , has_torch(std::move(has_torch_in))
    , torch(std::move(torch_in))
    , has_fill_light_mode(std::move(has_fill_light_mode_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , has_width(std::move(has_width_in))
    , width(std::move(width_in))
    , has_height(std::move(has_height_in))
    , height(std::move(height_in))
    , has_red_eye_reduction(std::move(has_red_eye_reduction_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , has_background_blur_mode(std::move(has_background_blur_mode_in))
    , background_blur_mode(std::move(background_blur_mode_in))
    , has_face_framing_mode()
    , face_framing_mode()
    , eye_gaze_correction_mode()
    , background_segmentation_mask_state()
{
}

PhotoSettings::PhotoSettings(bool has_white_balance_mode_in, MeteringMode white_balance_mode_in, bool has_exposure_mode_in, MeteringMode exposure_mode_in,
    bool has_focus_mode_in, MeteringMode focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, bool has_exposure_compensation_in,
    double exposure_compensation_in, bool has_exposure_time_in, double exposure_time_in, bool has_color_temperature_in, double color_temperature_in,
    bool has_iso_in, double iso_in, bool has_brightness_in, double brightness_in, bool has_contrast_in, double contrast_in, bool has_saturation_in,
    double saturation_in, bool has_sharpness_in, double sharpness_in, bool has_focus_distance_in, double focus_distance_in, bool has_pan_in, double pan_in,
    bool has_tilt_in, double tilt_in, bool has_zoom_in, double zoom_in, bool has_torch_in, bool torch_in, bool has_fill_light_mode_in,
    FillLightMode fill_light_mode_in, bool has_width_in, double width_in, bool has_height_in, double height_in, bool has_red_eye_reduction_in,
    bool red_eye_reduction_in, bool has_background_blur_mode_in, BackgroundBlurMode background_blur_mode_in, bool has_face_framing_mode_in,
    MeteringMode face_framing_mode_in)
    : has_white_balance_mode(std::move(has_white_balance_mode_in))
    , white_balance_mode(std::move(white_balance_mode_in))
    , has_exposure_mode(std::move(has_exposure_mode_in))
    , exposure_mode(std::move(exposure_mode_in))
    , has_focus_mode(std::move(has_focus_mode_in))
    , focus_mode(std::move(focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , has_exposure_compensation(std::move(has_exposure_compensation_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , has_exposure_time(std::move(has_exposure_time_in))
    , exposure_time(std::move(exposure_time_in))
    , has_color_temperature(std::move(has_color_temperature_in))
    , color_temperature(std::move(color_temperature_in))
    , has_iso(std::move(has_iso_in))
    , iso(std::move(iso_in))
    , has_brightness(std::move(has_brightness_in))
    , brightness(std::move(brightness_in))
    , has_contrast(std::move(has_contrast_in))
    , contrast(std::move(contrast_in))
    , has_saturation(std::move(has_saturation_in))
    , saturation(std::move(saturation_in))
    , has_sharpness(std::move(has_sharpness_in))
    , sharpness(std::move(sharpness_in))
    , has_focus_distance(std::move(has_focus_distance_in))
    , focus_distance(std::move(focus_distance_in))
    , has_pan(std::move(has_pan_in))
    , pan(std::move(pan_in))
    , has_tilt(std::move(has_tilt_in))
    , tilt(std::move(tilt_in))
    , has_zoom(std::move(has_zoom_in))
    , zoom(std::move(zoom_in))
    , has_torch(std::move(has_torch_in))
    , torch(std::move(torch_in))
    , has_fill_light_mode(std::move(has_fill_light_mode_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , has_width(std::move(has_width_in))
    , width(std::move(width_in))
    , has_height(std::move(has_height_in))
    , height(std::move(height_in))
    , has_red_eye_reduction(std::move(has_red_eye_reduction_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , has_background_blur_mode(std::move(has_background_blur_mode_in))
    , background_blur_mode(std::move(background_blur_mode_in))
    , has_face_framing_mode(std::move(has_face_framing_mode_in))
    , face_framing_mode(std::move(face_framing_mode_in))
    , eye_gaze_correction_mode()
    , background_segmentation_mask_state()
{
}

PhotoSettings::PhotoSettings(bool has_white_balance_mode_in, MeteringMode white_balance_mode_in, bool has_exposure_mode_in, MeteringMode exposure_mode_in,
    bool has_focus_mode_in, MeteringMode focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, bool has_exposure_compensation_in,
    double exposure_compensation_in, bool has_exposure_time_in, double exposure_time_in, bool has_color_temperature_in, double color_temperature_in,
    bool has_iso_in, double iso_in, bool has_brightness_in, double brightness_in, bool has_contrast_in, double contrast_in, bool has_saturation_in,
    double saturation_in, bool has_sharpness_in, double sharpness_in, bool has_focus_distance_in, double focus_distance_in, bool has_pan_in, double pan_in,
    bool has_tilt_in, double tilt_in, bool has_zoom_in, double zoom_in, bool has_torch_in, bool torch_in, bool has_fill_light_mode_in,
    FillLightMode fill_light_mode_in, bool has_width_in, double width_in, bool has_height_in, double height_in, bool has_red_eye_reduction_in,
    bool red_eye_reduction_in, bool has_background_blur_mode_in, BackgroundBlurMode background_blur_mode_in, bool has_face_framing_mode_in,
    MeteringMode face_framing_mode_in, std::optional<EyeGazeCorrectionMode> eye_gaze_correction_mode_in)
    : has_white_balance_mode(std::move(has_white_balance_mode_in))
    , white_balance_mode(std::move(white_balance_mode_in))
    , has_exposure_mode(std::move(has_exposure_mode_in))
    , exposure_mode(std::move(exposure_mode_in))
    , has_focus_mode(std::move(has_focus_mode_in))
    , focus_mode(std::move(focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , has_exposure_compensation(std::move(has_exposure_compensation_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , has_exposure_time(std::move(has_exposure_time_in))
    , exposure_time(std::move(exposure_time_in))
    , has_color_temperature(std::move(has_color_temperature_in))
    , color_temperature(std::move(color_temperature_in))
    , has_iso(std::move(has_iso_in))
    , iso(std::move(iso_in))
    , has_brightness(std::move(has_brightness_in))
    , brightness(std::move(brightness_in))
    , has_contrast(std::move(has_contrast_in))
    , contrast(std::move(contrast_in))
    , has_saturation(std::move(has_saturation_in))
    , saturation(std::move(saturation_in))
    , has_sharpness(std::move(has_sharpness_in))
    , sharpness(std::move(sharpness_in))
    , has_focus_distance(std::move(has_focus_distance_in))
    , focus_distance(std::move(focus_distance_in))
    , has_pan(std::move(has_pan_in))
    , pan(std::move(pan_in))
    , has_tilt(std::move(has_tilt_in))
    , tilt(std::move(tilt_in))
    , has_zoom(std::move(has_zoom_in))
    , zoom(std::move(zoom_in))
    , has_torch(std::move(has_torch_in))
    , torch(std::move(torch_in))
    , has_fill_light_mode(std::move(has_fill_light_mode_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , has_width(std::move(has_width_in))
    , width(std::move(width_in))
    , has_height(std::move(has_height_in))
    , height(std::move(height_in))
    , has_red_eye_reduction(std::move(has_red_eye_reduction_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , has_background_blur_mode(std::move(has_background_blur_mode_in))
    , background_blur_mode(std::move(background_blur_mode_in))
    , has_face_framing_mode(std::move(has_face_framing_mode_in))
    , face_framing_mode(std::move(face_framing_mode_in))
    , eye_gaze_correction_mode(std::move(eye_gaze_correction_mode_in))
    , background_segmentation_mask_state()
{
}

PhotoSettings::PhotoSettings(bool has_white_balance_mode_in, MeteringMode white_balance_mode_in, bool has_exposure_mode_in, MeteringMode exposure_mode_in,
    bool has_focus_mode_in, MeteringMode focus_mode_in, WTF::Vector<Point2DPtr> points_of_interest_in, bool has_exposure_compensation_in,
    double exposure_compensation_in, bool has_exposure_time_in, double exposure_time_in, bool has_color_temperature_in, double color_temperature_in,
    bool has_iso_in, double iso_in, bool has_brightness_in, double brightness_in, bool has_contrast_in, double contrast_in, bool has_saturation_in,
    double saturation_in, bool has_sharpness_in, double sharpness_in, bool has_focus_distance_in, double focus_distance_in, bool has_pan_in, double pan_in,
    bool has_tilt_in, double tilt_in, bool has_zoom_in, double zoom_in, bool has_torch_in, bool torch_in, bool has_fill_light_mode_in,
    FillLightMode fill_light_mode_in, bool has_width_in, double width_in, bool has_height_in, double height_in, bool has_red_eye_reduction_in,
    bool red_eye_reduction_in, bool has_background_blur_mode_in, BackgroundBlurMode background_blur_mode_in, bool has_face_framing_mode_in,
    MeteringMode face_framing_mode_in, std::optional<EyeGazeCorrectionMode> eye_gaze_correction_mode_in,
    std::optional<bool> background_segmentation_mask_state_in)
    : has_white_balance_mode(std::move(has_white_balance_mode_in))
    , white_balance_mode(std::move(white_balance_mode_in))
    , has_exposure_mode(std::move(has_exposure_mode_in))
    , exposure_mode(std::move(exposure_mode_in))
    , has_focus_mode(std::move(has_focus_mode_in))
    , focus_mode(std::move(focus_mode_in))
    , points_of_interest(std::move(points_of_interest_in))
    , has_exposure_compensation(std::move(has_exposure_compensation_in))
    , exposure_compensation(std::move(exposure_compensation_in))
    , has_exposure_time(std::move(has_exposure_time_in))
    , exposure_time(std::move(exposure_time_in))
    , has_color_temperature(std::move(has_color_temperature_in))
    , color_temperature(std::move(color_temperature_in))
    , has_iso(std::move(has_iso_in))
    , iso(std::move(iso_in))
    , has_brightness(std::move(has_brightness_in))
    , brightness(std::move(brightness_in))
    , has_contrast(std::move(has_contrast_in))
    , contrast(std::move(contrast_in))
    , has_saturation(std::move(has_saturation_in))
    , saturation(std::move(saturation_in))
    , has_sharpness(std::move(has_sharpness_in))
    , sharpness(std::move(sharpness_in))
    , has_focus_distance(std::move(has_focus_distance_in))
    , focus_distance(std::move(focus_distance_in))
    , has_pan(std::move(has_pan_in))
    , pan(std::move(pan_in))
    , has_tilt(std::move(has_tilt_in))
    , tilt(std::move(tilt_in))
    , has_zoom(std::move(has_zoom_in))
    , zoom(std::move(zoom_in))
    , has_torch(std::move(has_torch_in))
    , torch(std::move(torch_in))
    , has_fill_light_mode(std::move(has_fill_light_mode_in))
    , fill_light_mode(std::move(fill_light_mode_in))
    , has_width(std::move(has_width_in))
    , width(std::move(width_in))
    , has_height(std::move(has_height_in))
    , height(std::move(height_in))
    , has_red_eye_reduction(std::move(has_red_eye_reduction_in))
    , red_eye_reduction(std::move(red_eye_reduction_in))
    , has_background_blur_mode(std::move(has_background_blur_mode_in))
    , background_blur_mode(std::move(background_blur_mode_in))
    , has_face_framing_mode(std::move(has_face_framing_mode_in))
    , face_framing_mode(std::move(face_framing_mode_in))
    , eye_gaze_correction_mode(std::move(eye_gaze_correction_mode_in))
    , background_segmentation_mask_state(std::move(background_segmentation_mask_state_in))
{
}

PhotoSettings::~PhotoSettings() = default;

void PhotoSettings::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_white_balance_mode"), this->has_white_balance_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("white_balance_mode"), this->white_balance_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type MeteringMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_exposure_mode"), this->has_exposure_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("exposure_mode"), this->exposure_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type MeteringMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_focus_mode"), this->has_focus_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("focus_mode"), this->focus_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type MeteringMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("points_of_interest"), this->points_of_interest,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type WTF::Vector<Point2DPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_exposure_compensation"), this->has_exposure_compensation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("exposure_compensation"), this->exposure_compensation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_exposure_time"), this->has_exposure_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("exposure_time"), this->exposure_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_color_temperature"), this->has_color_temperature,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("color_temperature"), this->color_temperature,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_iso"), this->has_iso,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("iso"), this->iso,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_brightness"), this->has_brightness,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("brightness"), this->brightness,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_contrast"), this->has_contrast,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("contrast"), this->contrast,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_saturation"), this->has_saturation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("saturation"), this->saturation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_sharpness"), this->has_sharpness,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("sharpness"), this->sharpness,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_focus_distance"), this->has_focus_distance,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("focus_distance"), this->focus_distance,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_pan"), this->has_pan,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("pan"), this->pan,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_tilt"), this->has_tilt,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("tilt"), this->tilt,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_zoom"), this->has_zoom,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("zoom"), this->zoom,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_torch"), this->has_torch,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("torch"), this->torch,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_fill_light_mode"), this->has_fill_light_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("fill_light_mode"), this->fill_light_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type FillLightMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_width"), this->has_width,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("width"), this->width,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_height"), this->has_height,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("height"), this->height,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type double>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_red_eye_reduction"), this->has_red_eye_reduction,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("red_eye_reduction"), this->red_eye_reduction,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_background_blur_mode"), this->has_background_blur_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("background_blur_mode"), this->background_blur_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type BackgroundBlurMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("has_face_framing_mode"), this->has_face_framing_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("face_framing_mode"), this->face_framing_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type MeteringMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("eye_gaze_correction_mode"), this->eye_gaze_correction_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<EyeGazeCorrectionMode>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("background_segmentation_mask_state"), this->background_segmentation_mask_state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<bool>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PhotoSettings::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Blob::Blob()
    : mime_type()
    , data()
{
}

Blob::Blob(const WTF::String& mime_type_in, WTF::Vector<uint8_t> data_in)
    : mime_type(std::move(mime_type_in))
    , data(std::move(data_in))
{
}

Blob::~Blob() = default;

void Blob::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mime_type"), this->mime_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::String&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const WTF::Vector<uint8_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Blob::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
const char ImageCapture::Name_[] = "media.mojom.ImageCapture";

ImageCapture::IPCStableHashFunction ImageCapture::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::ImageCapture>(message.name())) {
    case messages::ImageCapture::kGetPhotoState: {
        return &ImageCapture::GetPhotoState_Sym::IPCStableHash;
    }
    case messages::ImageCapture::kSetPhotoOptions: {
        return &ImageCapture::SetPhotoOptions_Sym::IPCStableHash;
    }
    case messages::ImageCapture::kTakePhoto: {
        return &ImageCapture::TakePhoto_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* ImageCapture::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::ImageCapture>(message.name())) {
        case messages::ImageCapture::kGetPhotoState:
            return "Receive media::mojom::ImageCapture::GetPhotoState";
        case messages::ImageCapture::kSetPhotoOptions:
            return "Receive media::mojom::ImageCapture::SetPhotoOptions";
        case messages::ImageCapture::kTakePhoto:
            return "Receive media::mojom::ImageCapture::TakePhoto";
        }
    } else {
        switch (static_cast<messages::ImageCapture>(message.name())) {
        case messages::ImageCapture::kGetPhotoState:
            return "Receive reply media::mojom::ImageCapture::GetPhotoState";
        case messages::ImageCapture::kSetPhotoOptions:
            return "Receive reply media::mojom::ImageCapture::SetPhotoOptions";
        case messages::ImageCapture::kTakePhoto:
            return "Receive reply media::mojom::ImageCapture::TakePhoto";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t ImageCapture::GetPhotoState_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)media::mojom::ImageCapture::GetPhotoState");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t ImageCapture::SetPhotoOptions_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)media::mojom::ImageCapture::SetPhotoOptions");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t ImageCapture::TakePhoto_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)media::mojom::ImageCapture::TakePhoto");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class ImageCapture_GetPhotoState_ForwardToCallback : public mojo::MessageReceiver {
public:
    ImageCapture_GetPhotoState_ForwardToCallback(ImageCapture::GetPhotoStateCallback callback)
        : callback_(std::move(callback))
    {
    }

    ImageCapture_GetPhotoState_ForwardToCallback(const ImageCapture_GetPhotoState_ForwardToCallback&) = delete;
    ImageCapture_GetPhotoState_ForwardToCallback& operator=(const ImageCapture_GetPhotoState_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    ImageCapture::GetPhotoStateCallback callback_;
};

class ImageCapture_SetPhotoOptions_ForwardToCallback : public mojo::MessageReceiver {
public:
    ImageCapture_SetPhotoOptions_ForwardToCallback(ImageCapture::SetPhotoOptionsCallback callback)
        : callback_(std::move(callback))
    {
    }

    ImageCapture_SetPhotoOptions_ForwardToCallback(const ImageCapture_SetPhotoOptions_ForwardToCallback&) = delete;
    ImageCapture_SetPhotoOptions_ForwardToCallback& operator=(const ImageCapture_SetPhotoOptions_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    ImageCapture::SetPhotoOptionsCallback callback_;
};

class ImageCapture_TakePhoto_ForwardToCallback : public mojo::MessageReceiver {
public:
    ImageCapture_TakePhoto_ForwardToCallback(ImageCapture::TakePhotoCallback callback)
        : callback_(std::move(callback))
    {
    }

    ImageCapture_TakePhoto_ForwardToCallback(const ImageCapture_TakePhoto_ForwardToCallback&) = delete;
    ImageCapture_TakePhoto_ForwardToCallback& operator=(const ImageCapture_TakePhoto_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    ImageCapture::TakePhotoCallback callback_;
};

ImageCaptureProxy::ImageCaptureProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void ImageCaptureProxy::GetPhotoState(const WTF::String& in_source_id, GetPhotoStateCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send media::mojom::ImageCapture::GetPhotoState", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("source_id"), in_source_id, "<value of type const WTF::String&>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::ImageCapture::kGetPhotoState), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::media::mojom::internal::ImageCapture_GetPhotoState_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->source_id)::BaseType> source_id_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_source_id, source_id_fragment);
    params->source_id.Set(source_id_fragment.is_null() ? nullptr : source_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->source_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null source_id in ImageCapture.GetPhotoState request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(ImageCapture::Name_);
    message.set_method_name("GetPhotoState");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new ImageCapture_GetPhotoState_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void ImageCaptureProxy::SetPhotoOptions(const WTF::String& in_source_id, PhotoSettingsPtr in_settings, SetPhotoOptionsCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send media::mojom::ImageCapture::SetPhotoOptions", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("source_id"), in_source_id, "<value of type const WTF::String&>");
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("settings"), in_settings, "<value of type PhotoSettingsPtr>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::ImageCapture::kSetPhotoOptions), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::media::mojom::internal::ImageCapture_SetPhotoOptions_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->source_id)::BaseType> source_id_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_source_id, source_id_fragment);
    params->source_id.Set(source_id_fragment.is_null() ? nullptr : source_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->source_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null source_id in ImageCapture.SetPhotoOptions request");
    mojo::internal::MessageFragment<typename decltype(params->settings)::BaseType> settings_fragment(params.message());
    mojo::internal::Serialize<::media::mojom::PhotoSettingsDataView>(in_settings, settings_fragment);
    params->settings.Set(settings_fragment.is_null() ? nullptr : settings_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->settings.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null settings in ImageCapture.SetPhotoOptions request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(ImageCapture::Name_);
    message.set_method_name("SetPhotoOptions");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new ImageCapture_SetPhotoOptions_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void ImageCaptureProxy::TakePhoto(const WTF::String& in_source_id, TakePhotoCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send media::mojom::ImageCapture::TakePhoto", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("source_id"), in_source_id, "<value of type const WTF::String&>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::ImageCapture::kTakePhoto), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::media::mojom::internal::ImageCapture_TakePhoto_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->source_id)::BaseType> source_id_fragment(params.message());
    mojo::internal::Serialize<mojo::StringDataView>(in_source_id, source_id_fragment);
    params->source_id.Set(source_id_fragment.is_null() ? nullptr : source_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->source_id.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null source_id in ImageCapture.TakePhoto request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(ImageCapture::Name_);
    message.set_method_name("TakePhoto");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new ImageCapture_TakePhoto_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class ImageCapture_GetPhotoState_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static ImageCapture::GetPhotoStateCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<ImageCapture_GetPhotoState_ProxyToResponder> proxy(new ImageCapture_GetPhotoState_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&ImageCapture_GetPhotoState_ProxyToResponder::Run, std::move(proxy));
    }

    ~ImageCapture_GetPhotoState_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    ImageCapture_GetPhotoState_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "ImageCapture::GetPhotoStateCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(PhotoStatePtr in_state);
};

bool ImageCapture_GetPhotoState_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::ImageCapture_GetPhotoState_ResponseParams_Data* params
        = reinterpret_cast<internal::ImageCapture_GetPhotoState_ResponseParams_Data*>(message->mutable_payload());

    // Validation for ImageCapture.0
    bool success = true;
    PhotoStatePtr p_state {};
    ImageCapture_GetPhotoState_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadState(&p_state))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, ImageCapture::Name_, 0, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_state));
    return true;
}

void ImageCapture_GetPhotoState_ProxyToResponder::Run(PhotoStatePtr in_state)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply media::mojom::ImageCapture::GetPhotoState", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("state"), in_state, "<value of type PhotoStatePtr>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::ImageCapture::kGetPhotoState), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::media::mojom::internal::ImageCapture_GetPhotoState_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->state)::BaseType> state_fragment(params.message());
    mojo::internal::Serialize<::media::mojom::PhotoStateDataView>(in_state, state_fragment);
    params->state.Set(state_fragment.is_null() ? nullptr : state_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->state.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null state in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(ImageCapture::Name_);
    message.set_method_name("GetPhotoState");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class ImageCapture_SetPhotoOptions_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static ImageCapture::SetPhotoOptionsCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<ImageCapture_SetPhotoOptions_ProxyToResponder> proxy(new ImageCapture_SetPhotoOptions_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&ImageCapture_SetPhotoOptions_ProxyToResponder::Run, std::move(proxy));
    }

    ~ImageCapture_SetPhotoOptions_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    ImageCapture_SetPhotoOptions_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "ImageCapture::SetPhotoOptionsCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(bool in_success);
};

bool ImageCapture_SetPhotoOptions_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::ImageCapture_SetPhotoOptions_ResponseParams_Data* params
        = reinterpret_cast<internal::ImageCapture_SetPhotoOptions_ResponseParams_Data*>(message->mutable_payload());

    // Validation for ImageCapture.1
    bool success = true;
    bool p_success {};
    ImageCapture_SetPhotoOptions_ResponseParamsDataView input_data_view(params, message);

    if (success)
        p_success = input_data_view.success();
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, ImageCapture::Name_, 1, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_success));
    return true;
}

void ImageCapture_SetPhotoOptions_ProxyToResponder::Run(bool in_success)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply media::mojom::ImageCapture::SetPhotoOptions", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("success"), in_success, "<value of type bool>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::ImageCapture::kSetPhotoOptions), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::media::mojom::internal::ImageCapture_SetPhotoOptions_ResponseParams_Data> params(message);
    params.Allocate();
    params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(ImageCapture::Name_);
    message.set_method_name("SetPhotoOptions");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}
class ImageCapture_TakePhoto_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static ImageCapture::TakePhotoCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<ImageCapture_TakePhoto_ProxyToResponder> proxy(new ImageCapture_TakePhoto_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&ImageCapture_TakePhoto_ProxyToResponder::Run, std::move(proxy));
    }

    ~ImageCapture_TakePhoto_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    ImageCapture_TakePhoto_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "ImageCapture::TakePhotoCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(BlobPtr in_blob);
};

bool ImageCapture_TakePhoto_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::ImageCapture_TakePhoto_ResponseParams_Data* params
        = reinterpret_cast<internal::ImageCapture_TakePhoto_ResponseParams_Data*>(message->mutable_payload());

    // Validation for ImageCapture.2
    bool success = true;
    BlobPtr p_blob {};
    ImageCapture_TakePhoto_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadBlob(&p_blob))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, ImageCapture::Name_, 2, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_blob));
    return true;
}

void ImageCapture_TakePhoto_ProxyToResponder::Run(BlobPtr in_blob)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply media::mojom::ImageCapture::TakePhoto", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("blob"), in_blob, "<value of type BlobPtr>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::ImageCapture::kTakePhoto), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::media::mojom::internal::ImageCapture_TakePhoto_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->blob)::BaseType> blob_fragment(params.message());
    mojo::internal::Serialize<::media::mojom::BlobDataView>(in_blob, blob_fragment);
    params->blob.Set(blob_fragment.is_null() ? nullptr : blob_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->blob.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null blob in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(ImageCapture::Name_);
    message.set_method_name("TakePhoto");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool ImageCaptureStubDispatch::Accept(ImageCapture* impl, mojo::Message* message)
{
    switch (static_cast<messages::ImageCapture>(message->header()->name)) {
    case messages::ImageCapture::kGetPhotoState: {
        break;
    }
    case messages::ImageCapture::kSetPhotoOptions: {
        break;
    }
    case messages::ImageCapture::kTakePhoto: {
        break;
    }
    }
    return false;
}

// static
bool ImageCaptureStubDispatch::AcceptWithResponder(ImageCapture* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::ImageCapture>(message->header()->name)) {
    case messages::ImageCapture::kGetPhotoState: {
        internal::ImageCapture_GetPhotoState_Params_Data* params
            = reinterpret_cast<internal::ImageCapture_GetPhotoState_Params_Data*>(message->mutable_payload());

        // Validation for ImageCapture.0
        bool success = true;
        WTF::String p_source_id {};
        ImageCapture_GetPhotoState_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadSourceId(&p_source_id))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, ImageCapture::Name_, 0, false);
            return false;
        }
        ImageCapture::GetPhotoStateCallback callback = ImageCapture_GetPhotoState_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->GetPhotoState(std::move(p_source_id), std::move(callback));
        return true;
    }
    case messages::ImageCapture::kSetPhotoOptions: {
        internal::ImageCapture_SetPhotoOptions_Params_Data* params
            = reinterpret_cast<internal::ImageCapture_SetPhotoOptions_Params_Data*>(message->mutable_payload());

        // Validation for ImageCapture.1
        bool success = true;
        WTF::String p_source_id {};
        PhotoSettingsPtr p_settings {};
        ImageCapture_SetPhotoOptions_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadSourceId(&p_source_id))
            success = false;
        if (success && !input_data_view.ReadSettings(&p_settings))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, ImageCapture::Name_, 1, false);
            return false;
        }
        ImageCapture::SetPhotoOptionsCallback callback = ImageCapture_SetPhotoOptions_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->SetPhotoOptions(std::move(p_source_id), std::move(p_settings), std::move(callback));
        return true;
    }
    case messages::ImageCapture::kTakePhoto: {
        internal::ImageCapture_TakePhoto_Params_Data* params = reinterpret_cast<internal::ImageCapture_TakePhoto_Params_Data*>(message->mutable_payload());

        // Validation for ImageCapture.2
        bool success = true;
        WTF::String p_source_id {};
        ImageCapture_TakePhoto_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadSourceId(&p_source_id))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, ImageCapture::Name_, 2, false);
            return false;
        }
        ImageCapture::TakePhotoCallback callback = ImageCapture_TakePhoto_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->TakePhoto(std::move(p_source_id), std::move(callback));
        return true;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kImageCaptureValidationInfo[] = {
    { &internal::ImageCapture_GetPhotoState_Params_Data::Validate, &internal::ImageCapture_GetPhotoState_ResponseParams_Data::Validate },
    { &internal::ImageCapture_SetPhotoOptions_Params_Data::Validate, &internal::ImageCapture_SetPhotoOptions_ResponseParams_Data::Validate },
    { &internal::ImageCapture_TakePhoto_Params_Data::Validate, &internal::ImageCapture_TakePhoto_ResponseParams_Data::Validate },
};

bool ImageCaptureRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::media::mojom::blink::ImageCapture::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kImageCaptureValidationInfo);
}

bool ImageCaptureResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::media::mojom::blink::ImageCapture::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kImageCaptureValidationInfo);
}

} // media::mojom::blink

namespace mojo {

// static
bool StructTraits<::media::mojom::blink::Range::DataView, ::media::mojom::blink::RangePtr>::Read(
    ::media::mojom::blink::Range::DataView input, ::media::mojom::blink::RangePtr* output)
{
    bool success = true;
    ::media::mojom::blink::RangePtr result(::media::mojom::blink::Range::New());

    if (success)
        result->max = input.max();
    if (success)
        result->min = input.min();
    if (success)
        result->current = input.current();
    if (success)
        result->step = input.step();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::media::mojom::blink::PhotoState::DataView, ::media::mojom::blink::PhotoStatePtr>::Read(
    ::media::mojom::blink::PhotoState::DataView input, ::media::mojom::blink::PhotoStatePtr* output)
{
    bool success = true;
    ::media::mojom::blink::PhotoStatePtr result(::media::mojom::blink::PhotoState::New());

    if (success && !input.ReadSupportedWhiteBalanceModes(&result->supported_white_balance_modes))
        success = false;
    if (success && !input.ReadCurrentWhiteBalanceMode(&result->current_white_balance_mode))
        success = false;
    if (success && !input.ReadSupportedExposureModes(&result->supported_exposure_modes))
        success = false;
    if (success && !input.ReadCurrentExposureMode(&result->current_exposure_mode))
        success = false;
    if (success && !input.ReadSupportedFocusModes(&result->supported_focus_modes))
        success = false;
    if (success && !input.ReadCurrentFocusMode(&result->current_focus_mode))
        success = false;
    if (success && !input.ReadPointsOfInterest(&result->points_of_interest))
        success = false;
    if (success && !input.ReadExposureCompensation(&result->exposure_compensation))
        success = false;
    if (success && !input.ReadExposureTime(&result->exposure_time))
        success = false;
    if (success && !input.ReadColorTemperature(&result->color_temperature))
        success = false;
    if (success && !input.ReadIso(&result->iso))
        success = false;
    if (success && !input.ReadBrightness(&result->brightness))
        success = false;
    if (success && !input.ReadContrast(&result->contrast))
        success = false;
    if (success && !input.ReadSaturation(&result->saturation))
        success = false;
    if (success && !input.ReadSharpness(&result->sharpness))
        success = false;
    if (success && !input.ReadFocusDistance(&result->focus_distance))
        success = false;
    if (success && !input.ReadPan(&result->pan))
        success = false;
    if (success && !input.ReadTilt(&result->tilt))
        success = false;
    if (success && !input.ReadZoom(&result->zoom))
        success = false;
    if (success)
        result->supports_torch = input.supports_torch();
    if (success)
        result->torch = input.torch();
    if (success && !input.ReadRedEyeReduction(&result->red_eye_reduction))
        success = false;
    if (success && !input.ReadHeight(&result->height))
        success = false;
    if (success && !input.ReadWidth(&result->width))
        success = false;
    if (success && !input.ReadFillLightMode(&result->fill_light_mode))
        success = false;
    if (success && !input.ReadSupportedBackgroundBlurModes(&result->supported_background_blur_modes))
        success = false;
    if (success && !input.ReadBackgroundBlurMode(&result->background_blur_mode))
        success = false;
    if (success && !input.ReadSupportedFaceFramingModes(&result->supported_face_framing_modes))
        success = false;
    if (success && !input.ReadCurrentFaceFramingMode(&result->current_face_framing_mode))
        success = false;
    if (success && !input.ReadSupportedEyeGazeCorrectionModes(&result->supported_eye_gaze_correction_modes))
        success = false;
    if (success && !input.ReadCurrentEyeGazeCorrectionMode(&result->current_eye_gaze_correction_mode))
        success = false;
    if (success && !input.ReadSupportedBackgroundSegmentationMaskStates(&result->supported_background_segmentation_mask_states))
        success = false;
    if (success)
        result->current_background_segmentation_mask_state = input.current_background_segmentation_mask_state();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::media::mojom::blink::Point2D::DataView, ::media::mojom::blink::Point2DPtr>::Read(
    ::media::mojom::blink::Point2D::DataView input, ::media::mojom::blink::Point2DPtr* output)
{
    bool success = true;
    ::media::mojom::blink::Point2DPtr result(::media::mojom::blink::Point2D::New());

    if (success)
        result->x = input.x();
    if (success)
        result->y = input.y();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::media::mojom::blink::PhotoSettings::DataView, ::media::mojom::blink::PhotoSettingsPtr>::Read(
    ::media::mojom::blink::PhotoSettings::DataView input, ::media::mojom::blink::PhotoSettingsPtr* output)
{
    bool success = true;
    ::media::mojom::blink::PhotoSettingsPtr result(::media::mojom::blink::PhotoSettings::New());

    if (success)
        result->has_white_balance_mode = input.has_white_balance_mode();
    if (success && !input.ReadWhiteBalanceMode(&result->white_balance_mode))
        success = false;
    if (success)
        result->has_exposure_mode = input.has_exposure_mode();
    if (success && !input.ReadExposureMode(&result->exposure_mode))
        success = false;
    if (success)
        result->has_focus_mode = input.has_focus_mode();
    if (success && !input.ReadFocusMode(&result->focus_mode))
        success = false;
    if (success && !input.ReadPointsOfInterest(&result->points_of_interest))
        success = false;
    if (success)
        result->has_exposure_compensation = input.has_exposure_compensation();
    if (success)
        result->exposure_compensation = input.exposure_compensation();
    if (success)
        result->has_exposure_time = input.has_exposure_time();
    if (success)
        result->exposure_time = input.exposure_time();
    if (success)
        result->has_color_temperature = input.has_color_temperature();
    if (success)
        result->color_temperature = input.color_temperature();
    if (success)
        result->has_iso = input.has_iso();
    if (success)
        result->iso = input.iso();
    if (success)
        result->has_brightness = input.has_brightness();
    if (success)
        result->brightness = input.brightness();
    if (success)
        result->has_contrast = input.has_contrast();
    if (success)
        result->contrast = input.contrast();
    if (success)
        result->has_saturation = input.has_saturation();
    if (success)
        result->saturation = input.saturation();
    if (success)
        result->has_sharpness = input.has_sharpness();
    if (success)
        result->sharpness = input.sharpness();
    if (success)
        result->has_focus_distance = input.has_focus_distance();
    if (success)
        result->focus_distance = input.focus_distance();
    if (success)
        result->has_pan = input.has_pan();
    if (success)
        result->pan = input.pan();
    if (success)
        result->has_tilt = input.has_tilt();
    if (success)
        result->tilt = input.tilt();
    if (success)
        result->has_zoom = input.has_zoom();
    if (success)
        result->zoom = input.zoom();
    if (success)
        result->has_torch = input.has_torch();
    if (success)
        result->torch = input.torch();
    if (success)
        result->has_fill_light_mode = input.has_fill_light_mode();
    if (success && !input.ReadFillLightMode(&result->fill_light_mode))
        success = false;
    if (success)
        result->has_width = input.has_width();
    if (success)
        result->width = input.width();
    if (success)
        result->has_height = input.has_height();
    if (success)
        result->height = input.height();
    if (success)
        result->has_red_eye_reduction = input.has_red_eye_reduction();
    if (success)
        result->red_eye_reduction = input.red_eye_reduction();
    if (success)
        result->has_background_blur_mode = input.has_background_blur_mode();
    if (success && !input.ReadBackgroundBlurMode(&result->background_blur_mode))
        success = false;
    if (success)
        result->has_face_framing_mode = input.has_face_framing_mode();
    if (success && !input.ReadFaceFramingMode(&result->face_framing_mode))
        success = false;
    if (success && !input.ReadEyeGazeCorrectionMode(&result->eye_gaze_correction_mode)) {
        success = false;
    }
    if (success) {
        result->background_segmentation_mask_state = input.background_segmentation_mask_state();
    }
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::media::mojom::blink::Blob::DataView, ::media::mojom::blink::BlobPtr>::Read(
    ::media::mojom::blink::Blob::DataView input, ::media::mojom::blink::BlobPtr* output)
{
    bool success = true;
    ::media::mojom::blink::BlobPtr result(::media::mojom::blink::Blob::New());

    if (success && !input.ReadMimeType(&result->mime_type))
        success = false;
    if (success && !input.ReadData(&result->data))
        success = false;
    *output = std::move(result);
    return success;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace media::mojom::blink {

void ImageCaptureInterceptorForTesting::GetPhotoState(const WTF::String& source_id, GetPhotoStateCallback callback)
{
    GetForwardingInterface()->GetPhotoState(std::move(source_id), std::move(callback));
}
void ImageCaptureInterceptorForTesting::SetPhotoOptions(const WTF::String& source_id, PhotoSettingsPtr settings, SetPhotoOptionsCallback callback)
{
    GetForwardingInterface()->SetPhotoOptions(std::move(source_id), std::move(settings), std::move(callback));
}
void ImageCaptureInterceptorForTesting::TakePhoto(const WTF::String& source_id, TakePhotoCallback callback)
{
    GetForwardingInterface()->TakePhoto(std::move(source_id), std::move(callback));
}
ImageCaptureAsyncWaiter::ImageCaptureAsyncWaiter(ImageCapture* proxy)
    : proxy_(proxy)
{
}

ImageCaptureAsyncWaiter::~ImageCaptureAsyncWaiter() = default;

void ImageCaptureAsyncWaiter::GetPhotoState(const WTF::String& source_id, PhotoStatePtr* out_state)
{
    base::RunLoop loop;
    proxy_->GetPhotoState(std::move(source_id),
        base::BindOnce(
            [](base::RunLoop* loop, PhotoStatePtr* out_state, PhotoStatePtr state) {
                *out_state = std::move(state);
                loop->Quit();
            },
            &loop, out_state));
    loop.Run();
}

PhotoStatePtr ImageCaptureAsyncWaiter::GetPhotoState(const WTF::String& source_id)
{
    PhotoStatePtr async_wait_result;
    GetPhotoState(std::move(source_id), &async_wait_result);
    return async_wait_result;
}

void ImageCaptureAsyncWaiter::SetPhotoOptions(const WTF::String& source_id, PhotoSettingsPtr settings, bool* out_success)
{
    base::RunLoop loop;
    proxy_->SetPhotoOptions(std::move(source_id), std::move(settings),
        base::BindOnce(
            [](base::RunLoop* loop, bool* out_success, bool success) {
                *out_success = std::move(success);
                loop->Quit();
            },
            &loop, out_success));
    loop.Run();
}

bool ImageCaptureAsyncWaiter::SetPhotoOptions(const WTF::String& source_id, PhotoSettingsPtr settings)
{
    bool async_wait_result;
    SetPhotoOptions(std::move(source_id), std::move(settings), &async_wait_result);
    return async_wait_result;
}

void ImageCaptureAsyncWaiter::TakePhoto(const WTF::String& source_id, BlobPtr* out_blob)
{
    base::RunLoop loop;
    proxy_->TakePhoto(std::move(source_id),
        base::BindOnce(
            [](base::RunLoop* loop, BlobPtr* out_blob, BlobPtr blob) {
                *out_blob = std::move(blob);
                loop->Quit();
            },
            &loop, out_blob));
    loop.Run();
}

BlobPtr ImageCaptureAsyncWaiter::TakePhoto(const WTF::String& source_id)
{
    BlobPtr async_wait_result;
    TakePhoto(std::move(source_id), &async_wait_result);
    return async_wait_result;
}

} // media::mojom::blink

#if defined(__clang__)
#pragma clang diagnostic pop
#endif