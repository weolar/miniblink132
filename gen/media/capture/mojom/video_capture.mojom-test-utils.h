// media/capture/mojom/video_capture.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_CAPTURE_MOJOM_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_
#define MEDIA_CAPTURE_MOJOM_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_

#include "media/capture/mojom/video_capture.mojom.h"

namespace media::mojom {

class VideoCaptureObserverInterceptorForTesting : public VideoCaptureObserver {
    virtual VideoCaptureObserver* GetForwardingInterface() = 0;
    void OnStateChanged(VideoCaptureResultPtr result) override;
    void OnNewBuffer(int32_t buffer_id, ::media::mojom::VideoBufferHandlePtr buffer_handle) override;
    void OnBufferReady(::media::mojom::ReadyBufferPtr buffer) override;
    void OnBufferDestroyed(int32_t buffer_id) override;
    void OnFrameDropped(::media::VideoCaptureFrameDropReason reason) override;
    void OnNewSubCaptureTargetVersion(uint32_t sub_capture_target_version) override;
};
class VideoCaptureObserverAsyncWaiter {
public:
    explicit VideoCaptureObserverAsyncWaiter(VideoCaptureObserver* proxy);

    VideoCaptureObserverAsyncWaiter(const VideoCaptureObserverAsyncWaiter&) = delete;
    VideoCaptureObserverAsyncWaiter& operator=(const VideoCaptureObserverAsyncWaiter&) = delete;

    ~VideoCaptureObserverAsyncWaiter();

private:
    VideoCaptureObserver* const proxy_;
};

class VideoCaptureHostInterceptorForTesting : public VideoCaptureHost {
    virtual VideoCaptureHost* GetForwardingInterface() = 0;
    void Start(const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, const ::media::VideoCaptureParams& params,
        ::mojo::PendingRemote<VideoCaptureObserver> observer) override;
    void Stop(const ::base::UnguessableToken& device_id) override;
    void Pause(const ::base::UnguessableToken& device_id) override;
    void Resume(const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, const ::media::VideoCaptureParams& params) override;
    void RequestRefreshFrame(const ::base::UnguessableToken& device_id) override;
    void ReleaseBuffer(const ::base::UnguessableToken& device_id, int32_t buffer_id, const ::media::VideoCaptureFeedback& feedback) override;
    void GetDeviceSupportedFormats(
        const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, GetDeviceSupportedFormatsCallback callback) override;
    void GetDeviceFormatsInUse(
        const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, GetDeviceFormatsInUseCallback callback) override;
    void OnLog(const ::base::UnguessableToken& device_id, const std::string& message) override;
};
class VideoCaptureHostAsyncWaiter {
public:
    explicit VideoCaptureHostAsyncWaiter(VideoCaptureHost* proxy);

    VideoCaptureHostAsyncWaiter(const VideoCaptureHostAsyncWaiter&) = delete;
    VideoCaptureHostAsyncWaiter& operator=(const VideoCaptureHostAsyncWaiter&) = delete;

    ~VideoCaptureHostAsyncWaiter();
    void GetDeviceSupportedFormats(
        const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, std::vector<::media::VideoCaptureFormat>* out_formats_supported);
    std::vector<::media::VideoCaptureFormat> GetDeviceSupportedFormats(const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id);
    void GetDeviceFormatsInUse(
        const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id, std::vector<::media::VideoCaptureFormat>* out_formats_in_use);
    std::vector<::media::VideoCaptureFormat> GetDeviceFormatsInUse(const ::base::UnguessableToken& device_id, const ::base::UnguessableToken& session_id);

private:
    VideoCaptureHost* const proxy_;
};

} // media::mojom

#endif // MEDIA_CAPTURE_MOJOM_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_
