// media/mojo/mojom/media_foundation_service.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_MEDIA_FOUNDATION_SERVICE_MOJOM_TEST_UTILS_H_
#define MEDIA_MOJO_MOJOM_MEDIA_FOUNDATION_SERVICE_MOJOM_TEST_UTILS_H_

#include "media/mojo/mojom/media_foundation_service.mojom.h"

namespace media::mojom {

class GpuInfoObserverInterceptorForTesting : public GpuInfoObserver {
    virtual GpuInfoObserver* GetForwardingInterface() = 0;
    void OnGpuInfoUpdate(const ::gpu::GPUInfo& gpu_info) override;
};
class GpuInfoObserverAsyncWaiter {
public:
    explicit GpuInfoObserverAsyncWaiter(GpuInfoObserver* proxy);

    GpuInfoObserverAsyncWaiter(const GpuInfoObserverAsyncWaiter&) = delete;
    GpuInfoObserverAsyncWaiter& operator=(const GpuInfoObserverAsyncWaiter&) = delete;

    ~GpuInfoObserverAsyncWaiter();

private:
    GpuInfoObserver* const proxy_;
};

class MediaFoundationServiceInterceptorForTesting : public MediaFoundationService {
    virtual MediaFoundationService* GetForwardingInterface() = 0;
    void IsKeySystemSupported(const std::string& key_system, IsKeySystemSupportedCallback callback) override;
    void CreateInterfaceFactory(::mojo::PendingReceiver<::media::mojom::InterfaceFactory> factory,
        ::mojo::PendingRemote<::media::mojom::FrameInterfaceFactory> frame_interfaces) override;
};
class MediaFoundationServiceAsyncWaiter {
public:
    explicit MediaFoundationServiceAsyncWaiter(MediaFoundationService* proxy);

    MediaFoundationServiceAsyncWaiter(const MediaFoundationServiceAsyncWaiter&) = delete;
    MediaFoundationServiceAsyncWaiter& operator=(const MediaFoundationServiceAsyncWaiter&) = delete;

    ~MediaFoundationServiceAsyncWaiter();
    void IsKeySystemSupported(const std::string& key_system, bool* out_is_supported, std::optional<::media::KeySystemCapability>* out_key_system_capability);

private:
    MediaFoundationService* const proxy_;
};

class MediaFoundationServiceBrokerInterceptorForTesting : public MediaFoundationServiceBroker {
    virtual MediaFoundationServiceBroker* GetForwardingInterface() = 0;
    void UpdateGpuInfo(const ::gpu::GPUInfo& gpu_info, UpdateGpuInfoCallback callback) override;
    void GetService(const ::base::FilePath& cdm_path, ::mojo::PendingReceiver<MediaFoundationService> receiver) override;
};
class MediaFoundationServiceBrokerAsyncWaiter {
public:
    explicit MediaFoundationServiceBrokerAsyncWaiter(MediaFoundationServiceBroker* proxy);

    MediaFoundationServiceBrokerAsyncWaiter(const MediaFoundationServiceBrokerAsyncWaiter&) = delete;
    MediaFoundationServiceBrokerAsyncWaiter& operator=(const MediaFoundationServiceBrokerAsyncWaiter&) = delete;

    ~MediaFoundationServiceBrokerAsyncWaiter();
    void UpdateGpuInfo(const ::gpu::GPUInfo& gpu_info, ::mojo::PendingRemote<GpuInfoObserver>* out_gpu_info_observer);
    ::mojo::PendingRemote<GpuInfoObserver> UpdateGpuInfo(const ::gpu::GPUInfo& gpu_info);

private:
    MediaFoundationServiceBroker* const proxy_;
};

} // media::mojom

#endif // MEDIA_MOJO_MOJOM_MEDIA_FOUNDATION_SERVICE_MOJOM_TEST_UTILS_H_
