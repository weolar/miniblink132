// media/mojo/mojom/renderer_extensions.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_RENDERER_EXTENSIONS_MOJOM_TEST_UTILS_H_
#define MEDIA_MOJO_MOJOM_RENDERER_EXTENSIONS_MOJOM_TEST_UTILS_H_

#include "media/mojo/mojom/renderer_extensions.mojom.h"

namespace media::mojom {

class MediaPlayerRendererClientExtensionInterceptorForTesting : public MediaPlayerRendererClientExtension {
    virtual MediaPlayerRendererClientExtension* GetForwardingInterface() = 0;
    void OnVideoSizeChange(const ::gfx::Size& size) override;
    void OnDurationChange(::base::TimeDelta duration) override;
};
class MediaPlayerRendererClientExtensionAsyncWaiter {
public:
    explicit MediaPlayerRendererClientExtensionAsyncWaiter(MediaPlayerRendererClientExtension* proxy);

    MediaPlayerRendererClientExtensionAsyncWaiter(const MediaPlayerRendererClientExtensionAsyncWaiter&) = delete;
    MediaPlayerRendererClientExtensionAsyncWaiter& operator=(const MediaPlayerRendererClientExtensionAsyncWaiter&) = delete;

    ~MediaPlayerRendererClientExtensionAsyncWaiter();

private:
    MediaPlayerRendererClientExtension* const proxy_;
};

class MediaPlayerRendererExtensionInterceptorForTesting : public MediaPlayerRendererExtension {
    virtual MediaPlayerRendererExtension* GetForwardingInterface() = 0;
    void InitiateScopedSurfaceRequest(InitiateScopedSurfaceRequestCallback callback) override;
};
class MediaPlayerRendererExtensionAsyncWaiter {
public:
    explicit MediaPlayerRendererExtensionAsyncWaiter(MediaPlayerRendererExtension* proxy);

    MediaPlayerRendererExtensionAsyncWaiter(const MediaPlayerRendererExtensionAsyncWaiter&) = delete;
    MediaPlayerRendererExtensionAsyncWaiter& operator=(const MediaPlayerRendererExtensionAsyncWaiter&) = delete;

    ~MediaPlayerRendererExtensionAsyncWaiter();
    void InitiateScopedSurfaceRequest(::base::UnguessableToken* out_request_token);
    ::base::UnguessableToken InitiateScopedSurfaceRequest();

private:
    MediaPlayerRendererExtension* const proxy_;
};

class FlingingRendererClientExtensionInterceptorForTesting : public FlingingRendererClientExtension {
    virtual FlingingRendererClientExtension* GetForwardingInterface() = 0;
    void OnRemotePlayStateChange(::media::MediaStatus::State state) override;
};
class FlingingRendererClientExtensionAsyncWaiter {
public:
    explicit FlingingRendererClientExtensionAsyncWaiter(FlingingRendererClientExtension* proxy);

    FlingingRendererClientExtensionAsyncWaiter(const FlingingRendererClientExtensionAsyncWaiter&) = delete;
    FlingingRendererClientExtensionAsyncWaiter& operator=(const FlingingRendererClientExtensionAsyncWaiter&) = delete;

    ~FlingingRendererClientExtensionAsyncWaiter();

private:
    FlingingRendererClientExtension* const proxy_;
};

class MediaFoundationRendererClientExtensionInterceptorForTesting : public MediaFoundationRendererClientExtension {
    virtual MediaFoundationRendererClientExtension* GetForwardingInterface() = 0;
    void InitializeFramePool(FramePoolInitializationParametersPtr pool_info) override;
    void OnFrameAvailable(const ::base::UnguessableToken& frame_token, const ::gfx::Size& size, ::base::TimeDelta timestamp) override;
};
class MediaFoundationRendererClientExtensionAsyncWaiter {
public:
    explicit MediaFoundationRendererClientExtensionAsyncWaiter(MediaFoundationRendererClientExtension* proxy);

    MediaFoundationRendererClientExtensionAsyncWaiter(const MediaFoundationRendererClientExtensionAsyncWaiter&) = delete;
    MediaFoundationRendererClientExtensionAsyncWaiter& operator=(const MediaFoundationRendererClientExtensionAsyncWaiter&) = delete;

    ~MediaFoundationRendererClientExtensionAsyncWaiter();

private:
    MediaFoundationRendererClientExtension* const proxy_;
};

class MediaFoundationRendererExtensionInterceptorForTesting : public MediaFoundationRendererExtension {
    virtual MediaFoundationRendererExtension* GetForwardingInterface() = 0;
    void GetDCOMPSurface(GetDCOMPSurfaceCallback callback) override;
    void SetVideoStreamEnabled(bool enabled) override;
    void SetOutputRect(const ::gfx::Rect& rect, SetOutputRectCallback callback) override;
    void NotifyFrameReleased(const ::base::UnguessableToken& frame_token) override;
    void RequestNextFrame() override;
    void SetMediaFoundationRenderingMode(::media::MediaFoundationRenderingMode mode) override;
};
class MediaFoundationRendererExtensionAsyncWaiter {
public:
    explicit MediaFoundationRendererExtensionAsyncWaiter(MediaFoundationRendererExtension* proxy);

    MediaFoundationRendererExtensionAsyncWaiter(const MediaFoundationRendererExtensionAsyncWaiter&) = delete;
    MediaFoundationRendererExtensionAsyncWaiter& operator=(const MediaFoundationRendererExtensionAsyncWaiter&) = delete;

    ~MediaFoundationRendererExtensionAsyncWaiter();
    void GetDCOMPSurface(std::optional<::base::UnguessableToken>* out_token, std::string* out_error);

    void SetOutputRect(const ::gfx::Rect& rect, bool* out_success);
    bool SetOutputRect(const ::gfx::Rect& rect);

private:
    MediaFoundationRendererExtension* const proxy_;
};

class MediaFoundationRendererObserverInterceptorForTesting : public MediaFoundationRendererObserver {
    virtual MediaFoundationRendererObserver* GetForwardingInterface() = 0;
};
class MediaFoundationRendererObserverAsyncWaiter {
public:
    explicit MediaFoundationRendererObserverAsyncWaiter(MediaFoundationRendererObserver* proxy);

    MediaFoundationRendererObserverAsyncWaiter(const MediaFoundationRendererObserverAsyncWaiter&) = delete;
    MediaFoundationRendererObserverAsyncWaiter& operator=(const MediaFoundationRendererObserverAsyncWaiter&) = delete;

    ~MediaFoundationRendererObserverAsyncWaiter();

private:
    MediaFoundationRendererObserver* const proxy_;
};

class MediaFoundationRendererNotifierInterceptorForTesting : public MediaFoundationRendererNotifier {
    virtual MediaFoundationRendererNotifier* GetForwardingInterface() = 0;
    void MediaFoundationRendererCreated(::mojo::PendingReceiver<MediaFoundationRendererObserver> observer) override;
};
class MediaFoundationRendererNotifierAsyncWaiter {
public:
    explicit MediaFoundationRendererNotifierAsyncWaiter(MediaFoundationRendererNotifier* proxy);

    MediaFoundationRendererNotifierAsyncWaiter(const MediaFoundationRendererNotifierAsyncWaiter&) = delete;
    MediaFoundationRendererNotifierAsyncWaiter& operator=(const MediaFoundationRendererNotifierAsyncWaiter&) = delete;

    ~MediaFoundationRendererNotifierAsyncWaiter();

private:
    MediaFoundationRendererNotifier* const proxy_;
};

} // media::mojom

#endif // MEDIA_MOJO_MOJOM_RENDERER_EXTENSIONS_MOJOM_TEST_UTILS_H_
