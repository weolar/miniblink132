// media/mojo/mojom/speech_recognition_service.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_SPEECH_RECOGNITION_SERVICE_MOJOM_TEST_UTILS_H_
#define MEDIA_MOJO_MOJOM_SPEECH_RECOGNITION_SERVICE_MOJOM_TEST_UTILS_H_

#include "media/mojo/mojom/speech_recognition_service.mojom.h"

namespace media::mojom {

class AudioSourceSpeechRecognitionContextInterceptorForTesting : public AudioSourceSpeechRecognitionContext {
    virtual AudioSourceSpeechRecognitionContext* GetForwardingInterface() = 0;
    void BindAudioSourceFetcher(::mojo::PendingReceiver<AudioSourceFetcher> fetcher_receiver,
        ::mojo::PendingRemote<::media::mojom::SpeechRecognitionRecognizerClient> client, ::media::mojom::SpeechRecognitionOptionsPtr options,
        BindAudioSourceFetcherCallback callback) override;
};
class AudioSourceSpeechRecognitionContextAsyncWaiter {
public:
    explicit AudioSourceSpeechRecognitionContextAsyncWaiter(AudioSourceSpeechRecognitionContext* proxy);

    AudioSourceSpeechRecognitionContextAsyncWaiter(const AudioSourceSpeechRecognitionContextAsyncWaiter&) = delete;
    AudioSourceSpeechRecognitionContextAsyncWaiter& operator=(const AudioSourceSpeechRecognitionContextAsyncWaiter&) = delete;

    ~AudioSourceSpeechRecognitionContextAsyncWaiter();
    void BindAudioSourceFetcher(::mojo::PendingReceiver<AudioSourceFetcher> fetcher_receiver,
        ::mojo::PendingRemote<::media::mojom::SpeechRecognitionRecognizerClient> client, ::media::mojom::SpeechRecognitionOptionsPtr options,
        bool* out_is_multichannel_supported);
    bool BindAudioSourceFetcher(::mojo::PendingReceiver<AudioSourceFetcher> fetcher_receiver,
        ::mojo::PendingRemote<::media::mojom::SpeechRecognitionRecognizerClient> client, ::media::mojom::SpeechRecognitionOptionsPtr options);

private:
    AudioSourceSpeechRecognitionContext* const proxy_;
};

class SpeechRecognitionServiceInterceptorForTesting : public SpeechRecognitionService {
    virtual SpeechRecognitionService* GetForwardingInterface() = 0;
    void BindSpeechRecognitionContext(::mojo::PendingReceiver<::media::mojom::SpeechRecognitionContext> context) override;
    void BindAudioSourceSpeechRecognitionContext(::mojo::PendingReceiver<AudioSourceSpeechRecognitionContext> context) override;
    void SetSodaPaths(const ::base::FilePath& binary_path, const base::flat_map<std::string, ::base::FilePath>& config_paths,
        const std::string& primary_language_name) override;
    void SetSodaParams(bool mask_offensive_words) override;
    void SetSodaConfigPaths(const base::flat_map<std::string, ::base::FilePath>& config_paths) override;
};
class SpeechRecognitionServiceAsyncWaiter {
public:
    explicit SpeechRecognitionServiceAsyncWaiter(SpeechRecognitionService* proxy);

    SpeechRecognitionServiceAsyncWaiter(const SpeechRecognitionServiceAsyncWaiter&) = delete;
    SpeechRecognitionServiceAsyncWaiter& operator=(const SpeechRecognitionServiceAsyncWaiter&) = delete;

    ~SpeechRecognitionServiceAsyncWaiter();

private:
    SpeechRecognitionService* const proxy_;
};

class AudioSourceFetcherInterceptorForTesting : public AudioSourceFetcher {
    virtual AudioSourceFetcher* GetForwardingInterface() = 0;
    void Start(::mojo::PendingRemote<::media::mojom::AudioStreamFactory> factory, const std::string& device_id,
        const ::media::AudioParameters& audio_parameters) override;
    void Stop() override;
};
class AudioSourceFetcherAsyncWaiter {
public:
    explicit AudioSourceFetcherAsyncWaiter(AudioSourceFetcher* proxy);

    AudioSourceFetcherAsyncWaiter(const AudioSourceFetcherAsyncWaiter&) = delete;
    AudioSourceFetcherAsyncWaiter& operator=(const AudioSourceFetcherAsyncWaiter&) = delete;

    ~AudioSourceFetcherAsyncWaiter();

private:
    AudioSourceFetcher* const proxy_;
};

} // media::mojom

#endif // MEDIA_MOJO_MOJOM_SPEECH_RECOGNITION_SERVICE_MOJOM_TEST_UTILS_H_
