// media/mojo/mojom/video_encode_accelerator.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_VIDEO_ENCODE_ACCELERATOR_MOJOM_SHARED_H_
#define MEDIA_MOJO_MOJOM_VIDEO_ENCODE_ACCELERATOR_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "media/mojo/mojom/video_encode_accelerator.mojom-shared-internal.h"
#include "media/mojo/mojom/media_log.mojom-shared.h"
#include "media/mojo/mojom/media_types.mojom-shared.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/mojom/color_space.mojom-shared.h"
#include "media/mojo/mojom/video_encoder_info.mojom-shared.h"
#include "sandbox/policy/mojom/sandbox.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

#include "mojo/public/cpp/bindings/native_enum.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"

namespace media::mojom {
class VideoEncodeAcceleratorSupportedProfileDataView;

class EncodeCommandBufferIdDataView;

class VariableBitratePeakDataView;

class VideoBitrateAllocationDataView;

class SpatialLayerDataView;

class ConstantBitrateDataView;

class VariableBitrateDataView;

class ExternalBitrateDataView;

class VideoEncodeAcceleratorConfigDataView;

class VideoEncodeOptionsDataView;

class DropFrameMetadataDataView;

class H264MetadataDataView;

class Vp8MetadataDataView;

class Vp9MetadataDataView;

class SVCGenericMetadataDataView;

class BitstreamBufferMetadataDataView;

class BitrateDataView;
class OptionalMetadataDataView;

} // media::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::media::mojom::VideoEncodeAcceleratorSupportedProfileDataView> {
    using Data = ::media::mojom::internal::VideoEncodeAcceleratorSupportedProfile_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::EncodeCommandBufferIdDataView> {
    using Data = ::media::mojom::internal::EncodeCommandBufferId_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::VariableBitratePeakDataView> {
    using Data = ::media::mojom::internal::VariableBitratePeak_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::VideoBitrateAllocationDataView> {
    using Data = ::media::mojom::internal::VideoBitrateAllocation_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::SpatialLayerDataView> {
    using Data = ::media::mojom::internal::SpatialLayer_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::ConstantBitrateDataView> {
    using Data = ::media::mojom::internal::ConstantBitrate_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::VariableBitrateDataView> {
    using Data = ::media::mojom::internal::VariableBitrate_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::ExternalBitrateDataView> {
    using Data = ::media::mojom::internal::ExternalBitrate_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::VideoEncodeAcceleratorConfigDataView> {
    using Data = ::media::mojom::internal::VideoEncodeAcceleratorConfig_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::VideoEncodeOptionsDataView> {
    using Data = ::media::mojom::internal::VideoEncodeOptions_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::DropFrameMetadataDataView> {
    using Data = ::media::mojom::internal::DropFrameMetadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::H264MetadataDataView> {
    using Data = ::media::mojom::internal::H264Metadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::Vp8MetadataDataView> {
    using Data = ::media::mojom::internal::Vp8Metadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::Vp9MetadataDataView> {
    using Data = ::media::mojom::internal::Vp9Metadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::SVCGenericMetadataDataView> {
    using Data = ::media::mojom::internal::SVCGenericMetadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::BitstreamBufferMetadataDataView> {
    using Data = ::media::mojom::internal::BitstreamBufferMetadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::media::mojom::BitrateDataView> {
    using Data = ::media::mojom::internal::Bitrate_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <> struct MojomTypeTraits<::media::mojom::OptionalMetadataDataView> {
    using Data = ::media::mojom::internal::OptionalMetadata_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

} // namespace internal
} // namespace mojo

namespace media::mojom {

enum class VideoEncodeAcceleratorSupportedRateControlMode : int32_t {

    kNoMode = 0,

    kConstantMode = 1,

    kVariableMode = 2,

    kExternalMode = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, VideoEncodeAcceleratorSupportedRateControlMode value);
inline bool IsKnownEnumValue(VideoEncodeAcceleratorSupportedRateControlMode value)
{
    return internal::VideoEncodeAcceleratorSupportedRateControlMode_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class VideoEncodeAcceleratorConfig_ContentType : int32_t {

    kCamera = 0,

    kDisplay = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

std::ostream& operator<<(std::ostream& os, VideoEncodeAcceleratorConfig_ContentType value);
inline bool IsKnownEnumValue(VideoEncodeAcceleratorConfig_ContentType value)
{
    return internal::VideoEncodeAcceleratorConfig_ContentType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class VideoEncodeAcceleratorConfig_StorageType : int32_t {

    kShmem = 0,

    kGpuMemoryBuffer = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

std::ostream& operator<<(std::ostream& os, VideoEncodeAcceleratorConfig_StorageType value);
inline bool IsKnownEnumValue(VideoEncodeAcceleratorConfig_StorageType value)
{
    return internal::VideoEncodeAcceleratorConfig_StorageType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class VideoEncodeAcceleratorConfig_EncoderType : int32_t {

    kHardware = 0,

    kSoftware = 1,

    kNoPreference = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, VideoEncodeAcceleratorConfig_EncoderType value);
inline bool IsKnownEnumValue(VideoEncodeAcceleratorConfig_EncoderType value)
{
    return internal::VideoEncodeAcceleratorConfig_EncoderType_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class VideoEncodeAcceleratorProviderInterfaceBase { };

using VideoEncodeAcceleratorProviderPtrDataView = mojo::InterfacePtrDataView<VideoEncodeAcceleratorProviderInterfaceBase>;
using VideoEncodeAcceleratorProviderRequestDataView = mojo::InterfaceRequestDataView<VideoEncodeAcceleratorProviderInterfaceBase>;
using VideoEncodeAcceleratorProviderAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<VideoEncodeAcceleratorProviderInterfaceBase>;
using VideoEncodeAcceleratorProviderAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<VideoEncodeAcceleratorProviderInterfaceBase>;
class VideoEncodeAcceleratorInterfaceBase { };

using VideoEncodeAcceleratorPtrDataView = mojo::InterfacePtrDataView<VideoEncodeAcceleratorInterfaceBase>;
using VideoEncodeAcceleratorRequestDataView = mojo::InterfaceRequestDataView<VideoEncodeAcceleratorInterfaceBase>;
using VideoEncodeAcceleratorAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<VideoEncodeAcceleratorInterfaceBase>;
using VideoEncodeAcceleratorAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<VideoEncodeAcceleratorInterfaceBase>;
class VideoEncodeAcceleratorClientInterfaceBase { };

using VideoEncodeAcceleratorClientPtrDataView = mojo::InterfacePtrDataView<VideoEncodeAcceleratorClientInterfaceBase>;
using VideoEncodeAcceleratorClientRequestDataView = mojo::InterfaceRequestDataView<VideoEncodeAcceleratorClientInterfaceBase>;
using VideoEncodeAcceleratorClientAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<VideoEncodeAcceleratorClientInterfaceBase>;
using VideoEncodeAcceleratorClientAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<VideoEncodeAcceleratorClientInterfaceBase>;

class VideoEncodeAcceleratorSupportedProfileDataView {
public:
    VideoEncodeAcceleratorSupportedProfileDataView() = default;

    VideoEncodeAcceleratorSupportedProfileDataView(internal::VideoEncodeAcceleratorSupportedProfile_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadProfile(UserType* output) const
    {
        auto data_value = data_->profile;
        return mojo::internal::Deserialize<::media::mojom::VideoCodecProfile>(data_value, output);
    }
    ::media::mojom::VideoCodecProfile profile() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoCodecProfile>(data_->profile));
    }
    inline void GetMinResolutionDataView(::gfx::mojom::SizeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMinResolution(UserType* output)
    {

        auto* pointer = data_->min_resolution.Get();
        return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(pointer, output, message_);
    }
    inline void GetMaxResolutionDataView(::gfx::mojom::SizeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMaxResolution(UserType* output)
    {

        auto* pointer = data_->max_resolution.Get();
        return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(pointer, output, message_);
    }
    uint32_t max_framerate_numerator() const
    {
        return data_->max_framerate_numerator;
    }
    uint32_t max_framerate_denominator() const
    {
        return data_->max_framerate_denominator;
    }
    inline void GetRateControlModesDataView(mojo::ArrayDataView<VideoEncodeAcceleratorSupportedRateControlMode>* output);

    template <typename UserType> [[nodiscard]] bool ReadRateControlModes(UserType* output)
    {

        auto* pointer = data_->rate_control_modes.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode>>(pointer, output, message_);
    }
    inline void GetScalabilityModesDataView(mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>* output);

    template <typename UserType> [[nodiscard]] bool ReadScalabilityModes(UserType* output)
    {

        auto* pointer = data_->scalability_modes.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>>(pointer, output, message_);
    }
    bool is_software_codec() const
    {
        return data_->is_software_codec;
    }
    inline void GetGpuSupportedPixelFormatsDataView(mojo::ArrayDataView<::media::mojom::VideoPixelFormat>* output);

    template <typename UserType> [[nodiscard]] bool ReadGpuSupportedPixelFormats(UserType* output)
    {

        auto* pointer = data_->gpu_supported_pixel_formats.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::media::mojom::VideoPixelFormat>>(pointer, output, message_);
    }
    bool supports_gpu_shared_images() const
    {
        return data_->supports_gpu_shared_images;
    }

private:
    internal::VideoEncodeAcceleratorSupportedProfile_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class EncodeCommandBufferIdDataView {
public:
    EncodeCommandBufferIdDataView() = default;

    EncodeCommandBufferIdDataView(internal::EncodeCommandBufferId_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetChannelTokenDataView(::mojo_base::mojom::UnguessableTokenDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadChannelToken(UserType* output)
    {

        auto* pointer = data_->channel_token.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(pointer, output, message_);
    }
    int32_t route_id() const
    {
        return data_->route_id;
    }

private:
    internal::EncodeCommandBufferId_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class VariableBitratePeakDataView {
public:
    VariableBitratePeakDataView() = default;

    VariableBitratePeakDataView(internal::VariableBitratePeak_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t bps() const
    {
        return data_->bps;
    }

private:
    internal::VariableBitratePeak_Data* data_ = nullptr;
};

class VideoBitrateAllocationDataView {
public:
    VideoBitrateAllocationDataView() = default;

    VideoBitrateAllocationDataView(internal::VideoBitrateAllocation_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetBitratesDataView(mojo::ArrayDataView<uint32_t>* output);

    template <typename UserType> [[nodiscard]] bool ReadBitrates(UserType* output)
    {

        auto* pointer = data_->bitrates.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<uint32_t>>(pointer, output, message_);
    }
    inline void GetVariableBitratePeakDataView(VariableBitratePeakDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadVariableBitratePeak(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::media::mojom::VariableBitratePeakDataView, UserType>(),
            "Attempting to read the optional `variable_bitrate_peak` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadVariableBitratePeak` instead "
            "of `ReadVariableBitratePeak if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->variable_bitrate_peak.Get();
        return mojo::internal::Deserialize<::media::mojom::VariableBitratePeakDataView>(pointer, output, message_);
    }

private:
    internal::VideoBitrateAllocation_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SpatialLayerDataView {
public:
    SpatialLayerDataView() = default;

    SpatialLayerDataView(internal::SpatialLayer_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    int32_t width() const
    {
        return data_->width;
    }
    int32_t height() const
    {
        return data_->height;
    }
    uint32_t bitrate_bps() const
    {
        return data_->bitrate_bps;
    }
    uint32_t framerate() const
    {
        return data_->framerate;
    }
    uint8_t max_qp() const
    {
        return data_->max_qp;
    }
    uint8_t num_of_temporal_layers() const
    {
        return data_->num_of_temporal_layers;
    }

private:
    internal::SpatialLayer_Data* data_ = nullptr;
};

class ConstantBitrateDataView {
public:
    ConstantBitrateDataView() = default;

    ConstantBitrateDataView(internal::ConstantBitrate_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t target_bps() const
    {
        return data_->target_bps;
    }

private:
    internal::ConstantBitrate_Data* data_ = nullptr;
};

class VariableBitrateDataView {
public:
    VariableBitrateDataView() = default;

    VariableBitrateDataView(internal::VariableBitrate_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t target_bps() const
    {
        return data_->target_bps;
    }
    uint32_t peak_bps() const
    {
        return data_->peak_bps;
    }

private:
    internal::VariableBitrate_Data* data_ = nullptr;
};

class ExternalBitrateDataView {
public:
    ExternalBitrateDataView() = default;

    ExternalBitrateDataView(internal::ExternalBitrate_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }

private:
    internal::ExternalBitrate_Data* data_ = nullptr;
};

class VideoEncodeAcceleratorConfigDataView {
public:
    VideoEncodeAcceleratorConfigDataView() = default;

    VideoEncodeAcceleratorConfigDataView(internal::VideoEncodeAcceleratorConfig_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadInputFormat(UserType* output) const
    {
        auto data_value = data_->input_format;
        return mojo::internal::Deserialize<::media::mojom::VideoPixelFormat>(data_value, output);
    }
    ::media::mojom::VideoPixelFormat input_format() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoPixelFormat>(data_->input_format));
    }
    inline void GetInputVisibleSizeDataView(::gfx::mojom::SizeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInputVisibleSize(UserType* output)
    {

        auto* pointer = data_->input_visible_size.Get();
        return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadOutputProfile(UserType* output) const
    {
        auto data_value = data_->output_profile;
        return mojo::internal::Deserialize<::media::mojom::VideoCodecProfile>(data_value, output);
    }
    ::media::mojom::VideoCodecProfile output_profile() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoCodecProfile>(data_->output_profile));
    }
    inline void GetBitrateDataView(BitrateDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadBitrate(UserType* output)
    {

        auto* pointer = !data_->bitrate.is_null() ? &data_->bitrate : nullptr;
        return mojo::internal::Deserialize<::media::mojom::BitrateDataView>(pointer, output, message_);
    }
    uint32_t framerate() const
    {
        return data_->framerate;
    }
    template <typename UserType> [[nodiscard]] bool ReadStorageType(UserType* output) const
    {
        auto data_value = data_->storage_type;
        return mojo::internal::Deserialize<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>(data_value, output);
    }
    VideoEncodeAcceleratorConfig_StorageType storage_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>(data_->storage_type));
    }
    template <typename UserType> [[nodiscard]] bool ReadContentType(UserType* output) const
    {
        auto data_value = data_->content_type;
        return mojo::internal::Deserialize<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>(data_value, output);
    }
    VideoEncodeAcceleratorConfig_ContentType content_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>(data_->content_type));
    }
    uint32_t gop_length() const
    {
        return data_->gop_length;
    }
    bool has_gop_length() const
    {
        return data_->has_gop_length;
    }
    uint8_t h264_output_level() const
    {
        return data_->h264_output_level;
    }
    bool has_h264_output_level() const
    {
        return data_->has_h264_output_level;
    }
    bool is_constrained_h264() const
    {
        return data_->is_constrained_h264;
    }
    uint8_t drop_frame_thresh_percentage() const
    {
        return data_->drop_frame_thresh_percentage;
    }
    inline void GetSpatialLayersDataView(mojo::ArrayDataView<SpatialLayerDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadSpatialLayers(UserType* output)
    {

        auto* pointer = data_->spatial_layers.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::media::mojom::SpatialLayerDataView>>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadInterLayerPred(UserType* output) const
    {
        auto data_value = data_->inter_layer_pred;
        return mojo::internal::Deserialize<::media::mojom::SVCInterLayerPredMode>(data_value, output);
    }
    ::media::mojom::SVCInterLayerPredMode inter_layer_pred() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::SVCInterLayerPredMode>(data_->inter_layer_pred));
    }
    bool require_low_delay() const
    {
        return data_->require_low_delay;
    }
    template <typename UserType> [[nodiscard]] bool ReadRequiredEncoderType(UserType* output) const
    {
        auto data_value = data_->required_encoder_type;
        return mojo::internal::Deserialize<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType>(data_value, output);
    }
    VideoEncodeAcceleratorConfig_EncoderType required_encoder_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType>(data_->required_encoder_type));
    }

private:
    internal::VideoEncodeAcceleratorConfig_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class VideoEncodeOptionsDataView {
public:
    VideoEncodeOptionsDataView() = default;

    VideoEncodeOptionsDataView(internal::VideoEncodeOptions_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    bool force_keyframe() const
    {
        return data_->force_keyframe;
    }
    int32_t quantizer() const
    {
        return data_->quantizer;
    }

private:
    internal::VideoEncodeOptions_Data* data_ = nullptr;
};

class DropFrameMetadataDataView {
public:
    DropFrameMetadataDataView() = default;

    DropFrameMetadataDataView(internal::DropFrameMetadata_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint8_t spatial_idx() const
    {
        return data_->spatial_idx;
    }
    bool end_of_picture() const
    {
        return data_->end_of_picture;
    }

private:
    internal::DropFrameMetadata_Data* data_ = nullptr;
};

class H264MetadataDataView {
public:
    H264MetadataDataView() = default;

    H264MetadataDataView(internal::H264Metadata_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint8_t temporal_idx() const
    {
        return data_->temporal_idx;
    }
    bool layer_sync() const
    {
        return data_->layer_sync;
    }

private:
    internal::H264Metadata_Data* data_ = nullptr;
};

class Vp8MetadataDataView {
public:
    Vp8MetadataDataView() = default;

    Vp8MetadataDataView(internal::Vp8Metadata_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    bool non_reference() const
    {
        return data_->non_reference;
    }
    uint8_t temporal_idx() const
    {
        return data_->temporal_idx;
    }
    bool layer_sync() const
    {
        return data_->layer_sync;
    }

private:
    internal::Vp8Metadata_Data* data_ = nullptr;
};

class Vp9MetadataDataView {
public:
    Vp9MetadataDataView() = default;

    Vp9MetadataDataView(internal::Vp9Metadata_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    bool inter_pic_predicted() const
    {
        return data_->inter_pic_predicted;
    }
    bool temporal_up_switch() const
    {
        return data_->temporal_up_switch;
    }
    bool referenced_by_upper_spatial_layers() const
    {
        return data_->referenced_by_upper_spatial_layers;
    }
    bool reference_lower_spatial_layers() const
    {
        return data_->reference_lower_spatial_layers;
    }
    bool end_of_picture() const
    {
        return data_->end_of_picture;
    }
    uint8_t temporal_idx() const
    {
        return data_->temporal_idx;
    }
    uint8_t spatial_idx() const
    {
        return data_->spatial_idx;
    }
    inline void GetSpatialLayerResolutionsDataView(mojo::ArrayDataView<::gfx::mojom::SizeDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadSpatialLayerResolutions(UserType* output)
    {

        auto* pointer = data_->spatial_layer_resolutions.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::gfx::mojom::SizeDataView>>(pointer, output, message_);
    }
    uint8_t begin_active_spatial_layer_index() const
    {
        return data_->begin_active_spatial_layer_index;
    }
    uint8_t end_active_spatial_layer_index() const
    {
        return data_->end_active_spatial_layer_index;
    }
    inline void GetPDiffsDataView(mojo::ArrayDataView<uint8_t>* output);

    template <typename UserType> [[nodiscard]] bool ReadPDiffs(UserType* output)
    {

        auto* pointer = data_->p_diffs.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(pointer, output, message_);
    }

private:
    internal::Vp9Metadata_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SVCGenericMetadataDataView {
public:
    SVCGenericMetadataDataView() = default;

    SVCGenericMetadataDataView(internal::SVCGenericMetadata_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    bool follow_svc_spec() const
    {
        return data_->follow_svc_spec;
    }
    uint8_t temporal_idx() const
    {
        return data_->temporal_idx;
    }
    uint8_t spatial_idx() const
    {
        return data_->spatial_idx;
    }
    std::optional<uint16_t> reference_flags() const
    {

        return data_->reference_flags_$flag ? std::make_optional(data_->reference_flags_$value) : std::nullopt;
    }
    std::optional<uint16_t> refresh_flags() const
    {

        return data_->refresh_flags_$flag ? std::make_optional(data_->refresh_flags_$value) : std::nullopt;
    }

private:
    internal::SVCGenericMetadata_Data* data_ = nullptr;
};

class BitstreamBufferMetadataDataView {
public:
    BitstreamBufferMetadataDataView() = default;

    BitstreamBufferMetadataDataView(internal::BitstreamBufferMetadata_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t payload_size_bytes() const
    {
        return data_->payload_size_bytes;
    }
    bool key_frame() const
    {
        return data_->key_frame;
    }
    inline void GetTimestampDataView(::mojo_base::mojom::TimeDeltaDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTimestamp(UserType* output)
    {

        auto* pointer = data_->timestamp.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(pointer, output, message_);
    }
    int32_t qp() const
    {
        return data_->qp;
    }
    inline void GetOptionalMetadataDataView(OptionalMetadataDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadOptionalMetadata(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::media::mojom::OptionalMetadataDataView, UserType>(),
            "Attempting to read the optional `optional_metadata` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadOptionalMetadata` instead "
            "of `ReadOptionalMetadata if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = !data_->optional_metadata.is_null() ? &data_->optional_metadata : nullptr;
        return mojo::internal::Deserialize<::media::mojom::OptionalMetadataDataView>(pointer, output, message_);
    }
    inline void GetSvcGenericDataView(SVCGenericMetadataDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSvcGeneric(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::media::mojom::SVCGenericMetadataDataView, UserType>(),
            "Attempting to read the optional `svc_generic` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSvcGeneric` instead "
            "of `ReadSvcGeneric if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->svc_generic.Get();
        return mojo::internal::Deserialize<::media::mojom::SVCGenericMetadataDataView>(pointer, output, message_);
    }
    inline void GetEncodedSizeDataView(::gfx::mojom::SizeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadEncodedSize(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::gfx::mojom::SizeDataView, UserType>(),
            "Attempting to read the optional `encoded_size` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadEncodedSize` instead "
            "of `ReadEncodedSize if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->encoded_size.Get();
        return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(pointer, output, message_);
    }
    inline void GetEncodedColorSpaceDataView(::gfx::mojom::ColorSpaceDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadEncodedColorSpace(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::gfx::mojom::ColorSpaceDataView, UserType>(),
            "Attempting to read the optional `encoded_color_space` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadEncodedColorSpace` instead "
            "of `ReadEncodedColorSpace if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->encoded_color_space.Get();
        return mojo::internal::Deserialize<::gfx::mojom::ColorSpaceDataView>(pointer, output, message_);
    }

private:
    internal::BitstreamBufferMetadata_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class BitrateDataView {
public:
    using Tag = internal::Bitrate_Data::Bitrate_Tag;

    BitrateDataView() = default;

    BitrateDataView(internal::Bitrate_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_constant() const
    {
        return data_->tag == Tag::kConstant;
    }
    inline void GetConstantDataView(ConstantBitrateDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadConstant(UserType* output) const
    {

        CHECK(is_constant());
        return mojo::internal::Deserialize<::media::mojom::ConstantBitrateDataView>(data_->data.f_constant.Get(), output, message_);
    }
    bool is_variable() const
    {
        return data_->tag == Tag::kVariable;
    }
    inline void GetVariableDataView(VariableBitrateDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadVariable(UserType* output) const
    {

        CHECK(is_variable());
        return mojo::internal::Deserialize<::media::mojom::VariableBitrateDataView>(data_->data.f_variable.Get(), output, message_);
    }
    bool is_external() const
    {
        return data_->tag == Tag::kExternal;
    }
    inline void GetExternalDataView(ExternalBitrateDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadExternal(UserType* output) const
    {

        CHECK(is_external());
        return mojo::internal::Deserialize<::media::mojom::ExternalBitrateDataView>(data_->data.f_external.Get(), output, message_);
    }

private:
    internal::Bitrate_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class OptionalMetadataDataView {
public:
    using Tag = internal::OptionalMetadata_Data::OptionalMetadata_Tag;

    OptionalMetadataDataView() = default;

    OptionalMetadataDataView(internal::OptionalMetadata_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_drop() const
    {
        return data_->tag == Tag::kDrop;
    }
    inline void GetDropDataView(DropFrameMetadataDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadDrop(UserType* output) const
    {

        CHECK(is_drop());
        return mojo::internal::Deserialize<::media::mojom::DropFrameMetadataDataView>(data_->data.f_drop.Get(), output, message_);
    }
    bool is_h264() const
    {
        return data_->tag == Tag::kH264;
    }
    inline void GetH264DataView(H264MetadataDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadH264(UserType* output) const
    {

        CHECK(is_h264());
        return mojo::internal::Deserialize<::media::mojom::H264MetadataDataView>(data_->data.f_h264.Get(), output, message_);
    }
    bool is_vp8() const
    {
        return data_->tag == Tag::kVp8;
    }
    inline void GetVp8DataView(Vp8MetadataDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadVp8(UserType* output) const
    {

        CHECK(is_vp8());
        return mojo::internal::Deserialize<::media::mojom::Vp8MetadataDataView>(data_->data.f_vp8.Get(), output, message_);
    }
    bool is_vp9() const
    {
        return data_->tag == Tag::kVp9;
    }
    inline void GetVp9DataView(Vp9MetadataDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadVp9(UserType* output) const
    {

        CHECK(is_vp9());
        return mojo::internal::Deserialize<::media::mojom::Vp9MetadataDataView>(data_->data.f_vp9.Get(), output, message_);
    }

private:
    internal::OptionalMetadata_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // media::mojom

namespace std {

template <>
struct hash<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode> { };

template <>
struct hash<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAcceleratorConfig_ContentType> { };

template <>
struct hash<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAcceleratorConfig_StorageType> { };

template <>
struct hash<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType>
    : public mojo::internal::EnumHashImpl<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(
            ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VideoEncodeAcceleratorConfig_ContentType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::media::mojom::VideoEncodeAcceleratorConfig_ContentType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(
            ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VideoEncodeAcceleratorConfig_StorageType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::media::mojom::VideoEncodeAcceleratorConfig_StorageType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(
            ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(
            ::mojo::internal::ToKnownEnumValueHelper(static_cast<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VideoEncodeAcceleratorSupportedProfileDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::VideoEncodeAcceleratorSupportedProfileDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::VideoEncodeAcceleratorSupportedProfile_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::media::mojom::VideoCodecProfile>(Traits::profile(input), &fragment->profile);
        decltype(Traits::min_resolution(input)) in_min_resolution = Traits::min_resolution(input);
        mojo::internal::MessageFragment<typename decltype(fragment->min_resolution)::BaseType> min_resolution_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_min_resolution, min_resolution_fragment);
        fragment->min_resolution.Set(min_resolution_fragment.is_null() ? nullptr : min_resolution_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->min_resolution.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null min_resolution in VideoEncodeAcceleratorSupportedProfile struct");
        decltype(Traits::max_resolution(input)) in_max_resolution = Traits::max_resolution(input);
        mojo::internal::MessageFragment<typename decltype(fragment->max_resolution)::BaseType> max_resolution_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_max_resolution, max_resolution_fragment);
        fragment->max_resolution.Set(max_resolution_fragment.is_null() ? nullptr : max_resolution_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->max_resolution.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null max_resolution in VideoEncodeAcceleratorSupportedProfile struct");
        fragment->max_framerate_numerator = Traits::max_framerate_numerator(input);
        fragment->max_framerate_denominator = Traits::max_framerate_denominator(input);
        decltype(Traits::rate_control_modes(input)) in_rate_control_modes = Traits::rate_control_modes(input);
        mojo::internal::MessageFragment<typename decltype(fragment->rate_control_modes)::BaseType> rate_control_modes_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& rate_control_modes_validate_params
            = mojo::internal::GetArrayOfEnumsValidator<0, false, ::media::mojom::internal::VideoEncodeAcceleratorSupportedRateControlMode_Data::Validate>();
        mojo::internal::Serialize<mojo::ArrayDataView<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode>>(
            in_rate_control_modes, rate_control_modes_fragment, &rate_control_modes_validate_params);
        fragment->rate_control_modes.Set(rate_control_modes_fragment.is_null() ? nullptr : rate_control_modes_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->rate_control_modes.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null rate_control_modes in VideoEncodeAcceleratorSupportedProfile struct");
        decltype(Traits::scalability_modes(input)) in_scalability_modes = Traits::scalability_modes(input);
        mojo::internal::MessageFragment<typename decltype(fragment->scalability_modes)::BaseType> scalability_modes_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& scalability_modes_validate_params
            = mojo::internal::GetArrayOfEnumsValidator<0, false, ::media::mojom::internal::SVCScalabilityMode_Data::Validate>();
        mojo::internal::Serialize<mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>>(
            in_scalability_modes, scalability_modes_fragment, &scalability_modes_validate_params);
        fragment->scalability_modes.Set(scalability_modes_fragment.is_null() ? nullptr : scalability_modes_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->scalability_modes.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null scalability_modes in VideoEncodeAcceleratorSupportedProfile struct");
        fragment->is_software_codec = Traits::is_software_codec(input);
        decltype(Traits::gpu_supported_pixel_formats(input)) in_gpu_supported_pixel_formats = Traits::gpu_supported_pixel_formats(input);
        mojo::internal::MessageFragment<typename decltype(fragment->gpu_supported_pixel_formats)::BaseType> gpu_supported_pixel_formats_fragment(
            fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& gpu_supported_pixel_formats_validate_params
            = mojo::internal::GetArrayOfEnumsValidator<0, false, ::media::mojom::internal::VideoPixelFormat_Data::Validate>();
        mojo::internal::Serialize<mojo::ArrayDataView<::media::mojom::VideoPixelFormat>>(
            in_gpu_supported_pixel_formats, gpu_supported_pixel_formats_fragment, &gpu_supported_pixel_formats_validate_params);
        fragment->gpu_supported_pixel_formats.Set(gpu_supported_pixel_formats_fragment.is_null() ? nullptr : gpu_supported_pixel_formats_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->gpu_supported_pixel_formats.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null gpu_supported_pixel_formats in VideoEncodeAcceleratorSupportedProfile struct");
        fragment->supports_gpu_shared_images = Traits::supports_gpu_shared_images(input);
    }

    static bool Deserialize(::media::mojom::internal::VideoEncodeAcceleratorSupportedProfile_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::VideoEncodeAcceleratorSupportedProfileDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::EncodeCommandBufferIdDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::EncodeCommandBufferIdDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::EncodeCommandBufferId_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::channel_token(input)) in_channel_token = Traits::channel_token(input);
        mojo::internal::MessageFragment<typename decltype(fragment->channel_token)::BaseType> channel_token_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(in_channel_token, channel_token_fragment);
        fragment->channel_token.Set(channel_token_fragment.is_null() ? nullptr : channel_token_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->channel_token.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null channel_token in EncodeCommandBufferId struct");
        fragment->route_id = Traits::route_id(input);
    }

    static bool Deserialize(::media::mojom::internal::EncodeCommandBufferId_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::EncodeCommandBufferIdDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VariableBitratePeakDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::VariableBitratePeakDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::VariableBitratePeak_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->bps = Traits::bps(input);
    }

    static bool Deserialize(::media::mojom::internal::VariableBitratePeak_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::VariableBitratePeakDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VideoBitrateAllocationDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::VideoBitrateAllocationDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::VideoBitrateAllocation_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::bitrates(input)) in_bitrates = Traits::bitrates(input);
        mojo::internal::MessageFragment<typename decltype(fragment->bitrates)::BaseType> bitrates_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& bitrates_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(in_bitrates, bitrates_fragment, &bitrates_validate_params);
        fragment->bitrates.Set(bitrates_fragment.is_null() ? nullptr : bitrates_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->bitrates.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null bitrates in VideoBitrateAllocation struct");
        decltype(Traits::variable_bitrate_peak(input)) in_variable_bitrate_peak = Traits::variable_bitrate_peak(input);
        mojo::internal::MessageFragment<typename decltype(fragment->variable_bitrate_peak)::BaseType> variable_bitrate_peak_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::VariableBitratePeakDataView>(in_variable_bitrate_peak, variable_bitrate_peak_fragment);
        fragment->variable_bitrate_peak.Set(variable_bitrate_peak_fragment.is_null() ? nullptr : variable_bitrate_peak_fragment.data());
    }

    static bool Deserialize(::media::mojom::internal::VideoBitrateAllocation_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::VideoBitrateAllocationDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::SpatialLayerDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::SpatialLayerDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::SpatialLayer_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->width = Traits::width(input);
        fragment->height = Traits::height(input);
        fragment->bitrate_bps = Traits::bitrate_bps(input);
        fragment->framerate = Traits::framerate(input);
        fragment->max_qp = Traits::max_qp(input);
        fragment->num_of_temporal_layers = Traits::num_of_temporal_layers(input);
    }

    static bool Deserialize(::media::mojom::internal::SpatialLayer_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::SpatialLayerDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::ConstantBitrateDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::ConstantBitrateDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::ConstantBitrate_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->target_bps = Traits::target_bps(input);
    }

    static bool Deserialize(::media::mojom::internal::ConstantBitrate_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::ConstantBitrateDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VariableBitrateDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::VariableBitrateDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::VariableBitrate_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->target_bps = Traits::target_bps(input);
        fragment->peak_bps = Traits::peak_bps(input);
    }

    static bool Deserialize(::media::mojom::internal::VariableBitrate_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::VariableBitrateDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::ExternalBitrateDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::ExternalBitrateDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::ExternalBitrate_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
    }

    static bool Deserialize(::media::mojom::internal::ExternalBitrate_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::ExternalBitrateDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VideoEncodeAcceleratorConfigDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::VideoEncodeAcceleratorConfigDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::VideoEncodeAcceleratorConfig_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::media::mojom::VideoPixelFormat>(Traits::input_format(input), &fragment->input_format);
        decltype(Traits::input_visible_size(input)) in_input_visible_size = Traits::input_visible_size(input);
        mojo::internal::MessageFragment<typename decltype(fragment->input_visible_size)::BaseType> input_visible_size_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_input_visible_size, input_visible_size_fragment);
        fragment->input_visible_size.Set(input_visible_size_fragment.is_null() ? nullptr : input_visible_size_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->input_visible_size.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null input_visible_size in VideoEncodeAcceleratorConfig struct");
        mojo::internal::Serialize<::media::mojom::VideoCodecProfile>(Traits::output_profile(input), &fragment->output_profile);
        decltype(Traits::bitrate(input)) in_bitrate = Traits::bitrate(input);
        mojo::internal::MessageFragment<decltype(fragment->bitrate)> bitrate_fragment(fragment.message());
        bitrate_fragment.Claim(&fragment->bitrate);
        mojo::internal::Serialize<::media::mojom::BitrateDataView>(in_bitrate, bitrate_fragment, true);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->bitrate.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null bitrate in VideoEncodeAcceleratorConfig struct");
        fragment->framerate = Traits::framerate(input);
        mojo::internal::Serialize<::media::mojom::VideoEncodeAcceleratorConfig_StorageType>(Traits::storage_type(input), &fragment->storage_type);
        mojo::internal::Serialize<::media::mojom::VideoEncodeAcceleratorConfig_ContentType>(Traits::content_type(input), &fragment->content_type);
        fragment->gop_length = Traits::gop_length(input);
        fragment->has_gop_length = Traits::has_gop_length(input);
        fragment->h264_output_level = Traits::h264_output_level(input);
        fragment->has_h264_output_level = Traits::has_h264_output_level(input);
        fragment->is_constrained_h264 = Traits::is_constrained_h264(input);
        fragment->drop_frame_thresh_percentage = Traits::drop_frame_thresh_percentage(input);
        decltype(Traits::spatial_layers(input)) in_spatial_layers = Traits::spatial_layers(input);
        mojo::internal::MessageFragment<typename decltype(fragment->spatial_layers)::BaseType> spatial_layers_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& spatial_layers_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::media::mojom::SpatialLayerDataView>>(
            in_spatial_layers, spatial_layers_fragment, &spatial_layers_validate_params);
        fragment->spatial_layers.Set(spatial_layers_fragment.is_null() ? nullptr : spatial_layers_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->spatial_layers.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null spatial_layers in VideoEncodeAcceleratorConfig struct");
        mojo::internal::Serialize<::media::mojom::SVCInterLayerPredMode>(Traits::inter_layer_pred(input), &fragment->inter_layer_pred);
        fragment->require_low_delay = Traits::require_low_delay(input);
        mojo::internal::Serialize<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType>(
            Traits::required_encoder_type(input), &fragment->required_encoder_type);
    }

    static bool Deserialize(::media::mojom::internal::VideoEncodeAcceleratorConfig_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::VideoEncodeAcceleratorConfigDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::VideoEncodeOptionsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::VideoEncodeOptionsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::VideoEncodeOptions_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->force_keyframe = Traits::force_keyframe(input);
        fragment->quantizer = Traits::quantizer(input);
    }

    static bool Deserialize(::media::mojom::internal::VideoEncodeOptions_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::VideoEncodeOptionsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::DropFrameMetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::DropFrameMetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::DropFrameMetadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->spatial_idx = Traits::spatial_idx(input);
        fragment->end_of_picture = Traits::end_of_picture(input);
    }

    static bool Deserialize(::media::mojom::internal::DropFrameMetadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::DropFrameMetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::H264MetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::H264MetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::H264Metadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->temporal_idx = Traits::temporal_idx(input);
        fragment->layer_sync = Traits::layer_sync(input);
    }

    static bool Deserialize(::media::mojom::internal::H264Metadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::H264MetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::Vp8MetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::Vp8MetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::Vp8Metadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->non_reference = Traits::non_reference(input);
        fragment->temporal_idx = Traits::temporal_idx(input);
        fragment->layer_sync = Traits::layer_sync(input);
    }

    static bool Deserialize(::media::mojom::internal::Vp8Metadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::Vp8MetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::Vp9MetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::Vp9MetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::Vp9Metadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->inter_pic_predicted = Traits::inter_pic_predicted(input);
        fragment->temporal_up_switch = Traits::temporal_up_switch(input);
        fragment->referenced_by_upper_spatial_layers = Traits::referenced_by_upper_spatial_layers(input);
        fragment->reference_lower_spatial_layers = Traits::reference_lower_spatial_layers(input);
        fragment->end_of_picture = Traits::end_of_picture(input);
        fragment->temporal_idx = Traits::temporal_idx(input);
        fragment->spatial_idx = Traits::spatial_idx(input);
        decltype(Traits::spatial_layer_resolutions(input)) in_spatial_layer_resolutions = Traits::spatial_layer_resolutions(input);
        mojo::internal::MessageFragment<typename decltype(fragment->spatial_layer_resolutions)::BaseType> spatial_layer_resolutions_fragment(
            fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& spatial_layer_resolutions_validate_params
            = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::gfx::mojom::SizeDataView>>(
            in_spatial_layer_resolutions, spatial_layer_resolutions_fragment, &spatial_layer_resolutions_validate_params);
        fragment->spatial_layer_resolutions.Set(spatial_layer_resolutions_fragment.is_null() ? nullptr : spatial_layer_resolutions_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->spatial_layer_resolutions.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null spatial_layer_resolutions in Vp9Metadata struct");
        fragment->begin_active_spatial_layer_index = Traits::begin_active_spatial_layer_index(input);
        fragment->end_active_spatial_layer_index = Traits::end_active_spatial_layer_index(input);
        decltype(Traits::p_diffs(input)) in_p_diffs = Traits::p_diffs(input);
        mojo::internal::MessageFragment<typename decltype(fragment->p_diffs)::BaseType> p_diffs_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& p_diffs_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(in_p_diffs, p_diffs_fragment, &p_diffs_validate_params);
        fragment->p_diffs.Set(p_diffs_fragment.is_null() ? nullptr : p_diffs_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->p_diffs.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null p_diffs in Vp9Metadata struct");
    }

    static bool Deserialize(::media::mojom::internal::Vp9Metadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::Vp9MetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::SVCGenericMetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::SVCGenericMetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::SVCGenericMetadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->follow_svc_spec = Traits::follow_svc_spec(input);
        fragment->temporal_idx = Traits::temporal_idx(input);
        fragment->spatial_idx = Traits::spatial_idx(input);
        fragment->reference_flags_$flag = Traits::reference_flags(input).has_value();
        if (Traits::reference_flags(input).has_value()) {
            fragment->reference_flags_$value = Traits::reference_flags(input).value();
        }
        fragment->refresh_flags_$flag = Traits::refresh_flags(input).has_value();
        if (Traits::refresh_flags(input).has_value()) {
            fragment->refresh_flags_$value = Traits::refresh_flags(input).value();
        }
    }

    static bool Deserialize(::media::mojom::internal::SVCGenericMetadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::SVCGenericMetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::BitstreamBufferMetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::media::mojom::BitstreamBufferMetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::media::mojom::internal::BitstreamBufferMetadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->payload_size_bytes = Traits::payload_size_bytes(input);
        fragment->key_frame = Traits::key_frame(input);
        decltype(Traits::timestamp(input)) in_timestamp = Traits::timestamp(input);
        mojo::internal::MessageFragment<typename decltype(fragment->timestamp)::BaseType> timestamp_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(in_timestamp, timestamp_fragment);
        fragment->timestamp.Set(timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->timestamp.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null timestamp in BitstreamBufferMetadata struct");
        fragment->qp = Traits::qp(input);
        decltype(Traits::optional_metadata(input)) in_optional_metadata = Traits::optional_metadata(input);
        mojo::internal::MessageFragment<decltype(fragment->optional_metadata)> optional_metadata_fragment(fragment.message());
        optional_metadata_fragment.Claim(&fragment->optional_metadata);
        mojo::internal::Serialize<::media::mojom::OptionalMetadataDataView>(in_optional_metadata, optional_metadata_fragment, true);
        decltype(Traits::svc_generic(input)) in_svc_generic = Traits::svc_generic(input);
        mojo::internal::MessageFragment<typename decltype(fragment->svc_generic)::BaseType> svc_generic_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::SVCGenericMetadataDataView>(in_svc_generic, svc_generic_fragment);
        fragment->svc_generic.Set(svc_generic_fragment.is_null() ? nullptr : svc_generic_fragment.data());
        decltype(Traits::encoded_size(input)) in_encoded_size = Traits::encoded_size(input);
        mojo::internal::MessageFragment<typename decltype(fragment->encoded_size)::BaseType> encoded_size_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::SizeDataView>(in_encoded_size, encoded_size_fragment);
        fragment->encoded_size.Set(encoded_size_fragment.is_null() ? nullptr : encoded_size_fragment.data());
        decltype(Traits::encoded_color_space(input)) in_encoded_color_space = Traits::encoded_color_space(input);
        mojo::internal::MessageFragment<typename decltype(fragment->encoded_color_space)::BaseType> encoded_color_space_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(in_encoded_color_space, encoded_color_space_fragment);
        fragment->encoded_color_space.Set(encoded_color_space_fragment.is_null() ? nullptr : encoded_color_space_fragment.data());
    }

    static bool Deserialize(::media::mojom::internal::BitstreamBufferMetadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::BitstreamBufferMetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::BitrateDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::media::mojom::BitrateDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::media::mojom::internal::Bitrate_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::media::mojom::BitrateDataView::Tag::kConstant: {
            decltype(Traits::constant(input)) in_constant = Traits::constant(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_constant)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::media::mojom::ConstantBitrateDataView>(in_constant, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null constant in Bitrate union");
            fragment->data.f_constant.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::media::mojom::BitrateDataView::Tag::kVariable: {
            decltype(Traits::variable(input)) in_variable = Traits::variable(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_variable)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::media::mojom::VariableBitrateDataView>(in_variable, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null variable in Bitrate union");
            fragment->data.f_variable.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::media::mojom::BitrateDataView::Tag::kExternal: {
            decltype(Traits::external(input)) in_external = Traits::external(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_external)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::media::mojom::ExternalBitrateDataView>(in_external, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null external in Bitrate union");
            fragment->data.f_external.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::media::mojom::internal::Bitrate_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::BitrateDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::media::mojom::OptionalMetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::media::mojom::OptionalMetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::media::mojom::internal::OptionalMetadata_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::media::mojom::OptionalMetadataDataView::Tag::kDrop: {
            decltype(Traits::drop(input)) in_drop = Traits::drop(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_drop)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::media::mojom::DropFrameMetadataDataView>(in_drop, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null drop in OptionalMetadata union");
            fragment->data.f_drop.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::media::mojom::OptionalMetadataDataView::Tag::kH264: {
            decltype(Traits::h264(input)) in_h264 = Traits::h264(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_h264)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::media::mojom::H264MetadataDataView>(in_h264, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null h264 in OptionalMetadata union");
            fragment->data.f_h264.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::media::mojom::OptionalMetadataDataView::Tag::kVp8: {
            decltype(Traits::vp8(input)) in_vp8 = Traits::vp8(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_vp8)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::media::mojom::Vp8MetadataDataView>(in_vp8, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null vp8 in OptionalMetadata union");
            fragment->data.f_vp8.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::media::mojom::OptionalMetadataDataView::Tag::kVp9: {
            decltype(Traits::vp9(input)) in_vp9 = Traits::vp9(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_vp9)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::media::mojom::Vp9MetadataDataView>(in_vp9, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null vp9 in OptionalMetadata union");
            fragment->data.f_vp9.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::media::mojom::internal::OptionalMetadata_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::media::mojom::OptionalMetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace media::mojom {

inline void VideoEncodeAcceleratorSupportedProfileDataView::GetMinResolutionDataView(::gfx::mojom::SizeDataView* output)
{
    auto pointer = data_->min_resolution.Get();
    *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoEncodeAcceleratorSupportedProfileDataView::GetMaxResolutionDataView(::gfx::mojom::SizeDataView* output)
{
    auto pointer = data_->max_resolution.Get();
    *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoEncodeAcceleratorSupportedProfileDataView::GetRateControlModesDataView(
    mojo::ArrayDataView<VideoEncodeAcceleratorSupportedRateControlMode>* output)
{
    auto pointer = data_->rate_control_modes.Get();
    *output = mojo::ArrayDataView<VideoEncodeAcceleratorSupportedRateControlMode>(pointer, message_);
}
inline void VideoEncodeAcceleratorSupportedProfileDataView::GetScalabilityModesDataView(mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>* output)
{
    auto pointer = data_->scalability_modes.Get();
    *output = mojo::ArrayDataView<::media::mojom::SVCScalabilityMode>(pointer, message_);
}
inline void VideoEncodeAcceleratorSupportedProfileDataView::GetGpuSupportedPixelFormatsDataView(mojo::ArrayDataView<::media::mojom::VideoPixelFormat>* output)
{
    auto pointer = data_->gpu_supported_pixel_formats.Get();
    *output = mojo::ArrayDataView<::media::mojom::VideoPixelFormat>(pointer, message_);
}

inline void EncodeCommandBufferIdDataView::GetChannelTokenDataView(::mojo_base::mojom::UnguessableTokenDataView* output)
{
    auto pointer = data_->channel_token.Get();
    *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}

inline void VideoBitrateAllocationDataView::GetBitratesDataView(mojo::ArrayDataView<uint32_t>* output)
{
    auto pointer = data_->bitrates.Get();
    *output = mojo::ArrayDataView<uint32_t>(pointer, message_);
}
inline void VideoBitrateAllocationDataView::GetVariableBitratePeakDataView(VariableBitratePeakDataView* output)
{
    auto pointer = data_->variable_bitrate_peak.Get();
    *output = VariableBitratePeakDataView(pointer, message_);
}

inline void VideoEncodeAcceleratorConfigDataView::GetInputVisibleSizeDataView(::gfx::mojom::SizeDataView* output)
{
    auto pointer = data_->input_visible_size.Get();
    *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void VideoEncodeAcceleratorConfigDataView::GetBitrateDataView(BitrateDataView* output)
{
    auto pointer = &data_->bitrate;
    *output = BitrateDataView(pointer, message_);
}
inline void VideoEncodeAcceleratorConfigDataView::GetSpatialLayersDataView(mojo::ArrayDataView<SpatialLayerDataView>* output)
{
    auto pointer = data_->spatial_layers.Get();
    *output = mojo::ArrayDataView<SpatialLayerDataView>(pointer, message_);
}

inline void Vp9MetadataDataView::GetSpatialLayerResolutionsDataView(mojo::ArrayDataView<::gfx::mojom::SizeDataView>* output)
{
    auto pointer = data_->spatial_layer_resolutions.Get();
    *output = mojo::ArrayDataView<::gfx::mojom::SizeDataView>(pointer, message_);
}
inline void Vp9MetadataDataView::GetPDiffsDataView(mojo::ArrayDataView<uint8_t>* output)
{
    auto pointer = data_->p_diffs.Get();
    *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}

inline void BitstreamBufferMetadataDataView::GetTimestampDataView(::mojo_base::mojom::TimeDeltaDataView* output)
{
    auto pointer = data_->timestamp.Get();
    *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void BitstreamBufferMetadataDataView::GetOptionalMetadataDataView(OptionalMetadataDataView* output)
{
    auto pointer = &data_->optional_metadata;
    *output = OptionalMetadataDataView(pointer, message_);
}
inline void BitstreamBufferMetadataDataView::GetSvcGenericDataView(SVCGenericMetadataDataView* output)
{
    auto pointer = data_->svc_generic.Get();
    *output = SVCGenericMetadataDataView(pointer, message_);
}
inline void BitstreamBufferMetadataDataView::GetEncodedSizeDataView(::gfx::mojom::SizeDataView* output)
{
    auto pointer = data_->encoded_size.Get();
    *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void BitstreamBufferMetadataDataView::GetEncodedColorSpaceDataView(::gfx::mojom::ColorSpaceDataView* output)
{
    auto pointer = data_->encoded_color_space.Get();
    *output = ::gfx::mojom::ColorSpaceDataView(pointer, message_);
}

inline void BitrateDataView::GetConstantDataView(ConstantBitrateDataView* output) const
{
    CHECK(is_constant());
    *output = ConstantBitrateDataView(data_->data.f_constant.Get(), message_);
}
inline void BitrateDataView::GetVariableDataView(VariableBitrateDataView* output) const
{
    CHECK(is_variable());
    *output = VariableBitrateDataView(data_->data.f_variable.Get(), message_);
}
inline void BitrateDataView::GetExternalDataView(ExternalBitrateDataView* output) const
{
    CHECK(is_external());
    *output = ExternalBitrateDataView(data_->data.f_external.Get(), message_);
}

inline void OptionalMetadataDataView::GetDropDataView(DropFrameMetadataDataView* output) const
{
    CHECK(is_drop());
    *output = DropFrameMetadataDataView(data_->data.f_drop.Get(), message_);
}
inline void OptionalMetadataDataView::GetH264DataView(H264MetadataDataView* output) const
{
    CHECK(is_h264());
    *output = H264MetadataDataView(data_->data.f_h264.Get(), message_);
}
inline void OptionalMetadataDataView::GetVp8DataView(Vp8MetadataDataView* output) const
{
    CHECK(is_vp8());
    *output = Vp8MetadataDataView(data_->data.f_vp8.Get(), message_);
}
inline void OptionalMetadataDataView::GetVp9DataView(Vp9MetadataDataView* output) const
{
    CHECK(is_vp9());
    *output = Vp9MetadataDataView(data_->data.f_vp9.Get(), message_);
}

} // media::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct TraceFormatTraits<::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAcceleratorSupportedRateControlMode value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::media::mojom::VideoEncodeAcceleratorConfig_ContentType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAcceleratorConfig_ContentType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::media::mojom::VideoEncodeAcceleratorConfig_StorageType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAcceleratorConfig_StorageType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::media::mojom::VideoEncodeAcceleratorConfig_EncoderType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::media::mojom::VideoEncodeAcceleratorConfig_EncoderType value);
};

} // namespace perfetto

#endif // MEDIA_MOJO_MOJOM_VIDEO_ENCODE_ACCELERATOR_MOJOM_SHARED_H_
