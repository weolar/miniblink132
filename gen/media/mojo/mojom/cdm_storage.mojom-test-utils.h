// media/mojo/mojom/cdm_storage.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_CDM_STORAGE_MOJOM_TEST_UTILS_H_
#define MEDIA_MOJO_MOJOM_CDM_STORAGE_MOJOM_TEST_UTILS_H_

#include "media/mojo/mojom/cdm_storage.mojom.h"

namespace media::mojom {

class CdmStorageInterceptorForTesting : public CdmStorage {
    virtual CdmStorage* GetForwardingInterface() = 0;
    void Open(const std::string& file_name, OpenCallback callback) override;
};
class CdmStorageAsyncWaiter {
public:
    explicit CdmStorageAsyncWaiter(CdmStorage* proxy);

    CdmStorageAsyncWaiter(const CdmStorageAsyncWaiter&) = delete;
    CdmStorageAsyncWaiter& operator=(const CdmStorageAsyncWaiter&) = delete;

    ~CdmStorageAsyncWaiter();
    void Open(const std::string& file_name, CdmStorage::Status* out_status, ::mojo::PendingAssociatedRemote<CdmFile>* out_cdm_file);

private:
    CdmStorage* const proxy_;
};

class CdmFileInterceptorForTesting : public CdmFile {
    virtual CdmFile* GetForwardingInterface() = 0;
    void Read(ReadCallback callback) override;
    void Write(const std::vector<uint8_t>& data, WriteCallback callback) override;
};
class CdmFileAsyncWaiter {
public:
    explicit CdmFileAsyncWaiter(CdmFile* proxy);

    CdmFileAsyncWaiter(const CdmFileAsyncWaiter&) = delete;
    CdmFileAsyncWaiter& operator=(const CdmFileAsyncWaiter&) = delete;

    ~CdmFileAsyncWaiter();
    void Read(CdmFile::Status* out_status, std::vector<uint8_t>* out_data);

    void Write(const std::vector<uint8_t>& data, CdmFile::Status* out_status);
    CdmFile::Status Write(const std::vector<uint8_t>& data);

private:
    CdmFile* const proxy_;
};

} // media::mojom

#endif // MEDIA_MOJO_MOJOM_CDM_STORAGE_MOJOM_TEST_UTILS_H_
