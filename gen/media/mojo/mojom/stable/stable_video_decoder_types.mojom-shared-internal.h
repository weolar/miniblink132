// media/mojo/mojom/stable/stable_video_decoder_types.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef MEDIA_MOJO_MOJOM_STABLE_STABLE_VIDEO_DECODER_TYPES_MOJOM_SHARED_INTERNAL_H_
#define MEDIA_MOJO_MOJOM_STABLE_STABLE_VIDEO_DECODER_TYPES_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "media/mojo/mojom/encryption_pattern.mojom-shared-internal.h"
#include "media/mojo/mojom/stable/native_pixmap_handle.mojom-shared-internal.h"
#include "mojo/public/mojom/base/time.mojom-shared-internal.h"
#include "mojo/public/mojom/base/values.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared-internal.h"
#include "ui/gfx/mojom/buffer_types.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"

namespace mojo {
namespace internal {
class ValidationContext;
}
}

namespace media::stable::mojom {
namespace internal {
class SubsampleEntry_Data;
class DecryptConfig_Data;
class ColorVolumeMetadata_Data;
class HDRMetadata_Data;
class VideoDecoderConfig_Data;
class SupportedVideoDecoderConfig_Data;
class StatusData_Data;
class Status_Data;
class DecoderBufferSideData_Data;
class DecoderBuffer_Data;
class ColorSpace_Data;
class NativeGpuMemoryBufferHandle_Data;
class VideoFrameMetadata_Data;
class VideoFrame_Data;
class MediaLogRecord_Data;

struct VideoCodec_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct VideoCodecProfile_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case -1:
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct EncryptionScheme_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct StatusCode_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct VideoDecoderType_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct ColorSpacePrimaryID_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct ColorSpaceTransferID_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct ColorSpaceMatrixID_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct ColorSpaceRangeID_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct VideoPixelFormat_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 14:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct WaitingReason_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct DecryptStatus_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct CdmContextEvent_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

struct MediaLogRecord_Type_Data {
public:
    static bool constexpr kIsExtensible = true;

    static bool IsKnownValue(int32_t value)
    {
        switch (value) {
        case 0:
        case 1:
        case 2:
        case 3:
            return true;
        }
        return false;
    }

    static bool Validate(int32_t value, mojo::internal::ValidationContext* validation_context)
    {
        if (kIsExtensible || IsKnownValue(value))
            return true;

        ReportValidationError(validation_context, mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
        return false;
    }
};

#pragma pack(push, 1)
class SubsampleEntry_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    uint32_t clear_bytes;
    uint32_t cypher_bytes;

private:
    friend class mojo::internal::MessageFragment<SubsampleEntry_Data>;

    SubsampleEntry_Data();
    ~SubsampleEntry_Data() = delete;
};
static_assert(sizeof(SubsampleEntry_Data) == 16, "Bad sizeof(SubsampleEntry_Data)");
// Used by SubsampleEntry::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct SubsampleEntry_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SubsampleEntry_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SubsampleEntry_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SubsampleEntry_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SubsampleEntry_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class DecryptConfig_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t encryption_scheme;
    uint8_t pad0_[4];
    mojo::internal::Pointer<mojo::internal::String_Data> key_id;
    mojo::internal::Pointer<mojo::internal::String_Data> iv;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::SubsampleEntry_Data>>> subsamples;
    mojo::internal::Pointer<::media::mojom::internal::EncryptionPattern_Data> encryption_pattern;

private:
    friend class mojo::internal::MessageFragment<DecryptConfig_Data>;

    DecryptConfig_Data();
    ~DecryptConfig_Data() = delete;
};
static_assert(sizeof(DecryptConfig_Data) == 48, "Bad sizeof(DecryptConfig_Data)");
// Used by DecryptConfig::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct DecryptConfig_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    DecryptConfig_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~DecryptConfig_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<DecryptConfig_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag DecryptConfig_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class ColorVolumeMetadata_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::gfx::mojom::internal::PointF_Data> primary_r;
    mojo::internal::Pointer<::gfx::mojom::internal::PointF_Data> primary_g;
    mojo::internal::Pointer<::gfx::mojom::internal::PointF_Data> primary_b;
    mojo::internal::Pointer<::gfx::mojom::internal::PointF_Data> white_point;
    float luminance_max;
    float luminance_min;

private:
    friend class mojo::internal::MessageFragment<ColorVolumeMetadata_Data>;

    ColorVolumeMetadata_Data();
    ~ColorVolumeMetadata_Data() = delete;
};
static_assert(sizeof(ColorVolumeMetadata_Data) == 48, "Bad sizeof(ColorVolumeMetadata_Data)");
// Used by ColorVolumeMetadata::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ColorVolumeMetadata_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ColorVolumeMetadata_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ColorVolumeMetadata_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ColorVolumeMetadata_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ColorVolumeMetadata_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class HDRMetadata_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::ColorVolumeMetadata_Data> color_volume_metadata;
    uint32_t max_content_light_level;
    uint32_t max_frame_average_light_level;

private:
    friend class mojo::internal::MessageFragment<HDRMetadata_Data>;

    HDRMetadata_Data();
    ~HDRMetadata_Data() = delete;
};
static_assert(sizeof(HDRMetadata_Data) == 24, "Bad sizeof(HDRMetadata_Data)");
// Used by HDRMetadata::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct HDRMetadata_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    HDRMetadata_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~HDRMetadata_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<HDRMetadata_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag HDRMetadata_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class VideoDecoderConfig_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t codec;
    int32_t profile;
    uint32_t level;
    uint8_t has_alpha : 1;
    uint8_t pad3_[3];
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> coded_size;
    mojo::internal::Pointer<::gfx::mojom::internal::Rect_Data> visible_rect;
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> natural_size;
    mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> extra_data;
    int32_t encryption_scheme;
    uint8_t pad8_[4];
    mojo::internal::Pointer<internal::ColorSpace_Data> color_space_info;
    mojo::internal::Pointer<internal::HDRMetadata_Data> hdr_metadata;

private:
    friend class mojo::internal::MessageFragment<VideoDecoderConfig_Data>;

    VideoDecoderConfig_Data();
    ~VideoDecoderConfig_Data() = delete;
};
static_assert(sizeof(VideoDecoderConfig_Data) == 80, "Bad sizeof(VideoDecoderConfig_Data)");
// Used by VideoDecoderConfig::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct VideoDecoderConfig_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    VideoDecoderConfig_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~VideoDecoderConfig_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<VideoDecoderConfig_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag VideoDecoderConfig_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class SupportedVideoDecoderConfig_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t profile_min;
    int32_t profile_max;
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> coded_size_min;
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> coded_size_max;
    uint8_t allow_encrypted : 1;
    uint8_t require_encrypted : 1;
    uint8_t padfinal_[7];

private:
    friend class mojo::internal::MessageFragment<SupportedVideoDecoderConfig_Data>;

    SupportedVideoDecoderConfig_Data();
    ~SupportedVideoDecoderConfig_Data() = delete;
};
static_assert(sizeof(SupportedVideoDecoderConfig_Data) == 40, "Bad sizeof(SupportedVideoDecoderConfig_Data)");
// Used by SupportedVideoDecoderConfig::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SupportedVideoDecoderConfig_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    SupportedVideoDecoderConfig_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~SupportedVideoDecoderConfig_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<SupportedVideoDecoderConfig_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag SupportedVideoDecoderConfig_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class StatusData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::String_Data> group;
    int32_t code;
    uint8_t pad1_[4];
    mojo::internal::Pointer<mojo::internal::String_Data> message;
    mojo::internal::Pointer<mojo::internal::Array_Data<::mojo_base::mojom::internal::Value_Data>> frames;
    mojo::internal::Pointer<internal::StatusData_Data> cause;
    ::mojo_base::mojom::internal::Value_Data data;

private:
    friend class mojo::internal::MessageFragment<StatusData_Data>;

    StatusData_Data();
    ~StatusData_Data() = delete;
};
static_assert(sizeof(StatusData_Data) == 64, "Bad sizeof(StatusData_Data)");
// Used by StatusData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct StatusData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    StatusData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~StatusData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<StatusData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag StatusData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class Status_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<internal::StatusData_Data> internal;

private:
    friend class mojo::internal::MessageFragment<Status_Data>;

    Status_Data();
    ~Status_Data() = delete;
};
static_assert(sizeof(Status_Data) == 16, "Bad sizeof(Status_Data)");
// Used by Status::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct Status_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    Status_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~Status_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<Status_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag Status_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class DecoderBufferSideData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Array_Data<uint32_t>> spatial_layers;
    mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> alpha_data;
    uint64_t secure_handle;

private:
    friend class mojo::internal::MessageFragment<DecoderBufferSideData_Data>;

    DecoderBufferSideData_Data();
    ~DecoderBufferSideData_Data() = delete;
};
static_assert(sizeof(DecoderBufferSideData_Data) == 32, "Bad sizeof(DecoderBufferSideData_Data)");
// Used by DecoderBufferSideData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct DecoderBufferSideData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    DecoderBufferSideData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~DecoderBufferSideData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<DecoderBufferSideData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag DecoderBufferSideData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class DecoderBuffer_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> timestamp;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> duration;
    uint8_t is_end_of_stream : 1;
    uint8_t is_key_frame : 1;
    uint8_t pad3_[3];
    uint32_t data_size;
    mojo::internal::Pointer<mojo::internal::Array_Data<uint8_t>> raw_side_data;
    mojo::internal::Pointer<internal::DecryptConfig_Data> decrypt_config;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> front_discard;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> back_discard;
    mojo::internal::Pointer<internal::DecoderBufferSideData_Data> side_data;

private:
    friend class mojo::internal::MessageFragment<DecoderBuffer_Data>;

    DecoderBuffer_Data();
    ~DecoderBuffer_Data() = delete;
};
static_assert(sizeof(DecoderBuffer_Data) == 72, "Bad sizeof(DecoderBuffer_Data)");
// Used by DecoderBuffer::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct DecoderBuffer_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    DecoderBuffer_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~DecoderBuffer_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<DecoderBuffer_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag DecoderBuffer_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class ColorSpace_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t primaries;
    int32_t transfer;
    int32_t matrix;
    int32_t range;
    mojo::internal::Pointer<mojo::internal::Array_Data<float>> custom_primary_matrix;
    mojo::internal::Pointer<mojo::internal::Array_Data<float>> transfer_params;

private:
    friend class mojo::internal::MessageFragment<ColorSpace_Data>;

    ColorSpace_Data();
    ~ColorSpace_Data() = delete;
};
static_assert(sizeof(ColorSpace_Data) == 40, "Bad sizeof(ColorSpace_Data)");
// Used by ColorSpace::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ColorSpace_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ColorSpace_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ColorSpace_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ColorSpace_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ColorSpace_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class NativeGpuMemoryBufferHandle_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<::gfx::mojom::internal::GpuMemoryBufferId_Data> id;
    mojo::internal::Pointer<::media::stable::mojom::internal::NativePixmapHandle_Data> platform_handle;

private:
    friend class mojo::internal::MessageFragment<NativeGpuMemoryBufferHandle_Data>;

    NativeGpuMemoryBufferHandle_Data();
    ~NativeGpuMemoryBufferHandle_Data() = delete;
};
static_assert(sizeof(NativeGpuMemoryBufferHandle_Data) == 24, "Bad sizeof(NativeGpuMemoryBufferHandle_Data)");
// Used by NativeGpuMemoryBufferHandle::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct NativeGpuMemoryBufferHandle_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    NativeGpuMemoryBufferHandle_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~NativeGpuMemoryBufferHandle_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<NativeGpuMemoryBufferHandle_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag NativeGpuMemoryBufferHandle_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class VideoFrameMetadata_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    uint8_t protected_video : 1;
    uint8_t hw_protected : 1;
    uint8_t needs_detiling : 1;
    uint8_t padfinal_[7];

private:
    friend class mojo::internal::MessageFragment<VideoFrameMetadata_Data>;

    VideoFrameMetadata_Data();
    ~VideoFrameMetadata_Data() = delete;
};
static_assert(sizeof(VideoFrameMetadata_Data) == 16, "Bad sizeof(VideoFrameMetadata_Data)");
// Used by VideoFrameMetadata::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct VideoFrameMetadata_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    VideoFrameMetadata_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~VideoFrameMetadata_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<VideoFrameMetadata_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag VideoFrameMetadata_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class VideoFrame_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t format;
    uint8_t pad0_[4];
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> coded_size;
    mojo::internal::Pointer<::gfx::mojom::internal::Rect_Data> visible_rect;
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> natural_size;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeDelta_Data> timestamp;
    mojo::internal::Pointer<internal::NativeGpuMemoryBufferHandle_Data> gpu_memory_buffer_handle;
    mojo::internal::Pointer<internal::VideoFrameMetadata_Data> metadata;
    mojo::internal::Pointer<internal::ColorSpace_Data> color_space;
    mojo::internal::Pointer<internal::HDRMetadata_Data> hdr_metadata;

private:
    friend class mojo::internal::MessageFragment<VideoFrame_Data>;

    VideoFrame_Data();
    ~VideoFrame_Data() = delete;
};
static_assert(sizeof(VideoFrame_Data) == 80, "Bad sizeof(VideoFrame_Data)");
// Used by VideoFrame::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct VideoFrame_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    VideoFrame_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~VideoFrame_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<VideoFrame_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag VideoFrame_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class MediaLogRecord_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t id;
    int32_t type;
    mojo::internal::Pointer<::mojo_base::mojom::internal::DictionaryValue_Data> params;
    mojo::internal::Pointer<::mojo_base::mojom::internal::TimeTicks_Data> time;

private:
    friend class mojo::internal::MessageFragment<MediaLogRecord_Data>;

    MediaLogRecord_Data();
    ~MediaLogRecord_Data() = delete;
};
static_assert(sizeof(MediaLogRecord_Data) == 32, "Bad sizeof(MediaLogRecord_Data)");
// Used by MediaLogRecord::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct MediaLogRecord_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    MediaLogRecord_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~MediaLogRecord_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<MediaLogRecord_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag MediaLogRecord_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

} // namespace internal

} // media::stable::mojom

#endif // MEDIA_MOJO_MOJOM_STABLE_STABLE_VIDEO_DECODER_TYPES_MOJOM_SHARED_INTERNAL_H_
