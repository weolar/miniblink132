// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chrome_screen_ai.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chrome_5fscreen_5fai_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chrome_5fscreen_5fai_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chrome_5fscreen_5fai_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chrome_5fscreen_5fai_2eproto {
    static const uint32_t offsets[];
};
namespace chrome_screen_ai {
class LineBox;
struct LineBoxDefaultTypeInternal;
extern LineBoxDefaultTypeInternal _LineBox_default_instance_;
class Rect;
struct RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class SymbolBox;
struct SymbolBoxDefaultTypeInternal;
extern SymbolBoxDefaultTypeInternal _SymbolBox_default_instance_;
class VisualAnnotation;
struct VisualAnnotationDefaultTypeInternal;
extern VisualAnnotationDefaultTypeInternal _VisualAnnotation_default_instance_;
class WordBox;
struct WordBoxDefaultTypeInternal;
extern WordBoxDefaultTypeInternal _WordBox_default_instance_;
} // namespace chrome_screen_ai
PROTOBUF_NAMESPACE_OPEN
template <>::chrome_screen_ai::LineBox* Arena::CreateMaybeMessage<::chrome_screen_ai::LineBox>(Arena*);
template <>::chrome_screen_ai::Rect* Arena::CreateMaybeMessage<::chrome_screen_ai::Rect>(Arena*);
template <>::chrome_screen_ai::SymbolBox* Arena::CreateMaybeMessage<::chrome_screen_ai::SymbolBox>(Arena*);
template <>::chrome_screen_ai::VisualAnnotation* Arena::CreateMaybeMessage<::chrome_screen_ai::VisualAnnotation>(Arena*);
template <>::chrome_screen_ai::WordBox* Arena::CreateMaybeMessage<::chrome_screen_ai::WordBox>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chrome_screen_ai {

enum Direction : int {
    DIRECTION_UNSPECIFIED = 0,
    DIRECTION_LEFT_TO_RIGHT = 1,
    DIRECTION_RIGHT_TO_LEFT = 2,
    DIRECTION_TOP_TO_BOTTOM = 3,
    Direction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Direction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Direction_IsValid(int value);
constexpr Direction Direction_MIN = DIRECTION_UNSPECIFIED;
constexpr Direction Direction_MAX = DIRECTION_TOP_TO_BOTTOM;
constexpr int Direction_ARRAYSIZE = Direction_MAX + 1;

const std::string& Direction_Name(Direction value);
template <typename T> inline const std::string& Direction_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Direction>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Direction_Name.");
    return Direction_Name(static_cast<Direction>(enum_t_value));
}
bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Direction* value);
enum Orientation : int {
    ORIENTATION_DEFAULT = 0,
    ORIENTATION_HORIZONTAL = 1,
    ORIENTATION_VERTICAL = 2,
    ORIENTATION_ROTATED_HORIZONTAL = 3,
    ORIENTATION_ROTATED_VERTICAL = 4,
    Orientation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    Orientation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Orientation_IsValid(int value);
constexpr Orientation Orientation_MIN = ORIENTATION_DEFAULT;
constexpr Orientation Orientation_MAX = ORIENTATION_ROTATED_VERTICAL;
constexpr int Orientation_ARRAYSIZE = Orientation_MAX + 1;

const std::string& Orientation_Name(Orientation value);
template <typename T> inline const std::string& Orientation_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, Orientation>::value || ::std::is_integral<T>::value, "Incorrect type passed to function Orientation_Name.");
    return Orientation_Name(static_cast<Orientation>(enum_t_value));
}
bool Orientation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Orientation* value);
enum ContentType : int {
    CONTENT_TYPE_PRINTED_TEXT = 0,
    CONTENT_TYPE_HANDWRITTEN_TEXT = 1,
    CONTENT_TYPE_IMAGE = 2,
    CONTENT_TYPE_LINE_DRAWING = 3,
    CONTENT_TYPE_SEPARATOR = 4,
    CONTENT_TYPE_UNREADABLE_TEXT = 5,
    CONTENT_TYPE_FORMULA = 6,
    CONTENT_TYPE_HANDWRITTEN_FORMULA = 7,
    CONTENT_TYPE_SIGNATURE = 8,
    ContentType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    ContentType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ContentType_IsValid(int value);
constexpr ContentType ContentType_MIN = CONTENT_TYPE_PRINTED_TEXT;
constexpr ContentType ContentType_MAX = CONTENT_TYPE_SIGNATURE;
constexpr int ContentType_ARRAYSIZE = ContentType_MAX + 1;

const std::string& ContentType_Name(ContentType value);
template <typename T> inline const std::string& ContentType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, ContentType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function ContentType_Name.");
    return ContentType_Name(static_cast<ContentType>(enum_t_value));
}
bool ContentType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ContentType* value);
// ===================================================================

class Rect final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_screen_ai.Rect) */ {
public:
    inline Rect()
        : Rect(nullptr)
    {
    }
    ~Rect() override;
    explicit PROTOBUF_CONSTEXPR Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Rect(const Rect& from);
    Rect(Rect&& from) noexcept
        : Rect()
    {
        *this = ::std::move(from);
    }

    inline Rect& operator=(const Rect& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Rect& operator=(Rect&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const Rect& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Rect* internal_default_instance()
    {
        return reinterpret_cast<const Rect*>(&_Rect_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(Rect& a, Rect& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Rect* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Rect* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Rect>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Rect& from);
    void MergeFrom(const Rect& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Rect* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_screen_ai.Rect";
    }

protected:
    explicit Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kXFieldNumber = 1,
        kYFieldNumber = 2,
        kWidthFieldNumber = 3,
        kHeightFieldNumber = 4,
        kAngleFieldNumber = 5,
    };
    // int32 x = 1;
    void clear_x();
    int32_t x() const;
    void set_x(int32_t value);

private:
    int32_t _internal_x() const;
    void _internal_set_x(int32_t value);

public:
    // int32 y = 2;
    void clear_y();
    int32_t y() const;
    void set_y(int32_t value);

private:
    int32_t _internal_y() const;
    void _internal_set_y(int32_t value);

public:
    // int32 width = 3;
    void clear_width();
    int32_t width() const;
    void set_width(int32_t value);

private:
    int32_t _internal_width() const;
    void _internal_set_width(int32_t value);

public:
    // int32 height = 4;
    void clear_height();
    int32_t height() const;
    void set_height(int32_t value);

private:
    int32_t _internal_height() const;
    void _internal_set_height(int32_t value);

public:
    // float angle = 5;
    void clear_angle();
    float angle() const;
    void set_angle(float value);

private:
    float _internal_angle() const;
    void _internal_set_angle(float value);

public:
    // @@protoc_insertion_point(class_scope:chrome_screen_ai.Rect)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        int32_t x_;
        int32_t y_;
        int32_t width_;
        int32_t height_;
        float angle_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_chrome_5fscreen_5fai_2eproto;
};
// -------------------------------------------------------------------

class LineBox final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_screen_ai.LineBox) */ {
public:
    inline LineBox()
        : LineBox(nullptr)
    {
    }
    ~LineBox() override;
    explicit PROTOBUF_CONSTEXPR LineBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    LineBox(const LineBox& from);
    LineBox(LineBox&& from) noexcept
        : LineBox()
    {
        *this = ::std::move(from);
    }

    inline LineBox& operator=(const LineBox& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline LineBox& operator=(LineBox&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const LineBox& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const LineBox* internal_default_instance()
    {
        return reinterpret_cast<const LineBox*>(&_LineBox_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(LineBox& a, LineBox& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(LineBox* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(LineBox* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    LineBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<LineBox>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const LineBox& from);
    void MergeFrom(const LineBox& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(LineBox* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_screen_ai.LineBox";
    }

protected:
    explicit LineBox(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kWordsFieldNumber = 1,
        kUtf8StringFieldNumber = 3,
        kLanguageFieldNumber = 4,
        kBoundingBoxFieldNumber = 2,
        kBaselineBoxFieldNumber = 9,
        kBlockIdFieldNumber = 5,
        kOrderWithinBlockFieldNumber = 6,
        kDirectionFieldNumber = 7,
        kContentTypeFieldNumber = 8,
        kConfidenceFieldNumber = 10,
    };
    // repeated .chrome_screen_ai.WordBox words = 1;
    int words_size() const;

private:
    int _internal_words_size() const;

public:
    void clear_words();
    ::chrome_screen_ai::WordBox* mutable_words(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::WordBox>* mutable_words();

private:
    const ::chrome_screen_ai::WordBox& _internal_words(int index) const;
    ::chrome_screen_ai::WordBox* _internal_add_words();

public:
    const ::chrome_screen_ai::WordBox& words(int index) const;
    ::chrome_screen_ai::WordBox* add_words();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::WordBox>& words() const;

    // string utf8_string = 3;
    void clear_utf8_string();
    const std::string& utf8_string() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_utf8_string(ArgT0&& arg0, ArgT... args);
    std::string* mutable_utf8_string();
    PROTOBUF_NODISCARD std::string* release_utf8_string();
    void set_allocated_utf8_string(std::string* utf8_string);

private:
    const std::string& _internal_utf8_string() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf8_string(const std::string& value);
    std::string* _internal_mutable_utf8_string();

public:
    // string language = 4;
    void clear_language();
    const std::string& language() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_language(ArgT0&& arg0, ArgT... args);
    std::string* mutable_language();
    PROTOBUF_NODISCARD std::string* release_language();
    void set_allocated_language(std::string* language);

private:
    const std::string& _internal_language() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
    std::string* _internal_mutable_language();

public:
    // .chrome_screen_ai.Rect bounding_box = 2;
    bool has_bounding_box() const;

private:
    bool _internal_has_bounding_box() const;

public:
    void clear_bounding_box();
    const ::chrome_screen_ai::Rect& bounding_box() const;
    PROTOBUF_NODISCARD ::chrome_screen_ai::Rect* release_bounding_box();
    ::chrome_screen_ai::Rect* mutable_bounding_box();
    void set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box);

private:
    const ::chrome_screen_ai::Rect& _internal_bounding_box() const;
    ::chrome_screen_ai::Rect* _internal_mutable_bounding_box();

public:
    void unsafe_arena_set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box);
    ::chrome_screen_ai::Rect* unsafe_arena_release_bounding_box();

    // .chrome_screen_ai.Rect baseline_box = 9;
    bool has_baseline_box() const;

private:
    bool _internal_has_baseline_box() const;

public:
    void clear_baseline_box();
    const ::chrome_screen_ai::Rect& baseline_box() const;
    PROTOBUF_NODISCARD ::chrome_screen_ai::Rect* release_baseline_box();
    ::chrome_screen_ai::Rect* mutable_baseline_box();
    void set_allocated_baseline_box(::chrome_screen_ai::Rect* baseline_box);

private:
    const ::chrome_screen_ai::Rect& _internal_baseline_box() const;
    ::chrome_screen_ai::Rect* _internal_mutable_baseline_box();

public:
    void unsafe_arena_set_allocated_baseline_box(::chrome_screen_ai::Rect* baseline_box);
    ::chrome_screen_ai::Rect* unsafe_arena_release_baseline_box();

    // int32 block_id = 5;
    void clear_block_id();
    int32_t block_id() const;
    void set_block_id(int32_t value);

private:
    int32_t _internal_block_id() const;
    void _internal_set_block_id(int32_t value);

public:
    // int32 order_within_block = 6;
    void clear_order_within_block();
    int32_t order_within_block() const;
    void set_order_within_block(int32_t value);

private:
    int32_t _internal_order_within_block() const;
    void _internal_set_order_within_block(int32_t value);

public:
    // .chrome_screen_ai.Direction direction = 7;
    void clear_direction();
    ::chrome_screen_ai::Direction direction() const;
    void set_direction(::chrome_screen_ai::Direction value);

private:
    ::chrome_screen_ai::Direction _internal_direction() const;
    void _internal_set_direction(::chrome_screen_ai::Direction value);

public:
    // .chrome_screen_ai.ContentType content_type = 8;
    void clear_content_type();
    ::chrome_screen_ai::ContentType content_type() const;
    void set_content_type(::chrome_screen_ai::ContentType value);

private:
    ::chrome_screen_ai::ContentType _internal_content_type() const;
    void _internal_set_content_type(::chrome_screen_ai::ContentType value);

public:
    // float confidence = 10;
    void clear_confidence();
    float confidence() const;
    void set_confidence(float value);

private:
    float _internal_confidence() const;
    void _internal_set_confidence(float value);

public:
    // @@protoc_insertion_point(class_scope:chrome_screen_ai.LineBox)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::WordBox> words_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf8_string_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
        ::chrome_screen_ai::Rect* bounding_box_;
        ::chrome_screen_ai::Rect* baseline_box_;
        int32_t block_id_;
        int32_t order_within_block_;
        int direction_;
        int content_type_;
        float confidence_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_chrome_5fscreen_5fai_2eproto;
};
// -------------------------------------------------------------------

class WordBox final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_screen_ai.WordBox) */ {
public:
    inline WordBox()
        : WordBox(nullptr)
    {
    }
    ~WordBox() override;
    explicit PROTOBUF_CONSTEXPR WordBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    WordBox(const WordBox& from);
    WordBox(WordBox&& from) noexcept
        : WordBox()
    {
        *this = ::std::move(from);
    }

    inline WordBox& operator=(const WordBox& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline WordBox& operator=(WordBox&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const WordBox& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const WordBox* internal_default_instance()
    {
        return reinterpret_cast<const WordBox*>(&_WordBox_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(WordBox& a, WordBox& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(WordBox* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(WordBox* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    WordBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<WordBox>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const WordBox& from);
    void MergeFrom(const WordBox& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(WordBox* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_screen_ai.WordBox";
    }

protected:
    explicit WordBox(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSymbolsFieldNumber = 1,
        kUtf8StringFieldNumber = 3,
        kLanguageFieldNumber = 5,
        kBoundingBoxFieldNumber = 2,
        kForegroundGrayValueFieldNumber = 8,
        kDictionaryWordFieldNumber = 4,
        kHasSpaceAfterFieldNumber = 6,
        kEstimateColorSuccessFieldNumber = 7,
        kEstimateGraySuccessFieldNumber = 16,
        kBackgroundGrayValueFieldNumber = 9,
        kForegroundRgbValueFieldNumber = 10,
        kBackgroundRgbValueFieldNumber = 11,
        kDirectionFieldNumber = 12,
        kContentTypeFieldNumber = 13,
        kOrientationFieldNumber = 14,
        kConfidenceFieldNumber = 15,
    };
    // repeated .chrome_screen_ai.SymbolBox symbols = 1;
    int symbols_size() const;

private:
    int _internal_symbols_size() const;

public:
    void clear_symbols();
    ::chrome_screen_ai::SymbolBox* mutable_symbols(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::SymbolBox>* mutable_symbols();

private:
    const ::chrome_screen_ai::SymbolBox& _internal_symbols(int index) const;
    ::chrome_screen_ai::SymbolBox* _internal_add_symbols();

public:
    const ::chrome_screen_ai::SymbolBox& symbols(int index) const;
    ::chrome_screen_ai::SymbolBox* add_symbols();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::SymbolBox>& symbols() const;

    // string utf8_string = 3;
    void clear_utf8_string();
    const std::string& utf8_string() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_utf8_string(ArgT0&& arg0, ArgT... args);
    std::string* mutable_utf8_string();
    PROTOBUF_NODISCARD std::string* release_utf8_string();
    void set_allocated_utf8_string(std::string* utf8_string);

private:
    const std::string& _internal_utf8_string() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf8_string(const std::string& value);
    std::string* _internal_mutable_utf8_string();

public:
    // string language = 5;
    void clear_language();
    const std::string& language() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_language(ArgT0&& arg0, ArgT... args);
    std::string* mutable_language();
    PROTOBUF_NODISCARD std::string* release_language();
    void set_allocated_language(std::string* language);

private:
    const std::string& _internal_language() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
    std::string* _internal_mutable_language();

public:
    // .chrome_screen_ai.Rect bounding_box = 2;
    bool has_bounding_box() const;

private:
    bool _internal_has_bounding_box() const;

public:
    void clear_bounding_box();
    const ::chrome_screen_ai::Rect& bounding_box() const;
    PROTOBUF_NODISCARD ::chrome_screen_ai::Rect* release_bounding_box();
    ::chrome_screen_ai::Rect* mutable_bounding_box();
    void set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box);

private:
    const ::chrome_screen_ai::Rect& _internal_bounding_box() const;
    ::chrome_screen_ai::Rect* _internal_mutable_bounding_box();

public:
    void unsafe_arena_set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box);
    ::chrome_screen_ai::Rect* unsafe_arena_release_bounding_box();

    // int32 foreground_gray_value = 8;
    void clear_foreground_gray_value();
    int32_t foreground_gray_value() const;
    void set_foreground_gray_value(int32_t value);

private:
    int32_t _internal_foreground_gray_value() const;
    void _internal_set_foreground_gray_value(int32_t value);

public:
    // bool dictionary_word = 4;
    void clear_dictionary_word();
    bool dictionary_word() const;
    void set_dictionary_word(bool value);

private:
    bool _internal_dictionary_word() const;
    void _internal_set_dictionary_word(bool value);

public:
    // bool has_space_after = 6;
    void clear_has_space_after();
    bool has_space_after() const;
    void set_has_space_after(bool value);

private:
    bool _internal_has_space_after() const;
    void _internal_set_has_space_after(bool value);

public:
    // bool estimate_color_success = 7;
    void clear_estimate_color_success();
    bool estimate_color_success() const;
    void set_estimate_color_success(bool value);

private:
    bool _internal_estimate_color_success() const;
    void _internal_set_estimate_color_success(bool value);

public:
    // bool estimate_gray_success = 16;
    void clear_estimate_gray_success();
    bool estimate_gray_success() const;
    void set_estimate_gray_success(bool value);

private:
    bool _internal_estimate_gray_success() const;
    void _internal_set_estimate_gray_success(bool value);

public:
    // int32 background_gray_value = 9;
    void clear_background_gray_value();
    int32_t background_gray_value() const;
    void set_background_gray_value(int32_t value);

private:
    int32_t _internal_background_gray_value() const;
    void _internal_set_background_gray_value(int32_t value);

public:
    // int32 foreground_rgb_value = 10;
    void clear_foreground_rgb_value();
    int32_t foreground_rgb_value() const;
    void set_foreground_rgb_value(int32_t value);

private:
    int32_t _internal_foreground_rgb_value() const;
    void _internal_set_foreground_rgb_value(int32_t value);

public:
    // int32 background_rgb_value = 11;
    void clear_background_rgb_value();
    int32_t background_rgb_value() const;
    void set_background_rgb_value(int32_t value);

private:
    int32_t _internal_background_rgb_value() const;
    void _internal_set_background_rgb_value(int32_t value);

public:
    // .chrome_screen_ai.Direction direction = 12;
    void clear_direction();
    ::chrome_screen_ai::Direction direction() const;
    void set_direction(::chrome_screen_ai::Direction value);

private:
    ::chrome_screen_ai::Direction _internal_direction() const;
    void _internal_set_direction(::chrome_screen_ai::Direction value);

public:
    // .chrome_screen_ai.ContentType content_type = 13;
    void clear_content_type();
    ::chrome_screen_ai::ContentType content_type() const;
    void set_content_type(::chrome_screen_ai::ContentType value);

private:
    ::chrome_screen_ai::ContentType _internal_content_type() const;
    void _internal_set_content_type(::chrome_screen_ai::ContentType value);

public:
    // .chrome_screen_ai.Orientation orientation = 14;
    void clear_orientation();
    ::chrome_screen_ai::Orientation orientation() const;
    void set_orientation(::chrome_screen_ai::Orientation value);

private:
    ::chrome_screen_ai::Orientation _internal_orientation() const;
    void _internal_set_orientation(::chrome_screen_ai::Orientation value);

public:
    // float confidence = 15;
    void clear_confidence();
    float confidence() const;
    void set_confidence(float value);

private:
    float _internal_confidence() const;
    void _internal_set_confidence(float value);

public:
    // @@protoc_insertion_point(class_scope:chrome_screen_ai.WordBox)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::SymbolBox> symbols_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf8_string_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
        ::chrome_screen_ai::Rect* bounding_box_;
        int32_t foreground_gray_value_;
        bool dictionary_word_;
        bool has_space_after_;
        bool estimate_color_success_;
        bool estimate_gray_success_;
        int32_t background_gray_value_;
        int32_t foreground_rgb_value_;
        int32_t background_rgb_value_;
        int direction_;
        int content_type_;
        int orientation_;
        float confidence_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_chrome_5fscreen_5fai_2eproto;
};
// -------------------------------------------------------------------

class SymbolBox final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_screen_ai.SymbolBox) */ {
public:
    inline SymbolBox()
        : SymbolBox(nullptr)
    {
    }
    ~SymbolBox() override;
    explicit PROTOBUF_CONSTEXPR SymbolBox(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SymbolBox(const SymbolBox& from);
    SymbolBox(SymbolBox&& from) noexcept
        : SymbolBox()
    {
        *this = ::std::move(from);
    }

    inline SymbolBox& operator=(const SymbolBox& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SymbolBox& operator=(SymbolBox&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SymbolBox& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SymbolBox* internal_default_instance()
    {
        return reinterpret_cast<const SymbolBox*>(&_SymbolBox_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(SymbolBox& a, SymbolBox& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SymbolBox* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SymbolBox* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SymbolBox* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SymbolBox>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SymbolBox& from);
    void MergeFrom(const SymbolBox& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SymbolBox* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_screen_ai.SymbolBox";
    }

protected:
    explicit SymbolBox(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUtf8StringFieldNumber = 2,
        kBoundingBoxFieldNumber = 1,
        kConfidenceFieldNumber = 3,
    };
    // string utf8_string = 2;
    void clear_utf8_string();
    const std::string& utf8_string() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_utf8_string(ArgT0&& arg0, ArgT... args);
    std::string* mutable_utf8_string();
    PROTOBUF_NODISCARD std::string* release_utf8_string();
    void set_allocated_utf8_string(std::string* utf8_string);

private:
    const std::string& _internal_utf8_string() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_utf8_string(const std::string& value);
    std::string* _internal_mutable_utf8_string();

public:
    // .chrome_screen_ai.Rect bounding_box = 1;
    bool has_bounding_box() const;

private:
    bool _internal_has_bounding_box() const;

public:
    void clear_bounding_box();
    const ::chrome_screen_ai::Rect& bounding_box() const;
    PROTOBUF_NODISCARD ::chrome_screen_ai::Rect* release_bounding_box();
    ::chrome_screen_ai::Rect* mutable_bounding_box();
    void set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box);

private:
    const ::chrome_screen_ai::Rect& _internal_bounding_box() const;
    ::chrome_screen_ai::Rect* _internal_mutable_bounding_box();

public:
    void unsafe_arena_set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box);
    ::chrome_screen_ai::Rect* unsafe_arena_release_bounding_box();

    // float confidence = 3;
    void clear_confidence();
    float confidence() const;
    void set_confidence(float value);

private:
    float _internal_confidence() const;
    void _internal_set_confidence(float value);

public:
    // @@protoc_insertion_point(class_scope:chrome_screen_ai.SymbolBox)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr utf8_string_;
        ::chrome_screen_ai::Rect* bounding_box_;
        float confidence_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_chrome_5fscreen_5fai_2eproto;
};
// -------------------------------------------------------------------

class VisualAnnotation final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:chrome_screen_ai.VisualAnnotation) */ {
public:
    inline VisualAnnotation()
        : VisualAnnotation(nullptr)
    {
    }
    ~VisualAnnotation() override;
    explicit PROTOBUF_CONSTEXPR VisualAnnotation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    VisualAnnotation(const VisualAnnotation& from);
    VisualAnnotation(VisualAnnotation&& from) noexcept
        : VisualAnnotation()
    {
        *this = ::std::move(from);
    }

    inline VisualAnnotation& operator=(const VisualAnnotation& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline VisualAnnotation& operator=(VisualAnnotation&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const VisualAnnotation& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const VisualAnnotation* internal_default_instance()
    {
        return reinterpret_cast<const VisualAnnotation*>(&_VisualAnnotation_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(VisualAnnotation& a, VisualAnnotation& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(VisualAnnotation* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(VisualAnnotation* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    VisualAnnotation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<VisualAnnotation>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const VisualAnnotation& from);
    void MergeFrom(const VisualAnnotation& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(VisualAnnotation* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "chrome_screen_ai.VisualAnnotation";
    }

protected:
    explicit VisualAnnotation(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kLinesFieldNumber = 2,
    };
    // repeated .chrome_screen_ai.LineBox lines = 2;
    int lines_size() const;

private:
    int _internal_lines_size() const;

public:
    void clear_lines();
    ::chrome_screen_ai::LineBox* mutable_lines(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::LineBox>* mutable_lines();

private:
    const ::chrome_screen_ai::LineBox& _internal_lines(int index) const;
    ::chrome_screen_ai::LineBox* _internal_add_lines();

public:
    const ::chrome_screen_ai::LineBox& lines(int index) const;
    ::chrome_screen_ai::LineBox* add_lines();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::LineBox>& lines() const;

    // @@protoc_insertion_point(class_scope:chrome_screen_ai.VisualAnnotation)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::LineBox> lines_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_chrome_5fscreen_5fai_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Rect

// int32 x = 1;
inline void Rect::clear_x()
{
    _impl_.x_ = 0;
}
inline int32_t Rect::_internal_x() const
{
    return _impl_.x_;
}
inline int32_t Rect::x() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.Rect.x)
    return _internal_x();
}
inline void Rect::_internal_set_x(int32_t value)
{

    _impl_.x_ = value;
}
inline void Rect::set_x(int32_t value)
{
    _internal_set_x(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.Rect.x)
}

// int32 y = 2;
inline void Rect::clear_y()
{
    _impl_.y_ = 0;
}
inline int32_t Rect::_internal_y() const
{
    return _impl_.y_;
}
inline int32_t Rect::y() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.Rect.y)
    return _internal_y();
}
inline void Rect::_internal_set_y(int32_t value)
{

    _impl_.y_ = value;
}
inline void Rect::set_y(int32_t value)
{
    _internal_set_y(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.Rect.y)
}

// int32 width = 3;
inline void Rect::clear_width()
{
    _impl_.width_ = 0;
}
inline int32_t Rect::_internal_width() const
{
    return _impl_.width_;
}
inline int32_t Rect::width() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.Rect.width)
    return _internal_width();
}
inline void Rect::_internal_set_width(int32_t value)
{

    _impl_.width_ = value;
}
inline void Rect::set_width(int32_t value)
{
    _internal_set_width(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.Rect.width)
}

// int32 height = 4;
inline void Rect::clear_height()
{
    _impl_.height_ = 0;
}
inline int32_t Rect::_internal_height() const
{
    return _impl_.height_;
}
inline int32_t Rect::height() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.Rect.height)
    return _internal_height();
}
inline void Rect::_internal_set_height(int32_t value)
{

    _impl_.height_ = value;
}
inline void Rect::set_height(int32_t value)
{
    _internal_set_height(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.Rect.height)
}

// float angle = 5;
inline void Rect::clear_angle()
{
    _impl_.angle_ = 0;
}
inline float Rect::_internal_angle() const
{
    return _impl_.angle_;
}
inline float Rect::angle() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.Rect.angle)
    return _internal_angle();
}
inline void Rect::_internal_set_angle(float value)
{

    _impl_.angle_ = value;
}
inline void Rect::set_angle(float value)
{
    _internal_set_angle(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.Rect.angle)
}

// -------------------------------------------------------------------

// LineBox

// repeated .chrome_screen_ai.WordBox words = 1;
inline int LineBox::_internal_words_size() const
{
    return _impl_.words_.size();
}
inline int LineBox::words_size() const
{
    return _internal_words_size();
}
inline void LineBox::clear_words()
{
    _impl_.words_.Clear();
}
inline ::chrome_screen_ai::WordBox* LineBox::mutable_words(int index)
{
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.LineBox.words)
    return _impl_.words_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::WordBox>* LineBox::mutable_words()
{
    // @@protoc_insertion_point(field_mutable_list:chrome_screen_ai.LineBox.words)
    return &_impl_.words_;
}
inline const ::chrome_screen_ai::WordBox& LineBox::_internal_words(int index) const
{
    return _impl_.words_.Get(index);
}
inline const ::chrome_screen_ai::WordBox& LineBox::words(int index) const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.words)
    return _internal_words(index);
}
inline ::chrome_screen_ai::WordBox* LineBox::_internal_add_words()
{
    return _impl_.words_.Add();
}
inline ::chrome_screen_ai::WordBox* LineBox::add_words()
{
    ::chrome_screen_ai::WordBox* _add = _internal_add_words();
    // @@protoc_insertion_point(field_add:chrome_screen_ai.LineBox.words)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::WordBox>& LineBox::words() const
{
    // @@protoc_insertion_point(field_list:chrome_screen_ai.LineBox.words)
    return _impl_.words_;
}

// .chrome_screen_ai.Rect bounding_box = 2;
inline bool LineBox::_internal_has_bounding_box() const
{
    return this != internal_default_instance() && _impl_.bounding_box_ != nullptr;
}
inline bool LineBox::has_bounding_box() const
{
    return _internal_has_bounding_box();
}
inline void LineBox::clear_bounding_box()
{
    if (GetArenaForAllocation() == nullptr && _impl_.bounding_box_ != nullptr) {
        delete _impl_.bounding_box_;
    }
    _impl_.bounding_box_ = nullptr;
}
inline const ::chrome_screen_ai::Rect& LineBox::_internal_bounding_box() const
{
    const ::chrome_screen_ai::Rect* p = _impl_.bounding_box_;
    return p != nullptr ? *p : reinterpret_cast<const ::chrome_screen_ai::Rect&>(::chrome_screen_ai::_Rect_default_instance_);
}
inline const ::chrome_screen_ai::Rect& LineBox::bounding_box() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.bounding_box)
    return _internal_bounding_box();
}
inline void LineBox::unsafe_arena_set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bounding_box_);
    }
    _impl_.bounding_box_ = bounding_box;
    if (bounding_box) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_screen_ai.LineBox.bounding_box)
}
inline ::chrome_screen_ai::Rect* LineBox::release_bounding_box()
{

    ::chrome_screen_ai::Rect* temp = _impl_.bounding_box_;
    _impl_.bounding_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_screen_ai::Rect* LineBox::unsafe_arena_release_bounding_box()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.LineBox.bounding_box)

    ::chrome_screen_ai::Rect* temp = _impl_.bounding_box_;
    _impl_.bounding_box_ = nullptr;
    return temp;
}
inline ::chrome_screen_ai::Rect* LineBox::_internal_mutable_bounding_box()
{

    if (_impl_.bounding_box_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_screen_ai::Rect>(GetArenaForAllocation());
        _impl_.bounding_box_ = p;
    }
    return _impl_.bounding_box_;
}
inline ::chrome_screen_ai::Rect* LineBox::mutable_bounding_box()
{
    ::chrome_screen_ai::Rect* _msg = _internal_mutable_bounding_box();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.LineBox.bounding_box)
    return _msg;
}
inline void LineBox::set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.bounding_box_;
    }
    if (bounding_box) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bounding_box);
        if (message_arena != submessage_arena) {
            bounding_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, bounding_box, submessage_arena);
        }

    } else {
    }
    _impl_.bounding_box_ = bounding_box;
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.LineBox.bounding_box)
}

// string utf8_string = 3;
inline void LineBox::clear_utf8_string()
{
    _impl_.utf8_string_.ClearToEmpty();
}
inline const std::string& LineBox::utf8_string() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.utf8_string)
    return _internal_utf8_string();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void LineBox::set_utf8_string(ArgT0&& arg0, ArgT... args)
{

    _impl_.utf8_string_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_screen_ai.LineBox.utf8_string)
}
inline std::string* LineBox::mutable_utf8_string()
{
    std::string* _s = _internal_mutable_utf8_string();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.LineBox.utf8_string)
    return _s;
}
inline const std::string& LineBox::_internal_utf8_string() const
{
    return _impl_.utf8_string_.Get();
}
inline void LineBox::_internal_set_utf8_string(const std::string& value)
{

    _impl_.utf8_string_.Set(value, GetArenaForAllocation());
}
inline std::string* LineBox::_internal_mutable_utf8_string()
{

    return _impl_.utf8_string_.Mutable(GetArenaForAllocation());
}
inline std::string* LineBox::release_utf8_string()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.LineBox.utf8_string)
    return _impl_.utf8_string_.Release();
}
inline void LineBox::set_allocated_utf8_string(std::string* utf8_string)
{
    if (utf8_string != nullptr) {

    } else {
    }
    _impl_.utf8_string_.SetAllocated(utf8_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.utf8_string_.IsDefault()) {
        _impl_.utf8_string_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.LineBox.utf8_string)
}

// string language = 4;
inline void LineBox::clear_language()
{
    _impl_.language_.ClearToEmpty();
}
inline const std::string& LineBox::language() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.language)
    return _internal_language();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void LineBox::set_language(ArgT0&& arg0, ArgT... args)
{

    _impl_.language_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_screen_ai.LineBox.language)
}
inline std::string* LineBox::mutable_language()
{
    std::string* _s = _internal_mutable_language();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.LineBox.language)
    return _s;
}
inline const std::string& LineBox::_internal_language() const
{
    return _impl_.language_.Get();
}
inline void LineBox::_internal_set_language(const std::string& value)
{

    _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* LineBox::_internal_mutable_language()
{

    return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* LineBox::release_language()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.LineBox.language)
    return _impl_.language_.Release();
}
inline void LineBox::set_allocated_language(std::string* language)
{
    if (language != nullptr) {

    } else {
    }
    _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.language_.IsDefault()) {
        _impl_.language_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.LineBox.language)
}

// int32 block_id = 5;
inline void LineBox::clear_block_id()
{
    _impl_.block_id_ = 0;
}
inline int32_t LineBox::_internal_block_id() const
{
    return _impl_.block_id_;
}
inline int32_t LineBox::block_id() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.block_id)
    return _internal_block_id();
}
inline void LineBox::_internal_set_block_id(int32_t value)
{

    _impl_.block_id_ = value;
}
inline void LineBox::set_block_id(int32_t value)
{
    _internal_set_block_id(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.LineBox.block_id)
}

// int32 order_within_block = 6;
inline void LineBox::clear_order_within_block()
{
    _impl_.order_within_block_ = 0;
}
inline int32_t LineBox::_internal_order_within_block() const
{
    return _impl_.order_within_block_;
}
inline int32_t LineBox::order_within_block() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.order_within_block)
    return _internal_order_within_block();
}
inline void LineBox::_internal_set_order_within_block(int32_t value)
{

    _impl_.order_within_block_ = value;
}
inline void LineBox::set_order_within_block(int32_t value)
{
    _internal_set_order_within_block(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.LineBox.order_within_block)
}

// .chrome_screen_ai.Direction direction = 7;
inline void LineBox::clear_direction()
{
    _impl_.direction_ = 0;
}
inline ::chrome_screen_ai::Direction LineBox::_internal_direction() const
{
    return static_cast<::chrome_screen_ai::Direction>(_impl_.direction_);
}
inline ::chrome_screen_ai::Direction LineBox::direction() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.direction)
    return _internal_direction();
}
inline void LineBox::_internal_set_direction(::chrome_screen_ai::Direction value)
{

    _impl_.direction_ = value;
}
inline void LineBox::set_direction(::chrome_screen_ai::Direction value)
{
    _internal_set_direction(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.LineBox.direction)
}

// .chrome_screen_ai.ContentType content_type = 8;
inline void LineBox::clear_content_type()
{
    _impl_.content_type_ = 0;
}
inline ::chrome_screen_ai::ContentType LineBox::_internal_content_type() const
{
    return static_cast<::chrome_screen_ai::ContentType>(_impl_.content_type_);
}
inline ::chrome_screen_ai::ContentType LineBox::content_type() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.content_type)
    return _internal_content_type();
}
inline void LineBox::_internal_set_content_type(::chrome_screen_ai::ContentType value)
{

    _impl_.content_type_ = value;
}
inline void LineBox::set_content_type(::chrome_screen_ai::ContentType value)
{
    _internal_set_content_type(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.LineBox.content_type)
}

// .chrome_screen_ai.Rect baseline_box = 9;
inline bool LineBox::_internal_has_baseline_box() const
{
    return this != internal_default_instance() && _impl_.baseline_box_ != nullptr;
}
inline bool LineBox::has_baseline_box() const
{
    return _internal_has_baseline_box();
}
inline void LineBox::clear_baseline_box()
{
    if (GetArenaForAllocation() == nullptr && _impl_.baseline_box_ != nullptr) {
        delete _impl_.baseline_box_;
    }
    _impl_.baseline_box_ = nullptr;
}
inline const ::chrome_screen_ai::Rect& LineBox::_internal_baseline_box() const
{
    const ::chrome_screen_ai::Rect* p = _impl_.baseline_box_;
    return p != nullptr ? *p : reinterpret_cast<const ::chrome_screen_ai::Rect&>(::chrome_screen_ai::_Rect_default_instance_);
}
inline const ::chrome_screen_ai::Rect& LineBox::baseline_box() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.baseline_box)
    return _internal_baseline_box();
}
inline void LineBox::unsafe_arena_set_allocated_baseline_box(::chrome_screen_ai::Rect* baseline_box)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.baseline_box_);
    }
    _impl_.baseline_box_ = baseline_box;
    if (baseline_box) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_screen_ai.LineBox.baseline_box)
}
inline ::chrome_screen_ai::Rect* LineBox::release_baseline_box()
{

    ::chrome_screen_ai::Rect* temp = _impl_.baseline_box_;
    _impl_.baseline_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_screen_ai::Rect* LineBox::unsafe_arena_release_baseline_box()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.LineBox.baseline_box)

    ::chrome_screen_ai::Rect* temp = _impl_.baseline_box_;
    _impl_.baseline_box_ = nullptr;
    return temp;
}
inline ::chrome_screen_ai::Rect* LineBox::_internal_mutable_baseline_box()
{

    if (_impl_.baseline_box_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_screen_ai::Rect>(GetArenaForAllocation());
        _impl_.baseline_box_ = p;
    }
    return _impl_.baseline_box_;
}
inline ::chrome_screen_ai::Rect* LineBox::mutable_baseline_box()
{
    ::chrome_screen_ai::Rect* _msg = _internal_mutable_baseline_box();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.LineBox.baseline_box)
    return _msg;
}
inline void LineBox::set_allocated_baseline_box(::chrome_screen_ai::Rect* baseline_box)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.baseline_box_;
    }
    if (baseline_box) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(baseline_box);
        if (message_arena != submessage_arena) {
            baseline_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, baseline_box, submessage_arena);
        }

    } else {
    }
    _impl_.baseline_box_ = baseline_box;
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.LineBox.baseline_box)
}

// float confidence = 10;
inline void LineBox::clear_confidence()
{
    _impl_.confidence_ = 0;
}
inline float LineBox::_internal_confidence() const
{
    return _impl_.confidence_;
}
inline float LineBox::confidence() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.LineBox.confidence)
    return _internal_confidence();
}
inline void LineBox::_internal_set_confidence(float value)
{

    _impl_.confidence_ = value;
}
inline void LineBox::set_confidence(float value)
{
    _internal_set_confidence(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.LineBox.confidence)
}

// -------------------------------------------------------------------

// WordBox

// repeated .chrome_screen_ai.SymbolBox symbols = 1;
inline int WordBox::_internal_symbols_size() const
{
    return _impl_.symbols_.size();
}
inline int WordBox::symbols_size() const
{
    return _internal_symbols_size();
}
inline void WordBox::clear_symbols()
{
    _impl_.symbols_.Clear();
}
inline ::chrome_screen_ai::SymbolBox* WordBox::mutable_symbols(int index)
{
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.WordBox.symbols)
    return _impl_.symbols_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::SymbolBox>* WordBox::mutable_symbols()
{
    // @@protoc_insertion_point(field_mutable_list:chrome_screen_ai.WordBox.symbols)
    return &_impl_.symbols_;
}
inline const ::chrome_screen_ai::SymbolBox& WordBox::_internal_symbols(int index) const
{
    return _impl_.symbols_.Get(index);
}
inline const ::chrome_screen_ai::SymbolBox& WordBox::symbols(int index) const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.symbols)
    return _internal_symbols(index);
}
inline ::chrome_screen_ai::SymbolBox* WordBox::_internal_add_symbols()
{
    return _impl_.symbols_.Add();
}
inline ::chrome_screen_ai::SymbolBox* WordBox::add_symbols()
{
    ::chrome_screen_ai::SymbolBox* _add = _internal_add_symbols();
    // @@protoc_insertion_point(field_add:chrome_screen_ai.WordBox.symbols)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::SymbolBox>& WordBox::symbols() const
{
    // @@protoc_insertion_point(field_list:chrome_screen_ai.WordBox.symbols)
    return _impl_.symbols_;
}

// .chrome_screen_ai.Rect bounding_box = 2;
inline bool WordBox::_internal_has_bounding_box() const
{
    return this != internal_default_instance() && _impl_.bounding_box_ != nullptr;
}
inline bool WordBox::has_bounding_box() const
{
    return _internal_has_bounding_box();
}
inline void WordBox::clear_bounding_box()
{
    if (GetArenaForAllocation() == nullptr && _impl_.bounding_box_ != nullptr) {
        delete _impl_.bounding_box_;
    }
    _impl_.bounding_box_ = nullptr;
}
inline const ::chrome_screen_ai::Rect& WordBox::_internal_bounding_box() const
{
    const ::chrome_screen_ai::Rect* p = _impl_.bounding_box_;
    return p != nullptr ? *p : reinterpret_cast<const ::chrome_screen_ai::Rect&>(::chrome_screen_ai::_Rect_default_instance_);
}
inline const ::chrome_screen_ai::Rect& WordBox::bounding_box() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.bounding_box)
    return _internal_bounding_box();
}
inline void WordBox::unsafe_arena_set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bounding_box_);
    }
    _impl_.bounding_box_ = bounding_box;
    if (bounding_box) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_screen_ai.WordBox.bounding_box)
}
inline ::chrome_screen_ai::Rect* WordBox::release_bounding_box()
{

    ::chrome_screen_ai::Rect* temp = _impl_.bounding_box_;
    _impl_.bounding_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_screen_ai::Rect* WordBox::unsafe_arena_release_bounding_box()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.WordBox.bounding_box)

    ::chrome_screen_ai::Rect* temp = _impl_.bounding_box_;
    _impl_.bounding_box_ = nullptr;
    return temp;
}
inline ::chrome_screen_ai::Rect* WordBox::_internal_mutable_bounding_box()
{

    if (_impl_.bounding_box_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_screen_ai::Rect>(GetArenaForAllocation());
        _impl_.bounding_box_ = p;
    }
    return _impl_.bounding_box_;
}
inline ::chrome_screen_ai::Rect* WordBox::mutable_bounding_box()
{
    ::chrome_screen_ai::Rect* _msg = _internal_mutable_bounding_box();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.WordBox.bounding_box)
    return _msg;
}
inline void WordBox::set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.bounding_box_;
    }
    if (bounding_box) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bounding_box);
        if (message_arena != submessage_arena) {
            bounding_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, bounding_box, submessage_arena);
        }

    } else {
    }
    _impl_.bounding_box_ = bounding_box;
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.WordBox.bounding_box)
}

// string utf8_string = 3;
inline void WordBox::clear_utf8_string()
{
    _impl_.utf8_string_.ClearToEmpty();
}
inline const std::string& WordBox::utf8_string() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.utf8_string)
    return _internal_utf8_string();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WordBox::set_utf8_string(ArgT0&& arg0, ArgT... args)
{

    _impl_.utf8_string_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.utf8_string)
}
inline std::string* WordBox::mutable_utf8_string()
{
    std::string* _s = _internal_mutable_utf8_string();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.WordBox.utf8_string)
    return _s;
}
inline const std::string& WordBox::_internal_utf8_string() const
{
    return _impl_.utf8_string_.Get();
}
inline void WordBox::_internal_set_utf8_string(const std::string& value)
{

    _impl_.utf8_string_.Set(value, GetArenaForAllocation());
}
inline std::string* WordBox::_internal_mutable_utf8_string()
{

    return _impl_.utf8_string_.Mutable(GetArenaForAllocation());
}
inline std::string* WordBox::release_utf8_string()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.WordBox.utf8_string)
    return _impl_.utf8_string_.Release();
}
inline void WordBox::set_allocated_utf8_string(std::string* utf8_string)
{
    if (utf8_string != nullptr) {

    } else {
    }
    _impl_.utf8_string_.SetAllocated(utf8_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.utf8_string_.IsDefault()) {
        _impl_.utf8_string_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.WordBox.utf8_string)
}

// bool dictionary_word = 4;
inline void WordBox::clear_dictionary_word()
{
    _impl_.dictionary_word_ = false;
}
inline bool WordBox::_internal_dictionary_word() const
{
    return _impl_.dictionary_word_;
}
inline bool WordBox::dictionary_word() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.dictionary_word)
    return _internal_dictionary_word();
}
inline void WordBox::_internal_set_dictionary_word(bool value)
{

    _impl_.dictionary_word_ = value;
}
inline void WordBox::set_dictionary_word(bool value)
{
    _internal_set_dictionary_word(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.dictionary_word)
}

// string language = 5;
inline void WordBox::clear_language()
{
    _impl_.language_.ClearToEmpty();
}
inline const std::string& WordBox::language() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.language)
    return _internal_language();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void WordBox::set_language(ArgT0&& arg0, ArgT... args)
{

    _impl_.language_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.language)
}
inline std::string* WordBox::mutable_language()
{
    std::string* _s = _internal_mutable_language();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.WordBox.language)
    return _s;
}
inline const std::string& WordBox::_internal_language() const
{
    return _impl_.language_.Get();
}
inline void WordBox::_internal_set_language(const std::string& value)
{

    _impl_.language_.Set(value, GetArenaForAllocation());
}
inline std::string* WordBox::_internal_mutable_language()
{

    return _impl_.language_.Mutable(GetArenaForAllocation());
}
inline std::string* WordBox::release_language()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.WordBox.language)
    return _impl_.language_.Release();
}
inline void WordBox::set_allocated_language(std::string* language)
{
    if (language != nullptr) {

    } else {
    }
    _impl_.language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.language_.IsDefault()) {
        _impl_.language_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.WordBox.language)
}

// bool has_space_after = 6;
inline void WordBox::clear_has_space_after()
{
    _impl_.has_space_after_ = false;
}
inline bool WordBox::_internal_has_space_after() const
{
    return _impl_.has_space_after_;
}
inline bool WordBox::has_space_after() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.has_space_after)
    return _internal_has_space_after();
}
inline void WordBox::_internal_set_has_space_after(bool value)
{

    _impl_.has_space_after_ = value;
}
inline void WordBox::set_has_space_after(bool value)
{
    _internal_set_has_space_after(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.has_space_after)
}

// bool estimate_color_success = 7;
inline void WordBox::clear_estimate_color_success()
{
    _impl_.estimate_color_success_ = false;
}
inline bool WordBox::_internal_estimate_color_success() const
{
    return _impl_.estimate_color_success_;
}
inline bool WordBox::estimate_color_success() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.estimate_color_success)
    return _internal_estimate_color_success();
}
inline void WordBox::_internal_set_estimate_color_success(bool value)
{

    _impl_.estimate_color_success_ = value;
}
inline void WordBox::set_estimate_color_success(bool value)
{
    _internal_set_estimate_color_success(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.estimate_color_success)
}

// int32 foreground_gray_value = 8;
inline void WordBox::clear_foreground_gray_value()
{
    _impl_.foreground_gray_value_ = 0;
}
inline int32_t WordBox::_internal_foreground_gray_value() const
{
    return _impl_.foreground_gray_value_;
}
inline int32_t WordBox::foreground_gray_value() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.foreground_gray_value)
    return _internal_foreground_gray_value();
}
inline void WordBox::_internal_set_foreground_gray_value(int32_t value)
{

    _impl_.foreground_gray_value_ = value;
}
inline void WordBox::set_foreground_gray_value(int32_t value)
{
    _internal_set_foreground_gray_value(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.foreground_gray_value)
}

// int32 background_gray_value = 9;
inline void WordBox::clear_background_gray_value()
{
    _impl_.background_gray_value_ = 0;
}
inline int32_t WordBox::_internal_background_gray_value() const
{
    return _impl_.background_gray_value_;
}
inline int32_t WordBox::background_gray_value() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.background_gray_value)
    return _internal_background_gray_value();
}
inline void WordBox::_internal_set_background_gray_value(int32_t value)
{

    _impl_.background_gray_value_ = value;
}
inline void WordBox::set_background_gray_value(int32_t value)
{
    _internal_set_background_gray_value(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.background_gray_value)
}

// int32 foreground_rgb_value = 10;
inline void WordBox::clear_foreground_rgb_value()
{
    _impl_.foreground_rgb_value_ = 0;
}
inline int32_t WordBox::_internal_foreground_rgb_value() const
{
    return _impl_.foreground_rgb_value_;
}
inline int32_t WordBox::foreground_rgb_value() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.foreground_rgb_value)
    return _internal_foreground_rgb_value();
}
inline void WordBox::_internal_set_foreground_rgb_value(int32_t value)
{

    _impl_.foreground_rgb_value_ = value;
}
inline void WordBox::set_foreground_rgb_value(int32_t value)
{
    _internal_set_foreground_rgb_value(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.foreground_rgb_value)
}

// int32 background_rgb_value = 11;
inline void WordBox::clear_background_rgb_value()
{
    _impl_.background_rgb_value_ = 0;
}
inline int32_t WordBox::_internal_background_rgb_value() const
{
    return _impl_.background_rgb_value_;
}
inline int32_t WordBox::background_rgb_value() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.background_rgb_value)
    return _internal_background_rgb_value();
}
inline void WordBox::_internal_set_background_rgb_value(int32_t value)
{

    _impl_.background_rgb_value_ = value;
}
inline void WordBox::set_background_rgb_value(int32_t value)
{
    _internal_set_background_rgb_value(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.background_rgb_value)
}

// .chrome_screen_ai.Direction direction = 12;
inline void WordBox::clear_direction()
{
    _impl_.direction_ = 0;
}
inline ::chrome_screen_ai::Direction WordBox::_internal_direction() const
{
    return static_cast<::chrome_screen_ai::Direction>(_impl_.direction_);
}
inline ::chrome_screen_ai::Direction WordBox::direction() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.direction)
    return _internal_direction();
}
inline void WordBox::_internal_set_direction(::chrome_screen_ai::Direction value)
{

    _impl_.direction_ = value;
}
inline void WordBox::set_direction(::chrome_screen_ai::Direction value)
{
    _internal_set_direction(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.direction)
}

// .chrome_screen_ai.ContentType content_type = 13;
inline void WordBox::clear_content_type()
{
    _impl_.content_type_ = 0;
}
inline ::chrome_screen_ai::ContentType WordBox::_internal_content_type() const
{
    return static_cast<::chrome_screen_ai::ContentType>(_impl_.content_type_);
}
inline ::chrome_screen_ai::ContentType WordBox::content_type() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.content_type)
    return _internal_content_type();
}
inline void WordBox::_internal_set_content_type(::chrome_screen_ai::ContentType value)
{

    _impl_.content_type_ = value;
}
inline void WordBox::set_content_type(::chrome_screen_ai::ContentType value)
{
    _internal_set_content_type(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.content_type)
}

// .chrome_screen_ai.Orientation orientation = 14;
inline void WordBox::clear_orientation()
{
    _impl_.orientation_ = 0;
}
inline ::chrome_screen_ai::Orientation WordBox::_internal_orientation() const
{
    return static_cast<::chrome_screen_ai::Orientation>(_impl_.orientation_);
}
inline ::chrome_screen_ai::Orientation WordBox::orientation() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.orientation)
    return _internal_orientation();
}
inline void WordBox::_internal_set_orientation(::chrome_screen_ai::Orientation value)
{

    _impl_.orientation_ = value;
}
inline void WordBox::set_orientation(::chrome_screen_ai::Orientation value)
{
    _internal_set_orientation(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.orientation)
}

// float confidence = 15;
inline void WordBox::clear_confidence()
{
    _impl_.confidence_ = 0;
}
inline float WordBox::_internal_confidence() const
{
    return _impl_.confidence_;
}
inline float WordBox::confidence() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.confidence)
    return _internal_confidence();
}
inline void WordBox::_internal_set_confidence(float value)
{

    _impl_.confidence_ = value;
}
inline void WordBox::set_confidence(float value)
{
    _internal_set_confidence(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.confidence)
}

// bool estimate_gray_success = 16;
inline void WordBox::clear_estimate_gray_success()
{
    _impl_.estimate_gray_success_ = false;
}
inline bool WordBox::_internal_estimate_gray_success() const
{
    return _impl_.estimate_gray_success_;
}
inline bool WordBox::estimate_gray_success() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.WordBox.estimate_gray_success)
    return _internal_estimate_gray_success();
}
inline void WordBox::_internal_set_estimate_gray_success(bool value)
{

    _impl_.estimate_gray_success_ = value;
}
inline void WordBox::set_estimate_gray_success(bool value)
{
    _internal_set_estimate_gray_success(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.WordBox.estimate_gray_success)
}

// -------------------------------------------------------------------

// SymbolBox

// .chrome_screen_ai.Rect bounding_box = 1;
inline bool SymbolBox::_internal_has_bounding_box() const
{
    return this != internal_default_instance() && _impl_.bounding_box_ != nullptr;
}
inline bool SymbolBox::has_bounding_box() const
{
    return _internal_has_bounding_box();
}
inline void SymbolBox::clear_bounding_box()
{
    if (GetArenaForAllocation() == nullptr && _impl_.bounding_box_ != nullptr) {
        delete _impl_.bounding_box_;
    }
    _impl_.bounding_box_ = nullptr;
}
inline const ::chrome_screen_ai::Rect& SymbolBox::_internal_bounding_box() const
{
    const ::chrome_screen_ai::Rect* p = _impl_.bounding_box_;
    return p != nullptr ? *p : reinterpret_cast<const ::chrome_screen_ai::Rect&>(::chrome_screen_ai::_Rect_default_instance_);
}
inline const ::chrome_screen_ai::Rect& SymbolBox::bounding_box() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.SymbolBox.bounding_box)
    return _internal_bounding_box();
}
inline void SymbolBox::unsafe_arena_set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bounding_box_);
    }
    _impl_.bounding_box_ = bounding_box;
    if (bounding_box) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chrome_screen_ai.SymbolBox.bounding_box)
}
inline ::chrome_screen_ai::Rect* SymbolBox::release_bounding_box()
{

    ::chrome_screen_ai::Rect* temp = _impl_.bounding_box_;
    _impl_.bounding_box_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::chrome_screen_ai::Rect* SymbolBox::unsafe_arena_release_bounding_box()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.SymbolBox.bounding_box)

    ::chrome_screen_ai::Rect* temp = _impl_.bounding_box_;
    _impl_.bounding_box_ = nullptr;
    return temp;
}
inline ::chrome_screen_ai::Rect* SymbolBox::_internal_mutable_bounding_box()
{

    if (_impl_.bounding_box_ == nullptr) {
        auto* p = CreateMaybeMessage<::chrome_screen_ai::Rect>(GetArenaForAllocation());
        _impl_.bounding_box_ = p;
    }
    return _impl_.bounding_box_;
}
inline ::chrome_screen_ai::Rect* SymbolBox::mutable_bounding_box()
{
    ::chrome_screen_ai::Rect* _msg = _internal_mutable_bounding_box();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.SymbolBox.bounding_box)
    return _msg;
}
inline void SymbolBox::set_allocated_bounding_box(::chrome_screen_ai::Rect* bounding_box)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.bounding_box_;
    }
    if (bounding_box) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bounding_box);
        if (message_arena != submessage_arena) {
            bounding_box = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, bounding_box, submessage_arena);
        }

    } else {
    }
    _impl_.bounding_box_ = bounding_box;
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.SymbolBox.bounding_box)
}

// string utf8_string = 2;
inline void SymbolBox::clear_utf8_string()
{
    _impl_.utf8_string_.ClearToEmpty();
}
inline const std::string& SymbolBox::utf8_string() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.SymbolBox.utf8_string)
    return _internal_utf8_string();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SymbolBox::set_utf8_string(ArgT0&& arg0, ArgT... args)
{

    _impl_.utf8_string_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:chrome_screen_ai.SymbolBox.utf8_string)
}
inline std::string* SymbolBox::mutable_utf8_string()
{
    std::string* _s = _internal_mutable_utf8_string();
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.SymbolBox.utf8_string)
    return _s;
}
inline const std::string& SymbolBox::_internal_utf8_string() const
{
    return _impl_.utf8_string_.Get();
}
inline void SymbolBox::_internal_set_utf8_string(const std::string& value)
{

    _impl_.utf8_string_.Set(value, GetArenaForAllocation());
}
inline std::string* SymbolBox::_internal_mutable_utf8_string()
{

    return _impl_.utf8_string_.Mutable(GetArenaForAllocation());
}
inline std::string* SymbolBox::release_utf8_string()
{
    // @@protoc_insertion_point(field_release:chrome_screen_ai.SymbolBox.utf8_string)
    return _impl_.utf8_string_.Release();
}
inline void SymbolBox::set_allocated_utf8_string(std::string* utf8_string)
{
    if (utf8_string != nullptr) {

    } else {
    }
    _impl_.utf8_string_.SetAllocated(utf8_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.utf8_string_.IsDefault()) {
        _impl_.utf8_string_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:chrome_screen_ai.SymbolBox.utf8_string)
}

// float confidence = 3;
inline void SymbolBox::clear_confidence()
{
    _impl_.confidence_ = 0;
}
inline float SymbolBox::_internal_confidence() const
{
    return _impl_.confidence_;
}
inline float SymbolBox::confidence() const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.SymbolBox.confidence)
    return _internal_confidence();
}
inline void SymbolBox::_internal_set_confidence(float value)
{

    _impl_.confidence_ = value;
}
inline void SymbolBox::set_confidence(float value)
{
    _internal_set_confidence(value);
    // @@protoc_insertion_point(field_set:chrome_screen_ai.SymbolBox.confidence)
}

// -------------------------------------------------------------------

// VisualAnnotation

// repeated .chrome_screen_ai.LineBox lines = 2;
inline int VisualAnnotation::_internal_lines_size() const
{
    return _impl_.lines_.size();
}
inline int VisualAnnotation::lines_size() const
{
    return _internal_lines_size();
}
inline void VisualAnnotation::clear_lines()
{
    _impl_.lines_.Clear();
}
inline ::chrome_screen_ai::LineBox* VisualAnnotation::mutable_lines(int index)
{
    // @@protoc_insertion_point(field_mutable:chrome_screen_ai.VisualAnnotation.lines)
    return _impl_.lines_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::LineBox>* VisualAnnotation::mutable_lines()
{
    // @@protoc_insertion_point(field_mutable_list:chrome_screen_ai.VisualAnnotation.lines)
    return &_impl_.lines_;
}
inline const ::chrome_screen_ai::LineBox& VisualAnnotation::_internal_lines(int index) const
{
    return _impl_.lines_.Get(index);
}
inline const ::chrome_screen_ai::LineBox& VisualAnnotation::lines(int index) const
{
    // @@protoc_insertion_point(field_get:chrome_screen_ai.VisualAnnotation.lines)
    return _internal_lines(index);
}
inline ::chrome_screen_ai::LineBox* VisualAnnotation::_internal_add_lines()
{
    return _impl_.lines_.Add();
}
inline ::chrome_screen_ai::LineBox* VisualAnnotation::add_lines()
{
    ::chrome_screen_ai::LineBox* _add = _internal_add_lines();
    // @@protoc_insertion_point(field_add:chrome_screen_ai.VisualAnnotation.lines)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::chrome_screen_ai::LineBox>& VisualAnnotation::lines() const
{
    // @@protoc_insertion_point(field_list:chrome_screen_ai.VisualAnnotation.lines)
    return _impl_.lines_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace chrome_screen_ai

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::chrome_screen_ai::Direction> : ::std::true_type { };
template <> struct is_proto_enum<::chrome_screen_ai::Orientation> : ::std::true_type { };
template <> struct is_proto_enum<::chrome_screen_ai::ContentType> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chrome_5fscreen_5fai_2eproto
