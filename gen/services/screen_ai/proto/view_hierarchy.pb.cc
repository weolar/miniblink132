// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: view_hierarchy.proto

#include "view_hierarchy.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace screenai {
PROTOBUF_CONSTEXPR BoundingBox::BoundingBox(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.top_)*/ 0, /*decltype(_impl_.left_)*/ 0,
        /*decltype(_impl_.bottom_)*/ 0, /*decltype(_impl_.right_)*/ 0 }
{
}
struct BoundingBoxDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BoundingBoxDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BoundingBoxDefaultTypeInternal()
    {
    }
    union {
        BoundingBox _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoundingBoxDefaultTypeInternal _BoundingBox_default_instance_;
PROTOBUF_CONSTEXPR BoundingBoxPixels::BoundingBoxPixels(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.top_)*/ 0, /*decltype(_impl_.left_)*/ 0,
        /*decltype(_impl_.bottom_)*/ 0, /*decltype(_impl_.right_)*/ 0 }
{
}
struct BoundingBoxPixelsDefaultTypeInternal {
    PROTOBUF_CONSTEXPR BoundingBoxPixelsDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~BoundingBoxPixelsDefaultTypeInternal()
    {
    }
    union {
        BoundingBoxPixels _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BoundingBoxPixelsDefaultTypeInternal _BoundingBoxPixels_default_instance_;
PROTOBUF_CONSTEXPR ViewHierarchy::ViewHierarchy(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.ui_elements_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct ViewHierarchyDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ViewHierarchyDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ViewHierarchyDefaultTypeInternal()
    {
    }
    union {
        ViewHierarchy _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ViewHierarchyDefaultTypeInternal _ViewHierarchy_default_instance_;
PROTOBUF_CONSTEXPR UiElement::UiElement(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.child_ids_)*/ {},
        /*decltype(_impl_._child_ids_cached_byte_size_)*/ { 0 }, /*decltype(_impl_.attributes_)*/ {}, /*decltype(_impl_.bounding_box_)*/ nullptr,
        /*decltype(_impl_.bounding_box_pixels_)*/ nullptr, /*decltype(_impl_.chrome_info_)*/ nullptr, /*decltype(_impl_.type_)*/ 0, /*decltype(_impl_.id_)*/ -1,
        /*decltype(_impl_.parent_id_)*/ -1 }
{
}
struct UiElementDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UiElementDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UiElementDefaultTypeInternal()
    {
    }
    union {
        UiElement _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UiElementDefaultTypeInternal _UiElement_default_instance_;
PROTOBUF_CONSTEXPR UiElementAttribute::UiElementAttribute(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {},
        /*decltype(_impl_.name_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.value_)*/ {},
        /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct UiElementAttributeDefaultTypeInternal {
    PROTOBUF_CONSTEXPR UiElementAttributeDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~UiElementAttributeDefaultTypeInternal()
    {
    }
    union {
        UiElementAttribute _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UiElementAttributeDefaultTypeInternal _UiElementAttribute_default_instance_;
PROTOBUF_CONSTEXPR IntList::IntList(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.value_)*/ {}, /*decltype(_impl_._value_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct IntListDefaultTypeInternal {
    PROTOBUF_CONSTEXPR IntListDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~IntListDefaultTypeInternal()
    {
    }
    union {
        IntList _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 IntListDefaultTypeInternal _IntList_default_instance_;
PROTOBUF_CONSTEXPR StringList::StringList(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.value_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct StringListDefaultTypeInternal {
    PROTOBUF_CONSTEXPR StringListDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~StringListDefaultTypeInternal()
    {
    }
    union {
        StringList _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StringListDefaultTypeInternal _StringList_default_instance_;
PROTOBUF_CONSTEXPR FloatList::FloatList(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.value_)*/ {}, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct FloatListDefaultTypeInternal {
    PROTOBUF_CONSTEXPR FloatListDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~FloatListDefaultTypeInternal()
    {
    }
    union {
        FloatList _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FloatListDefaultTypeInternal _FloatList_default_instance_;
PROTOBUF_CONSTEXPR ChromeInfo::ChromeInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_._has_bits_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_.dom_node_id_)*/ -1 }
{
}
struct ChromeInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR ChromeInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~ChromeInfoDefaultTypeInternal()
    {
    }
    union {
        ChromeInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeInfoDefaultTypeInternal _ChromeInfo_default_instance_;
} // namespace screenai
namespace screenai {
bool UiElementType_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> UiElementType_strings[4] = {};

static const char UiElementType_names[] = "ROOT"
                                          "UNKNOWN"
                                          "VIEW"
                                          "WINDOW";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry UiElementType_entries[] = {
    { { UiElementType_names + 0, 4 }, 1 },
    { { UiElementType_names + 4, 7 }, 0 },
    { { UiElementType_names + 11, 4 }, 3 },
    { { UiElementType_names + 15, 6 }, 2 },
};

static const int UiElementType_entries_by_number[] = {
    1, // 0 -> UNKNOWN
    0, // 1 -> ROOT
    3, // 2 -> WINDOW
    2, // 3 -> VIEW
};

const std::string& UiElementType_Name(UiElementType value)
{
    static const bool dummy
        = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(UiElementType_entries, UiElementType_entries_by_number, 4, UiElementType_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(UiElementType_entries, UiElementType_entries_by_number, 4, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : UiElementType_strings[idx].get();
}
bool UiElementType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UiElementType* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(UiElementType_entries, 4, name, &int_value);
    if (success) {
        *value = static_cast<UiElementType>(int_value);
    }
    return success;
}

// ===================================================================

class BoundingBox::_Internal {
public:
    using HasBits = decltype(std::declval<BoundingBox>()._impl_._has_bits_);
    static void set_has_top(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_left(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_bottom(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_right(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

BoundingBox::BoundingBox(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.BoundingBox)
}
BoundingBox::BoundingBox(const BoundingBox& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BoundingBox* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.top_) {},
        decltype(_impl_.left_) {}, decltype(_impl_.bottom_) {}, decltype(_impl_.right_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.top_, &from._impl_.top_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.right_) - reinterpret_cast<char*>(&_impl_.top_)) + sizeof(_impl_.right_));
    // @@protoc_insertion_point(copy_constructor:screenai.BoundingBox)
}

inline void BoundingBox::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.top_) { 0 }, decltype(_impl_.left_) { 0 },
        decltype(_impl_.bottom_) { 0 }, decltype(_impl_.right_) { 0 } };
}

BoundingBox::~BoundingBox()
{
    // @@protoc_insertion_point(destructor:screenai.BoundingBox)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BoundingBox::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BoundingBox::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BoundingBox::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.BoundingBox)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.top_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.right_) - reinterpret_cast<char*>(&_impl_.top_)) + sizeof(_impl_.right_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BoundingBox::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional float top = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                _Internal::set_has_top(&has_bits);
                _impl_.top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float left = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
                _Internal::set_has_left(&has_bits);
                _impl_.left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float bottom = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
                _Internal::set_has_bottom(&has_bits);
                _impl_.bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // optional float right = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
                _Internal::set_has_right(&has_bits);
                _impl_.right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BoundingBox::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.BoundingBox)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional float top = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_top(), target);
    }

    // optional float left = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_left(), target);
    }

    // optional float bottom = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_bottom(), target);
    }

    // optional float right = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_right(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.BoundingBox)
    return target;
}

size_t BoundingBox::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.BoundingBox)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional float top = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + 4;
        }

        // optional float left = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + 4;
        }

        // optional float bottom = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + 4;
        }

        // optional float right = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + 4;
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BoundingBox::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BoundingBox*>(&from));
}

void BoundingBox::MergeFrom(const BoundingBox& from)
{
    BoundingBox* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.BoundingBox)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.top_ = from._impl_.top_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.left_ = from._impl_.left_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.bottom_ = from._impl_.bottom_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.right_ = from._impl_.right_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BoundingBox::CopyFrom(const BoundingBox& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.BoundingBox)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BoundingBox::IsInitialized() const
{
    return true;
}

void BoundingBox::InternalSwap(BoundingBox* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_.right_) + sizeof(BoundingBox::_impl_.right_)
        - PROTOBUF_FIELD_OFFSET(BoundingBox, _impl_.top_)>(reinterpret_cast<char*>(&_impl_.top_), reinterpret_cast<char*>(&other->_impl_.top_));
}

std::string BoundingBox::GetTypeName() const
{
    return "screenai.BoundingBox";
}

// ===================================================================

class BoundingBoxPixels::_Internal {
public:
    using HasBits = decltype(std::declval<BoundingBoxPixels>()._impl_._has_bits_);
    static void set_has_top(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static void set_has_left(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static void set_has_bottom(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
    static void set_has_right(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
};

BoundingBoxPixels::BoundingBoxPixels(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.BoundingBoxPixels)
}
BoundingBoxPixels::BoundingBoxPixels(const BoundingBoxPixels& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    BoundingBoxPixels* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.top_) {},
        decltype(_impl_.left_) {}, decltype(_impl_.bottom_) {}, decltype(_impl_.right_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    ::memcpy(&_impl_.top_, &from._impl_.top_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.right_) - reinterpret_cast<char*>(&_impl_.top_)) + sizeof(_impl_.right_));
    // @@protoc_insertion_point(copy_constructor:screenai.BoundingBoxPixels)
}

inline void BoundingBoxPixels::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.top_) { 0 }, decltype(_impl_.left_) { 0 },
        decltype(_impl_.bottom_) { 0 }, decltype(_impl_.right_) { 0 } };
}

BoundingBoxPixels::~BoundingBoxPixels()
{
    // @@protoc_insertion_point(destructor:screenai.BoundingBoxPixels)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void BoundingBoxPixels::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BoundingBoxPixels::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void BoundingBoxPixels::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.BoundingBoxPixels)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        ::memset(&_impl_.top_, 0, static_cast<size_t>(reinterpret_cast<char*>(&_impl_.right_) - reinterpret_cast<char*>(&_impl_.top_)) + sizeof(_impl_.right_));
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* BoundingBoxPixels::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 top = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_top(&has_bits);
                _impl_.top_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 left = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _Internal::set_has_left(&has_bits);
                _impl_.left_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 bottom = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_bottom(&has_bits);
                _impl_.bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional int32 right = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _Internal::set_has_right(&has_bits);
                _impl_.right_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* BoundingBoxPixels::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.BoundingBoxPixels)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 top = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_top(), target);
    }

    // optional int32 left = 2;
    if (cached_has_bits & 0x00000002u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_left(), target);
    }

    // optional int32 bottom = 3;
    if (cached_has_bits & 0x00000004u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_bottom(), target);
    }

    // optional int32 right = 4;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_right(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.BoundingBoxPixels)
    return target;
}

size_t BoundingBoxPixels::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.BoundingBoxPixels)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        // optional int32 top = 1;
        if (cached_has_bits & 0x00000001u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_top());
        }

        // optional int32 left = 2;
        if (cached_has_bits & 0x00000002u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_left());
        }

        // optional int32 bottom = 3;
        if (cached_has_bits & 0x00000004u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bottom());
        }

        // optional int32 right = 4;
        if (cached_has_bits & 0x00000008u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_right());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void BoundingBoxPixels::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const BoundingBoxPixels*>(&from));
}

void BoundingBoxPixels::MergeFrom(const BoundingBoxPixels& from)
{
    BoundingBoxPixels* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.BoundingBoxPixels)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000000fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_impl_.top_ = from._impl_.top_;
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_impl_.left_ = from._impl_.left_;
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_impl_.bottom_ = from._impl_.bottom_;
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.right_ = from._impl_.right_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BoundingBoxPixels::CopyFrom(const BoundingBoxPixels& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.BoundingBoxPixels)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool BoundingBoxPixels::IsInitialized() const
{
    return true;
}

void BoundingBoxPixels::InternalSwap(BoundingBoxPixels* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(BoundingBoxPixels, _impl_.right_) + sizeof(BoundingBoxPixels::_impl_.right_)
        - PROTOBUF_FIELD_OFFSET(BoundingBoxPixels, _impl_.top_)>(reinterpret_cast<char*>(&_impl_.top_), reinterpret_cast<char*>(&other->_impl_.top_));
}

std::string BoundingBoxPixels::GetTypeName() const
{
    return "screenai.BoundingBoxPixels";
}

// ===================================================================

class ViewHierarchy::_Internal {
public:
};

ViewHierarchy::ViewHierarchy(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.ViewHierarchy)
}
ViewHierarchy::ViewHierarchy(const ViewHierarchy& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ViewHierarchy* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.ui_elements_) { from._impl_.ui_elements_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:screenai.ViewHierarchy)
}

inline void ViewHierarchy::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.ui_elements_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

ViewHierarchy::~ViewHierarchy()
{
    // @@protoc_insertion_point(destructor:screenai.ViewHierarchy)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ViewHierarchy::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.ui_elements_.~RepeatedPtrField();
}

void ViewHierarchy::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ViewHierarchy::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.ViewHierarchy)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.ui_elements_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ViewHierarchy::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated .screenai.UiElement ui_elements = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_ui_elements(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ViewHierarchy::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.ViewHierarchy)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated .screenai.UiElement ui_elements = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_ui_elements_size()); i < n; i++) {
        const auto& repfield = this->_internal_ui_elements(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.ViewHierarchy)
    return target;
}

size_t ViewHierarchy::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.ViewHierarchy)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .screenai.UiElement ui_elements = 2;
    total_size += 1UL * this->_internal_ui_elements_size();
    for (const auto& msg : this->_impl_.ui_elements_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ViewHierarchy::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ViewHierarchy*>(&from));
}

void ViewHierarchy::MergeFrom(const ViewHierarchy& from)
{
    ViewHierarchy* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.ViewHierarchy)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.ui_elements_.MergeFrom(from._impl_.ui_elements_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ViewHierarchy::CopyFrom(const ViewHierarchy& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.ViewHierarchy)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ViewHierarchy::IsInitialized() const
{
    return true;
}

void ViewHierarchy::InternalSwap(ViewHierarchy* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.ui_elements_.InternalSwap(&other->_impl_.ui_elements_);
}

std::string ViewHierarchy::GetTypeName() const
{
    return "screenai.ViewHierarchy";
}

// ===================================================================

class UiElement::_Internal {
public:
    using HasBits = decltype(std::declval<UiElement>()._impl_._has_bits_);
    static void set_has_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 16u;
    }
    static void set_has_type(HasBits* has_bits)
    {
        (*has_bits)[0] |= 8u;
    }
    static void set_has_parent_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 32u;
    }
    static const ::screenai::BoundingBox& bounding_box(const UiElement* msg);
    static void set_has_bounding_box(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::screenai::BoundingBoxPixels& bounding_box_pixels(const UiElement* msg);
    static void set_has_bounding_box_pixels(HasBits* has_bits)
    {
        (*has_bits)[0] |= 2u;
    }
    static const ::screenai::ChromeInfo& chrome_info(const UiElement* msg);
    static void set_has_chrome_info(HasBits* has_bits)
    {
        (*has_bits)[0] |= 4u;
    }
};

const ::screenai::BoundingBox& UiElement::_Internal::bounding_box(const UiElement* msg)
{
    return *msg->_impl_.bounding_box_;
}
const ::screenai::BoundingBoxPixels& UiElement::_Internal::bounding_box_pixels(const UiElement* msg)
{
    return *msg->_impl_.bounding_box_pixels_;
}
const ::screenai::ChromeInfo& UiElement::_Internal::chrome_info(const UiElement* msg)
{
    return *msg->_impl_.chrome_info_;
}
UiElement::UiElement(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.UiElement)
}
UiElement::UiElement(const UiElement& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UiElement* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {},
        decltype(_impl_.child_ids_) { from._impl_.child_ids_ }, /*decltype(_impl_._child_ids_cached_byte_size_)*/ { 0 },
        decltype(_impl_.attributes_) { from._impl_.attributes_ }, decltype(_impl_.bounding_box_) { nullptr }, decltype(_impl_.bounding_box_pixels_) { nullptr },
        decltype(_impl_.chrome_info_) { nullptr }, decltype(_impl_.type_) {}, decltype(_impl_.id_) {}, decltype(_impl_.parent_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_bounding_box()) {
        _this->_impl_.bounding_box_ = new ::screenai::BoundingBox(*from._impl_.bounding_box_);
    }
    if (from._internal_has_bounding_box_pixels()) {
        _this->_impl_.bounding_box_pixels_ = new ::screenai::BoundingBoxPixels(*from._impl_.bounding_box_pixels_);
    }
    if (from._internal_has_chrome_info()) {
        _this->_impl_.chrome_info_ = new ::screenai::ChromeInfo(*from._impl_.chrome_info_);
    }
    ::memcpy(&_impl_.type_, &from._impl_.type_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.parent_id_) - reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.parent_id_));
    // @@protoc_insertion_point(copy_constructor:screenai.UiElement)
}

inline void UiElement::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.child_ids_) { arena },
        /*decltype(_impl_._child_ids_cached_byte_size_)*/ { 0 }, decltype(_impl_.attributes_) { arena }, decltype(_impl_.bounding_box_) { nullptr },
        decltype(_impl_.bounding_box_pixels_) { nullptr }, decltype(_impl_.chrome_info_) { nullptr }, decltype(_impl_.type_) { 0 }, decltype(_impl_.id_) { -1 },
        decltype(_impl_.parent_id_) { -1 } };
}

UiElement::~UiElement()
{
    // @@protoc_insertion_point(destructor:screenai.UiElement)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UiElement::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.child_ids_.~RepeatedField();
    _impl_.attributes_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.bounding_box_;
    if (this != internal_default_instance())
        delete _impl_.bounding_box_pixels_;
    if (this != internal_default_instance())
        delete _impl_.chrome_info_;
}

void UiElement::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UiElement::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.UiElement)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.child_ids_.Clear();
    _impl_.attributes_.Clear();
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000007u) {
        if (cached_has_bits & 0x00000001u) {
            GOOGLE_DCHECK(_impl_.bounding_box_ != nullptr);
            _impl_.bounding_box_->Clear();
        }
        if (cached_has_bits & 0x00000002u) {
            GOOGLE_DCHECK(_impl_.bounding_box_pixels_ != nullptr);
            _impl_.bounding_box_pixels_->Clear();
        }
        if (cached_has_bits & 0x00000004u) {
            GOOGLE_DCHECK(_impl_.chrome_info_ != nullptr);
            _impl_.chrome_info_->Clear();
        }
    }
    if (cached_has_bits & 0x00000038u) {
        _impl_.type_ = 0;
        _impl_.id_ = -1;
        _impl_.parent_id_ = -1;
    }
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UiElement::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 id = 1 [default = -1];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_id(&has_bits);
                _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .screenai.UiElementType type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                if (PROTOBUF_PREDICT_TRUE(::screenai::UiElementType_IsValid(val))) {
                    _internal_set_type(static_cast<::screenai::UiElementType>(val));
                } else {
                    ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
                }
            } else
                goto handle_unusual;
            continue;
        // optional int32 parent_id = 3 [default = -1];
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _Internal::set_has_parent_id(&has_bits);
                _impl_.parent_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated int32 child_ids = 4 [packed = true];
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_child_ids(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 32) {
                _internal_add_child_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .screenai.BoundingBox bounding_box = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_bounding_box(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .screenai.UiElementAttribute attributes = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_attributes(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
            } else
                goto handle_unusual;
            continue;
        // optional .screenai.BoundingBoxPixels bounding_box_pixels = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_bounding_box_pixels(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // optional .screenai.ChromeInfo chrome_info = 9;
        case 9:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
                ptr = ctx->ParseMessage(_internal_mutable_chrome_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UiElement::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.UiElement)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 id = 1 [default = -1];
    if (cached_has_bits & 0x00000010u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
    }

    // optional .screenai.UiElementType type = 2;
    if (cached_has_bits & 0x00000008u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(2, this->_internal_type(), target);
    }

    // optional int32 parent_id = 3 [default = -1];
    if (cached_has_bits & 0x00000020u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_parent_id(), target);
    }

    // repeated int32 child_ids = 4 [packed = true];
    {
        int byte_size = _impl_._child_ids_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteInt32Packed(4, _internal_child_ids(), byte_size, target);
        }
    }

    // optional .screenai.BoundingBox bounding_box = 6;
    if (cached_has_bits & 0x00000001u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::bounding_box(this), _Internal::bounding_box(this).GetCachedSize(), target, stream);
    }

    // repeated .screenai.UiElementAttribute attributes = 7;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_attributes_size()); i < n; i++) {
        const auto& repfield = this->_internal_attributes(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
    }

    // optional .screenai.BoundingBoxPixels bounding_box_pixels = 8;
    if (cached_has_bits & 0x00000002u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::bounding_box_pixels(this), _Internal::bounding_box_pixels(this).GetCachedSize(), target, stream);
    }

    // optional .screenai.ChromeInfo chrome_info = 9;
    if (cached_has_bits & 0x00000004u) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            9, _Internal::chrome_info(this), _Internal::chrome_info(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.UiElement)
    return target;
}

size_t UiElement::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.UiElement)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 child_ids = 4 [packed = true];
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.child_ids_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._child_ids_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    // repeated .screenai.UiElementAttribute attributes = 7;
    total_size += 1UL * this->_internal_attributes_size();
    for (const auto& msg : this->_impl_.attributes_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        // optional .screenai.BoundingBox bounding_box = 6;
        if (cached_has_bits & 0x00000001u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.bounding_box_);
        }

        // optional .screenai.BoundingBoxPixels bounding_box_pixels = 8;
        if (cached_has_bits & 0x00000002u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.bounding_box_pixels_);
        }

        // optional .screenai.ChromeInfo chrome_info = 9;
        if (cached_has_bits & 0x00000004u) {
            total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.chrome_info_);
        }

        // optional .screenai.UiElementType type = 2;
        if (cached_has_bits & 0x00000008u) {
            total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
        }

        // optional int32 id = 1 [default = -1];
        if (cached_has_bits & 0x00000010u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
        }

        // optional int32 parent_id = 3 [default = -1];
        if (cached_has_bits & 0x00000020u) {
            total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_parent_id());
        }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UiElement::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UiElement*>(&from));
}

void UiElement::MergeFrom(const UiElement& from)
{
    UiElement* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.UiElement)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.child_ids_.MergeFrom(from._impl_.child_ids_);
    _this->_impl_.attributes_.MergeFrom(from._impl_.attributes_);
    cached_has_bits = from._impl_._has_bits_[0];
    if (cached_has_bits & 0x0000003fu) {
        if (cached_has_bits & 0x00000001u) {
            _this->_internal_mutable_bounding_box()->::screenai::BoundingBox::MergeFrom(from._internal_bounding_box());
        }
        if (cached_has_bits & 0x00000002u) {
            _this->_internal_mutable_bounding_box_pixels()->::screenai::BoundingBoxPixels::MergeFrom(from._internal_bounding_box_pixels());
        }
        if (cached_has_bits & 0x00000004u) {
            _this->_internal_mutable_chrome_info()->::screenai::ChromeInfo::MergeFrom(from._internal_chrome_info());
        }
        if (cached_has_bits & 0x00000008u) {
            _this->_impl_.type_ = from._impl_.type_;
        }
        if (cached_has_bits & 0x00000010u) {
            _this->_impl_.id_ = from._impl_.id_;
        }
        if (cached_has_bits & 0x00000020u) {
            _this->_impl_.parent_id_ = from._impl_.parent_id_;
        }
        _this->_impl_._has_bits_[0] |= cached_has_bits;
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UiElement::CopyFrom(const UiElement& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.UiElement)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UiElement::IsInitialized() const
{
    return true;
}

void UiElement::InternalSwap(UiElement* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    _impl_.child_ids_.InternalSwap(&other->_impl_.child_ids_);
    _impl_.attributes_.InternalSwap(&other->_impl_.attributes_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(UiElement, _impl_.type_) + sizeof(UiElement::_impl_.type_)
        - PROTOBUF_FIELD_OFFSET(UiElement, _impl_.bounding_box_)>(
        reinterpret_cast<char*>(&_impl_.bounding_box_), reinterpret_cast<char*>(&other->_impl_.bounding_box_));
    swap(_impl_.id_, other->_impl_.id_);
    swap(_impl_.parent_id_, other->_impl_.parent_id_);
}

std::string UiElement::GetTypeName() const
{
    return "screenai.UiElement";
}

// ===================================================================

class UiElementAttribute::_Internal {
public:
    using HasBits = decltype(std::declval<UiElementAttribute>()._impl_._has_bits_);
    static void set_has_name(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
    static const ::screenai::IntList& int_list_value(const UiElementAttribute* msg);
    static const ::screenai::StringList& string_list_value(const UiElementAttribute* msg);
    static const ::screenai::FloatList& float_list_value(const UiElementAttribute* msg);
};

const ::screenai::IntList& UiElementAttribute::_Internal::int_list_value(const UiElementAttribute* msg)
{
    return *msg->_impl_.value_.int_list_value_;
}
const ::screenai::StringList& UiElementAttribute::_Internal::string_list_value(const UiElementAttribute* msg)
{
    return *msg->_impl_.value_.string_list_value_;
}
const ::screenai::FloatList& UiElementAttribute::_Internal::float_list_value(const UiElementAttribute* msg)
{
    return *msg->_impl_.value_.float_list_value_;
}
void UiElementAttribute::set_allocated_int_list_value(::screenai::IntList* int_list_value)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_value();
    if (int_list_value) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(int_list_value);
        if (message_arena != submessage_arena) {
            int_list_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, int_list_value, submessage_arena);
        }
        set_has_int_list_value();
        _impl_.value_.int_list_value_ = int_list_value;
    }
    // @@protoc_insertion_point(field_set_allocated:screenai.UiElementAttribute.int_list_value)
}
void UiElementAttribute::set_allocated_string_list_value(::screenai::StringList* string_list_value)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_value();
    if (string_list_value) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(string_list_value);
        if (message_arena != submessage_arena) {
            string_list_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, string_list_value, submessage_arena);
        }
        set_has_string_list_value();
        _impl_.value_.string_list_value_ = string_list_value;
    }
    // @@protoc_insertion_point(field_set_allocated:screenai.UiElementAttribute.string_list_value)
}
void UiElementAttribute::set_allocated_float_list_value(::screenai::FloatList* float_list_value)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_value();
    if (float_list_value) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(float_list_value);
        if (message_arena != submessage_arena) {
            float_list_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, float_list_value, submessage_arena);
        }
        set_has_float_list_value();
        _impl_.value_.float_list_value_ = float_list_value;
    }
    // @@protoc_insertion_point(field_set_allocated:screenai.UiElementAttribute.float_list_value)
}
UiElementAttribute::UiElementAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.UiElementAttribute)
}
UiElementAttribute::UiElementAttribute(const UiElementAttribute& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    UiElementAttribute* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {},
        decltype(_impl_.value_) {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (from._internal_has_name()) {
        _this->_impl_.name_.Set(from._internal_name(), _this->GetArenaForAllocation());
    }
    clear_has_value();
    switch (from.value_case()) {
    case kBoolValue: {
        _this->_internal_set_bool_value(from._internal_bool_value());
        break;
    }
    case kIntValue: {
        _this->_internal_set_int_value(from._internal_int_value());
        break;
    }
    case kStringValue: {
        _this->_internal_set_string_value(from._internal_string_value());
        break;
    }
    case kFloatValue: {
        _this->_internal_set_float_value(from._internal_float_value());
        break;
    }
    case kIntListValue: {
        _this->_internal_mutable_int_list_value()->::screenai::IntList::MergeFrom(from._internal_int_list_value());
        break;
    }
    case kStringListValue: {
        _this->_internal_mutable_string_list_value()->::screenai::StringList::MergeFrom(from._internal_string_list_value());
        break;
    }
    case kFloatListValue: {
        _this->_internal_mutable_float_list_value()->::screenai::FloatList::MergeFrom(from._internal_float_list_value());
        break;
    }
    case VALUE_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:screenai.UiElementAttribute)
}

inline void UiElementAttribute::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.name_) {}, decltype(_impl_.value_) {},
        /*decltype(_impl_._oneof_case_)*/ {} };
    _impl_.name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clear_has_value();
}

UiElementAttribute::~UiElementAttribute()
{
    // @@protoc_insertion_point(destructor:screenai.UiElementAttribute)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void UiElementAttribute::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.name_.Destroy();
    if (has_value()) {
        clear_value();
    }
}

void UiElementAttribute::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void UiElementAttribute::clear_value()
{
    // @@protoc_insertion_point(one_of_clear_start:screenai.UiElementAttribute)
    switch (value_case()) {
    case kBoolValue: {
        // No need to clear
        break;
    }
    case kIntValue: {
        // No need to clear
        break;
    }
    case kStringValue: {
        _impl_.value_.string_value_.Destroy();
        break;
    }
    case kFloatValue: {
        // No need to clear
        break;
    }
    case kIntListValue: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.value_.int_list_value_;
        }
        break;
    }
    case kStringListValue: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.value_.string_list_value_;
        }
        break;
    }
    case kFloatListValue: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.value_.float_list_value_;
        }
        break;
    }
    case VALUE_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = VALUE_NOT_SET;
}

void UiElementAttribute::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.UiElementAttribute)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        _impl_.name_.ClearNonDefaultToEmpty();
    }
    clear_value();
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* UiElementAttribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional string name = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_name();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool bool_value = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _internal_set_bool_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int32 int_value = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                _internal_set_int_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string string_value = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                auto str = _internal_mutable_string_value();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // float float_value = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
                _internal_set_float_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                ptr += sizeof(float);
            } else
                goto handle_unusual;
            continue;
        // .screenai.IntList int_list_value = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_int_list_value(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .screenai.StringList string_list_value = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_string_list_value(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .screenai.FloatList float_list_value = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_float_list_value(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* UiElementAttribute::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.UiElementAttribute)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
        target = stream->WriteStringMaybeAliased(1, this->_internal_name(), target);
    }

    switch (value_case()) {
    case kBoolValue: {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_bool_value(), target);
        break;
    }
    case kIntValue: {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_int_value(), target);
        break;
    }
    case kStringValue: {
        target = stream->WriteStringMaybeAliased(4, this->_internal_string_value(), target);
        break;
    }
    case kFloatValue: {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_float_value(), target);
        break;
    }
    case kIntListValue: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::int_list_value(this), _Internal::int_list_value(this).GetCachedSize(), target, stream);
        break;
    }
    case kStringListValue: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::string_list_value(this), _Internal::string_list_value(this).GetCachedSize(), target, stream);
        break;
    }
    case kFloatListValue: {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::float_list_value(this), _Internal::float_list_value(this).GetCachedSize(), target, stream);
        break;
    }
    default:;
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.UiElementAttribute)
    return target;
}

size_t UiElementAttribute::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.UiElementAttribute)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional string name = 1;
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_name());
    }

    switch (value_case()) {
    // bool bool_value = 2;
    case kBoolValue: {
        total_size += 1 + 1;
        break;
    }
    // int32 int_value = 3;
    case kIntValue: {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_int_value());
        break;
    }
    // string string_value = 4;
    case kStringValue: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_string_value());
        break;
    }
    // float float_value = 5;
    case kFloatValue: {
        total_size += 1 + 4;
        break;
    }
    // .screenai.IntList int_list_value = 6;
    case kIntListValue: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.value_.int_list_value_);
        break;
    }
    // .screenai.StringList string_list_value = 7;
    case kStringListValue: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.value_.string_list_value_);
        break;
    }
    // .screenai.FloatList float_list_value = 8;
    case kFloatListValue: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.value_.float_list_value_);
        break;
    }
    case VALUE_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void UiElementAttribute::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const UiElementAttribute*>(&from));
}

void UiElementAttribute::MergeFrom(const UiElementAttribute& from)
{
    UiElementAttribute* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.UiElementAttribute)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_name()) {
        _this->_internal_set_name(from._internal_name());
    }
    switch (from.value_case()) {
    case kBoolValue: {
        _this->_internal_set_bool_value(from._internal_bool_value());
        break;
    }
    case kIntValue: {
        _this->_internal_set_int_value(from._internal_int_value());
        break;
    }
    case kStringValue: {
        _this->_internal_set_string_value(from._internal_string_value());
        break;
    }
    case kFloatValue: {
        _this->_internal_set_float_value(from._internal_float_value());
        break;
    }
    case kIntListValue: {
        _this->_internal_mutable_int_list_value()->::screenai::IntList::MergeFrom(from._internal_int_list_value());
        break;
    }
    case kStringListValue: {
        _this->_internal_mutable_string_list_value()->::screenai::StringList::MergeFrom(from._internal_string_list_value());
        break;
    }
    case kFloatListValue: {
        _this->_internal_mutable_float_list_value()->::screenai::FloatList::MergeFrom(from._internal_float_list_value());
        break;
    }
    case VALUE_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void UiElementAttribute::CopyFrom(const UiElementAttribute& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.UiElementAttribute)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool UiElementAttribute::IsInitialized() const
{
    return true;
}

void UiElementAttribute::InternalSwap(UiElementAttribute* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.name_, lhs_arena, &other->_impl_.name_, rhs_arena);
    swap(_impl_.value_, other->_impl_.value_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string UiElementAttribute::GetTypeName() const
{
    return "screenai.UiElementAttribute";
}

// ===================================================================

class IntList::_Internal {
public:
};

IntList::IntList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.IntList)
}
IntList::IntList(const IntList& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    IntList* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.value_) { from._impl_.value_ }, /*decltype(_impl_._value_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:screenai.IntList)
}

inline void IntList::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.value_) { arena }, /*decltype(_impl_._value_cached_byte_size_)*/ { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

IntList::~IntList()
{
    // @@protoc_insertion_point(destructor:screenai.IntList)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void IntList::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.~RepeatedField();
}

void IntList::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void IntList::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.IntList)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.value_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* IntList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated int32 value = 1 [packed = true];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_value(), ptr, ctx);
                CHK_(ptr);
            } else if (static_cast<uint8_t>(tag) == 8) {
                _internal_add_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* IntList::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.IntList)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated int32 value = 1 [packed = true];
    {
        int byte_size = _impl_._value_cached_byte_size_.load(std::memory_order_relaxed);
        if (byte_size > 0) {
            target = stream->WriteInt32Packed(1, _internal_value(), byte_size, target);
        }
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.IntList)
    return target;
}

size_t IntList::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.IntList)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated int32 value = 1 [packed = true];
    {
        size_t data_size = ::_pbi::WireFormatLite::Int32Size(this->_impl_.value_);
        if (data_size > 0) {
            total_size += 1 + ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
        }
        int cached_size = ::_pbi::ToCachedSize(data_size);
        _impl_._value_cached_byte_size_.store(cached_size, std::memory_order_relaxed);
        total_size += data_size;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void IntList::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const IntList*>(&from));
}

void IntList::MergeFrom(const IntList& from)
{
    IntList* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.IntList)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.value_.MergeFrom(from._impl_.value_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void IntList::CopyFrom(const IntList& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.IntList)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool IntList::IsInitialized() const
{
    return true;
}

void IntList::InternalSwap(IntList* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.value_.InternalSwap(&other->_impl_.value_);
}

std::string IntList::GetTypeName() const
{
    return "screenai.IntList";
}

// ===================================================================

class StringList::_Internal {
public:
};

StringList::StringList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.StringList)
}
StringList::StringList(const StringList& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    StringList* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.value_) { from._impl_.value_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:screenai.StringList)
}

inline void StringList::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.value_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

StringList::~StringList()
{
    // @@protoc_insertion_point(destructor:screenai.StringList)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void StringList::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.~RepeatedPtrField();
}

void StringList::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void StringList::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.StringList)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.value_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* StringList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string value = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_value();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* StringList::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.StringList)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string value = 1;
    for (int i = 0, n = this->_internal_value_size(); i < n; i++) {
        const auto& s = this->_internal_value(i);
        target = stream->WriteString(1, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.StringList)
    return target;
}

size_t StringList::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.StringList)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string value = 1;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.value_.size());
    for (int i = 0, n = _impl_.value_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.value_.Get(i));
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void StringList::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const StringList*>(&from));
}

void StringList::MergeFrom(const StringList& from)
{
    StringList* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.StringList)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.value_.MergeFrom(from._impl_.value_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StringList::CopyFrom(const StringList& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.StringList)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool StringList::IsInitialized() const
{
    return true;
}

void StringList::InternalSwap(StringList* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.value_.InternalSwap(&other->_impl_.value_);
}

std::string StringList::GetTypeName() const
{
    return "screenai.StringList";
}

// ===================================================================

class FloatList::_Internal {
public:
};

FloatList::FloatList(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.FloatList)
}
FloatList::FloatList(const FloatList& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    FloatList* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.value_) { from._impl_.value_ }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    // @@protoc_insertion_point(copy_constructor:screenai.FloatList)
}

inline void FloatList::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.value_) { arena }, /*decltype(_impl_._cached_size_)*/ {} };
}

FloatList::~FloatList()
{
    // @@protoc_insertion_point(destructor:screenai.FloatList)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void FloatList::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.value_.~RepeatedField();
}

void FloatList::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void FloatList::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.FloatList)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.value_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* FloatList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated float value = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    _internal_add_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
                    ptr += sizeof(float);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
            } else if (static_cast<uint8_t>(tag) == 10) {
                ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_value(), ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* FloatList::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.FloatList)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated float value = 1;
    for (int i = 0, n = this->_internal_value_size(); i < n; i++) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_value(i), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.FloatList)
    return target;
}

size_t FloatList::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.FloatList)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated float value = 1;
    {
        unsigned int count = static_cast<unsigned int>(this->_internal_value_size());
        size_t data_size = 4UL * count;
        total_size += 1 * ::_pbi::FromIntSize(this->_internal_value_size());
        total_size += data_size;
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void FloatList::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const FloatList*>(&from));
}

void FloatList::MergeFrom(const FloatList& from)
{
    FloatList* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.FloatList)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.value_.MergeFrom(from._impl_.value_);
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FloatList::CopyFrom(const FloatList& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.FloatList)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool FloatList::IsInitialized() const
{
    return true;
}

void FloatList::InternalSwap(FloatList* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.value_.InternalSwap(&other->_impl_.value_);
}

std::string FloatList::GetTypeName() const
{
    return "screenai.FloatList";
}

// ===================================================================

class ChromeInfo::_Internal {
public:
    using HasBits = decltype(std::declval<ChromeInfo>()._impl_._has_bits_);
    static void set_has_dom_node_id(HasBits* has_bits)
    {
        (*has_bits)[0] |= 1u;
    }
};

ChromeInfo::ChromeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:screenai.ChromeInfo)
}
ChromeInfo::ChromeInfo(const ChromeInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    ChromeInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) { from._impl_._has_bits_ }, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.dom_node_id_) {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _this->_impl_.dom_node_id_ = from._impl_.dom_node_id_;
    // @@protoc_insertion_point(copy_constructor:screenai.ChromeInfo)
}

inline void ChromeInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_._has_bits_) {}, /*decltype(_impl_._cached_size_)*/ {}, decltype(_impl_.dom_node_id_) { -1 } };
}

ChromeInfo::~ChromeInfo()
{
    // @@protoc_insertion_point(destructor:screenai.ChromeInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void ChromeInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChromeInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void ChromeInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:screenai.ChromeInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.dom_node_id_ = -1;
    _impl_._has_bits_.Clear();
    _internal_metadata_.Clear<std::string>();
}

const char* ChromeInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    _Internal::HasBits has_bits {};
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // optional int32 dom_node_id = 1 [default = -1];
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _Internal::set_has_dom_node_id(&has_bits);
                _impl_.dom_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    _impl_._has_bits_.Or(has_bits);
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* ChromeInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:screenai.ChromeInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    cached_has_bits = _impl_._has_bits_[0];
    // optional int32 dom_node_id = 1 [default = -1];
    if (cached_has_bits & 0x00000001u) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dom_node_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:screenai.ChromeInfo)
    return target;
}

size_t ChromeInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:screenai.ChromeInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // optional int32 dom_node_id = 1 [default = -1];
    cached_has_bits = _impl_._has_bits_[0];
    if (cached_has_bits & 0x00000001u) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dom_node_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ChromeInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const ChromeInfo*>(&from));
}

void ChromeInfo::MergeFrom(const ChromeInfo& from)
{
    ChromeInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:screenai.ChromeInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_dom_node_id()) {
        _this->_internal_set_dom_node_id(from._internal_dom_node_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeInfo::CopyFrom(const ChromeInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:screenai.ChromeInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool ChromeInfo::IsInitialized() const
{
    return true;
}

void ChromeInfo::InternalSwap(ChromeInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
    swap(_impl_.dom_node_id_, other->_impl_.dom_node_id_);
}

std::string ChromeInfo::GetTypeName() const
{
    return "screenai.ChromeInfo";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace screenai
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::screenai::BoundingBox* Arena::CreateMaybeMessage<::screenai::BoundingBox>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::BoundingBox>(arena);
}
template <> PROTOBUF_NOINLINE ::screenai::BoundingBoxPixels* Arena::CreateMaybeMessage<::screenai::BoundingBoxPixels>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::BoundingBoxPixels>(arena);
}
template <> PROTOBUF_NOINLINE ::screenai::ViewHierarchy* Arena::CreateMaybeMessage<::screenai::ViewHierarchy>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::ViewHierarchy>(arena);
}
template <> PROTOBUF_NOINLINE ::screenai::UiElement* Arena::CreateMaybeMessage<::screenai::UiElement>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::UiElement>(arena);
}
template <> PROTOBUF_NOINLINE ::screenai::UiElementAttribute* Arena::CreateMaybeMessage<::screenai::UiElementAttribute>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::UiElementAttribute>(arena);
}
template <> PROTOBUF_NOINLINE ::screenai::IntList* Arena::CreateMaybeMessage<::screenai::IntList>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::IntList>(arena);
}
template <> PROTOBUF_NOINLINE ::screenai::StringList* Arena::CreateMaybeMessage<::screenai::StringList>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::StringList>(arena);
}
template <> PROTOBUF_NOINLINE ::screenai::FloatList* Arena::CreateMaybeMessage<::screenai::FloatList>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::FloatList>(arena);
}
template <> PROTOBUF_NOINLINE ::screenai::ChromeInfo* Arena::CreateMaybeMessage<::screenai::ChromeInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::screenai::ChromeInfo>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
