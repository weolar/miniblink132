// services/screen_ai/public/mojom/screen_ai_service.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_SCREEN_AI_PUBLIC_MOJOM_SCREEN_AI_SERVICE_MOJOM_SHARED_H_
#define SERVICES_SCREEN_AI_PUBLIC_MOJOM_SCREEN_AI_SERVICE_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/screen_ai/public/mojom/screen_ai_service.mojom-shared-internal.h"
#include "skia/public/mojom/bitmap.mojom-shared.h"
#include "ui/accessibility/ax_features.mojom-shared.h"
#include "ui/accessibility/mojom/ax_tree_id.mojom-shared.h"
#include "ui/accessibility/mojom/ax_tree_update.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

namespace screen_ai::mojom {
class VisualAnnotationDataView;

class LineBoxDataView;

class WordBoxDataView;

} // screen_ai::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::screen_ai::mojom::VisualAnnotationDataView> {
    using Data = ::screen_ai::mojom::internal::VisualAnnotation_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::screen_ai::mojom::LineBoxDataView> {
    using Data = ::screen_ai::mojom::internal::LineBox_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::screen_ai::mojom::WordBoxDataView> {
    using Data = ::screen_ai::mojom::internal::WordBox_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace screen_ai::mojom {

enum class Direction : int32_t {

    DIRECTION_UNSPECIFIED = 0,

    DIRECTION_LEFT_TO_RIGHT = 1,

    DIRECTION_RIGHT_TO_LEFT = 2,

    DIRECTION_TOP_TO_BOTTOM = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, Direction value);
inline bool IsKnownEnumValue(Direction value)
{
    return internal::Direction_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class OcrClientType : int32_t {

    kTest = 0,

    kPdfViewer = 1,

    kLocalSearch = 2,

    kCameraApp = 3,

    kMediaApp = 4,

    kScreenshotTextDetection = 5,
    kMinValue = 0,
    kMaxValue = 5,
};

std::ostream& operator<<(std::ostream& os, OcrClientType value);
inline bool IsKnownEnumValue(OcrClientType value)
{
    return internal::OcrClientType_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class ScreenAIAnnotatorInterfaceBase { };

using ScreenAIAnnotatorPtrDataView = mojo::InterfacePtrDataView<ScreenAIAnnotatorInterfaceBase>;
using ScreenAIAnnotatorRequestDataView = mojo::InterfaceRequestDataView<ScreenAIAnnotatorInterfaceBase>;
using ScreenAIAnnotatorAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<ScreenAIAnnotatorInterfaceBase>;
using ScreenAIAnnotatorAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<ScreenAIAnnotatorInterfaceBase>;
class Screen2xMainContentExtractorInterfaceBase { };

using Screen2xMainContentExtractorPtrDataView = mojo::InterfacePtrDataView<Screen2xMainContentExtractorInterfaceBase>;
using Screen2xMainContentExtractorRequestDataView = mojo::InterfaceRequestDataView<Screen2xMainContentExtractorInterfaceBase>;
using Screen2xMainContentExtractorAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<Screen2xMainContentExtractorInterfaceBase>;
using Screen2xMainContentExtractorAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<Screen2xMainContentExtractorInterfaceBase>;
class OCRServiceInterfaceBase { };

using OCRServicePtrDataView = mojo::InterfacePtrDataView<OCRServiceInterfaceBase>;
using OCRServiceRequestDataView = mojo::InterfaceRequestDataView<OCRServiceInterfaceBase>;
using OCRServiceAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<OCRServiceInterfaceBase>;
using OCRServiceAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<OCRServiceInterfaceBase>;
class MainContentExtractionServiceInterfaceBase { };

using MainContentExtractionServicePtrDataView = mojo::InterfacePtrDataView<MainContentExtractionServiceInterfaceBase>;
using MainContentExtractionServiceRequestDataView = mojo::InterfaceRequestDataView<MainContentExtractionServiceInterfaceBase>;
using MainContentExtractionServiceAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<MainContentExtractionServiceInterfaceBase>;
using MainContentExtractionServiceAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<MainContentExtractionServiceInterfaceBase>;

class VisualAnnotationDataView {
public:
    VisualAnnotationDataView() = default;

    VisualAnnotationDataView(internal::VisualAnnotation_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetLinesDataView(mojo::ArrayDataView<LineBoxDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadLines(UserType* output)
    {

        auto* pointer = data_->lines.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::screen_ai::mojom::LineBoxDataView>>(pointer, output, message_);
    }

private:
    internal::VisualAnnotation_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LineBoxDataView {
public:
    LineBoxDataView() = default;

    LineBoxDataView(internal::LineBox_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetWordsDataView(mojo::ArrayDataView<WordBoxDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadWords(UserType* output)
    {

        auto* pointer = data_->words.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::screen_ai::mojom::WordBoxDataView>>(pointer, output, message_);
    }
    inline void GetTextLineDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTextLine(UserType* output)
    {

        auto* pointer = data_->text_line.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetLanguageDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLanguage(UserType* output)
    {

        auto* pointer = data_->language.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    int32_t block_id() const
    {
        return data_->block_id;
    }
    int32_t order_within_block() const
    {
        return data_->order_within_block;
    }
    inline void GetBoundingBoxDataView(::gfx::mojom::RectDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadBoundingBox(UserType* output)
    {

        auto* pointer = data_->bounding_box.Get();
        return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(pointer, output, message_);
    }
    float bounding_box_angle() const
    {
        return data_->bounding_box_angle;
    }
    inline void GetBaselineBoxDataView(::gfx::mojom::RectDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadBaselineBox(UserType* output)
    {

        auto* pointer = data_->baseline_box.Get();
        return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(pointer, output, message_);
    }
    float baseline_box_angle() const
    {
        return data_->baseline_box_angle;
    }
    float confidence() const
    {
        return data_->confidence;
    }

private:
    internal::LineBox_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class WordBoxDataView {
public:
    WordBoxDataView() = default;

    WordBoxDataView(internal::WordBox_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetWordDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadWord(UserType* output)
    {

        auto* pointer = data_->word.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    bool dictionary_word() const
    {
        return data_->dictionary_word;
    }
    inline void GetLanguageDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLanguage(UserType* output)
    {

        auto* pointer = data_->language.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    bool has_space_after() const
    {
        return data_->has_space_after;
    }
    inline void GetBoundingBoxDataView(::gfx::mojom::RectDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadBoundingBox(UserType* output)
    {

        auto* pointer = data_->bounding_box.Get();
        return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(pointer, output, message_);
    }
    float bounding_box_angle() const
    {
        return data_->bounding_box_angle;
    }
    template <typename UserType> [[nodiscard]] bool ReadDirection(UserType* output) const
    {
        auto data_value = data_->direction;
        return mojo::internal::Deserialize<::screen_ai::mojom::Direction>(data_value, output);
    }
    Direction direction() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::screen_ai::mojom::Direction>(data_->direction));
    }
    float confidence() const
    {
        return data_->confidence;
    }

private:
    internal::WordBox_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // screen_ai::mojom

namespace std {

template <> struct hash<::screen_ai::mojom::Direction> : public mojo::internal::EnumHashImpl<::screen_ai::mojom::Direction> { };

template <> struct hash<::screen_ai::mojom::OcrClientType> : public mojo::internal::EnumHashImpl<::screen_ai::mojom::OcrClientType> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::screen_ai::mojom::Direction, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::screen_ai::mojom::Direction, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::screen_ai::mojom::Direction>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::screen_ai::mojom::OcrClientType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::screen_ai::mojom::OcrClientType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::screen_ai::mojom::OcrClientType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::screen_ai::mojom::VisualAnnotationDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::screen_ai::mojom::VisualAnnotationDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::screen_ai::mojom::internal::VisualAnnotation_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::lines(input)) in_lines = Traits::lines(input);
        mojo::internal::MessageFragment<typename decltype(fragment->lines)::BaseType> lines_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& lines_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::screen_ai::mojom::LineBoxDataView>>(in_lines, lines_fragment, &lines_validate_params);
        fragment->lines.Set(lines_fragment.is_null() ? nullptr : lines_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->lines.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null lines in VisualAnnotation struct");
    }

    static bool Deserialize(::screen_ai::mojom::internal::VisualAnnotation_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::screen_ai::mojom::VisualAnnotationDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::screen_ai::mojom::LineBoxDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::screen_ai::mojom::LineBoxDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::screen_ai::mojom::internal::LineBox_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::words(input)) in_words = Traits::words(input);
        mojo::internal::MessageFragment<typename decltype(fragment->words)::BaseType> words_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& words_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::screen_ai::mojom::WordBoxDataView>>(in_words, words_fragment, &words_validate_params);
        fragment->words.Set(words_fragment.is_null() ? nullptr : words_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->words.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null words in LineBox struct");
        decltype(Traits::text_line(input)) in_text_line = Traits::text_line(input);
        mojo::internal::MessageFragment<typename decltype(fragment->text_line)::BaseType> text_line_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_text_line, text_line_fragment);
        fragment->text_line.Set(text_line_fragment.is_null() ? nullptr : text_line_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->text_line.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null text_line in LineBox struct");
        decltype(Traits::language(input)) in_language = Traits::language(input);
        mojo::internal::MessageFragment<typename decltype(fragment->language)::BaseType> language_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_language, language_fragment);
        fragment->language.Set(language_fragment.is_null() ? nullptr : language_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->language.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null language in LineBox struct");
        fragment->block_id = Traits::block_id(input);
        fragment->order_within_block = Traits::order_within_block(input);
        decltype(Traits::bounding_box(input)) in_bounding_box = Traits::bounding_box(input);
        mojo::internal::MessageFragment<typename decltype(fragment->bounding_box)::BaseType> bounding_box_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_bounding_box, bounding_box_fragment);
        fragment->bounding_box.Set(bounding_box_fragment.is_null() ? nullptr : bounding_box_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->bounding_box.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null bounding_box in LineBox struct");
        fragment->bounding_box_angle = Traits::bounding_box_angle(input);
        decltype(Traits::baseline_box(input)) in_baseline_box = Traits::baseline_box(input);
        mojo::internal::MessageFragment<typename decltype(fragment->baseline_box)::BaseType> baseline_box_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_baseline_box, baseline_box_fragment);
        fragment->baseline_box.Set(baseline_box_fragment.is_null() ? nullptr : baseline_box_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->baseline_box.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null baseline_box in LineBox struct");
        fragment->baseline_box_angle = Traits::baseline_box_angle(input);
        fragment->confidence = Traits::confidence(input);
    }

    static bool Deserialize(::screen_ai::mojom::internal::LineBox_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::screen_ai::mojom::LineBoxDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::screen_ai::mojom::WordBoxDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::screen_ai::mojom::WordBoxDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::screen_ai::mojom::internal::WordBox_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::word(input)) in_word = Traits::word(input);
        mojo::internal::MessageFragment<typename decltype(fragment->word)::BaseType> word_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_word, word_fragment);
        fragment->word.Set(word_fragment.is_null() ? nullptr : word_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->word.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null word in WordBox struct");
        fragment->dictionary_word = Traits::dictionary_word(input);
        decltype(Traits::language(input)) in_language = Traits::language(input);
        mojo::internal::MessageFragment<typename decltype(fragment->language)::BaseType> language_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_language, language_fragment);
        fragment->language.Set(language_fragment.is_null() ? nullptr : language_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->language.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null language in WordBox struct");
        fragment->has_space_after = Traits::has_space_after(input);
        decltype(Traits::bounding_box(input)) in_bounding_box = Traits::bounding_box(input);
        mojo::internal::MessageFragment<typename decltype(fragment->bounding_box)::BaseType> bounding_box_fragment(fragment.message());
        mojo::internal::Serialize<::gfx::mojom::RectDataView>(in_bounding_box, bounding_box_fragment);
        fragment->bounding_box.Set(bounding_box_fragment.is_null() ? nullptr : bounding_box_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->bounding_box.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null bounding_box in WordBox struct");
        fragment->bounding_box_angle = Traits::bounding_box_angle(input);
        mojo::internal::Serialize<::screen_ai::mojom::Direction>(Traits::direction(input), &fragment->direction);
        fragment->confidence = Traits::confidence(input);
    }

    static bool Deserialize(::screen_ai::mojom::internal::WordBox_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::screen_ai::mojom::WordBoxDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace screen_ai::mojom {

inline void VisualAnnotationDataView::GetLinesDataView(mojo::ArrayDataView<LineBoxDataView>* output)
{
    auto pointer = data_->lines.Get();
    *output = mojo::ArrayDataView<LineBoxDataView>(pointer, message_);
}

inline void LineBoxDataView::GetWordsDataView(mojo::ArrayDataView<WordBoxDataView>* output)
{
    auto pointer = data_->words.Get();
    *output = mojo::ArrayDataView<WordBoxDataView>(pointer, message_);
}
inline void LineBoxDataView::GetTextLineDataView(mojo::StringDataView* output)
{
    auto pointer = data_->text_line.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void LineBoxDataView::GetLanguageDataView(mojo::StringDataView* output)
{
    auto pointer = data_->language.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void LineBoxDataView::GetBoundingBoxDataView(::gfx::mojom::RectDataView* output)
{
    auto pointer = data_->bounding_box.Get();
    *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void LineBoxDataView::GetBaselineBoxDataView(::gfx::mojom::RectDataView* output)
{
    auto pointer = data_->baseline_box.Get();
    *output = ::gfx::mojom::RectDataView(pointer, message_);
}

inline void WordBoxDataView::GetWordDataView(mojo::StringDataView* output)
{
    auto pointer = data_->word.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void WordBoxDataView::GetLanguageDataView(mojo::StringDataView* output)
{
    auto pointer = data_->language.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void WordBoxDataView::GetBoundingBoxDataView(::gfx::mojom::RectDataView* output)
{
    auto pointer = data_->bounding_box.Get();
    *output = ::gfx::mojom::RectDataView(pointer, message_);
}

} // screen_ai::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct TraceFormatTraits<::screen_ai::mojom::Direction> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::screen_ai::mojom::Direction value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::screen_ai::mojom::OcrClientType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::screen_ai::mojom::OcrClientType value);
};

} // namespace perfetto

#endif // SERVICES_SCREEN_AI_PUBLIC_MOJOM_SCREEN_AI_SERVICE_MOJOM_SHARED_H_
