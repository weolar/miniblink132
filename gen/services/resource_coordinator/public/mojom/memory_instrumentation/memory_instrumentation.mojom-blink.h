// services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_RESOURCE_COORDINATOR_PUBLIC_MOJOM_MEMORY_INSTRUMENTATION_MEMORY_INSTRUMENTATION_MOJOM_BLINK_H_
#define SERVICES_RESOURCE_COORDINATOR_PUBLIC_MOJOM_MEMORY_INSTRUMENTATION_MEMORY_INSTRUMENTATION_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom-features.h" // IWYU pragma: export
#include "services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom-shared.h" // IWYU pragma: export
#include "services/resource_coordinator/public/mojom/memory_instrumentation/memory_instrumentation.mojom-blink-forward.h" // IWYU pragma: export
#include "mojo/public/mojom/base/big_string.mojom-blink.h"
#include "mojo/public/mojom/base/process_id.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "base/component_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace memory_instrumentation::mojom::blink {

class ClientProcessProxy;

template <typename ImplRefTraits> class ClientProcessStub;

class ClientProcessRequestValidator;
class ClientProcessResponseValidator;

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) ClientProcess : public ClientProcessInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = ClientProcessInterfaceBase;
    using Proxy_ = ClientProcessProxy;

    template <typename ImplRefTraits> using Stub_ = ClientProcessStub<ImplRefTraits>;

    using RequestValidator_ = ClientProcessRequestValidator;
    using ResponseValidator_ = ClientProcessResponseValidator;
    enum MethodMinVersions : uint32_t {
        kRequestChromeMemoryDumpMinVersion = 0,
        kRequestOSMemoryDumpMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct RequestChromeMemoryDump_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RequestOSMemoryDump_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~ClientProcess() = default;

    using RequestChromeMemoryDumpCallback = base::OnceCallback<void(bool, uint64_t, RawProcessMemoryDumpPtr)>;

    virtual void RequestChromeMemoryDump(RequestArgsPtr args, RequestChromeMemoryDumpCallback callback) = 0;

    using RequestOSMemoryDumpCallback = base::OnceCallback<void(bool, WTF::HashMap<::mojo_base::mojom::blink::ProcessIdPtr, RawOSMemDumpPtr>)>;

    virtual void RequestOSMemoryDump(MemoryMapOption option, WTF::Vector<::mojo_base::mojom::blink::ProcessIdPtr> pids, RequestOSMemoryDumpCallback callback)
        = 0;
};

class HeapProfilerProxy;

template <typename ImplRefTraits> class HeapProfilerStub;

class HeapProfilerRequestValidator;
class HeapProfilerResponseValidator;

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfiler : public HeapProfilerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = HeapProfilerInterfaceBase;
    using Proxy_ = HeapProfilerProxy;

    template <typename ImplRefTraits> using Stub_ = HeapProfilerStub<ImplRefTraits>;

    using RequestValidator_ = HeapProfilerRequestValidator;
    using ResponseValidator_ = HeapProfilerResponseValidator;
    enum MethodMinVersions : uint32_t {
        kDumpProcessesForTracingMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct DumpProcessesForTracing_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~HeapProfiler() = default;

    using DumpProcessesForTracingCallback = base::OnceCallback<void(WTF::Vector<HeapProfileResultPtr>)>;

    virtual void DumpProcessesForTracing(bool strip_path_from_mapped_files, bool write_proto, DumpProcessesForTracingCallback callback) = 0;
};

class HeapProfilerHelperProxy;

template <typename ImplRefTraits> class HeapProfilerHelperStub;

class HeapProfilerHelperRequestValidator;
class HeapProfilerHelperResponseValidator;

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerHelper : public HeapProfilerHelperInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = HeapProfilerHelperInterfaceBase;
    using Proxy_ = HeapProfilerHelperProxy;

    template <typename ImplRefTraits> using Stub_ = HeapProfilerHelperStub<ImplRefTraits>;

    using RequestValidator_ = HeapProfilerHelperRequestValidator;
    using ResponseValidator_ = HeapProfilerHelperResponseValidator;
    enum MethodMinVersions : uint32_t {
        kGetVmRegionsForHeapProfilerMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct GetVmRegionsForHeapProfiler_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~HeapProfilerHelper() = default;

    using GetVmRegionsForHeapProfilerCallback = base::OnceCallback<void(WTF::HashMap<::mojo_base::mojom::blink::ProcessIdPtr, WTF::Vector<VmRegionPtr>>)>;

    virtual void GetVmRegionsForHeapProfiler(WTF::Vector<::mojo_base::mojom::blink::ProcessIdPtr> pids, GetVmRegionsForHeapProfilerCallback callback) = 0;
};

class CoordinatorProxy;

template <typename ImplRefTraits> class CoordinatorStub;

class CoordinatorRequestValidator;
class CoordinatorResponseValidator;

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) Coordinator : public CoordinatorInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = CoordinatorInterfaceBase;
    using Proxy_ = CoordinatorProxy;

    template <typename ImplRefTraits> using Stub_ = CoordinatorStub<ImplRefTraits>;

    using RequestValidator_ = CoordinatorRequestValidator;
    using ResponseValidator_ = CoordinatorResponseValidator;
    enum MethodMinVersions : uint32_t {
        kRequestGlobalMemoryDumpMinVersion = 0,
        kRequestGlobalMemoryDumpForPidMinVersion = 0,
        kRequestPrivateMemoryFootprintMinVersion = 0,
        kRequestGlobalMemoryDumpAndAppendToTraceMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct RequestGlobalMemoryDump_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RequestGlobalMemoryDumpForPid_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RequestPrivateMemoryFootprint_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct RequestGlobalMemoryDumpAndAppendToTrace_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~Coordinator() = default;

    using RequestGlobalMemoryDumpCallback = base::OnceCallback<void(bool, GlobalMemoryDumpPtr)>;

    virtual void RequestGlobalMemoryDump(DumpType dump_type, LevelOfDetail level_of_detail, Determinism determinism,
        const WTF::Vector<WTF::String>& allocator_dump_names, RequestGlobalMemoryDumpCallback callback)
        = 0;

    using RequestGlobalMemoryDumpForPidCallback = base::OnceCallback<void(bool, GlobalMemoryDumpPtr)>;

    virtual void RequestGlobalMemoryDumpForPid(
        ::mojo_base::mojom::blink::ProcessIdPtr pid, const WTF::Vector<WTF::String>& allocator_dump_names, RequestGlobalMemoryDumpForPidCallback callback)
        = 0;

    using RequestPrivateMemoryFootprintCallback = base::OnceCallback<void(bool, GlobalMemoryDumpPtr)>;

    virtual void RequestPrivateMemoryFootprint(::mojo_base::mojom::blink::ProcessIdPtr pid, RequestPrivateMemoryFootprintCallback callback) = 0;

    using RequestGlobalMemoryDumpAndAppendToTraceCallback = base::OnceCallback<void(bool, uint64_t)>;

    virtual void RequestGlobalMemoryDumpAndAppendToTrace(
        DumpType dump_type, LevelOfDetail level_of_detail, Determinism determinism, RequestGlobalMemoryDumpAndAppendToTraceCallback callback)
        = 0;
};

class CoordinatorConnectorProxy;

template <typename ImplRefTraits> class CoordinatorConnectorStub;

class CoordinatorConnectorRequestValidator;

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) CoordinatorConnector : public CoordinatorConnectorInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = CoordinatorConnectorInterfaceBase;
    using Proxy_ = CoordinatorConnectorProxy;

    template <typename ImplRefTraits> using Stub_ = CoordinatorConnectorStub<ImplRefTraits>;

    using RequestValidator_ = CoordinatorConnectorRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kRegisterCoordinatorClientMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct RegisterCoordinatorClient_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~CoordinatorConnector() = default;

    virtual void RegisterCoordinatorClient(::mojo::PendingReceiver<Coordinator> receiver, ::mojo::PendingRemote<ClientProcess> client_process) = 0;
};

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) ClientProcessProxy : public ClientProcess {
public:
    using InterfaceType = ClientProcess;

    explicit ClientProcessProxy(mojo::MessageReceiverWithResponder* receiver);

    void RequestChromeMemoryDump(RequestArgsPtr args, RequestChromeMemoryDumpCallback callback) final;

    void RequestOSMemoryDump(MemoryMapOption option, WTF::Vector<::mojo_base::mojom::blink::ProcessIdPtr> pids, RequestOSMemoryDumpCallback callback) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerProxy : public HeapProfiler {
public:
    using InterfaceType = HeapProfiler;

    explicit HeapProfilerProxy(mojo::MessageReceiverWithResponder* receiver);

    void DumpProcessesForTracing(bool strip_path_from_mapped_files, bool write_proto, DumpProcessesForTracingCallback callback) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerHelperProxy : public HeapProfilerHelper {
public:
    using InterfaceType = HeapProfilerHelper;

    explicit HeapProfilerHelperProxy(mojo::MessageReceiverWithResponder* receiver);

    void GetVmRegionsForHeapProfiler(WTF::Vector<::mojo_base::mojom::blink::ProcessIdPtr> pids, GetVmRegionsForHeapProfilerCallback callback) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) CoordinatorProxy : public Coordinator {
public:
    using InterfaceType = Coordinator;

    explicit CoordinatorProxy(mojo::MessageReceiverWithResponder* receiver);

    void RequestGlobalMemoryDump(DumpType dump_type, LevelOfDetail level_of_detail, Determinism determinism,
        const WTF::Vector<WTF::String>& allocator_dump_names, RequestGlobalMemoryDumpCallback callback) final;

    void RequestGlobalMemoryDumpForPid(::mojo_base::mojom::blink::ProcessIdPtr pid, const WTF::Vector<WTF::String>& allocator_dump_names,
        RequestGlobalMemoryDumpForPidCallback callback) final;

    void RequestPrivateMemoryFootprint(::mojo_base::mojom::blink::ProcessIdPtr pid, RequestPrivateMemoryFootprintCallback callback) final;

    void RequestGlobalMemoryDumpAndAppendToTrace(
        DumpType dump_type, LevelOfDetail level_of_detail, Determinism determinism, RequestGlobalMemoryDumpAndAppendToTraceCallback callback) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) CoordinatorConnectorProxy : public CoordinatorConnector {
public:
    using InterfaceType = CoordinatorConnector;

    explicit CoordinatorConnectorProxy(mojo::MessageReceiverWithResponder* receiver);

    void RegisterCoordinatorClient(::mojo::PendingReceiver<Coordinator> receiver, ::mojo::PendingRemote<ClientProcess> client_process) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};
class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) ClientProcessStubDispatch {
public:
    static bool Accept(ClientProcess* impl, mojo::Message* message);
    static bool AcceptWithResponder(ClientProcess* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<ClientProcess>> class ClientProcessStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    ClientProcessStub() = default;
//    ~ClientProcessStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return ClientProcessStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return ClientProcessStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerStubDispatch {
public:
    static bool Accept(HeapProfiler* impl, mojo::Message* message);
    static bool AcceptWithResponder(HeapProfiler* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<HeapProfiler>> class HeapProfilerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    HeapProfilerStub() = default;
//    ~HeapProfilerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return HeapProfilerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return HeapProfilerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerHelperStubDispatch {
public:
    static bool Accept(HeapProfilerHelper* impl, mojo::Message* message);
    static bool AcceptWithResponder(HeapProfilerHelper* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<HeapProfilerHelper>>
//class HeapProfilerHelperStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    HeapProfilerHelperStub() = default;
//    ~HeapProfilerHelperStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return HeapProfilerHelperStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return HeapProfilerHelperStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) CoordinatorStubDispatch {
public:
    static bool Accept(Coordinator* impl, mojo::Message* message);
    static bool AcceptWithResponder(Coordinator* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<Coordinator>> class CoordinatorStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    CoordinatorStub() = default;
//    ~CoordinatorStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return CoordinatorStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return CoordinatorStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) CoordinatorConnectorStubDispatch {
public:
    static bool Accept(CoordinatorConnector* impl, mojo::Message* message);
    static bool AcceptWithResponder(CoordinatorConnector* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<CoordinatorConnector>>
//class CoordinatorConnectorStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    CoordinatorConnectorStub() = default;
//    ~CoordinatorConnectorStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return CoordinatorConnectorStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return CoordinatorConnectorStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) ClientProcessRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerHelperRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) CoordinatorRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) CoordinatorConnectorRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) ClientProcessResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfilerHelperResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) CoordinatorResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) RequestArgs {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<RequestArgs, T>::value>;
    using DataView = RequestArgsDataView;
    using Data_ = internal::RequestArgs_Data;

    template <typename... Args> static RequestArgsPtr New(Args&&... args)
    {
        return RequestArgsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static RequestArgsPtr From(const U& u)
    {
        return mojo::TypeConverter<RequestArgsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, RequestArgs>::Convert(*this);
    }

    RequestArgs();

    RequestArgs(uint64_t dump_guid, DumpType dump_type, LevelOfDetail level_of_detail, Determinism determinism);

    ~RequestArgs();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = RequestArgsPtr> RequestArgsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, RequestArgs::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, RequestArgs::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, RequestArgs::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<RequestArgs::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<RequestArgs::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::RequestArgs_UnserializedMessageContext<UserType, RequestArgs::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<RequestArgs::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return RequestArgs::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::RequestArgs_UnserializedMessageContext<UserType, RequestArgs::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<RequestArgs::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t dump_guid;

    DumpType dump_type;

    LevelOfDetail level_of_detail;

    Determinism determinism;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RequestArgs::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, RequestArgs::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, RequestArgs::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, RequestArgs::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) RawAllocatorDumpEdge {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<RawAllocatorDumpEdge, T>::value>;
    using DataView = RawAllocatorDumpEdgeDataView;
    using Data_ = internal::RawAllocatorDumpEdge_Data;

    template <typename... Args> static RawAllocatorDumpEdgePtr New(Args&&... args)
    {
        return RawAllocatorDumpEdgePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static RawAllocatorDumpEdgePtr From(const U& u)
    {
        return mojo::TypeConverter<RawAllocatorDumpEdgePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, RawAllocatorDumpEdge>::Convert(*this);
    }

    RawAllocatorDumpEdge();

    RawAllocatorDumpEdge(uint64_t source_id, uint64_t target_id, int32_t importance, bool overridable);

    ~RawAllocatorDumpEdge();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = RawAllocatorDumpEdgePtr> RawAllocatorDumpEdgePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<RawAllocatorDumpEdge::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<RawAllocatorDumpEdge::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::RawAllocatorDumpEdge_UnserializedMessageContext<UserType, RawAllocatorDumpEdge::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<RawAllocatorDumpEdge::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return RawAllocatorDumpEdge::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::RawAllocatorDumpEdge_UnserializedMessageContext<UserType, RawAllocatorDumpEdge::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<RawAllocatorDumpEdge::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t source_id;

    uint64_t target_id;

    int32_t importance;

    bool overridable;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) AggregatedMetrics {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AggregatedMetrics, T>::value>;
    using DataView = AggregatedMetricsDataView;
    using Data_ = internal::AggregatedMetrics_Data;

    template <typename... Args> static AggregatedMetricsPtr New(Args&&... args)
    {
        return AggregatedMetricsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AggregatedMetricsPtr From(const U& u)
    {
        return mojo::TypeConverter<AggregatedMetricsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AggregatedMetrics>::Convert(*this);
    }

    AggregatedMetrics();

    AggregatedMetrics(int32_t native_library_resident_kb, int32_t native_library_resident_not_ordered_kb, int32_t native_library_not_resident_ordered_kb);

    ~AggregatedMetrics();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AggregatedMetricsPtr> AggregatedMetricsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AggregatedMetrics::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AggregatedMetrics::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AggregatedMetrics::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AggregatedMetrics::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AggregatedMetrics::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AggregatedMetrics_UnserializedMessageContext<UserType, AggregatedMetrics::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AggregatedMetrics::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AggregatedMetrics::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AggregatedMetrics_UnserializedMessageContext<UserType, AggregatedMetrics::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AggregatedMetrics::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    int32_t native_library_resident_kb;

    int32_t native_library_resident_not_ordered_kb;

    int32_t native_library_not_resident_ordered_kb;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AggregatedMetrics::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AggregatedMetrics::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AggregatedMetrics::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AggregatedMetrics::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) RawAllocatorDumpEntryValue {
public:
    using DataView = RawAllocatorDumpEntryValueDataView;
    using Data_ = internal::RawAllocatorDumpEntryValue_Data;
    using Tag = Data_::RawAllocatorDumpEntryValue_Tag;

    template <typename... Args> static RawAllocatorDumpEntryValuePtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |value_uint64|.
    static RawAllocatorDumpEntryValuePtr NewValueUint64(uint64_t value)
    {
        auto result = RawAllocatorDumpEntryValuePtr(std::in_place);
        result->set_value_uint64(std::move(value));
        return result;
    }
    // Construct an instance holding |value_string|.
    static RawAllocatorDumpEntryValuePtr NewValueString(const WTF::String& value)
    {
        auto result = RawAllocatorDumpEntryValuePtr(std::in_place);
        result->set_value_string(std::move(value));
        return result;
    }

    template <typename U> static RawAllocatorDumpEntryValuePtr From(const U& u)
    {
        return mojo::TypeConverter<RawAllocatorDumpEntryValuePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, RawAllocatorDumpEntryValue>::Convert(*this);
    }

    RawAllocatorDumpEntryValue();
    ~RawAllocatorDumpEntryValue();
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    RawAllocatorDumpEntryValue(const RawAllocatorDumpEntryValue& other) = delete;
    RawAllocatorDumpEntryValue& operator=(const RawAllocatorDumpEntryValue& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = RawAllocatorDumpEntryValuePtr> RawAllocatorDumpEntryValuePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, RawAllocatorDumpEntryValue>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, RawAllocatorDumpEntryValue>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }
    size_t Hash(size_t seed) const;

    Tag which() const
    {
        return tag_;
    }

    bool is_value_uint64() const
    {
        return tag_ == Tag::kValueUint64;
    }

    uint64_t get_value_uint64() const
    {
        CHECK(tag_ == Tag::kValueUint64);
        return data_.value_uint64;
    }

    void set_value_uint64(uint64_t value_uint64);

    bool is_value_string() const
    {
        return tag_ == Tag::kValueString;
    }

    WTF::String& get_value_string() const
    {
        CHECK(tag_ == Tag::kValueString);
        return *(data_.value_string);
    }

    void set_value_string(const WTF::String& value_string);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<RawAllocatorDumpEntryValue::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<RawAllocatorDumpEntryValue::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        uint64_t value_uint64;
        WTF::String* value_string;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) RawAllocatorDumpEntry {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<RawAllocatorDumpEntry, T>::value>;
    using DataView = RawAllocatorDumpEntryDataView;
    using Data_ = internal::RawAllocatorDumpEntry_Data;

    template <typename... Args> static RawAllocatorDumpEntryPtr New(Args&&... args)
    {
        return RawAllocatorDumpEntryPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static RawAllocatorDumpEntryPtr From(const U& u)
    {
        return mojo::TypeConverter<RawAllocatorDumpEntryPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, RawAllocatorDumpEntry>::Convert(*this);
    }

    RawAllocatorDumpEntry();

    RawAllocatorDumpEntry(const WTF::String& name, const WTF::String& units, RawAllocatorDumpEntryValuePtr value);

    RawAllocatorDumpEntry(const RawAllocatorDumpEntry&) = delete;
    RawAllocatorDumpEntry& operator=(const RawAllocatorDumpEntry&) = delete;

    ~RawAllocatorDumpEntry();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = RawAllocatorDumpEntryPtr> RawAllocatorDumpEntryPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<RawAllocatorDumpEntry::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<RawAllocatorDumpEntry::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::RawAllocatorDumpEntry_UnserializedMessageContext<UserType, RawAllocatorDumpEntry::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<RawAllocatorDumpEntry::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return RawAllocatorDumpEntry::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::RawAllocatorDumpEntry_UnserializedMessageContext<UserType, RawAllocatorDumpEntry::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<RawAllocatorDumpEntry::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String name;

    WTF::String units;

    RawAllocatorDumpEntryValuePtr value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) RawAllocatorDump {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<RawAllocatorDump, T>::value>;
    using DataView = RawAllocatorDumpDataView;
    using Data_ = internal::RawAllocatorDump_Data;

    template <typename... Args> static RawAllocatorDumpPtr New(Args&&... args)
    {
        return RawAllocatorDumpPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static RawAllocatorDumpPtr From(const U& u)
    {
        return mojo::TypeConverter<RawAllocatorDumpPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, RawAllocatorDump>::Convert(*this);
    }

    RawAllocatorDump();

    RawAllocatorDump(uint64_t id, const WTF::String& absolute_name, bool weak, LevelOfDetail level_of_detail, WTF::Vector<RawAllocatorDumpEntryPtr> entries);

    RawAllocatorDump(const RawAllocatorDump&) = delete;
    RawAllocatorDump& operator=(const RawAllocatorDump&) = delete;

    ~RawAllocatorDump();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = RawAllocatorDumpPtr> RawAllocatorDumpPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, RawAllocatorDump::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, RawAllocatorDump::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, RawAllocatorDump::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<RawAllocatorDump::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<RawAllocatorDump::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::RawAllocatorDump_UnserializedMessageContext<UserType, RawAllocatorDump::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<RawAllocatorDump::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return RawAllocatorDump::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::RawAllocatorDump_UnserializedMessageContext<UserType, RawAllocatorDump::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<RawAllocatorDump::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t id;

    WTF::String absolute_name;

    bool weak;

    LevelOfDetail level_of_detail;

    WTF::Vector<RawAllocatorDumpEntryPtr> entries;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RawAllocatorDump::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, RawAllocatorDump::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, RawAllocatorDump::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, RawAllocatorDump::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) RawProcessMemoryDump {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<RawProcessMemoryDump, T>::value>;
    using DataView = RawProcessMemoryDumpDataView;
    using Data_ = internal::RawProcessMemoryDump_Data;

    template <typename... Args> static RawProcessMemoryDumpPtr New(Args&&... args)
    {
        return RawProcessMemoryDumpPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static RawProcessMemoryDumpPtr From(const U& u)
    {
        return mojo::TypeConverter<RawProcessMemoryDumpPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, RawProcessMemoryDump>::Convert(*this);
    }

    RawProcessMemoryDump();

    RawProcessMemoryDump(
        LevelOfDetail level_of_detail, WTF::Vector<RawAllocatorDumpEdgePtr> allocator_dump_edges, WTF::Vector<RawAllocatorDumpPtr> allocator_dumps);

    RawProcessMemoryDump(const RawProcessMemoryDump&) = delete;
    RawProcessMemoryDump& operator=(const RawProcessMemoryDump&) = delete;

    ~RawProcessMemoryDump();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = RawProcessMemoryDumpPtr> RawProcessMemoryDumpPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, RawProcessMemoryDump::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, RawProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, RawProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<RawProcessMemoryDump::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<RawProcessMemoryDump::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::RawProcessMemoryDump_UnserializedMessageContext<UserType, RawProcessMemoryDump::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<RawProcessMemoryDump::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return RawProcessMemoryDump::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::RawProcessMemoryDump_UnserializedMessageContext<UserType, RawProcessMemoryDump::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<RawProcessMemoryDump::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    LevelOfDetail level_of_detail;

    WTF::Vector<RawAllocatorDumpEdgePtr> allocator_dump_edges;

    WTF::Vector<RawAllocatorDumpPtr> allocator_dumps;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RawProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, RawProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, RawProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, RawProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) VmRegion {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<VmRegion, T>::value>;
    using DataView = VmRegionDataView;
    using Data_ = internal::VmRegion_Data;

    static constexpr uint32_t kProtectionFlagsRead = 4U;

    static constexpr uint32_t kProtectionFlagsWrite = 2U;

    static constexpr uint32_t kProtectionFlagsExec = 1U;

    static constexpr uint32_t kProtectionFlagsMayshare = 128U;

    template <typename... Args> static VmRegionPtr New(Args&&... args)
    {
        return VmRegionPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static VmRegionPtr From(const U& u)
    {
        return mojo::TypeConverter<VmRegionPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, VmRegion>::Convert(*this);
    }

    VmRegion();

    VmRegion(uint64_t start_address, uint64_t size_in_bytes, uint64_t module_timestamp, const WTF::String& module_debugid, const WTF::String& module_debug_path,
        uint32_t protection_flags, const WTF::String& mapped_file, uint64_t byte_stats_private_dirty_resident, uint64_t byte_stats_private_clean_resident,
        uint64_t byte_stats_shared_dirty_resident, uint64_t byte_stats_shared_clean_resident, uint64_t byte_stats_swapped, uint64_t byte_locked,
        uint64_t byte_stats_proportional_resident);

    ~VmRegion();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = VmRegionPtr> VmRegionPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, VmRegion::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, VmRegion::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, VmRegion::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<VmRegion::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<VmRegion::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::VmRegion_UnserializedMessageContext<UserType, VmRegion::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<VmRegion::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return VmRegion::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::VmRegion_UnserializedMessageContext<UserType, VmRegion::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<VmRegion::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t start_address;

    uint64_t size_in_bytes;

    uint64_t module_timestamp;

    WTF::String module_debugid;

    WTF::String module_debug_path;

    uint32_t protection_flags;

    WTF::String mapped_file;

    uint64_t byte_stats_private_dirty_resident;

    uint64_t byte_stats_private_clean_resident;

    uint64_t byte_stats_shared_dirty_resident;

    uint64_t byte_stats_shared_clean_resident;

    uint64_t byte_stats_swapped;

    uint64_t byte_locked;

    uint64_t byte_stats_proportional_resident;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VmRegion::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, VmRegion::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, VmRegion::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, VmRegion::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) PlatformPrivateFootprint {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<PlatformPrivateFootprint, T>::value>;
    using DataView = PlatformPrivateFootprintDataView;
    using Data_ = internal::PlatformPrivateFootprint_Data;

    template <typename... Args> static PlatformPrivateFootprintPtr New(Args&&... args)
    {
        return PlatformPrivateFootprintPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PlatformPrivateFootprintPtr From(const U& u)
    {
        return mojo::TypeConverter<PlatformPrivateFootprintPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PlatformPrivateFootprint>::Convert(*this);
    }

    PlatformPrivateFootprint();

    PlatformPrivateFootprint(uint64_t phys_footprint_bytes, uint64_t internal_bytes, uint64_t compressed_bytes, uint64_t rss_anon_bytes, uint64_t vm_swap_bytes,
        uint64_t private_bytes);

    ~PlatformPrivateFootprint();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PlatformPrivateFootprintPtr> PlatformPrivateFootprintPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, PlatformPrivateFootprint::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, PlatformPrivateFootprint::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, PlatformPrivateFootprint::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<PlatformPrivateFootprint::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PlatformPrivateFootprint::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::PlatformPrivateFootprint_UnserializedMessageContext<UserType, PlatformPrivateFootprint::DataView>>(
                                 0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<PlatformPrivateFootprint::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return PlatformPrivateFootprint::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::PlatformPrivateFootprint_UnserializedMessageContext<UserType, PlatformPrivateFootprint::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<PlatformPrivateFootprint::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t phys_footprint_bytes;

    uint64_t internal_bytes;

    uint64_t compressed_bytes;

    uint64_t rss_anon_bytes;

    uint64_t vm_swap_bytes;

    uint64_t private_bytes;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PlatformPrivateFootprint::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, PlatformPrivateFootprint::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, PlatformPrivateFootprint::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, PlatformPrivateFootprint::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) RawOSMemDump {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<RawOSMemDump, T>::value>;
    using DataView = RawOSMemDumpDataView;
    using Data_ = internal::RawOSMemDump_Data;

    template <typename... Args> static RawOSMemDumpPtr New(Args&&... args)
    {
        return RawOSMemDumpPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static RawOSMemDumpPtr From(const U& u)
    {
        return mojo::TypeConverter<RawOSMemDumpPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, RawOSMemDump>::Convert(*this);
    }

    RawOSMemDump();

    RawOSMemDump(uint32_t resident_set_kb, uint32_t peak_resident_set_kb, bool is_peak_rss_resettable, PlatformPrivateFootprintPtr platform_private_footprint,
        WTF::Vector<VmRegionPtr> memory_maps, WTF::Vector<uint8_t> native_library_pages_bitmap);

    RawOSMemDump(const RawOSMemDump&) = delete;
    RawOSMemDump& operator=(const RawOSMemDump&) = delete;

    ~RawOSMemDump();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = RawOSMemDumpPtr> RawOSMemDumpPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, RawOSMemDump::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, RawOSMemDump::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, RawOSMemDump::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<RawOSMemDump::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<RawOSMemDump::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::RawOSMemDump_UnserializedMessageContext<UserType, RawOSMemDump::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<RawOSMemDump::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return RawOSMemDump::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::RawOSMemDump_UnserializedMessageContext<UserType, RawOSMemDump::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<RawOSMemDump::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint32_t resident_set_kb;

    uint32_t peak_resident_set_kb;

    bool is_peak_rss_resettable;

    PlatformPrivateFootprintPtr platform_private_footprint;

    WTF::Vector<VmRegionPtr> memory_maps;

    WTF::Vector<uint8_t> native_library_pages_bitmap;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RawOSMemDump::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, RawOSMemDump::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, RawOSMemDump::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, RawOSMemDump::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) OSMemDump {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<OSMemDump, T>::value>;
    using DataView = OSMemDumpDataView;
    using Data_ = internal::OSMemDump_Data;

    template <typename... Args> static OSMemDumpPtr New(Args&&... args)
    {
        return OSMemDumpPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static OSMemDumpPtr From(const U& u)
    {
        return mojo::TypeConverter<OSMemDumpPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, OSMemDump>::Convert(*this);
    }

    OSMemDump();

    OSMemDump(
        uint32_t resident_set_kb, uint32_t peak_resident_set_kb, bool is_peak_rss_resettable, uint32_t private_footprint_kb, uint32_t shared_footprint_kb);

    ~OSMemDump();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = OSMemDumpPtr> OSMemDumpPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, OSMemDump::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, OSMemDump::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, OSMemDump::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<OSMemDump::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<OSMemDump::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::OSMemDump_UnserializedMessageContext<UserType, OSMemDump::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<OSMemDump::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return OSMemDump::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::OSMemDump_UnserializedMessageContext<UserType, OSMemDump::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<OSMemDump::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint32_t resident_set_kb;

    uint32_t peak_resident_set_kb;

    bool is_peak_rss_resettable;

    uint32_t private_footprint_kb;

    uint32_t shared_footprint_kb;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, OSMemDump::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, OSMemDump::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, OSMemDump::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, OSMemDump::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) AllocatorMemDump {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<AllocatorMemDump, T>::value>;
    using DataView = AllocatorMemDumpDataView;
    using Data_ = internal::AllocatorMemDump_Data;

    template <typename... Args> static AllocatorMemDumpPtr New(Args&&... args)
    {
        return AllocatorMemDumpPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static AllocatorMemDumpPtr From(const U& u)
    {
        return mojo::TypeConverter<AllocatorMemDumpPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, AllocatorMemDump>::Convert(*this);
    }

    AllocatorMemDump();

    AllocatorMemDump(const WTF::HashMap<WTF::String, uint64_t>& numeric_entries, WTF::HashMap<WTF::String, AllocatorMemDumpPtr> children);

    AllocatorMemDump(const AllocatorMemDump&) = delete;
    AllocatorMemDump& operator=(const AllocatorMemDump&) = delete;

    ~AllocatorMemDump();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = AllocatorMemDumpPtr> AllocatorMemDumpPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, AllocatorMemDump::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, AllocatorMemDump::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, AllocatorMemDump::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<AllocatorMemDump::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<AllocatorMemDump::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::AllocatorMemDump_UnserializedMessageContext<UserType, AllocatorMemDump::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<AllocatorMemDump::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return AllocatorMemDump::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::AllocatorMemDump_UnserializedMessageContext<UserType, AllocatorMemDump::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<AllocatorMemDump::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::HashMap<WTF::String, uint64_t> numeric_entries;

    WTF::HashMap<WTF::String, AllocatorMemDumpPtr> children;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AllocatorMemDump::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, AllocatorMemDump::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, AllocatorMemDump::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, AllocatorMemDump::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) ProcessMemoryDump {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ProcessMemoryDump, T>::value>;
    using DataView = ProcessMemoryDumpDataView;
    using Data_ = internal::ProcessMemoryDump_Data;

    template <typename... Args> static ProcessMemoryDumpPtr New(Args&&... args)
    {
        return ProcessMemoryDumpPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ProcessMemoryDumpPtr From(const U& u)
    {
        return mojo::TypeConverter<ProcessMemoryDumpPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ProcessMemoryDump>::Convert(*this);
    }

    ProcessMemoryDump();

    ProcessMemoryDump(ProcessType process_type, OSMemDumpPtr os_dump, WTF::HashMap<WTF::String, AllocatorMemDumpPtr> chrome_allocator_dumps,
        ::mojo_base::mojom::blink::ProcessIdPtr pid, const WTF::String& service_name);

    ProcessMemoryDump(const ProcessMemoryDump&) = delete;
    ProcessMemoryDump& operator=(const ProcessMemoryDump&) = delete;

    ~ProcessMemoryDump();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ProcessMemoryDumpPtr> ProcessMemoryDumpPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ProcessMemoryDump::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ProcessMemoryDump::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ProcessMemoryDump::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ProcessMemoryDump_UnserializedMessageContext<UserType, ProcessMemoryDump::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ProcessMemoryDump::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ProcessMemoryDump::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ProcessMemoryDump_UnserializedMessageContext<UserType, ProcessMemoryDump::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ProcessMemoryDump::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ProcessType process_type;

    OSMemDumpPtr os_dump;

    WTF::HashMap<WTF::String, AllocatorMemDumpPtr> chrome_allocator_dumps;

    ::mojo_base::mojom::blink::ProcessIdPtr pid;

    WTF::String service_name;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ProcessMemoryDump::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) GlobalMemoryDump {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GlobalMemoryDump, T>::value>;
    using DataView = GlobalMemoryDumpDataView;
    using Data_ = internal::GlobalMemoryDump_Data;

    template <typename... Args> static GlobalMemoryDumpPtr New(Args&&... args)
    {
        return GlobalMemoryDumpPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GlobalMemoryDumpPtr From(const U& u)
    {
        return mojo::TypeConverter<GlobalMemoryDumpPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GlobalMemoryDump>::Convert(*this);
    }

    GlobalMemoryDump();

    GlobalMemoryDump(::base::TimeTicks start_time, WTF::Vector<ProcessMemoryDumpPtr> process_dumps, AggregatedMetricsPtr aggregated_metrics);

    GlobalMemoryDump(const GlobalMemoryDump&) = delete;
    GlobalMemoryDump& operator=(const GlobalMemoryDump&) = delete;

    ~GlobalMemoryDump();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GlobalMemoryDumpPtr> GlobalMemoryDumpPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GlobalMemoryDump::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GlobalMemoryDump::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GlobalMemoryDump::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<GlobalMemoryDump::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GlobalMemoryDump::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::GlobalMemoryDump_UnserializedMessageContext<UserType, GlobalMemoryDump::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GlobalMemoryDump::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GlobalMemoryDump::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GlobalMemoryDump_UnserializedMessageContext<UserType, GlobalMemoryDump::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GlobalMemoryDump::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::TimeTicks start_time;

    WTF::Vector<ProcessMemoryDumpPtr> process_dumps;

    AggregatedMetricsPtr aggregated_metrics;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GlobalMemoryDump::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GlobalMemoryDump::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GlobalMemoryDump::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GlobalMemoryDump::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) HeapProfileResult {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<HeapProfileResult, T>::value>;
    using DataView = HeapProfileResultDataView;
    using Data_ = internal::HeapProfileResult_Data;

    template <typename... Args> static HeapProfileResultPtr New(Args&&... args)
    {
        return HeapProfileResultPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static HeapProfileResultPtr From(const U& u)
    {
        return mojo::TypeConverter<HeapProfileResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, HeapProfileResult>::Convert(*this);
    }

    HeapProfileResult();

    HeapProfileResult(::mojo_base::mojom::blink::ProcessIdPtr pid, const ::WTF::String& json);

    HeapProfileResult(const HeapProfileResult&) = delete;
    HeapProfileResult& operator=(const HeapProfileResult&) = delete;

    ~HeapProfileResult();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = HeapProfileResultPtr> HeapProfileResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, HeapProfileResult::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, HeapProfileResult::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, HeapProfileResult::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<HeapProfileResult::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::HeapProfileResult_UnserializedMessageContext<UserType, HeapProfileResult::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<HeapProfileResult::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return HeapProfileResult::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::HeapProfileResult_UnserializedMessageContext<UserType, HeapProfileResult::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<HeapProfileResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::mojo_base::mojom::blink::ProcessIdPtr pid;

    ::WTF::String json;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HeapProfileResult::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, HeapProfileResult::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, HeapProfileResult::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, HeapProfileResult::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename UnionPtrType> RawAllocatorDumpEntryValuePtr RawAllocatorDumpEntryValue::Clone() const
{
    switch (tag_) {
    case Tag::kValueUint64:
        return NewValueUint64(mojo::Clone(data_.value_uint64));
    case Tag::kValueString:
        return NewValueString(mojo::Clone(*data_.value_string));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, RawAllocatorDumpEntryValue>::value>::type*>
bool RawAllocatorDumpEntryValue::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kValueUint64:
        return mojo::Equals(data_.value_uint64, other.data_.value_uint64);
    case Tag::kValueString:
        return mojo::Equals(*(data_.value_string), *(other.data_.value_string));
    }

    return false;
}
template <typename StructPtrType> RequestArgsPtr RequestArgs::Clone() const
{
    return New(mojo::Clone(dump_guid), mojo::Clone(dump_type), mojo::Clone(level_of_detail), mojo::Clone(determinism));
}

template <typename T, RequestArgs::EnableIfSame<T>*> bool RequestArgs::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->dump_guid, other_struct.dump_guid))
        return false;
    if (!mojo::Equals(this->dump_type, other_struct.dump_type))
        return false;
    if (!mojo::Equals(this->level_of_detail, other_struct.level_of_detail))
        return false;
    if (!mojo::Equals(this->determinism, other_struct.determinism))
        return false;
    return true;
}

template <typename T, RequestArgs::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.dump_guid < rhs.dump_guid)
        return true;
    if (rhs.dump_guid < lhs.dump_guid)
        return false;
    if (lhs.dump_type < rhs.dump_type)
        return true;
    if (rhs.dump_type < lhs.dump_type)
        return false;
    if (lhs.level_of_detail < rhs.level_of_detail)
        return true;
    if (rhs.level_of_detail < lhs.level_of_detail)
        return false;
    if (lhs.determinism < rhs.determinism)
        return true;
    if (rhs.determinism < lhs.determinism)
        return false;
    return false;
}
template <typename StructPtrType> RawAllocatorDumpEdgePtr RawAllocatorDumpEdge::Clone() const
{
    return New(mojo::Clone(source_id), mojo::Clone(target_id), mojo::Clone(importance), mojo::Clone(overridable));
}

template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>*> bool RawAllocatorDumpEdge::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->source_id, other_struct.source_id))
        return false;
    if (!mojo::Equals(this->target_id, other_struct.target_id))
        return false;
    if (!mojo::Equals(this->importance, other_struct.importance))
        return false;
    if (!mojo::Equals(this->overridable, other_struct.overridable))
        return false;
    return true;
}

template <typename T, RawAllocatorDumpEdge::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.source_id < rhs.source_id)
        return true;
    if (rhs.source_id < lhs.source_id)
        return false;
    if (lhs.target_id < rhs.target_id)
        return true;
    if (rhs.target_id < lhs.target_id)
        return false;
    if (lhs.importance < rhs.importance)
        return true;
    if (rhs.importance < lhs.importance)
        return false;
    if (lhs.overridable < rhs.overridable)
        return true;
    if (rhs.overridable < lhs.overridable)
        return false;
    return false;
}
template <typename StructPtrType> RawAllocatorDumpEntryPtr RawAllocatorDumpEntry::Clone() const
{
    return New(mojo::Clone(name), mojo::Clone(units), mojo::Clone(value));
}

template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>*> bool RawAllocatorDumpEntry::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->units, other_struct.units))
        return false;
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, RawAllocatorDumpEntry::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.units < rhs.units)
        return true;
    if (rhs.units < lhs.units)
        return false;
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> RawAllocatorDumpPtr RawAllocatorDump::Clone() const
{
    return New(mojo::Clone(id), mojo::Clone(absolute_name), mojo::Clone(weak), mojo::Clone(level_of_detail), mojo::Clone(entries));
}

template <typename T, RawAllocatorDump::EnableIfSame<T>*> bool RawAllocatorDump::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->id, other_struct.id))
        return false;
    if (!mojo::Equals(this->absolute_name, other_struct.absolute_name))
        return false;
    if (!mojo::Equals(this->weak, other_struct.weak))
        return false;
    if (!mojo::Equals(this->level_of_detail, other_struct.level_of_detail))
        return false;
    if (!mojo::Equals(this->entries, other_struct.entries))
        return false;
    return true;
}

template <typename T, RawAllocatorDump::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.id < rhs.id)
        return true;
    if (rhs.id < lhs.id)
        return false;
    if (lhs.absolute_name < rhs.absolute_name)
        return true;
    if (rhs.absolute_name < lhs.absolute_name)
        return false;
    if (lhs.weak < rhs.weak)
        return true;
    if (rhs.weak < lhs.weak)
        return false;
    if (lhs.level_of_detail < rhs.level_of_detail)
        return true;
    if (rhs.level_of_detail < lhs.level_of_detail)
        return false;
    if (lhs.entries < rhs.entries)
        return true;
    if (rhs.entries < lhs.entries)
        return false;
    return false;
}
template <typename StructPtrType> RawProcessMemoryDumpPtr RawProcessMemoryDump::Clone() const
{
    return New(mojo::Clone(level_of_detail), mojo::Clone(allocator_dump_edges), mojo::Clone(allocator_dumps));
}

template <typename T, RawProcessMemoryDump::EnableIfSame<T>*> bool RawProcessMemoryDump::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->level_of_detail, other_struct.level_of_detail))
        return false;
    if (!mojo::Equals(this->allocator_dump_edges, other_struct.allocator_dump_edges))
        return false;
    if (!mojo::Equals(this->allocator_dumps, other_struct.allocator_dumps))
        return false;
    return true;
}

template <typename T, RawProcessMemoryDump::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.level_of_detail < rhs.level_of_detail)
        return true;
    if (rhs.level_of_detail < lhs.level_of_detail)
        return false;
    if (lhs.allocator_dump_edges < rhs.allocator_dump_edges)
        return true;
    if (rhs.allocator_dump_edges < lhs.allocator_dump_edges)
        return false;
    if (lhs.allocator_dumps < rhs.allocator_dumps)
        return true;
    if (rhs.allocator_dumps < lhs.allocator_dumps)
        return false;
    return false;
}
template <typename StructPtrType> VmRegionPtr VmRegion::Clone() const
{
    return New(mojo::Clone(start_address), mojo::Clone(size_in_bytes), mojo::Clone(module_timestamp), mojo::Clone(module_debugid),
        mojo::Clone(module_debug_path), mojo::Clone(protection_flags), mojo::Clone(mapped_file), mojo::Clone(byte_stats_private_dirty_resident),
        mojo::Clone(byte_stats_private_clean_resident), mojo::Clone(byte_stats_shared_dirty_resident), mojo::Clone(byte_stats_shared_clean_resident),
        mojo::Clone(byte_stats_swapped), mojo::Clone(byte_locked), mojo::Clone(byte_stats_proportional_resident));
}

template <typename T, VmRegion::EnableIfSame<T>*> bool VmRegion::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->start_address, other_struct.start_address))
        return false;
    if (!mojo::Equals(this->size_in_bytes, other_struct.size_in_bytes))
        return false;
    if (!mojo::Equals(this->module_timestamp, other_struct.module_timestamp))
        return false;
    if (!mojo::Equals(this->module_debugid, other_struct.module_debugid))
        return false;
    if (!mojo::Equals(this->module_debug_path, other_struct.module_debug_path))
        return false;
    if (!mojo::Equals(this->protection_flags, other_struct.protection_flags))
        return false;
    if (!mojo::Equals(this->mapped_file, other_struct.mapped_file))
        return false;
    if (!mojo::Equals(this->byte_stats_private_dirty_resident, other_struct.byte_stats_private_dirty_resident))
        return false;
    if (!mojo::Equals(this->byte_stats_private_clean_resident, other_struct.byte_stats_private_clean_resident))
        return false;
    if (!mojo::Equals(this->byte_stats_shared_dirty_resident, other_struct.byte_stats_shared_dirty_resident))
        return false;
    if (!mojo::Equals(this->byte_stats_shared_clean_resident, other_struct.byte_stats_shared_clean_resident))
        return false;
    if (!mojo::Equals(this->byte_stats_swapped, other_struct.byte_stats_swapped))
        return false;
    if (!mojo::Equals(this->byte_locked, other_struct.byte_locked))
        return false;
    if (!mojo::Equals(this->byte_stats_proportional_resident, other_struct.byte_stats_proportional_resident))
        return false;
    return true;
}

template <typename T, VmRegion::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.start_address < rhs.start_address)
        return true;
    if (rhs.start_address < lhs.start_address)
        return false;
    if (lhs.size_in_bytes < rhs.size_in_bytes)
        return true;
    if (rhs.size_in_bytes < lhs.size_in_bytes)
        return false;
    if (lhs.module_timestamp < rhs.module_timestamp)
        return true;
    if (rhs.module_timestamp < lhs.module_timestamp)
        return false;
    if (lhs.module_debugid < rhs.module_debugid)
        return true;
    if (rhs.module_debugid < lhs.module_debugid)
        return false;
    if (lhs.module_debug_path < rhs.module_debug_path)
        return true;
    if (rhs.module_debug_path < lhs.module_debug_path)
        return false;
    if (lhs.protection_flags < rhs.protection_flags)
        return true;
    if (rhs.protection_flags < lhs.protection_flags)
        return false;
    if (lhs.mapped_file < rhs.mapped_file)
        return true;
    if (rhs.mapped_file < lhs.mapped_file)
        return false;
    if (lhs.byte_stats_private_dirty_resident < rhs.byte_stats_private_dirty_resident)
        return true;
    if (rhs.byte_stats_private_dirty_resident < lhs.byte_stats_private_dirty_resident)
        return false;
    if (lhs.byte_stats_private_clean_resident < rhs.byte_stats_private_clean_resident)
        return true;
    if (rhs.byte_stats_private_clean_resident < lhs.byte_stats_private_clean_resident)
        return false;
    if (lhs.byte_stats_shared_dirty_resident < rhs.byte_stats_shared_dirty_resident)
        return true;
    if (rhs.byte_stats_shared_dirty_resident < lhs.byte_stats_shared_dirty_resident)
        return false;
    if (lhs.byte_stats_shared_clean_resident < rhs.byte_stats_shared_clean_resident)
        return true;
    if (rhs.byte_stats_shared_clean_resident < lhs.byte_stats_shared_clean_resident)
        return false;
    if (lhs.byte_stats_swapped < rhs.byte_stats_swapped)
        return true;
    if (rhs.byte_stats_swapped < lhs.byte_stats_swapped)
        return false;
    if (lhs.byte_locked < rhs.byte_locked)
        return true;
    if (rhs.byte_locked < lhs.byte_locked)
        return false;
    if (lhs.byte_stats_proportional_resident < rhs.byte_stats_proportional_resident)
        return true;
    if (rhs.byte_stats_proportional_resident < lhs.byte_stats_proportional_resident)
        return false;
    return false;
}
template <typename StructPtrType> PlatformPrivateFootprintPtr PlatformPrivateFootprint::Clone() const
{
    return New(mojo::Clone(phys_footprint_bytes), mojo::Clone(internal_bytes), mojo::Clone(compressed_bytes), mojo::Clone(rss_anon_bytes),
        mojo::Clone(vm_swap_bytes), mojo::Clone(private_bytes));
}

template <typename T, PlatformPrivateFootprint::EnableIfSame<T>*> bool PlatformPrivateFootprint::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->phys_footprint_bytes, other_struct.phys_footprint_bytes))
        return false;
    if (!mojo::Equals(this->internal_bytes, other_struct.internal_bytes))
        return false;
    if (!mojo::Equals(this->compressed_bytes, other_struct.compressed_bytes))
        return false;
    if (!mojo::Equals(this->rss_anon_bytes, other_struct.rss_anon_bytes))
        return false;
    if (!mojo::Equals(this->vm_swap_bytes, other_struct.vm_swap_bytes))
        return false;
    if (!mojo::Equals(this->private_bytes, other_struct.private_bytes))
        return false;
    return true;
}

template <typename T, PlatformPrivateFootprint::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.phys_footprint_bytes < rhs.phys_footprint_bytes)
        return true;
    if (rhs.phys_footprint_bytes < lhs.phys_footprint_bytes)
        return false;
    if (lhs.internal_bytes < rhs.internal_bytes)
        return true;
    if (rhs.internal_bytes < lhs.internal_bytes)
        return false;
    if (lhs.compressed_bytes < rhs.compressed_bytes)
        return true;
    if (rhs.compressed_bytes < lhs.compressed_bytes)
        return false;
    if (lhs.rss_anon_bytes < rhs.rss_anon_bytes)
        return true;
    if (rhs.rss_anon_bytes < lhs.rss_anon_bytes)
        return false;
    if (lhs.vm_swap_bytes < rhs.vm_swap_bytes)
        return true;
    if (rhs.vm_swap_bytes < lhs.vm_swap_bytes)
        return false;
    if (lhs.private_bytes < rhs.private_bytes)
        return true;
    if (rhs.private_bytes < lhs.private_bytes)
        return false;
    return false;
}
template <typename StructPtrType> RawOSMemDumpPtr RawOSMemDump::Clone() const
{
    return New(mojo::Clone(resident_set_kb), mojo::Clone(peak_resident_set_kb), mojo::Clone(is_peak_rss_resettable), mojo::Clone(platform_private_footprint),
        mojo::Clone(memory_maps), mojo::Clone(native_library_pages_bitmap));
}

template <typename T, RawOSMemDump::EnableIfSame<T>*> bool RawOSMemDump::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->resident_set_kb, other_struct.resident_set_kb))
        return false;
    if (!mojo::Equals(this->peak_resident_set_kb, other_struct.peak_resident_set_kb))
        return false;
    if (!mojo::Equals(this->is_peak_rss_resettable, other_struct.is_peak_rss_resettable))
        return false;
    if (!mojo::Equals(this->platform_private_footprint, other_struct.platform_private_footprint))
        return false;
    if (!mojo::Equals(this->memory_maps, other_struct.memory_maps))
        return false;
    if (!mojo::Equals(this->native_library_pages_bitmap, other_struct.native_library_pages_bitmap))
        return false;
    return true;
}

template <typename T, RawOSMemDump::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.resident_set_kb < rhs.resident_set_kb)
        return true;
    if (rhs.resident_set_kb < lhs.resident_set_kb)
        return false;
    if (lhs.peak_resident_set_kb < rhs.peak_resident_set_kb)
        return true;
    if (rhs.peak_resident_set_kb < lhs.peak_resident_set_kb)
        return false;
    if (lhs.is_peak_rss_resettable < rhs.is_peak_rss_resettable)
        return true;
    if (rhs.is_peak_rss_resettable < lhs.is_peak_rss_resettable)
        return false;
    if (lhs.platform_private_footprint < rhs.platform_private_footprint)
        return true;
    if (rhs.platform_private_footprint < lhs.platform_private_footprint)
        return false;
    if (lhs.memory_maps < rhs.memory_maps)
        return true;
    if (rhs.memory_maps < lhs.memory_maps)
        return false;
    if (lhs.native_library_pages_bitmap < rhs.native_library_pages_bitmap)
        return true;
    if (rhs.native_library_pages_bitmap < lhs.native_library_pages_bitmap)
        return false;
    return false;
}
template <typename StructPtrType> OSMemDumpPtr OSMemDump::Clone() const
{
    return New(mojo::Clone(resident_set_kb), mojo::Clone(peak_resident_set_kb), mojo::Clone(is_peak_rss_resettable), mojo::Clone(private_footprint_kb),
        mojo::Clone(shared_footprint_kb));
}

template <typename T, OSMemDump::EnableIfSame<T>*> bool OSMemDump::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->resident_set_kb, other_struct.resident_set_kb))
        return false;
    if (!mojo::Equals(this->peak_resident_set_kb, other_struct.peak_resident_set_kb))
        return false;
    if (!mojo::Equals(this->is_peak_rss_resettable, other_struct.is_peak_rss_resettable))
        return false;
    if (!mojo::Equals(this->private_footprint_kb, other_struct.private_footprint_kb))
        return false;
    if (!mojo::Equals(this->shared_footprint_kb, other_struct.shared_footprint_kb))
        return false;
    return true;
}

template <typename T, OSMemDump::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.resident_set_kb < rhs.resident_set_kb)
        return true;
    if (rhs.resident_set_kb < lhs.resident_set_kb)
        return false;
    if (lhs.peak_resident_set_kb < rhs.peak_resident_set_kb)
        return true;
    if (rhs.peak_resident_set_kb < lhs.peak_resident_set_kb)
        return false;
    if (lhs.is_peak_rss_resettable < rhs.is_peak_rss_resettable)
        return true;
    if (rhs.is_peak_rss_resettable < lhs.is_peak_rss_resettable)
        return false;
    if (lhs.private_footprint_kb < rhs.private_footprint_kb)
        return true;
    if (rhs.private_footprint_kb < lhs.private_footprint_kb)
        return false;
    if (lhs.shared_footprint_kb < rhs.shared_footprint_kb)
        return true;
    if (rhs.shared_footprint_kb < lhs.shared_footprint_kb)
        return false;
    return false;
}
template <typename StructPtrType> AllocatorMemDumpPtr AllocatorMemDump::Clone() const
{
    return New(mojo::Clone(numeric_entries), mojo::Clone(children));
}

template <typename T, AllocatorMemDump::EnableIfSame<T>*> bool AllocatorMemDump::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->numeric_entries, other_struct.numeric_entries))
        return false;
    if (!mojo::Equals(this->children, other_struct.children))
        return false;
    return true;
}

template <typename T, AllocatorMemDump::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.numeric_entries < rhs.numeric_entries)
        return true;
    if (rhs.numeric_entries < lhs.numeric_entries)
        return false;
    if (lhs.children < rhs.children)
        return true;
    if (rhs.children < lhs.children)
        return false;
    return false;
}
template <typename StructPtrType> ProcessMemoryDumpPtr ProcessMemoryDump::Clone() const
{
    return New(mojo::Clone(process_type), mojo::Clone(os_dump), mojo::Clone(chrome_allocator_dumps), mojo::Clone(pid), mojo::Clone(service_name));
}

template <typename T, ProcessMemoryDump::EnableIfSame<T>*> bool ProcessMemoryDump::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->process_type, other_struct.process_type))
        return false;
    if (!mojo::Equals(this->os_dump, other_struct.os_dump))
        return false;
    if (!mojo::Equals(this->chrome_allocator_dumps, other_struct.chrome_allocator_dumps))
        return false;
    if (!mojo::Equals(this->pid, other_struct.pid))
        return false;
    if (!mojo::Equals(this->service_name, other_struct.service_name))
        return false;
    return true;
}

template <typename T, ProcessMemoryDump::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.process_type < rhs.process_type)
        return true;
    if (rhs.process_type < lhs.process_type)
        return false;
    if (lhs.os_dump < rhs.os_dump)
        return true;
    if (rhs.os_dump < lhs.os_dump)
        return false;
    if (lhs.chrome_allocator_dumps < rhs.chrome_allocator_dumps)
        return true;
    if (rhs.chrome_allocator_dumps < lhs.chrome_allocator_dumps)
        return false;
    if (lhs.pid < rhs.pid)
        return true;
    if (rhs.pid < lhs.pid)
        return false;
    if (lhs.service_name < rhs.service_name)
        return true;
    if (rhs.service_name < lhs.service_name)
        return false;
    return false;
}
template <typename StructPtrType> AggregatedMetricsPtr AggregatedMetrics::Clone() const
{
    return New(
        mojo::Clone(native_library_resident_kb), mojo::Clone(native_library_resident_not_ordered_kb), mojo::Clone(native_library_not_resident_ordered_kb));
}

template <typename T, AggregatedMetrics::EnableIfSame<T>*> bool AggregatedMetrics::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->native_library_resident_kb, other_struct.native_library_resident_kb))
        return false;
    if (!mojo::Equals(this->native_library_resident_not_ordered_kb, other_struct.native_library_resident_not_ordered_kb))
        return false;
    if (!mojo::Equals(this->native_library_not_resident_ordered_kb, other_struct.native_library_not_resident_ordered_kb))
        return false;
    return true;
}

template <typename T, AggregatedMetrics::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.native_library_resident_kb < rhs.native_library_resident_kb)
        return true;
    if (rhs.native_library_resident_kb < lhs.native_library_resident_kb)
        return false;
    if (lhs.native_library_resident_not_ordered_kb < rhs.native_library_resident_not_ordered_kb)
        return true;
    if (rhs.native_library_resident_not_ordered_kb < lhs.native_library_resident_not_ordered_kb)
        return false;
    if (lhs.native_library_not_resident_ordered_kb < rhs.native_library_not_resident_ordered_kb)
        return true;
    if (rhs.native_library_not_resident_ordered_kb < lhs.native_library_not_resident_ordered_kb)
        return false;
    return false;
}
template <typename StructPtrType> GlobalMemoryDumpPtr GlobalMemoryDump::Clone() const
{
    return New(mojo::Clone(start_time), mojo::Clone(process_dumps), mojo::Clone(aggregated_metrics));
}

template <typename T, GlobalMemoryDump::EnableIfSame<T>*> bool GlobalMemoryDump::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->start_time, other_struct.start_time))
        return false;
    if (!mojo::Equals(this->process_dumps, other_struct.process_dumps))
        return false;
    if (!mojo::Equals(this->aggregated_metrics, other_struct.aggregated_metrics))
        return false;
    return true;
}

template <typename T, GlobalMemoryDump::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.start_time < rhs.start_time)
        return true;
    if (rhs.start_time < lhs.start_time)
        return false;
    if (lhs.process_dumps < rhs.process_dumps)
        return true;
    if (rhs.process_dumps < lhs.process_dumps)
        return false;
    if (lhs.aggregated_metrics < rhs.aggregated_metrics)
        return true;
    if (rhs.aggregated_metrics < lhs.aggregated_metrics)
        return false;
    return false;
}
template <typename StructPtrType> HeapProfileResultPtr HeapProfileResult::Clone() const
{
    return New(mojo::Clone(pid), mojo::Clone(json));
}

template <typename T, HeapProfileResult::EnableIfSame<T>*> bool HeapProfileResult::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->pid, other_struct.pid))
        return false;
    if (!mojo::Equals(this->json, other_struct.json))
        return false;
    return true;
}

template <typename T, HeapProfileResult::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.pid < rhs.pid)
        return true;
    if (rhs.pid < lhs.pid)
        return false;
    if (lhs.json < rhs.json)
        return true;
    if (rhs.json < lhs.json)
        return false;
    return false;
}

} // memory_instrumentation::mojom::blink

namespace mojo {

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::RequestArgs::DataView, ::memory_instrumentation::mojom::blink::RequestArgsPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::RequestArgsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::RequestArgsPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::RequestArgs::dump_guid) dump_guid(
        const ::memory_instrumentation::mojom::blink::RequestArgsPtr& input)
    {
        return input->dump_guid;
    }

    static decltype(::memory_instrumentation::mojom::blink::RequestArgs::dump_type) dump_type(
        const ::memory_instrumentation::mojom::blink::RequestArgsPtr& input)
    {
        return input->dump_type;
    }

    static decltype(::memory_instrumentation::mojom::blink::RequestArgs::level_of_detail) level_of_detail(
        const ::memory_instrumentation::mojom::blink::RequestArgsPtr& input)
    {
        return input->level_of_detail;
    }

    static decltype(::memory_instrumentation::mojom::blink::RequestArgs::determinism) determinism(
        const ::memory_instrumentation::mojom::blink::RequestArgsPtr& input)
    {
        return input->determinism;
    }

    static bool Read(::memory_instrumentation::mojom::blink::RequestArgs::DataView input, ::memory_instrumentation::mojom::blink::RequestArgsPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::RawAllocatorDumpEdge::DataView, ::memory_instrumentation::mojom::blink::RawAllocatorDumpEdgePtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEdgePtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::RawAllocatorDumpEdgePtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::RawAllocatorDumpEdge::source_id) source_id(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEdgePtr& input)
    {
        return input->source_id;
    }

    static decltype(::memory_instrumentation::mojom::blink::RawAllocatorDumpEdge::target_id) target_id(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEdgePtr& input)
    {
        return input->target_id;
    }

    static decltype(::memory_instrumentation::mojom::blink::RawAllocatorDumpEdge::importance) importance(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEdgePtr& input)
    {
        return input->importance;
    }

    static decltype(::memory_instrumentation::mojom::blink::RawAllocatorDumpEdge::overridable) overridable(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEdgePtr& input)
    {
        return input->overridable;
    }

    static bool Read(
        ::memory_instrumentation::mojom::blink::RawAllocatorDumpEdge::DataView input, ::memory_instrumentation::mojom::blink::RawAllocatorDumpEdgePtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::RawAllocatorDumpEntry::DataView, ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryPtr* output)
    {
        output->reset();
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawAllocatorDumpEntry::name)& name(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryPtr& input)
    {
        return input->name;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawAllocatorDumpEntry::units)& units(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryPtr& input)
    {
        return input->units;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawAllocatorDumpEntry::value)& value(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryPtr& input)
    {
        return input->value;
    }

    static bool Read(::memory_instrumentation::mojom::blink::RawAllocatorDumpEntry::DataView input,
        ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::RawAllocatorDump::DataView, ::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::RawAllocatorDump::id) id(const ::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr& input)
    {
        return input->id;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawAllocatorDump::absolute_name)& absolute_name(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr& input)
    {
        return input->absolute_name;
    }

    static decltype(::memory_instrumentation::mojom::blink::RawAllocatorDump::weak) weak(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr& input)
    {
        return input->weak;
    }

    static decltype(::memory_instrumentation::mojom::blink::RawAllocatorDump::level_of_detail) level_of_detail(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr& input)
    {
        return input->level_of_detail;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawAllocatorDump::entries)& entries(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr& input)
    {
        return input->entries;
    }

    static bool Read(
        ::memory_instrumentation::mojom::blink::RawAllocatorDump::DataView input, ::memory_instrumentation::mojom::blink::RawAllocatorDumpPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::RawProcessMemoryDump::DataView, ::memory_instrumentation::mojom::blink::RawProcessMemoryDumpPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::RawProcessMemoryDumpPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::RawProcessMemoryDumpPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::RawProcessMemoryDump::level_of_detail) level_of_detail(
        const ::memory_instrumentation::mojom::blink::RawProcessMemoryDumpPtr& input)
    {
        return input->level_of_detail;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawProcessMemoryDump::allocator_dump_edges)& allocator_dump_edges(
        const ::memory_instrumentation::mojom::blink::RawProcessMemoryDumpPtr& input)
    {
        return input->allocator_dump_edges;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawProcessMemoryDump::allocator_dumps)& allocator_dumps(
        const ::memory_instrumentation::mojom::blink::RawProcessMemoryDumpPtr& input)
    {
        return input->allocator_dumps;
    }

    static bool Read(
        ::memory_instrumentation::mojom::blink::RawProcessMemoryDump::DataView input, ::memory_instrumentation::mojom::blink::RawProcessMemoryDumpPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::VmRegion::DataView, ::memory_instrumentation::mojom::blink::VmRegionPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::VmRegionPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::start_address) start_address(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->start_address;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::size_in_bytes) size_in_bytes(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->size_in_bytes;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::module_timestamp) module_timestamp(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->module_timestamp;
    }

    static const decltype(::memory_instrumentation::mojom::blink::VmRegion::module_debugid)& module_debugid(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->module_debugid;
    }

    static const decltype(::memory_instrumentation::mojom::blink::VmRegion::module_debug_path)& module_debug_path(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->module_debug_path;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::protection_flags) protection_flags(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->protection_flags;
    }

    static const decltype(::memory_instrumentation::mojom::blink::VmRegion::mapped_file)& mapped_file(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->mapped_file;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::byte_stats_private_dirty_resident) byte_stats_private_dirty_resident(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->byte_stats_private_dirty_resident;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::byte_stats_private_clean_resident) byte_stats_private_clean_resident(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->byte_stats_private_clean_resident;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::byte_stats_shared_dirty_resident) byte_stats_shared_dirty_resident(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->byte_stats_shared_dirty_resident;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::byte_stats_shared_clean_resident) byte_stats_shared_clean_resident(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->byte_stats_shared_clean_resident;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::byte_stats_swapped) byte_stats_swapped(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->byte_stats_swapped;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::byte_locked) byte_locked(const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->byte_locked;
    }

    static decltype(::memory_instrumentation::mojom::blink::VmRegion::byte_stats_proportional_resident) byte_stats_proportional_resident(
        const ::memory_instrumentation::mojom::blink::VmRegionPtr& input)
    {
        return input->byte_stats_proportional_resident;
    }

    static bool Read(::memory_instrumentation::mojom::blink::VmRegion::DataView input, ::memory_instrumentation::mojom::blink::VmRegionPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) StructTraits<::memory_instrumentation::mojom::blink::PlatformPrivateFootprint::DataView,
    ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::PlatformPrivateFootprint::phys_footprint_bytes) phys_footprint_bytes(
        const ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr& input)
    {
        return input->phys_footprint_bytes;
    }

    static decltype(::memory_instrumentation::mojom::blink::PlatformPrivateFootprint::internal_bytes) internal_bytes(
        const ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr& input)
    {
        return input->internal_bytes;
    }

    static decltype(::memory_instrumentation::mojom::blink::PlatformPrivateFootprint::compressed_bytes) compressed_bytes(
        const ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr& input)
    {
        return input->compressed_bytes;
    }

    static decltype(::memory_instrumentation::mojom::blink::PlatformPrivateFootprint::rss_anon_bytes) rss_anon_bytes(
        const ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr& input)
    {
        return input->rss_anon_bytes;
    }

    static decltype(::memory_instrumentation::mojom::blink::PlatformPrivateFootprint::vm_swap_bytes) vm_swap_bytes(
        const ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr& input)
    {
        return input->vm_swap_bytes;
    }

    static decltype(::memory_instrumentation::mojom::blink::PlatformPrivateFootprint::private_bytes) private_bytes(
        const ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr& input)
    {
        return input->private_bytes;
    }

    static bool Read(::memory_instrumentation::mojom::blink::PlatformPrivateFootprint::DataView input,
        ::memory_instrumentation::mojom::blink::PlatformPrivateFootprintPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::RawOSMemDump::DataView, ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::RawOSMemDumpPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::RawOSMemDump::resident_set_kb) resident_set_kb(
        const ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr& input)
    {
        return input->resident_set_kb;
    }

    static decltype(::memory_instrumentation::mojom::blink::RawOSMemDump::peak_resident_set_kb) peak_resident_set_kb(
        const ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr& input)
    {
        return input->peak_resident_set_kb;
    }

    static decltype(::memory_instrumentation::mojom::blink::RawOSMemDump::is_peak_rss_resettable) is_peak_rss_resettable(
        const ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr& input)
    {
        return input->is_peak_rss_resettable;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawOSMemDump::platform_private_footprint)& platform_private_footprint(
        const ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr& input)
    {
        return input->platform_private_footprint;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawOSMemDump::memory_maps)& memory_maps(
        const ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr& input)
    {
        return input->memory_maps;
    }

    static const decltype(::memory_instrumentation::mojom::blink::RawOSMemDump::native_library_pages_bitmap)& native_library_pages_bitmap(
        const ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr& input)
    {
        return input->native_library_pages_bitmap;
    }

    static bool Read(::memory_instrumentation::mojom::blink::RawOSMemDump::DataView input, ::memory_instrumentation::mojom::blink::RawOSMemDumpPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::OSMemDump::DataView, ::memory_instrumentation::mojom::blink::OSMemDumpPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::OSMemDumpPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::OSMemDumpPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::OSMemDump::resident_set_kb) resident_set_kb(
        const ::memory_instrumentation::mojom::blink::OSMemDumpPtr& input)
    {
        return input->resident_set_kb;
    }

    static decltype(::memory_instrumentation::mojom::blink::OSMemDump::peak_resident_set_kb) peak_resident_set_kb(
        const ::memory_instrumentation::mojom::blink::OSMemDumpPtr& input)
    {
        return input->peak_resident_set_kb;
    }

    static decltype(::memory_instrumentation::mojom::blink::OSMemDump::is_peak_rss_resettable) is_peak_rss_resettable(
        const ::memory_instrumentation::mojom::blink::OSMemDumpPtr& input)
    {
        return input->is_peak_rss_resettable;
    }

    static decltype(::memory_instrumentation::mojom::blink::OSMemDump::private_footprint_kb) private_footprint_kb(
        const ::memory_instrumentation::mojom::blink::OSMemDumpPtr& input)
    {
        return input->private_footprint_kb;
    }

    static decltype(::memory_instrumentation::mojom::blink::OSMemDump::shared_footprint_kb) shared_footprint_kb(
        const ::memory_instrumentation::mojom::blink::OSMemDumpPtr& input)
    {
        return input->shared_footprint_kb;
    }

    static bool Read(::memory_instrumentation::mojom::blink::OSMemDump::DataView input, ::memory_instrumentation::mojom::blink::OSMemDumpPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::AllocatorMemDump::DataView, ::memory_instrumentation::mojom::blink::AllocatorMemDumpPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::AllocatorMemDumpPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::AllocatorMemDumpPtr* output)
    {
        output->reset();
    }

    static const decltype(::memory_instrumentation::mojom::blink::AllocatorMemDump::numeric_entries)& numeric_entries(
        const ::memory_instrumentation::mojom::blink::AllocatorMemDumpPtr& input)
    {
        return input->numeric_entries;
    }

    static const decltype(::memory_instrumentation::mojom::blink::AllocatorMemDump::children)& children(
        const ::memory_instrumentation::mojom::blink::AllocatorMemDumpPtr& input)
    {
        return input->children;
    }

    static bool Read(
        ::memory_instrumentation::mojom::blink::AllocatorMemDump::DataView input, ::memory_instrumentation::mojom::blink::AllocatorMemDumpPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::ProcessMemoryDump::DataView, ::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::ProcessMemoryDump::process_type) process_type(
        const ::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr& input)
    {
        return input->process_type;
    }

    static const decltype(::memory_instrumentation::mojom::blink::ProcessMemoryDump::os_dump)& os_dump(
        const ::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr& input)
    {
        return input->os_dump;
    }

    static const decltype(::memory_instrumentation::mojom::blink::ProcessMemoryDump::chrome_allocator_dumps)& chrome_allocator_dumps(
        const ::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr& input)
    {
        return input->chrome_allocator_dumps;
    }

    static const decltype(::memory_instrumentation::mojom::blink::ProcessMemoryDump::pid)& pid(
        const ::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr& input)
    {
        return input->pid;
    }

    static const decltype(::memory_instrumentation::mojom::blink::ProcessMemoryDump::service_name)& service_name(
        const ::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr& input)
    {
        return input->service_name;
    }

    static bool Read(
        ::memory_instrumentation::mojom::blink::ProcessMemoryDump::DataView input, ::memory_instrumentation::mojom::blink::ProcessMemoryDumpPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::AggregatedMetrics::DataView, ::memory_instrumentation::mojom::blink::AggregatedMetricsPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::AggregatedMetricsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::AggregatedMetricsPtr* output)
    {
        output->reset();
    }

    static decltype(::memory_instrumentation::mojom::blink::AggregatedMetrics::native_library_resident_kb) native_library_resident_kb(
        const ::memory_instrumentation::mojom::blink::AggregatedMetricsPtr& input)
    {
        return input->native_library_resident_kb;
    }

    static decltype(::memory_instrumentation::mojom::blink::AggregatedMetrics::native_library_resident_not_ordered_kb) native_library_resident_not_ordered_kb(
        const ::memory_instrumentation::mojom::blink::AggregatedMetricsPtr& input)
    {
        return input->native_library_resident_not_ordered_kb;
    }

    static decltype(::memory_instrumentation::mojom::blink::AggregatedMetrics::native_library_not_resident_ordered_kb) native_library_not_resident_ordered_kb(
        const ::memory_instrumentation::mojom::blink::AggregatedMetricsPtr& input)
    {
        return input->native_library_not_resident_ordered_kb;
    }

    static bool Read(
        ::memory_instrumentation::mojom::blink::AggregatedMetrics::DataView input, ::memory_instrumentation::mojom::blink::AggregatedMetricsPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::GlobalMemoryDump::DataView, ::memory_instrumentation::mojom::blink::GlobalMemoryDumpPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::GlobalMemoryDumpPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::GlobalMemoryDumpPtr* output)
    {
        output->reset();
    }

    static const decltype(::memory_instrumentation::mojom::blink::GlobalMemoryDump::start_time)& start_time(
        const ::memory_instrumentation::mojom::blink::GlobalMemoryDumpPtr& input)
    {
        return input->start_time;
    }

    static const decltype(::memory_instrumentation::mojom::blink::GlobalMemoryDump::process_dumps)& process_dumps(
        const ::memory_instrumentation::mojom::blink::GlobalMemoryDumpPtr& input)
    {
        return input->process_dumps;
    }

    static const decltype(::memory_instrumentation::mojom::blink::GlobalMemoryDump::aggregated_metrics)& aggregated_metrics(
        const ::memory_instrumentation::mojom::blink::GlobalMemoryDumpPtr& input)
    {
        return input->aggregated_metrics;
    }

    static bool Read(
        ::memory_instrumentation::mojom::blink::GlobalMemoryDump::DataView input, ::memory_instrumentation::mojom::blink::GlobalMemoryDumpPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK)
    StructTraits<::memory_instrumentation::mojom::blink::HeapProfileResult::DataView, ::memory_instrumentation::mojom::blink::HeapProfileResultPtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::HeapProfileResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::HeapProfileResultPtr* output)
    {
        output->reset();
    }

    static const decltype(::memory_instrumentation::mojom::blink::HeapProfileResult::pid)& pid(
        const ::memory_instrumentation::mojom::blink::HeapProfileResultPtr& input)
    {
        return input->pid;
    }

    static decltype(::memory_instrumentation::mojom::blink::HeapProfileResult::json)& json(::memory_instrumentation::mojom::blink::HeapProfileResultPtr& input)
    {
        return input->json;
    }

    static bool Read(
        ::memory_instrumentation::mojom::blink::HeapProfileResult::DataView input, ::memory_instrumentation::mojom::blink::HeapProfileResultPtr* output);
};

template <>
struct COMPONENT_EXPORT(RESOURCE_COORDINATOR_PUBLIC_MOJOM_BLINK) UnionTraits<::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValue::DataView,
    ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValuePtr> {
    static bool IsNull(const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValuePtr& input)
    {
        return !input;
    }
    static void SetToNull(::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValuePtr* output)
    {
        output->reset();
    }

    static ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValue::Tag GetTag(
        const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValuePtr& input)
    {
        return input->which();
    }

    static uint64_t value_uint64(const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValuePtr& input)
    {
        return input->get_value_uint64();
    }

    static const WTF::String& value_string(const ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValuePtr& input)
    {
        return input->get_value_string();
    }

    static bool Read(::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValue::DataView input,
        ::memory_instrumentation::mojom::blink::RawAllocatorDumpEntryValuePtr* output);
};

} // namespace mojo

#endif // SERVICES_RESOURCE_COORDINATOR_PUBLIC_MOJOM_MEMORY_INSTRUMENTATION_MEMORY_INSTRUMENTATION_MOJOM_BLINK_H_
