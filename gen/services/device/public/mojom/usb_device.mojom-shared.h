// services/device/public/mojom/usb_device.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_DEVICE_PUBLIC_MOJOM_USB_DEVICE_MOJOM_SHARED_H_
#define SERVICES_DEVICE_PUBLIC_MOJOM_USB_DEVICE_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/device/public/mojom/usb_device.mojom-shared-internal.h"
#include "mojo/public/mojom/base/read_only_buffer.mojom-shared.h"
#include "mojo/public/mojom/base/string16.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

namespace device::mojom {
class UsbEndpointInfoDataView;

class UsbAlternateInterfaceInfoDataView;

class UsbInterfaceInfoDataView;

class UsbConfigurationInfoDataView;

class UsbDeviceInfoDataView;

class UsbControlTransferParamsDataView;

class UsbIsochronousPacketDataView;

class UsbOpenDeviceResultDataView;

} // device::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::device::mojom::UsbEndpointInfoDataView> {
    using Data = ::device::mojom::internal::UsbEndpointInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device::mojom::UsbAlternateInterfaceInfoDataView> {
    using Data = ::device::mojom::internal::UsbAlternateInterfaceInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device::mojom::UsbInterfaceInfoDataView> {
    using Data = ::device::mojom::internal::UsbInterfaceInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device::mojom::UsbConfigurationInfoDataView> {
    using Data = ::device::mojom::internal::UsbConfigurationInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device::mojom::UsbDeviceInfoDataView> {
    using Data = ::device::mojom::internal::UsbDeviceInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device::mojom::UsbControlTransferParamsDataView> {
    using Data = ::device::mojom::internal::UsbControlTransferParams_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device::mojom::UsbIsochronousPacketDataView> {
    using Data = ::device::mojom::internal::UsbIsochronousPacket_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::device::mojom::UsbOpenDeviceResultDataView> {
    using Data = ::device::mojom::internal::UsbOpenDeviceResult_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

} // namespace internal
} // namespace mojo

namespace device::mojom {

enum class UsbOpenDeviceSuccess : int32_t {

    OK = 0,
    kMinValue = 0,
    kMaxValue = 0,
};

std::ostream& operator<<(std::ostream& os, UsbOpenDeviceSuccess value);
inline bool IsKnownEnumValue(UsbOpenDeviceSuccess value)
{
    return internal::UsbOpenDeviceSuccess_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbOpenDeviceError : int32_t {

    ACCESS_DENIED = 0,

    ALREADY_OPEN = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

std::ostream& operator<<(std::ostream& os, UsbOpenDeviceError value);
inline bool IsKnownEnumValue(UsbOpenDeviceError value)
{
    return internal::UsbOpenDeviceError_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbClaimInterfaceResult : int32_t {

    kSuccess = 0,

    kProtectedClass = 1,

    kFailure = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, UsbClaimInterfaceResult value);
inline bool IsKnownEnumValue(UsbClaimInterfaceResult value)
{
    return internal::UsbClaimInterfaceResult_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbTransferDirection : int32_t {

    INBOUND = 0,

    OUTBOUND = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

std::ostream& operator<<(std::ostream& os, UsbTransferDirection value);
inline bool IsKnownEnumValue(UsbTransferDirection value)
{
    return internal::UsbTransferDirection_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbControlTransferType : int32_t {

    STANDARD = 0,

    CLASS = 1,

    VENDOR = 2,

    RESERVED = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, UsbControlTransferType value);
inline bool IsKnownEnumValue(UsbControlTransferType value)
{
    return internal::UsbControlTransferType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbControlTransferRecipient : int32_t {

    DEVICE = 0,

    INTERFACE = 1,

    ENDPOINT = 2,

    OTHER = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, UsbControlTransferRecipient value);
inline bool IsKnownEnumValue(UsbControlTransferRecipient value)
{
    return internal::UsbControlTransferRecipient_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbTransferType : int32_t {

    CONTROL = 0,

    ISOCHRONOUS = 1,

    BULK = 2,

    INTERRUPT = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, UsbTransferType value);
inline bool IsKnownEnumValue(UsbTransferType value)
{
    return internal::UsbTransferType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbSynchronizationType : int32_t {

    NONE = 0,

    ASYNCHRONOUS = 1,

    ADAPTIVE = 2,

    SYNCHRONOUS = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, UsbSynchronizationType value);
inline bool IsKnownEnumValue(UsbSynchronizationType value)
{
    return internal::UsbSynchronizationType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbUsageType : int32_t {

    DATA = 0,

    FEEDBACK = 1,

    EXPLICIT_FEEDBACK = 2,

    PERIODIC = 3,

    NOTIFICATION = 4,

    RESERVED = 5,
    kMinValue = 0,
    kMaxValue = 5,
};

std::ostream& operator<<(std::ostream& os, UsbUsageType value);
inline bool IsKnownEnumValue(UsbUsageType value)
{
    return internal::UsbUsageType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class UsbTransferStatus : int32_t {

    COMPLETED = 0,

    TRANSFER_ERROR = 1,

    TIMEOUT = 2,

    CANCELLED = 3,

    STALLED = 4,

    DISCONNECT = 5,

    BABBLE = 6,

    SHORT_PACKET = 7,

    PERMISSION_DENIED = 8,
    kMinValue = 0,
    kMaxValue = 8,
};

std::ostream& operator<<(std::ostream& os, UsbTransferStatus value);
inline bool IsKnownEnumValue(UsbTransferStatus value)
{
    return internal::UsbTransferStatus_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class UsbDeviceInterfaceBase { };

using UsbDevicePtrDataView = mojo::InterfacePtrDataView<UsbDeviceInterfaceBase>;
using UsbDeviceRequestDataView = mojo::InterfaceRequestDataView<UsbDeviceInterfaceBase>;
using UsbDeviceAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<UsbDeviceInterfaceBase>;
using UsbDeviceAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<UsbDeviceInterfaceBase>;
class UsbDeviceClientInterfaceBase { };

using UsbDeviceClientPtrDataView = mojo::InterfacePtrDataView<UsbDeviceClientInterfaceBase>;
using UsbDeviceClientRequestDataView = mojo::InterfaceRequestDataView<UsbDeviceClientInterfaceBase>;
using UsbDeviceClientAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<UsbDeviceClientInterfaceBase>;
using UsbDeviceClientAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<UsbDeviceClientInterfaceBase>;

class UsbEndpointInfoDataView {
public:
    UsbEndpointInfoDataView() = default;

    UsbEndpointInfoDataView(internal::UsbEndpointInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint8_t endpoint_number() const
    {
        return data_->endpoint_number;
    }
    template <typename UserType> [[nodiscard]] bool ReadDirection(UserType* output) const
    {
        auto data_value = data_->direction;
        return mojo::internal::Deserialize<::device::mojom::UsbTransferDirection>(data_value, output);
    }
    UsbTransferDirection direction() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbTransferDirection>(data_->direction));
    }
    template <typename UserType> [[nodiscard]] bool ReadType(UserType* output) const
    {
        auto data_value = data_->type;
        return mojo::internal::Deserialize<::device::mojom::UsbTransferType>(data_value, output);
    }
    UsbTransferType type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbTransferType>(data_->type));
    }
    uint32_t packet_size() const
    {
        return data_->packet_size;
    }
    template <typename UserType> [[nodiscard]] bool ReadSynchronizationType(UserType* output) const
    {
        auto data_value = data_->synchronization_type;
        return mojo::internal::Deserialize<::device::mojom::UsbSynchronizationType>(data_value, output);
    }
    UsbSynchronizationType synchronization_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbSynchronizationType>(data_->synchronization_type));
    }
    template <typename UserType> [[nodiscard]] bool ReadUsageType(UserType* output) const
    {
        auto data_value = data_->usage_type;
        return mojo::internal::Deserialize<::device::mojom::UsbUsageType>(data_value, output);
    }
    UsbUsageType usage_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbUsageType>(data_->usage_type));
    }
    uint8_t polling_interval() const
    {
        return data_->polling_interval;
    }
    inline void GetExtraDataDataView(mojo::ArrayDataView<uint8_t>* output);

    template <typename UserType> [[nodiscard]] bool ReadExtraData(UserType* output)
    {

        auto* pointer = data_->extra_data.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(pointer, output, message_);
    }

private:
    internal::UsbEndpointInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class UsbAlternateInterfaceInfoDataView {
public:
    UsbAlternateInterfaceInfoDataView() = default;

    UsbAlternateInterfaceInfoDataView(internal::UsbAlternateInterfaceInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint8_t alternate_setting() const
    {
        return data_->alternate_setting;
    }
    uint8_t class_code() const
    {
        return data_->class_code;
    }
    uint8_t subclass_code() const
    {
        return data_->subclass_code;
    }
    uint8_t protocol_code() const
    {
        return data_->protocol_code;
    }
    inline void GetInterfaceNameDataView(::mojo_base::mojom::String16DataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInterfaceName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::String16DataView, UserType>(),
            "Attempting to read the optional `interface_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadInterfaceName` instead "
            "of `ReadInterfaceName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->interface_name.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(pointer, output, message_);
    }
    inline void GetEndpointsDataView(mojo::ArrayDataView<UsbEndpointInfoDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadEndpoints(UserType* output)
    {

        auto* pointer = data_->endpoints.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::device::mojom::UsbEndpointInfoDataView>>(pointer, output, message_);
    }
    inline void GetExtraDataDataView(mojo::ArrayDataView<uint8_t>* output);

    template <typename UserType> [[nodiscard]] bool ReadExtraData(UserType* output)
    {

        auto* pointer = data_->extra_data.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(pointer, output, message_);
    }

private:
    internal::UsbAlternateInterfaceInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class UsbInterfaceInfoDataView {
public:
    UsbInterfaceInfoDataView() = default;

    UsbInterfaceInfoDataView(internal::UsbInterfaceInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint8_t interface_number() const
    {
        return data_->interface_number;
    }
    uint8_t first_interface() const
    {
        return data_->first_interface;
    }
    inline void GetAlternatesDataView(mojo::ArrayDataView<UsbAlternateInterfaceInfoDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadAlternates(UserType* output)
    {

        auto* pointer = data_->alternates.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::device::mojom::UsbAlternateInterfaceInfoDataView>>(pointer, output, message_);
    }

private:
    internal::UsbInterfaceInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class UsbConfigurationInfoDataView {
public:
    UsbConfigurationInfoDataView() = default;

    UsbConfigurationInfoDataView(internal::UsbConfigurationInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint8_t configuration_value() const
    {
        return data_->configuration_value;
    }
    inline void GetConfigurationNameDataView(::mojo_base::mojom::String16DataView* output);

    template <typename UserType> [[nodiscard]] bool ReadConfigurationName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::String16DataView, UserType>(),
            "Attempting to read the optional `configuration_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadConfigurationName` instead "
            "of `ReadConfigurationName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->configuration_name.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(pointer, output, message_);
    }
    bool self_powered() const
    {
        return data_->self_powered;
    }
    bool remote_wakeup() const
    {
        return data_->remote_wakeup;
    }
    uint8_t maximum_power() const
    {
        return data_->maximum_power;
    }
    inline void GetInterfacesDataView(mojo::ArrayDataView<UsbInterfaceInfoDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadInterfaces(UserType* output)
    {

        auto* pointer = data_->interfaces.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::device::mojom::UsbInterfaceInfoDataView>>(pointer, output, message_);
    }
    inline void GetExtraDataDataView(mojo::ArrayDataView<uint8_t>* output);

    template <typename UserType> [[nodiscard]] bool ReadExtraData(UserType* output)
    {

        auto* pointer = data_->extra_data.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(pointer, output, message_);
    }

private:
    internal::UsbConfigurationInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class UsbDeviceInfoDataView {
public:
    UsbDeviceInfoDataView() = default;

    UsbDeviceInfoDataView(internal::UsbDeviceInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetGuidDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadGuid(UserType* output)
    {

        auto* pointer = data_->guid.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    uint8_t usb_version_major() const
    {
        return data_->usb_version_major;
    }
    uint8_t usb_version_minor() const
    {
        return data_->usb_version_minor;
    }
    uint8_t usb_version_subminor() const
    {
        return data_->usb_version_subminor;
    }
    uint8_t class_code() const
    {
        return data_->class_code;
    }
    uint8_t subclass_code() const
    {
        return data_->subclass_code;
    }
    uint8_t protocol_code() const
    {
        return data_->protocol_code;
    }
    uint32_t bus_number() const
    {
        return data_->bus_number;
    }
    uint32_t port_number() const
    {
        return data_->port_number;
    }
    uint16_t vendor_id() const
    {
        return data_->vendor_id;
    }
    uint16_t product_id() const
    {
        return data_->product_id;
    }
    uint8_t device_version_major() const
    {
        return data_->device_version_major;
    }
    uint8_t device_version_minor() const
    {
        return data_->device_version_minor;
    }
    uint8_t device_version_subminor() const
    {
        return data_->device_version_subminor;
    }
    inline void GetManufacturerNameDataView(::mojo_base::mojom::String16DataView* output);

    template <typename UserType> [[nodiscard]] bool ReadManufacturerName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::String16DataView, UserType>(),
            "Attempting to read the optional `manufacturer_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadManufacturerName` instead "
            "of `ReadManufacturerName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->manufacturer_name.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(pointer, output, message_);
    }
    inline void GetProductNameDataView(::mojo_base::mojom::String16DataView* output);

    template <typename UserType> [[nodiscard]] bool ReadProductName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::String16DataView, UserType>(),
            "Attempting to read the optional `product_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadProductName` instead "
            "of `ReadProductName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->product_name.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(pointer, output, message_);
    }
    inline void GetSerialNumberDataView(::mojo_base::mojom::String16DataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSerialNumber(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::String16DataView, UserType>(),
            "Attempting to read the optional `serial_number` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSerialNumber` instead "
            "of `ReadSerialNumber if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->serial_number.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(pointer, output, message_);
    }
    inline void GetWebusbLandingPageDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadWebusbLandingPage(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::url::mojom::UrlDataView, UserType>(),
            "Attempting to read the optional `webusb_landing_page` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadWebusbLandingPage` instead "
            "of `ReadWebusbLandingPage if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->webusb_landing_page.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    uint8_t active_configuration() const
    {
        return data_->active_configuration;
    }
    inline void GetConfigurationsDataView(mojo::ArrayDataView<UsbConfigurationInfoDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadConfigurations(UserType* output)
    {

        auto* pointer = data_->configurations.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::device::mojom::UsbConfigurationInfoDataView>>(pointer, output, message_);
    }

private:
    internal::UsbDeviceInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class UsbControlTransferParamsDataView {
public:
    UsbControlTransferParamsDataView() = default;

    UsbControlTransferParamsDataView(internal::UsbControlTransferParams_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadType(UserType* output) const
    {
        auto data_value = data_->type;
        return mojo::internal::Deserialize<::device::mojom::UsbControlTransferType>(data_value, output);
    }
    UsbControlTransferType type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbControlTransferType>(data_->type));
    }
    template <typename UserType> [[nodiscard]] bool ReadRecipient(UserType* output) const
    {
        auto data_value = data_->recipient;
        return mojo::internal::Deserialize<::device::mojom::UsbControlTransferRecipient>(data_value, output);
    }
    UsbControlTransferRecipient recipient() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbControlTransferRecipient>(data_->recipient));
    }
    uint8_t request() const
    {
        return data_->request;
    }
    uint16_t value() const
    {
        return data_->value;
    }
    uint16_t index() const
    {
        return data_->index;
    }

private:
    internal::UsbControlTransferParams_Data* data_ = nullptr;
};

class UsbIsochronousPacketDataView {
public:
    UsbIsochronousPacketDataView() = default;

    UsbIsochronousPacketDataView(internal::UsbIsochronousPacket_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t length() const
    {
        return data_->length;
    }
    uint32_t transferred_length() const
    {
        return data_->transferred_length;
    }
    template <typename UserType> [[nodiscard]] bool ReadStatus(UserType* output) const
    {
        auto data_value = data_->status;
        return mojo::internal::Deserialize<::device::mojom::UsbTransferStatus>(data_value, output);
    }
    UsbTransferStatus status() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbTransferStatus>(data_->status));
    }

private:
    internal::UsbIsochronousPacket_Data* data_ = nullptr;
};

class UsbOpenDeviceResultDataView {
public:
    using Tag = internal::UsbOpenDeviceResult_Data::UsbOpenDeviceResult_Tag;

    UsbOpenDeviceResultDataView() = default;

    UsbOpenDeviceResultDataView(internal::UsbOpenDeviceResult_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_success() const
    {
        return data_->tag == Tag::kSuccess;
    }
    template <typename UserType> [[nodiscard]] bool ReadSuccess(UserType* output) const
    {
        CHECK(is_success());
        return mojo::internal::Deserialize<::device::mojom::UsbOpenDeviceSuccess>(data_->data.f_success, output);
    }
    UsbOpenDeviceSuccess success() const
    {
        CHECK(is_success());
        // TODO(dcheng): This seems incorrect, as it bypasses enum traits.
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbOpenDeviceSuccess>(data_->data.f_success));
    }
    bool is_error() const
    {
        return data_->tag == Tag::kError;
    }
    template <typename UserType> [[nodiscard]] bool ReadError(UserType* output) const
    {
        CHECK(is_error());
        return mojo::internal::Deserialize<::device::mojom::UsbOpenDeviceError>(data_->data.f_error, output);
    }
    UsbOpenDeviceError error() const
    {
        CHECK(is_error());
        // TODO(dcheng): This seems incorrect, as it bypasses enum traits.
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbOpenDeviceError>(data_->data.f_error));
    }

private:
    internal::UsbOpenDeviceResult_Data* data_ = nullptr;
};

} // device::mojom

namespace std {

template <> struct hash<::device::mojom::UsbOpenDeviceSuccess> : public mojo::internal::EnumHashImpl<::device::mojom::UsbOpenDeviceSuccess> { };

template <> struct hash<::device::mojom::UsbOpenDeviceError> : public mojo::internal::EnumHashImpl<::device::mojom::UsbOpenDeviceError> { };

template <> struct hash<::device::mojom::UsbClaimInterfaceResult> : public mojo::internal::EnumHashImpl<::device::mojom::UsbClaimInterfaceResult> { };

template <> struct hash<::device::mojom::UsbTransferDirection> : public mojo::internal::EnumHashImpl<::device::mojom::UsbTransferDirection> { };

template <> struct hash<::device::mojom::UsbControlTransferType> : public mojo::internal::EnumHashImpl<::device::mojom::UsbControlTransferType> { };

template <> struct hash<::device::mojom::UsbControlTransferRecipient> : public mojo::internal::EnumHashImpl<::device::mojom::UsbControlTransferRecipient> { };

template <> struct hash<::device::mojom::UsbTransferType> : public mojo::internal::EnumHashImpl<::device::mojom::UsbTransferType> { };

template <> struct hash<::device::mojom::UsbSynchronizationType> : public mojo::internal::EnumHashImpl<::device::mojom::UsbSynchronizationType> { };

template <> struct hash<::device::mojom::UsbUsageType> : public mojo::internal::EnumHashImpl<::device::mojom::UsbUsageType> { };

template <> struct hash<::device::mojom::UsbTransferStatus> : public mojo::internal::EnumHashImpl<::device::mojom::UsbTransferStatus> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbOpenDeviceSuccess, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbOpenDeviceSuccess, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbOpenDeviceSuccess>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbOpenDeviceError, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbOpenDeviceError, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbOpenDeviceError>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbClaimInterfaceResult, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbClaimInterfaceResult, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbClaimInterfaceResult>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbTransferDirection, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbTransferDirection, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbTransferDirection>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbControlTransferType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbControlTransferType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbControlTransferType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbControlTransferRecipient, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbControlTransferRecipient, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbControlTransferRecipient>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbTransferType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbTransferType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbTransferType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbSynchronizationType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbSynchronizationType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbSynchronizationType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbUsageType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbUsageType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbUsageType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbTransferStatus, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::device::mojom::UsbTransferStatus, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::device::mojom::UsbTransferStatus>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbEndpointInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device::mojom::UsbEndpointInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device::mojom::internal::UsbEndpointInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->endpoint_number = Traits::endpoint_number(input);
        mojo::internal::Serialize<::device::mojom::UsbTransferDirection>(Traits::direction(input), &fragment->direction);
        mojo::internal::Serialize<::device::mojom::UsbTransferType>(Traits::type(input), &fragment->type);
        fragment->packet_size = Traits::packet_size(input);
        mojo::internal::Serialize<::device::mojom::UsbSynchronizationType>(Traits::synchronization_type(input), &fragment->synchronization_type);
        mojo::internal::Serialize<::device::mojom::UsbUsageType>(Traits::usage_type(input), &fragment->usage_type);
        fragment->polling_interval = Traits::polling_interval(input);
        decltype(Traits::extra_data(input)) in_extra_data = Traits::extra_data(input);
        mojo::internal::MessageFragment<typename decltype(fragment->extra_data)::BaseType> extra_data_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& extra_data_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(in_extra_data, extra_data_fragment, &extra_data_validate_params);
        fragment->extra_data.Set(extra_data_fragment.is_null() ? nullptr : extra_data_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->extra_data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null extra_data in UsbEndpointInfo struct");
    }

    static bool Deserialize(::device::mojom::internal::UsbEndpointInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device::mojom::UsbEndpointInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbAlternateInterfaceInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device::mojom::UsbAlternateInterfaceInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device::mojom::internal::UsbAlternateInterfaceInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->alternate_setting = Traits::alternate_setting(input);
        fragment->class_code = Traits::class_code(input);
        fragment->subclass_code = Traits::subclass_code(input);
        fragment->protocol_code = Traits::protocol_code(input);
        decltype(Traits::interface_name(input)) in_interface_name = Traits::interface_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->interface_name)::BaseType> interface_name_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_interface_name, interface_name_fragment);
        fragment->interface_name.Set(interface_name_fragment.is_null() ? nullptr : interface_name_fragment.data());
        decltype(Traits::endpoints(input)) in_endpoints = Traits::endpoints(input);
        mojo::internal::MessageFragment<typename decltype(fragment->endpoints)::BaseType> endpoints_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& endpoints_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::UsbEndpointInfoDataView>>(in_endpoints, endpoints_fragment, &endpoints_validate_params);
        fragment->endpoints.Set(endpoints_fragment.is_null() ? nullptr : endpoints_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->endpoints.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null endpoints in UsbAlternateInterfaceInfo struct");
        decltype(Traits::extra_data(input)) in_extra_data = Traits::extra_data(input);
        mojo::internal::MessageFragment<typename decltype(fragment->extra_data)::BaseType> extra_data_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& extra_data_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(in_extra_data, extra_data_fragment, &extra_data_validate_params);
        fragment->extra_data.Set(extra_data_fragment.is_null() ? nullptr : extra_data_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->extra_data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null extra_data in UsbAlternateInterfaceInfo struct");
    }

    static bool Deserialize(::device::mojom::internal::UsbAlternateInterfaceInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device::mojom::UsbAlternateInterfaceInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbInterfaceInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device::mojom::UsbInterfaceInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device::mojom::internal::UsbInterfaceInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->interface_number = Traits::interface_number(input);
        fragment->first_interface = Traits::first_interface(input);
        decltype(Traits::alternates(input)) in_alternates = Traits::alternates(input);
        mojo::internal::MessageFragment<typename decltype(fragment->alternates)::BaseType> alternates_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& alternates_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::UsbAlternateInterfaceInfoDataView>>(
            in_alternates, alternates_fragment, &alternates_validate_params);
        fragment->alternates.Set(alternates_fragment.is_null() ? nullptr : alternates_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->alternates.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null alternates in UsbInterfaceInfo struct");
    }

    static bool Deserialize(::device::mojom::internal::UsbInterfaceInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device::mojom::UsbInterfaceInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbConfigurationInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device::mojom::UsbConfigurationInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device::mojom::internal::UsbConfigurationInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->configuration_value = Traits::configuration_value(input);
        decltype(Traits::configuration_name(input)) in_configuration_name = Traits::configuration_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->configuration_name)::BaseType> configuration_name_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_configuration_name, configuration_name_fragment);
        fragment->configuration_name.Set(configuration_name_fragment.is_null() ? nullptr : configuration_name_fragment.data());
        fragment->self_powered = Traits::self_powered(input);
        fragment->remote_wakeup = Traits::remote_wakeup(input);
        fragment->maximum_power = Traits::maximum_power(input);
        decltype(Traits::interfaces(input)) in_interfaces = Traits::interfaces(input);
        mojo::internal::MessageFragment<typename decltype(fragment->interfaces)::BaseType> interfaces_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& interfaces_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::UsbInterfaceInfoDataView>>(
            in_interfaces, interfaces_fragment, &interfaces_validate_params);
        fragment->interfaces.Set(interfaces_fragment.is_null() ? nullptr : interfaces_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->interfaces.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null interfaces in UsbConfigurationInfo struct");
        decltype(Traits::extra_data(input)) in_extra_data = Traits::extra_data(input);
        mojo::internal::MessageFragment<typename decltype(fragment->extra_data)::BaseType> extra_data_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& extra_data_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(in_extra_data, extra_data_fragment, &extra_data_validate_params);
        fragment->extra_data.Set(extra_data_fragment.is_null() ? nullptr : extra_data_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->extra_data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null extra_data in UsbConfigurationInfo struct");
    }

    static bool Deserialize(::device::mojom::internal::UsbConfigurationInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device::mojom::UsbConfigurationInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbDeviceInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device::mojom::UsbDeviceInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device::mojom::internal::UsbDeviceInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::guid(input)) in_guid = Traits::guid(input);
        mojo::internal::MessageFragment<typename decltype(fragment->guid)::BaseType> guid_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_guid, guid_fragment);
        fragment->guid.Set(guid_fragment.is_null() ? nullptr : guid_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->guid.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null guid in UsbDeviceInfo struct");
        fragment->usb_version_major = Traits::usb_version_major(input);
        fragment->usb_version_minor = Traits::usb_version_minor(input);
        fragment->usb_version_subminor = Traits::usb_version_subminor(input);
        fragment->class_code = Traits::class_code(input);
        fragment->subclass_code = Traits::subclass_code(input);
        fragment->protocol_code = Traits::protocol_code(input);
        fragment->bus_number = Traits::bus_number(input);
        fragment->port_number = Traits::port_number(input);
        fragment->vendor_id = Traits::vendor_id(input);
        fragment->product_id = Traits::product_id(input);
        fragment->device_version_major = Traits::device_version_major(input);
        fragment->device_version_minor = Traits::device_version_minor(input);
        fragment->device_version_subminor = Traits::device_version_subminor(input);
        decltype(Traits::manufacturer_name(input)) in_manufacturer_name = Traits::manufacturer_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->manufacturer_name)::BaseType> manufacturer_name_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_manufacturer_name, manufacturer_name_fragment);
        fragment->manufacturer_name.Set(manufacturer_name_fragment.is_null() ? nullptr : manufacturer_name_fragment.data());
        decltype(Traits::product_name(input)) in_product_name = Traits::product_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->product_name)::BaseType> product_name_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_product_name, product_name_fragment);
        fragment->product_name.Set(product_name_fragment.is_null() ? nullptr : product_name_fragment.data());
        decltype(Traits::serial_number(input)) in_serial_number = Traits::serial_number(input);
        mojo::internal::MessageFragment<typename decltype(fragment->serial_number)::BaseType> serial_number_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(in_serial_number, serial_number_fragment);
        fragment->serial_number.Set(serial_number_fragment.is_null() ? nullptr : serial_number_fragment.data());
        decltype(Traits::webusb_landing_page(input)) in_webusb_landing_page = Traits::webusb_landing_page(input);
        mojo::internal::MessageFragment<typename decltype(fragment->webusb_landing_page)::BaseType> webusb_landing_page_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_webusb_landing_page, webusb_landing_page_fragment);
        fragment->webusb_landing_page.Set(webusb_landing_page_fragment.is_null() ? nullptr : webusb_landing_page_fragment.data());
        fragment->active_configuration = Traits::active_configuration(input);
        decltype(Traits::configurations(input)) in_configurations = Traits::configurations(input);
        mojo::internal::MessageFragment<typename decltype(fragment->configurations)::BaseType> configurations_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& configurations_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::device::mojom::UsbConfigurationInfoDataView>>(
            in_configurations, configurations_fragment, &configurations_validate_params);
        fragment->configurations.Set(configurations_fragment.is_null() ? nullptr : configurations_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->configurations.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null configurations in UsbDeviceInfo struct");
    }

    static bool Deserialize(::device::mojom::internal::UsbDeviceInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device::mojom::UsbDeviceInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbControlTransferParamsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device::mojom::UsbControlTransferParamsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device::mojom::internal::UsbControlTransferParams_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::device::mojom::UsbControlTransferType>(Traits::type(input), &fragment->type);
        mojo::internal::Serialize<::device::mojom::UsbControlTransferRecipient>(Traits::recipient(input), &fragment->recipient);
        fragment->request = Traits::request(input);
        fragment->value = Traits::value(input);
        fragment->index = Traits::index(input);
    }

    static bool Deserialize(::device::mojom::internal::UsbControlTransferParams_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device::mojom::UsbControlTransferParamsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbIsochronousPacketDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::device::mojom::UsbIsochronousPacketDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::device::mojom::internal::UsbIsochronousPacket_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->length = Traits::length(input);
        fragment->transferred_length = Traits::transferred_length(input);
        mojo::internal::Serialize<::device::mojom::UsbTransferStatus>(Traits::status(input), &fragment->status);
    }

    static bool Deserialize(::device::mojom::internal::UsbIsochronousPacket_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::device::mojom::UsbIsochronousPacketDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::device::mojom::UsbOpenDeviceResultDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::device::mojom::UsbOpenDeviceResultDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::device::mojom::internal::UsbOpenDeviceResult_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::device::mojom::UsbOpenDeviceResultDataView::Tag::kSuccess: {
            decltype(Traits::success(input)) in_success = Traits::success(input);
            mojo::internal::Serialize<::device::mojom::UsbOpenDeviceSuccess>(in_success, &fragment->data.f_success);
            break;
        }
        case ::device::mojom::UsbOpenDeviceResultDataView::Tag::kError: {
            decltype(Traits::error(input)) in_error = Traits::error(input);
            mojo::internal::Serialize<::device::mojom::UsbOpenDeviceError>(in_error, &fragment->data.f_error);
            break;
        }
        }
    }

    static bool Deserialize(::device::mojom::internal::UsbOpenDeviceResult_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::device::mojom::UsbOpenDeviceResultDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace device::mojom {

inline void UsbEndpointInfoDataView::GetExtraDataDataView(mojo::ArrayDataView<uint8_t>* output)
{
    auto pointer = data_->extra_data.Get();
    *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}

inline void UsbAlternateInterfaceInfoDataView::GetInterfaceNameDataView(::mojo_base::mojom::String16DataView* output)
{
    auto pointer = data_->interface_name.Get();
    *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void UsbAlternateInterfaceInfoDataView::GetEndpointsDataView(mojo::ArrayDataView<UsbEndpointInfoDataView>* output)
{
    auto pointer = data_->endpoints.Get();
    *output = mojo::ArrayDataView<UsbEndpointInfoDataView>(pointer, message_);
}
inline void UsbAlternateInterfaceInfoDataView::GetExtraDataDataView(mojo::ArrayDataView<uint8_t>* output)
{
    auto pointer = data_->extra_data.Get();
    *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}

inline void UsbInterfaceInfoDataView::GetAlternatesDataView(mojo::ArrayDataView<UsbAlternateInterfaceInfoDataView>* output)
{
    auto pointer = data_->alternates.Get();
    *output = mojo::ArrayDataView<UsbAlternateInterfaceInfoDataView>(pointer, message_);
}

inline void UsbConfigurationInfoDataView::GetConfigurationNameDataView(::mojo_base::mojom::String16DataView* output)
{
    auto pointer = data_->configuration_name.Get();
    *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void UsbConfigurationInfoDataView::GetInterfacesDataView(mojo::ArrayDataView<UsbInterfaceInfoDataView>* output)
{
    auto pointer = data_->interfaces.Get();
    *output = mojo::ArrayDataView<UsbInterfaceInfoDataView>(pointer, message_);
}
inline void UsbConfigurationInfoDataView::GetExtraDataDataView(mojo::ArrayDataView<uint8_t>* output)
{
    auto pointer = data_->extra_data.Get();
    *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}

inline void UsbDeviceInfoDataView::GetGuidDataView(mojo::StringDataView* output)
{
    auto pointer = data_->guid.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void UsbDeviceInfoDataView::GetManufacturerNameDataView(::mojo_base::mojom::String16DataView* output)
{
    auto pointer = data_->manufacturer_name.Get();
    *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void UsbDeviceInfoDataView::GetProductNameDataView(::mojo_base::mojom::String16DataView* output)
{
    auto pointer = data_->product_name.Get();
    *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void UsbDeviceInfoDataView::GetSerialNumberDataView(::mojo_base::mojom::String16DataView* output)
{
    auto pointer = data_->serial_number.Get();
    *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void UsbDeviceInfoDataView::GetWebusbLandingPageDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->webusb_landing_page.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void UsbDeviceInfoDataView::GetConfigurationsDataView(mojo::ArrayDataView<UsbConfigurationInfoDataView>* output)
{
    auto pointer = data_->configurations.Get();
    *output = mojo::ArrayDataView<UsbConfigurationInfoDataView>(pointer, message_);
}

} // device::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbOpenDeviceSuccess> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbOpenDeviceSuccess value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbOpenDeviceError> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbOpenDeviceError value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbClaimInterfaceResult> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbClaimInterfaceResult value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbTransferDirection> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbTransferDirection value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbControlTransferType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbControlTransferType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbControlTransferRecipient> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbControlTransferRecipient value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbTransferType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbTransferType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbSynchronizationType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbSynchronizationType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbUsageType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbUsageType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::device::mojom::UsbTransferStatus> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::device::mojom::UsbTransferStatus value);
};

} // namespace perfetto

#endif // SERVICES_DEVICE_PUBLIC_MOJOM_USB_DEVICE_MOJOM_SHARED_H_
