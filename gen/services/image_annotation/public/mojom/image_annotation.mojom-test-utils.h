// services/image_annotation/public/mojom/image_annotation.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_IMAGE_ANNOTATION_PUBLIC_MOJOM_IMAGE_ANNOTATION_MOJOM_TEST_UTILS_H_
#define SERVICES_IMAGE_ANNOTATION_PUBLIC_MOJOM_IMAGE_ANNOTATION_MOJOM_TEST_UTILS_H_

#include "services/image_annotation/public/mojom/image_annotation.mojom.h"

namespace image_annotation::mojom {

class ImageProcessorInterceptorForTesting : public ImageProcessor {
    virtual ImageProcessor* GetForwardingInterface() = 0;
    void GetJpgImageData(GetJpgImageDataCallback callback) override;
};
class ImageProcessorAsyncWaiter {
public:
    explicit ImageProcessorAsyncWaiter(ImageProcessor* proxy);

    ImageProcessorAsyncWaiter(const ImageProcessorAsyncWaiter&) = delete;
    ImageProcessorAsyncWaiter& operator=(const ImageProcessorAsyncWaiter&) = delete;

    ~ImageProcessorAsyncWaiter();
    void GetJpgImageData(std::vector<uint8_t>* out_bytes, int32_t* out_width, int32_t* out_height);

private:
    ImageProcessor* const proxy_;
};

class AnnotatorInterceptorForTesting : public Annotator {
    virtual Annotator* GetForwardingInterface() = 0;
    void AnnotateImage(const std::string& source_id, const std::string& description_language_tag, ::mojo::PendingRemote<ImageProcessor> image_processor,
        AnnotateImageCallback callback) override;
};
class AnnotatorAsyncWaiter {
public:
    explicit AnnotatorAsyncWaiter(Annotator* proxy);

    AnnotatorAsyncWaiter(const AnnotatorAsyncWaiter&) = delete;
    AnnotatorAsyncWaiter& operator=(const AnnotatorAsyncWaiter&) = delete;

    ~AnnotatorAsyncWaiter();
    void AnnotateImage(const std::string& source_id, const std::string& description_language_tag, ::mojo::PendingRemote<ImageProcessor> image_processor,
        AnnotateImageResultPtr* out_result);
    AnnotateImageResultPtr AnnotateImage(
        const std::string& source_id, const std::string& description_language_tag, ::mojo::PendingRemote<ImageProcessor> image_processor);

private:
    Annotator* const proxy_;
};

class ImageAnnotationServiceInterceptorForTesting : public ImageAnnotationService {
    virtual ImageAnnotationService* GetForwardingInterface() = 0;
    void BindAnnotator(::mojo::PendingReceiver<Annotator> receiver) override;
};
class ImageAnnotationServiceAsyncWaiter {
public:
    explicit ImageAnnotationServiceAsyncWaiter(ImageAnnotationService* proxy);

    ImageAnnotationServiceAsyncWaiter(const ImageAnnotationServiceAsyncWaiter&) = delete;
    ImageAnnotationServiceAsyncWaiter& operator=(const ImageAnnotationServiceAsyncWaiter&) = delete;

    ~ImageAnnotationServiceAsyncWaiter();

private:
    ImageAnnotationService* const proxy_;
};

} // image_annotation::mojom

#endif // SERVICES_IMAGE_ANNOTATION_PUBLIC_MOJOM_IMAGE_ANNOTATION_MOJOM_TEST_UTILS_H_
