// services/on_device_model/public/mojom/on_device_model_service.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_SERVICE_MOJOM_H_
#define SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_SERVICE_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/on_device_model/public/mojom/on_device_model_service.mojom-features.h" // IWYU pragma: export
#include "services/on_device_model/public/mojom/on_device_model_service.mojom-shared.h" // IWYU pragma: export
#include "services/on_device_model/public/mojom/on_device_model_service.mojom-forward.h" // IWYU pragma: export
#include "mojo/public/mojom/base/file.mojom.h"
#include "mojo/public/mojom/base/file_path.mojom.h"
#include "mojo/public/mojom/base/uuid.mojom.h"
#include "sandbox/policy/mojom/context.mojom-forward.h"
#include "sandbox/policy/mojom/sandbox.mojom-forward.h"
#include "services/on_device_model/public/mojom/on_device_model.mojom-forward.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "services/on_device_model/ml/chrome_ml_types_traits.h"
#include "services/on_device_model/public/cpp/adaptation_assets_mojom_traits.h"
#include "services/on_device_model/public/cpp/model_assets_mojom_traits.h"

namespace on_device_model::mojom {

class PlatformModelProgressObserverProxy;

template <typename ImplRefTraits> class PlatformModelProgressObserverStub;

class PlatformModelProgressObserverRequestValidator;

class PlatformModelProgressObserver : public PlatformModelProgressObserverInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = PlatformModelProgressObserverInterfaceBase;
    using Proxy_ = PlatformModelProgressObserverProxy;

    template <typename ImplRefTraits> using Stub_ = PlatformModelProgressObserverStub<ImplRefTraits>;

    using RequestValidator_ = PlatformModelProgressObserverRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kProgressMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct Progress_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~PlatformModelProgressObserver() = default;

    virtual void Progress(double progress) = 0;
};

class OnDeviceModelServiceProxy;

template <typename ImplRefTraits> class OnDeviceModelServiceStub;

class OnDeviceModelServiceRequestValidator;
class OnDeviceModelServiceResponseValidator;

class OnDeviceModelService : public OnDeviceModelServiceInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr auto kServiceSandbox = sandbox::mojom::Sandbox::kOnDeviceModelExecution;
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = OnDeviceModelServiceInterfaceBase;
    using Proxy_ = OnDeviceModelServiceProxy;

    template <typename ImplRefTraits> using Stub_ = OnDeviceModelServiceStub<ImplRefTraits>;

    using RequestValidator_ = OnDeviceModelServiceRequestValidator;
    using ResponseValidator_ = OnDeviceModelServiceResponseValidator;
    enum MethodMinVersions : uint32_t {
        kLoadModelMinVersion = 0,
        kLoadTextSafetyModelMinVersion = 0,
        kGetEstimatedPerformanceClassMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct LoadModel_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct LoadTextSafetyModel_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetEstimatedPerformanceClass_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~OnDeviceModelService() = default;

    using LoadModelCallback = base::OnceCallback<void(::on_device_model::mojom::LoadModelResult)>;

    virtual void LoadModel(LoadModelParamsPtr params, ::mojo::PendingReceiver<::on_device_model::mojom::OnDeviceModel> model, LoadModelCallback callback) = 0;

    virtual void LoadTextSafetyModel(TextSafetyModelParamsPtr params, ::mojo::PendingReceiver<::on_device_model::mojom::TextSafetyModel> model) = 0;

    using GetEstimatedPerformanceClassCallback = base::OnceCallback<void(::on_device_model::mojom::PerformanceClass)>;

    virtual void GetEstimatedPerformanceClass(GetEstimatedPerformanceClassCallback callback) = 0;
};

class OnDeviceModelPlatformServiceProxy;

template <typename ImplRefTraits> class OnDeviceModelPlatformServiceStub;

class OnDeviceModelPlatformServiceRequestValidator;
class OnDeviceModelPlatformServiceResponseValidator;

class OnDeviceModelPlatformService : public OnDeviceModelPlatformServiceInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 4;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = OnDeviceModelPlatformServiceInterfaceBase;
    using Proxy_ = OnDeviceModelPlatformServiceProxy;

    template <typename ImplRefTraits> using Stub_ = OnDeviceModelPlatformServiceStub<ImplRefTraits>;

    using RequestValidator_ = OnDeviceModelPlatformServiceRequestValidator;
    using ResponseValidator_ = OnDeviceModelPlatformServiceResponseValidator;
    enum MethodMinVersions : uint32_t {
        kLoadPlatformModelMinVersion = 0,
        kGetPlatformModelStateMinVersion = 1,
        kGetEstimatedPerformanceClassMinVersion = 2,
        kFormatInputMinVersion = 3,
        kValidateSafetyResultMinVersion = 4,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct LoadPlatformModel_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetPlatformModelState_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetEstimatedPerformanceClass_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct FormatInput_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ValidateSafetyResult_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~OnDeviceModelPlatformService() = default;

    using LoadPlatformModelCallback = base::OnceCallback<void(::on_device_model::mojom::LoadModelResult)>;

    virtual void LoadPlatformModel(const ::base::Uuid& uuid, ::mojo::PendingReceiver<::on_device_model::mojom::OnDeviceModel> model,
        ::mojo::PendingRemote<PlatformModelProgressObserver> progress_observer, LoadPlatformModelCallback callback)
        = 0;

    using GetPlatformModelStateCallback = base::OnceCallback<void(PlatformModelState)>;

    virtual void GetPlatformModelState(const ::base::Uuid& uuid, GetPlatformModelStateCallback callback) = 0;

    using GetEstimatedPerformanceClassCallback = base::OnceCallback<void(::on_device_model::mojom::PerformanceClass)>;

    virtual void GetEstimatedPerformanceClass(GetEstimatedPerformanceClassCallback callback) = 0;

    using FormatInputCallback = base::OnceCallback<void(const std::optional<std::string>&)>;

    virtual void FormatInput(
        const ::base::Uuid& uuid, FormatFeature feature, const base::flat_map<std::string, std::string>& fields, FormatInputCallback callback)
        = 0;

    using ValidateSafetyResultCallback = base::OnceCallback<void(bool)>;

    virtual void ValidateSafetyResult(
        SafetyFeature safety_feature, const std::string& text, ::on_device_model::mojom::SafetyInfoPtr safety_info, ValidateSafetyResultCallback callback)
        = 0;
};

class PlatformModelProgressObserverProxy : public PlatformModelProgressObserver {
public:
    using InterfaceType = PlatformModelProgressObserver;

    explicit PlatformModelProgressObserverProxy(mojo::MessageReceiverWithResponder* receiver);

    void Progress(double progress) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class OnDeviceModelServiceProxy : public OnDeviceModelService {
public:
    using InterfaceType = OnDeviceModelService;

    explicit OnDeviceModelServiceProxy(mojo::MessageReceiverWithResponder* receiver);

    void LoadModel(LoadModelParamsPtr params, ::mojo::PendingReceiver<::on_device_model::mojom::OnDeviceModel> model, LoadModelCallback callback) final;

    void LoadTextSafetyModel(TextSafetyModelParamsPtr params, ::mojo::PendingReceiver<::on_device_model::mojom::TextSafetyModel> model) final;

    void GetEstimatedPerformanceClass(GetEstimatedPerformanceClassCallback callback) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class OnDeviceModelPlatformServiceProxy : public OnDeviceModelPlatformService {
public:
    using InterfaceType = OnDeviceModelPlatformService;

    explicit OnDeviceModelPlatformServiceProxy(mojo::MessageReceiverWithResponder* receiver);

    void LoadPlatformModel(const ::base::Uuid& uuid, ::mojo::PendingReceiver<::on_device_model::mojom::OnDeviceModel> model,
        ::mojo::PendingRemote<PlatformModelProgressObserver> progress_observer, LoadPlatformModelCallback callback) final;

    void GetPlatformModelState(const ::base::Uuid& uuid, GetPlatformModelStateCallback callback) final;

    void GetEstimatedPerformanceClass(GetEstimatedPerformanceClassCallback callback) final;

    void FormatInput(
        const ::base::Uuid& uuid, FormatFeature feature, const base::flat_map<std::string, std::string>& fields, FormatInputCallback callback) final;

    void ValidateSafetyResult(SafetyFeature safety_feature, const std::string& text, ::on_device_model::mojom::SafetyInfoPtr safety_info,
        ValidateSafetyResultCallback callback) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};
class PlatformModelProgressObserverStubDispatch {
public:
    static bool Accept(PlatformModelProgressObserver* impl, mojo::Message* message);
    static bool AcceptWithResponder(PlatformModelProgressObserver* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<PlatformModelProgressObserver>>
//class PlatformModelProgressObserverStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    PlatformModelProgressObserverStub() = default;
//    ~PlatformModelProgressObserverStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return PlatformModelProgressObserverStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return PlatformModelProgressObserverStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class OnDeviceModelServiceStubDispatch {
public:
    static bool Accept(OnDeviceModelService* impl, mojo::Message* message);
    static bool AcceptWithResponder(OnDeviceModelService* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<OnDeviceModelService>>
//class OnDeviceModelServiceStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    OnDeviceModelServiceStub() = default;
//    ~OnDeviceModelServiceStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return OnDeviceModelServiceStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return OnDeviceModelServiceStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class OnDeviceModelPlatformServiceStubDispatch {
public:
    static bool Accept(OnDeviceModelPlatformService* impl, mojo::Message* message);
    static bool AcceptWithResponder(OnDeviceModelPlatformService* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<OnDeviceModelPlatformService>>
//class OnDeviceModelPlatformServiceStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    OnDeviceModelPlatformServiceStub() = default;
//    ~OnDeviceModelPlatformServiceStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return OnDeviceModelPlatformServiceStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return OnDeviceModelPlatformServiceStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class PlatformModelProgressObserverRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class OnDeviceModelServiceRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class OnDeviceModelPlatformServiceRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class OnDeviceModelServiceResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class OnDeviceModelPlatformServiceResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class ModelAssets {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ModelAssets, T>::value>;
    using DataView = ModelAssetsDataView;
    using Data_ = internal::ModelAssets_Data;

    template <typename... Args> static ModelAssetsPtr New(Args&&... args)
    {
        return ModelAssetsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ModelAssetsPtr From(const U& u)
    {
        return mojo::TypeConverter<ModelAssetsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ModelAssets>::Convert(*this);
    }

    ModelAssets();

    ModelAssets(::base::File weights, const std::optional<::base::FilePath>& weights_path, const std::optional<::base::FilePath>& sp_model_path);

    ModelAssets(const ModelAssets&) = delete;
    ModelAssets& operator=(const ModelAssets&) = delete;

    ~ModelAssets();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ModelAssetsPtr> ModelAssetsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ModelAssets::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ModelAssets::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ModelAssets::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ModelAssets::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::ModelAssets_UnserializedMessageContext<UserType, ModelAssets::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ModelAssets::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ModelAssets::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ModelAssets_UnserializedMessageContext<UserType, ModelAssets::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ModelAssets::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::File weights;

    std::optional<::base::FilePath> weights_path;

    std::optional<::base::FilePath> sp_model_path;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ModelAssets::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ModelAssets::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ModelAssets::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ModelAssets::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class LoadModelParams {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<LoadModelParams, T>::value>;
    using DataView = LoadModelParamsDataView;
    using Data_ = internal::LoadModelParams_Data;

    template <typename... Args> static LoadModelParamsPtr New(Args&&... args)
    {
        return LoadModelParamsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LoadModelParamsPtr From(const U& u)
    {
        return mojo::TypeConverter<LoadModelParamsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, LoadModelParams>::Convert(*this);
    }

    LoadModelParams();

    LoadModelParams(ModelBackendType backend_type, ::on_device_model::ModelAssets assets, uint32_t max_tokens, std::vector<uint32_t> adaptation_ranks);

    LoadModelParams(const LoadModelParams&) = delete;
    LoadModelParams& operator=(const LoadModelParams&) = delete;

    ~LoadModelParams();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LoadModelParamsPtr> LoadModelParamsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, LoadModelParams::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, LoadModelParams::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, LoadModelParams::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<LoadModelParams::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::LoadModelParams_UnserializedMessageContext<UserType, LoadModelParams::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<LoadModelParams::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return LoadModelParams::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::LoadModelParams_UnserializedMessageContext<UserType, LoadModelParams::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<LoadModelParams::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ModelBackendType backend_type;

    ::on_device_model::ModelAssets assets;

    uint32_t max_tokens;

    std::vector<uint32_t> adaptation_ranks;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LoadModelParams::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, LoadModelParams::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, LoadModelParams::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, LoadModelParams::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class TextSafetyModelAssets {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<TextSafetyModelAssets, T>::value>;
    using DataView = TextSafetyModelAssetsDataView;
    using Data_ = internal::TextSafetyModelAssets_Data;

    template <typename... Args> static TextSafetyModelAssetsPtr New(Args&&... args)
    {
        return TextSafetyModelAssetsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TextSafetyModelAssetsPtr From(const U& u)
    {
        return mojo::TypeConverter<TextSafetyModelAssetsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, TextSafetyModelAssets>::Convert(*this);
    }

    TextSafetyModelAssets();

    TextSafetyModelAssets(::base::File data, ::base::File sp_model);

    TextSafetyModelAssets(const TextSafetyModelAssets&) = delete;
    TextSafetyModelAssets& operator=(const TextSafetyModelAssets&) = delete;

    ~TextSafetyModelAssets();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TextSafetyModelAssetsPtr> TextSafetyModelAssetsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, TextSafetyModelAssets::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, TextSafetyModelAssets::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, TextSafetyModelAssets::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<TextSafetyModelAssets::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::TextSafetyModelAssets_UnserializedMessageContext<UserType, TextSafetyModelAssets::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<TextSafetyModelAssets::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return TextSafetyModelAssets::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::TextSafetyModelAssets_UnserializedMessageContext<UserType, TextSafetyModelAssets::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<TextSafetyModelAssets::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::File data;

    ::base::File sp_model;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TextSafetyModelAssets::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, TextSafetyModelAssets::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, TextSafetyModelAssets::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, TextSafetyModelAssets::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class LanguageModelAssets {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<LanguageModelAssets, T>::value>;
    using DataView = LanguageModelAssetsDataView;
    using Data_ = internal::LanguageModelAssets_Data;

    template <typename... Args> static LanguageModelAssetsPtr New(Args&&... args)
    {
        return LanguageModelAssetsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LanguageModelAssetsPtr From(const U& u)
    {
        return mojo::TypeConverter<LanguageModelAssetsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, LanguageModelAssets>::Convert(*this);
    }

    LanguageModelAssets();

    explicit LanguageModelAssets(::base::File model);

    LanguageModelAssets(const LanguageModelAssets&) = delete;
    LanguageModelAssets& operator=(const LanguageModelAssets&) = delete;

    ~LanguageModelAssets();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LanguageModelAssetsPtr> LanguageModelAssetsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, LanguageModelAssets::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, LanguageModelAssets::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, LanguageModelAssets::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<LanguageModelAssets::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::LanguageModelAssets_UnserializedMessageContext<UserType, LanguageModelAssets::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<LanguageModelAssets::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return LanguageModelAssets::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::LanguageModelAssets_UnserializedMessageContext<UserType, LanguageModelAssets::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<LanguageModelAssets::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::File model;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LanguageModelAssets::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, LanguageModelAssets::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, LanguageModelAssets::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, LanguageModelAssets::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class TextSafetyModelParams {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<TextSafetyModelParams, T>::value>;
    using DataView = TextSafetyModelParamsDataView;
    using Data_ = internal::TextSafetyModelParams_Data;

    template <typename... Args> static TextSafetyModelParamsPtr New(Args&&... args)
    {
        return TextSafetyModelParamsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TextSafetyModelParamsPtr From(const U& u)
    {
        return mojo::TypeConverter<TextSafetyModelParamsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, TextSafetyModelParams>::Convert(*this);
    }

    TextSafetyModelParams();

    TextSafetyModelParams(TextSafetyModelAssetsPtr ts_assets, LanguageModelAssetsPtr language_assets);

    TextSafetyModelParams(const TextSafetyModelParams&) = delete;
    TextSafetyModelParams& operator=(const TextSafetyModelParams&) = delete;

    ~TextSafetyModelParams();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TextSafetyModelParamsPtr> TextSafetyModelParamsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, TextSafetyModelParams::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, TextSafetyModelParams::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, TextSafetyModelParams::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<TextSafetyModelParams::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::TextSafetyModelParams_UnserializedMessageContext<UserType, TextSafetyModelParams::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<TextSafetyModelParams::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return TextSafetyModelParams::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::TextSafetyModelParams_UnserializedMessageContext<UserType, TextSafetyModelParams::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<TextSafetyModelParams::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    TextSafetyModelAssetsPtr ts_assets;

    LanguageModelAssetsPtr language_assets;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, TextSafetyModelParams::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, TextSafetyModelParams::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, TextSafetyModelParams::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, TextSafetyModelParams::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename StructPtrType> ModelAssetsPtr ModelAssets::Clone() const
{
    return New(mojo::Clone(weights), mojo::Clone(weights_path), mojo::Clone(sp_model_path));
}

template <typename T, ModelAssets::EnableIfSame<T>*> bool ModelAssets::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->weights, other_struct.weights))
        return false;
    if (!mojo::Equals(this->weights_path, other_struct.weights_path))
        return false;
    if (!mojo::Equals(this->sp_model_path, other_struct.sp_model_path))
        return false;
    return true;
}

template <typename T, ModelAssets::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.weights < rhs.weights)
        return true;
    if (rhs.weights < lhs.weights)
        return false;
    if (lhs.weights_path < rhs.weights_path)
        return true;
    if (rhs.weights_path < lhs.weights_path)
        return false;
    if (lhs.sp_model_path < rhs.sp_model_path)
        return true;
    if (rhs.sp_model_path < lhs.sp_model_path)
        return false;
    return false;
}
template <typename StructPtrType> LoadModelParamsPtr LoadModelParams::Clone() const
{
    return New(mojo::Clone(backend_type), mojo::Clone(assets), mojo::Clone(max_tokens), mojo::Clone(adaptation_ranks));
}

template <typename T, LoadModelParams::EnableIfSame<T>*> bool LoadModelParams::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->backend_type, other_struct.backend_type))
        return false;
    if (!mojo::Equals(this->assets, other_struct.assets))
        return false;
    if (!mojo::Equals(this->max_tokens, other_struct.max_tokens))
        return false;
    if (!mojo::Equals(this->adaptation_ranks, other_struct.adaptation_ranks))
        return false;
    return true;
}

template <typename T, LoadModelParams::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.backend_type < rhs.backend_type)
        return true;
    if (rhs.backend_type < lhs.backend_type)
        return false;
    if (lhs.assets < rhs.assets)
        return true;
    if (rhs.assets < lhs.assets)
        return false;
    if (lhs.max_tokens < rhs.max_tokens)
        return true;
    if (rhs.max_tokens < lhs.max_tokens)
        return false;
    if (lhs.adaptation_ranks < rhs.adaptation_ranks)
        return true;
    if (rhs.adaptation_ranks < lhs.adaptation_ranks)
        return false;
    return false;
}
template <typename StructPtrType> TextSafetyModelAssetsPtr TextSafetyModelAssets::Clone() const
{
    return New(mojo::Clone(data), mojo::Clone(sp_model));
}

template <typename T, TextSafetyModelAssets::EnableIfSame<T>*> bool TextSafetyModelAssets::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->data, other_struct.data))
        return false;
    if (!mojo::Equals(this->sp_model, other_struct.sp_model))
        return false;
    return true;
}

template <typename T, TextSafetyModelAssets::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.data < rhs.data)
        return true;
    if (rhs.data < lhs.data)
        return false;
    if (lhs.sp_model < rhs.sp_model)
        return true;
    if (rhs.sp_model < lhs.sp_model)
        return false;
    return false;
}
template <typename StructPtrType> LanguageModelAssetsPtr LanguageModelAssets::Clone() const
{
    return New(mojo::Clone(model));
}

template <typename T, LanguageModelAssets::EnableIfSame<T>*> bool LanguageModelAssets::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->model, other_struct.model))
        return false;
    return true;
}

template <typename T, LanguageModelAssets::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.model < rhs.model)
        return true;
    if (rhs.model < lhs.model)
        return false;
    return false;
}
template <typename StructPtrType> TextSafetyModelParamsPtr TextSafetyModelParams::Clone() const
{
    return New(mojo::Clone(ts_assets), mojo::Clone(language_assets));
}

template <typename T, TextSafetyModelParams::EnableIfSame<T>*> bool TextSafetyModelParams::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->ts_assets, other_struct.ts_assets))
        return false;
    if (!mojo::Equals(this->language_assets, other_struct.language_assets))
        return false;
    return true;
}

template <typename T, TextSafetyModelParams::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.ts_assets < rhs.ts_assets)
        return true;
    if (rhs.ts_assets < lhs.ts_assets)
        return false;
    if (lhs.language_assets < rhs.language_assets)
        return true;
    if (rhs.language_assets < lhs.language_assets)
        return false;
    return false;
}

} // on_device_model::mojom

namespace mojo {

template <> struct StructTraits<::on_device_model::mojom::ModelAssets::DataView, ::on_device_model::mojom::ModelAssetsPtr> {
    static bool IsNull(const ::on_device_model::mojom::ModelAssetsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::on_device_model::mojom::ModelAssetsPtr* output)
    {
        output->reset();
    }

    static decltype(::on_device_model::mojom::ModelAssets::weights)& weights(::on_device_model::mojom::ModelAssetsPtr& input)
    {
        return input->weights;
    }

    static const decltype(::on_device_model::mojom::ModelAssets::weights_path)& weights_path(const ::on_device_model::mojom::ModelAssetsPtr& input)
    {
        return input->weights_path;
    }

    static const decltype(::on_device_model::mojom::ModelAssets::sp_model_path)& sp_model_path(const ::on_device_model::mojom::ModelAssetsPtr& input)
    {
        return input->sp_model_path;
    }

    static bool Read(::on_device_model::mojom::ModelAssets::DataView input, ::on_device_model::mojom::ModelAssetsPtr* output);
};

template <> struct StructTraits<::on_device_model::mojom::LoadModelParams::DataView, ::on_device_model::mojom::LoadModelParamsPtr> {
    static bool IsNull(const ::on_device_model::mojom::LoadModelParamsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::on_device_model::mojom::LoadModelParamsPtr* output)
    {
        output->reset();
    }

    static decltype(::on_device_model::mojom::LoadModelParams::backend_type) backend_type(const ::on_device_model::mojom::LoadModelParamsPtr& input)
    {
        return input->backend_type;
    }

    static decltype(::on_device_model::mojom::LoadModelParams::assets)& assets(::on_device_model::mojom::LoadModelParamsPtr& input)
    {
        return input->assets;
    }

    static decltype(::on_device_model::mojom::LoadModelParams::max_tokens) max_tokens(const ::on_device_model::mojom::LoadModelParamsPtr& input)
    {
        return input->max_tokens;
    }

    static const decltype(::on_device_model::mojom::LoadModelParams::adaptation_ranks)& adaptation_ranks(
        const ::on_device_model::mojom::LoadModelParamsPtr& input)
    {
        return input->adaptation_ranks;
    }

    static bool Read(::on_device_model::mojom::LoadModelParams::DataView input, ::on_device_model::mojom::LoadModelParamsPtr* output);
};

template <> struct StructTraits<::on_device_model::mojom::TextSafetyModelAssets::DataView, ::on_device_model::mojom::TextSafetyModelAssetsPtr> {
    static bool IsNull(const ::on_device_model::mojom::TextSafetyModelAssetsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::on_device_model::mojom::TextSafetyModelAssetsPtr* output)
    {
        output->reset();
    }

    static decltype(::on_device_model::mojom::TextSafetyModelAssets::data)& data(::on_device_model::mojom::TextSafetyModelAssetsPtr& input)
    {
        return input->data;
    }

    static decltype(::on_device_model::mojom::TextSafetyModelAssets::sp_model)& sp_model(::on_device_model::mojom::TextSafetyModelAssetsPtr& input)
    {
        return input->sp_model;
    }

    static bool Read(::on_device_model::mojom::TextSafetyModelAssets::DataView input, ::on_device_model::mojom::TextSafetyModelAssetsPtr* output);
};

template <> struct StructTraits<::on_device_model::mojom::LanguageModelAssets::DataView, ::on_device_model::mojom::LanguageModelAssetsPtr> {
    static bool IsNull(const ::on_device_model::mojom::LanguageModelAssetsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::on_device_model::mojom::LanguageModelAssetsPtr* output)
    {
        output->reset();
    }

    static decltype(::on_device_model::mojom::LanguageModelAssets::model)& model(::on_device_model::mojom::LanguageModelAssetsPtr& input)
    {
        return input->model;
    }

    static bool Read(::on_device_model::mojom::LanguageModelAssets::DataView input, ::on_device_model::mojom::LanguageModelAssetsPtr* output);
};

template <> struct StructTraits<::on_device_model::mojom::TextSafetyModelParams::DataView, ::on_device_model::mojom::TextSafetyModelParamsPtr> {
    static bool IsNull(const ::on_device_model::mojom::TextSafetyModelParamsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::on_device_model::mojom::TextSafetyModelParamsPtr* output)
    {
        output->reset();
    }

    static decltype(::on_device_model::mojom::TextSafetyModelParams::ts_assets)& ts_assets(::on_device_model::mojom::TextSafetyModelParamsPtr& input)
    {
        return input->ts_assets;
    }

    static decltype(::on_device_model::mojom::TextSafetyModelParams::language_assets)& language_assets(
        ::on_device_model::mojom::TextSafetyModelParamsPtr& input)
    {
        return input->language_assets;
    }

    static bool Read(::on_device_model::mojom::TextSafetyModelParams::DataView input, ::on_device_model::mojom::TextSafetyModelParamsPtr* output);
};

} // namespace mojo

#endif // SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_SERVICE_MOJOM_H_
