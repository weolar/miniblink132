// services/on_device_model/public/mojom/on_device_model_service.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_SERVICE_MOJOM_SHARED_H_
#define SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_SERVICE_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/on_device_model/public/mojom/on_device_model_service.mojom-shared-internal.h"
#include "mojo/public/mojom/base/file.mojom-shared.h"
#include "mojo/public/mojom/base/file_path.mojom-shared.h"
#include "mojo/public/mojom/base/uuid.mojom-shared.h"
#include "sandbox/policy/mojom/context.mojom-shared.h"
#include "sandbox/policy/mojom/sandbox.mojom-shared.h"
#include "services/on_device_model/public/mojom/on_device_model.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

namespace on_device_model::mojom {
class ModelAssetsDataView;

class LoadModelParamsDataView;

class TextSafetyModelAssetsDataView;

class LanguageModelAssetsDataView;

class TextSafetyModelParamsDataView;

} // on_device_model::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::on_device_model::mojom::ModelAssetsDataView> {
    using Data = ::on_device_model::mojom::internal::ModelAssets_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::LoadModelParamsDataView> {
    using Data = ::on_device_model::mojom::internal::LoadModelParams_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::TextSafetyModelAssetsDataView> {
    using Data = ::on_device_model::mojom::internal::TextSafetyModelAssets_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::LanguageModelAssetsDataView> {
    using Data = ::on_device_model::mojom::internal::LanguageModelAssets_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::TextSafetyModelParamsDataView> {
    using Data = ::on_device_model::mojom::internal::TextSafetyModelParams_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

} // namespace internal
} // namespace mojo

namespace on_device_model::mojom {

enum class ModelBackendType : int32_t {

    kGpu = 0,

    kApu = 1,
    kMinValue = 0,
    kMaxValue = 1,
};

std::ostream& operator<<(std::ostream& os, ModelBackendType value);
inline bool IsKnownEnumValue(ModelBackendType value)
{
    return internal::ModelBackendType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class PlatformModelState : int32_t {

    kUnknownState = 0,

    kInstalledOnDisk = 1,

    kInvalidUuid = 2,

    kInvalidDlcClient = 3,

    kInvalidDlcPackage = 4,

    kInvalidDlcVerifiedState = 5,

    kInvalidDlcInstall = 6,

    kInvalidModelFormat = 7,

    kInvalidModelDescriptor = 8,

    kInvalidBaseModelDescriptor = 9,
    kMinValue = 0,
    kMaxValue = 9,
    kDefaultValue = 0
};

std::ostream& operator<<(std::ostream& os, PlatformModelState value);
inline bool IsKnownEnumValue(PlatformModelState value)
{
    return internal::PlatformModelState_Data::IsKnownValue(static_cast<int32_t>(value));
}
inline PlatformModelState ToKnownEnumValue(PlatformModelState value)
{
    if (IsKnownEnumValue(value)) {
        return value;
    }
    return PlatformModelState::kDefaultValue;
}

enum class FormatFeature : int32_t {

    kNone = 0,

    kPrompt = 1,

    kAudioSummary = 2,

    kAudioTitle = 3,
    kMinValue = 0,
    kMaxValue = 3,
    kDefaultValue = 0
};

std::ostream& operator<<(std::ostream& os, FormatFeature value);
inline bool IsKnownEnumValue(FormatFeature value)
{
    return internal::FormatFeature_Data::IsKnownValue(static_cast<int32_t>(value));
}
inline FormatFeature ToKnownEnumValue(FormatFeature value)
{
    if (IsKnownEnumValue(value)) {
        return value;
    }
    return FormatFeature::kDefaultValue;
}

enum class SafetyFeature : int32_t {

    kGeneral = 0,

    kAudioSummaryRequest = 1,

    kAudioTitleRequest = 2,

    kAudioSummaryResponse = 3,

    kAudioTitleResponse = 4,
    kMinValue = 0,
    kMaxValue = 4,
    kDefaultValue = 0
};

std::ostream& operator<<(std::ostream& os, SafetyFeature value);
inline bool IsKnownEnumValue(SafetyFeature value)
{
    return internal::SafetyFeature_Data::IsKnownValue(static_cast<int32_t>(value));
}
inline SafetyFeature ToKnownEnumValue(SafetyFeature value)
{
    if (IsKnownEnumValue(value)) {
        return value;
    }
    return SafetyFeature::kDefaultValue;
}
// Interface base classes. They are used for type safety check.
class PlatformModelProgressObserverInterfaceBase { };

using PlatformModelProgressObserverPtrDataView = mojo::InterfacePtrDataView<PlatformModelProgressObserverInterfaceBase>;
using PlatformModelProgressObserverRequestDataView = mojo::InterfaceRequestDataView<PlatformModelProgressObserverInterfaceBase>;
using PlatformModelProgressObserverAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<PlatformModelProgressObserverInterfaceBase>;
using PlatformModelProgressObserverAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<PlatformModelProgressObserverInterfaceBase>;
class OnDeviceModelServiceInterfaceBase { };

using OnDeviceModelServicePtrDataView = mojo::InterfacePtrDataView<OnDeviceModelServiceInterfaceBase>;
using OnDeviceModelServiceRequestDataView = mojo::InterfaceRequestDataView<OnDeviceModelServiceInterfaceBase>;
using OnDeviceModelServiceAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<OnDeviceModelServiceInterfaceBase>;
using OnDeviceModelServiceAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<OnDeviceModelServiceInterfaceBase>;
class OnDeviceModelPlatformServiceInterfaceBase { };

using OnDeviceModelPlatformServicePtrDataView = mojo::InterfacePtrDataView<OnDeviceModelPlatformServiceInterfaceBase>;
using OnDeviceModelPlatformServiceRequestDataView = mojo::InterfaceRequestDataView<OnDeviceModelPlatformServiceInterfaceBase>;
using OnDeviceModelPlatformServiceAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<OnDeviceModelPlatformServiceInterfaceBase>;
using OnDeviceModelPlatformServiceAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<OnDeviceModelPlatformServiceInterfaceBase>;

class ModelAssetsDataView {
public:
    ModelAssetsDataView() = default;

    ModelAssetsDataView(internal::ModelAssets_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetWeightsDataView(::mojo_base::mojom::FileDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadWeights(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::FileDataView, UserType>(),
            "Attempting to read the optional `weights` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadWeights` instead "
            "of `ReadWeights if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->weights.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::FileDataView>(pointer, output, message_);
    }
    inline void GetWeightsPathDataView(::mojo_base::mojom::FilePathDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadWeightsPath(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::FilePathDataView, UserType>(),
            "Attempting to read the optional `weights_path` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadWeightsPath` instead "
            "of `ReadWeightsPath if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->weights_path.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::FilePathDataView>(pointer, output, message_);
    }
    inline void GetSpModelPathDataView(::mojo_base::mojom::FilePathDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSpModelPath(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::FilePathDataView, UserType>(),
            "Attempting to read the optional `sp_model_path` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSpModelPath` instead "
            "of `ReadSpModelPath if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->sp_model_path.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::FilePathDataView>(pointer, output, message_);
    }

private:
    internal::ModelAssets_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LoadModelParamsDataView {
public:
    LoadModelParamsDataView() = default;

    LoadModelParamsDataView(internal::LoadModelParams_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadBackendType(UserType* output) const
    {
        auto data_value = data_->backend_type;
        return mojo::internal::Deserialize<::on_device_model::mojom::ModelBackendType>(data_value, output);
    }
    ModelBackendType backend_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::ModelBackendType>(data_->backend_type));
    }
    inline void GetAssetsDataView(ModelAssetsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAssets(UserType* output)
    {

        auto* pointer = data_->assets.Get();
        return mojo::internal::Deserialize<::on_device_model::mojom::ModelAssetsDataView>(pointer, output, message_);
    }
    uint32_t max_tokens() const
    {
        return data_->max_tokens;
    }
    inline void GetAdaptationRanksDataView(mojo::ArrayDataView<uint32_t>* output);

    template <typename UserType> [[nodiscard]] bool ReadAdaptationRanks(UserType* output)
    {

        auto* pointer = data_->adaptation_ranks.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<uint32_t>>(pointer, output, message_);
    }

private:
    internal::LoadModelParams_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class TextSafetyModelAssetsDataView {
public:
    TextSafetyModelAssetsDataView() = default;

    TextSafetyModelAssetsDataView(internal::TextSafetyModelAssets_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetDataDataView(::mojo_base::mojom::ReadOnlyFileDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadData(UserType* output)
    {

        auto* pointer = data_->data.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::ReadOnlyFileDataView>(pointer, output, message_);
    }
    inline void GetSpModelDataView(::mojo_base::mojom::ReadOnlyFileDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSpModel(UserType* output)
    {

        auto* pointer = data_->sp_model.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::ReadOnlyFileDataView>(pointer, output, message_);
    }

private:
    internal::TextSafetyModelAssets_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LanguageModelAssetsDataView {
public:
    LanguageModelAssetsDataView() = default;

    LanguageModelAssetsDataView(internal::LanguageModelAssets_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetModelDataView(::mojo_base::mojom::ReadOnlyFileDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadModel(UserType* output)
    {

        auto* pointer = data_->model.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::ReadOnlyFileDataView>(pointer, output, message_);
    }

private:
    internal::LanguageModelAssets_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class TextSafetyModelParamsDataView {
public:
    TextSafetyModelParamsDataView() = default;

    TextSafetyModelParamsDataView(internal::TextSafetyModelParams_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetTsAssetsDataView(TextSafetyModelAssetsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadTsAssets(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::on_device_model::mojom::TextSafetyModelAssetsDataView, UserType>(),
            "Attempting to read the optional `ts_assets` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadTsAssets` instead "
            "of `ReadTsAssets if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->ts_assets.Get();
        return mojo::internal::Deserialize<::on_device_model::mojom::TextSafetyModelAssetsDataView>(pointer, output, message_);
    }
    inline void GetLanguageAssetsDataView(LanguageModelAssetsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLanguageAssets(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::on_device_model::mojom::LanguageModelAssetsDataView, UserType>(),
            "Attempting to read the optional `language_assets` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadLanguageAssets` instead "
            "of `ReadLanguageAssets if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->language_assets.Get();
        return mojo::internal::Deserialize<::on_device_model::mojom::LanguageModelAssetsDataView>(pointer, output, message_);
    }

private:
    internal::TextSafetyModelParams_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // on_device_model::mojom

namespace std {

template <> struct hash<::on_device_model::mojom::ModelBackendType> : public mojo::internal::EnumHashImpl<::on_device_model::mojom::ModelBackendType> { };

template <> struct hash<::on_device_model::mojom::PlatformModelState> : public mojo::internal::EnumHashImpl<::on_device_model::mojom::PlatformModelState> { };

template <> struct hash<::on_device_model::mojom::FormatFeature> : public mojo::internal::EnumHashImpl<::on_device_model::mojom::FormatFeature> { };

template <> struct hash<::on_device_model::mojom::SafetyFeature> : public mojo::internal::EnumHashImpl<::on_device_model::mojom::SafetyFeature> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::ModelBackendType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::on_device_model::mojom::ModelBackendType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::ModelBackendType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::PlatformModelState, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::on_device_model::mojom::PlatformModelState, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::PlatformModelState>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::FormatFeature, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::on_device_model::mojom::FormatFeature, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::FormatFeature>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::SafetyFeature, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::on_device_model::mojom::SafetyFeature, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::SafetyFeature>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::ModelAssetsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::ModelAssetsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::ModelAssets_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::weights(input)) in_weights = Traits::weights(input);
        mojo::internal::MessageFragment<typename decltype(fragment->weights)::BaseType> weights_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::FileDataView>(in_weights, weights_fragment);
        fragment->weights.Set(weights_fragment.is_null() ? nullptr : weights_fragment.data());
        decltype(Traits::weights_path(input)) in_weights_path = Traits::weights_path(input);
        mojo::internal::MessageFragment<typename decltype(fragment->weights_path)::BaseType> weights_path_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(in_weights_path, weights_path_fragment);
        fragment->weights_path.Set(weights_path_fragment.is_null() ? nullptr : weights_path_fragment.data());
        decltype(Traits::sp_model_path(input)) in_sp_model_path = Traits::sp_model_path(input);
        mojo::internal::MessageFragment<typename decltype(fragment->sp_model_path)::BaseType> sp_model_path_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(in_sp_model_path, sp_model_path_fragment);
        fragment->sp_model_path.Set(sp_model_path_fragment.is_null() ? nullptr : sp_model_path_fragment.data());
    }

    static bool Deserialize(::on_device_model::mojom::internal::ModelAssets_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::ModelAssetsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::LoadModelParamsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::LoadModelParamsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::LoadModelParams_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::on_device_model::mojom::ModelBackendType>(Traits::backend_type(input), &fragment->backend_type);
        decltype(Traits::assets(input)) in_assets = Traits::assets(input);
        mojo::internal::MessageFragment<typename decltype(fragment->assets)::BaseType> assets_fragment(fragment.message());
        mojo::internal::Serialize<::on_device_model::mojom::ModelAssetsDataView>(in_assets, assets_fragment);
        fragment->assets.Set(assets_fragment.is_null() ? nullptr : assets_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->assets.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null assets in LoadModelParams struct");
        fragment->max_tokens = Traits::max_tokens(input);
        decltype(Traits::adaptation_ranks(input)) in_adaptation_ranks = Traits::adaptation_ranks(input);
        mojo::internal::MessageFragment<typename decltype(fragment->adaptation_ranks)::BaseType> adaptation_ranks_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& adaptation_ranks_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(in_adaptation_ranks, adaptation_ranks_fragment, &adaptation_ranks_validate_params);
        fragment->adaptation_ranks.Set(adaptation_ranks_fragment.is_null() ? nullptr : adaptation_ranks_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->adaptation_ranks.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null adaptation_ranks in LoadModelParams struct");
    }

    static bool Deserialize(::on_device_model::mojom::internal::LoadModelParams_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::LoadModelParamsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::TextSafetyModelAssetsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::TextSafetyModelAssetsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::TextSafetyModelAssets_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::data(input)) in_data = Traits::data(input);
        mojo::internal::MessageFragment<typename decltype(fragment->data)::BaseType> data_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::ReadOnlyFileDataView>(in_data, data_fragment);
        fragment->data.Set(data_fragment.is_null() ? nullptr : data_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->data.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null data in TextSafetyModelAssets struct");
        decltype(Traits::sp_model(input)) in_sp_model = Traits::sp_model(input);
        mojo::internal::MessageFragment<typename decltype(fragment->sp_model)::BaseType> sp_model_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::ReadOnlyFileDataView>(in_sp_model, sp_model_fragment);
        fragment->sp_model.Set(sp_model_fragment.is_null() ? nullptr : sp_model_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->sp_model.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null sp_model in TextSafetyModelAssets struct");
    }

    static bool Deserialize(::on_device_model::mojom::internal::TextSafetyModelAssets_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::TextSafetyModelAssetsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::LanguageModelAssetsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::LanguageModelAssetsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::LanguageModelAssets_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::model(input)) in_model = Traits::model(input);
        mojo::internal::MessageFragment<typename decltype(fragment->model)::BaseType> model_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::ReadOnlyFileDataView>(in_model, model_fragment);
        fragment->model.Set(model_fragment.is_null() ? nullptr : model_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->model.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null model in LanguageModelAssets struct");
    }

    static bool Deserialize(::on_device_model::mojom::internal::LanguageModelAssets_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::LanguageModelAssetsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::TextSafetyModelParamsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::TextSafetyModelParamsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::TextSafetyModelParams_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::ts_assets(input)) in_ts_assets = Traits::ts_assets(input);
        mojo::internal::MessageFragment<typename decltype(fragment->ts_assets)::BaseType> ts_assets_fragment(fragment.message());
        mojo::internal::Serialize<::on_device_model::mojom::TextSafetyModelAssetsDataView>(in_ts_assets, ts_assets_fragment);
        fragment->ts_assets.Set(ts_assets_fragment.is_null() ? nullptr : ts_assets_fragment.data());
        decltype(Traits::language_assets(input)) in_language_assets = Traits::language_assets(input);
        mojo::internal::MessageFragment<typename decltype(fragment->language_assets)::BaseType> language_assets_fragment(fragment.message());
        mojo::internal::Serialize<::on_device_model::mojom::LanguageModelAssetsDataView>(in_language_assets, language_assets_fragment);
        fragment->language_assets.Set(language_assets_fragment.is_null() ? nullptr : language_assets_fragment.data());
    }

    static bool Deserialize(::on_device_model::mojom::internal::TextSafetyModelParams_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::TextSafetyModelParamsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace on_device_model::mojom {

inline void ModelAssetsDataView::GetWeightsDataView(::mojo_base::mojom::FileDataView* output)
{
    auto pointer = data_->weights.Get();
    *output = ::mojo_base::mojom::FileDataView(pointer, message_);
}
inline void ModelAssetsDataView::GetWeightsPathDataView(::mojo_base::mojom::FilePathDataView* output)
{
    auto pointer = data_->weights_path.Get();
    *output = ::mojo_base::mojom::FilePathDataView(pointer, message_);
}
inline void ModelAssetsDataView::GetSpModelPathDataView(::mojo_base::mojom::FilePathDataView* output)
{
    auto pointer = data_->sp_model_path.Get();
    *output = ::mojo_base::mojom::FilePathDataView(pointer, message_);
}

inline void LoadModelParamsDataView::GetAssetsDataView(ModelAssetsDataView* output)
{
    auto pointer = data_->assets.Get();
    *output = ModelAssetsDataView(pointer, message_);
}
inline void LoadModelParamsDataView::GetAdaptationRanksDataView(mojo::ArrayDataView<uint32_t>* output)
{
    auto pointer = data_->adaptation_ranks.Get();
    *output = mojo::ArrayDataView<uint32_t>(pointer, message_);
}

inline void TextSafetyModelAssetsDataView::GetDataDataView(::mojo_base::mojom::ReadOnlyFileDataView* output)
{
    auto pointer = data_->data.Get();
    *output = ::mojo_base::mojom::ReadOnlyFileDataView(pointer, message_);
}
inline void TextSafetyModelAssetsDataView::GetSpModelDataView(::mojo_base::mojom::ReadOnlyFileDataView* output)
{
    auto pointer = data_->sp_model.Get();
    *output = ::mojo_base::mojom::ReadOnlyFileDataView(pointer, message_);
}

inline void LanguageModelAssetsDataView::GetModelDataView(::mojo_base::mojom::ReadOnlyFileDataView* output)
{
    auto pointer = data_->model.Get();
    *output = ::mojo_base::mojom::ReadOnlyFileDataView(pointer, message_);
}

inline void TextSafetyModelParamsDataView::GetTsAssetsDataView(TextSafetyModelAssetsDataView* output)
{
    auto pointer = data_->ts_assets.Get();
    *output = TextSafetyModelAssetsDataView(pointer, message_);
}
inline void TextSafetyModelParamsDataView::GetLanguageAssetsDataView(LanguageModelAssetsDataView* output)
{
    auto pointer = data_->language_assets.Get();
    *output = LanguageModelAssetsDataView(pointer, message_);
}

} // on_device_model::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct TraceFormatTraits<::on_device_model::mojom::ModelBackendType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::on_device_model::mojom::ModelBackendType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::on_device_model::mojom::PlatformModelState> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::on_device_model::mojom::PlatformModelState value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::on_device_model::mojom::FormatFeature> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::on_device_model::mojom::FormatFeature value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::on_device_model::mojom::SafetyFeature> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::on_device_model::mojom::SafetyFeature value);
};

} // namespace perfetto

#endif // SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_SERVICE_MOJOM_SHARED_H_
