// services/on_device_model/public/mojom/on_device_model.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_MOJOM_SHARED_H_
#define SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/on_device_model/public/mojom/on_device_model.mojom-shared-internal.h"
#include "mojo/public/mojom/base/file.mojom-shared.h"
#include "mojo/public/mojom/base/file_path.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

namespace on_device_model::mojom {
class AdaptationAssetsDataView;

class LanguageDetectionResultDataView;

class SafetyInfoDataView;

class ResponseChunkDataView;

class ResponseSummaryDataView;

class LoadAdaptationParamsDataView;

class InputDataView;

class InputOptionsDataView;

class InputPieceDataView;

} // on_device_model::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::on_device_model::mojom::AdaptationAssetsDataView> {
    using Data = ::on_device_model::mojom::internal::AdaptationAssets_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::LanguageDetectionResultDataView> {
    using Data = ::on_device_model::mojom::internal::LanguageDetectionResult_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::SafetyInfoDataView> {
    using Data = ::on_device_model::mojom::internal::SafetyInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::ResponseChunkDataView> {
    using Data = ::on_device_model::mojom::internal::ResponseChunk_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::ResponseSummaryDataView> {
    using Data = ::on_device_model::mojom::internal::ResponseSummary_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::LoadAdaptationParamsDataView> {
    using Data = ::on_device_model::mojom::internal::LoadAdaptationParams_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::InputDataView> {
    using Data = ::on_device_model::mojom::internal::Input_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::InputOptionsDataView> {
    using Data = ::on_device_model::mojom::internal::InputOptions_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::on_device_model::mojom::InputPieceDataView> {
    using Data = ::on_device_model::mojom::internal::InputPiece_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

} // namespace internal
} // namespace mojo

namespace on_device_model::mojom {

enum class Token : int32_t {

    kSystem = 0,

    kModel = 1,

    kUser = 2,

    kEnd = 3,
    kMinValue = 0,
    kMaxValue = 3,
    kDefaultValue = 3
};

std::ostream& operator<<(std::ostream& os, Token value);
inline bool IsKnownEnumValue(Token value)
{
    return internal::Token_Data::IsKnownValue(static_cast<int32_t>(value));
}
inline Token ToKnownEnumValue(Token value)
{
    if (IsKnownEnumValue(value)) {
        return value;
    }
    return Token::kDefaultValue;
}

enum class PerformanceClass : int32_t {

    kError = 0,

    kGpuBlocked = 1,

    kFailedToLoadLibrary = 2,

    kVeryLow = 3,

    kLow = 4,

    kMedium = 5,

    kHigh = 6,

    kVeryHigh = 7,
    kMinValue = 0,
    kMaxValue = 7,
    kDefaultValue = 0
};

std::ostream& operator<<(std::ostream& os, PerformanceClass value);
inline bool IsKnownEnumValue(PerformanceClass value)
{
    return internal::PerformanceClass_Data::IsKnownValue(static_cast<int32_t>(value));
}
inline PerformanceClass ToKnownEnumValue(PerformanceClass value)
{
    if (IsKnownEnumValue(value)) {
        return value;
    }
    return PerformanceClass::kDefaultValue;
}

enum class LoadModelResult : int32_t {

    kSuccess = 0,

    kGpuBlocked = 1,

    kFailedToLoadLibrary = 2,
    kMinValue = 0,
    kMaxValue = 2,
    kDefaultValue = 2
};

std::ostream& operator<<(std::ostream& os, LoadModelResult value);
inline bool IsKnownEnumValue(LoadModelResult value)
{
    return internal::LoadModelResult_Data::IsKnownValue(static_cast<int32_t>(value));
}
inline LoadModelResult ToKnownEnumValue(LoadModelResult value)
{
    if (IsKnownEnumValue(value)) {
        return value;
    }
    return LoadModelResult::kDefaultValue;
}
// Interface base classes. They are used for type safety check.
class StreamingResponderInterfaceBase { };

using StreamingResponderPtrDataView = mojo::InterfacePtrDataView<StreamingResponderInterfaceBase>;
using StreamingResponderRequestDataView = mojo::InterfaceRequestDataView<StreamingResponderInterfaceBase>;
using StreamingResponderAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<StreamingResponderInterfaceBase>;
using StreamingResponderAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<StreamingResponderInterfaceBase>;
class ContextClientInterfaceBase { };

using ContextClientPtrDataView = mojo::InterfacePtrDataView<ContextClientInterfaceBase>;
using ContextClientRequestDataView = mojo::InterfaceRequestDataView<ContextClientInterfaceBase>;
using ContextClientAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<ContextClientInterfaceBase>;
using ContextClientAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<ContextClientInterfaceBase>;
class SessionInterfaceBase { };

using SessionPtrDataView = mojo::InterfacePtrDataView<SessionInterfaceBase>;
using SessionRequestDataView = mojo::InterfaceRequestDataView<SessionInterfaceBase>;
using SessionAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<SessionInterfaceBase>;
using SessionAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<SessionInterfaceBase>;
class OnDeviceModelInterfaceBase { };

using OnDeviceModelPtrDataView = mojo::InterfacePtrDataView<OnDeviceModelInterfaceBase>;
using OnDeviceModelRequestDataView = mojo::InterfaceRequestDataView<OnDeviceModelInterfaceBase>;
using OnDeviceModelAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<OnDeviceModelInterfaceBase>;
using OnDeviceModelAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<OnDeviceModelInterfaceBase>;
class TextSafetyModelInterfaceBase { };

using TextSafetyModelPtrDataView = mojo::InterfacePtrDataView<TextSafetyModelInterfaceBase>;
using TextSafetyModelRequestDataView = mojo::InterfaceRequestDataView<TextSafetyModelInterfaceBase>;
using TextSafetyModelAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<TextSafetyModelInterfaceBase>;
using TextSafetyModelAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<TextSafetyModelInterfaceBase>;

class AdaptationAssetsDataView {
public:
    AdaptationAssetsDataView() = default;

    AdaptationAssetsDataView(internal::AdaptationAssets_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetWeightsDataView(::mojo_base::mojom::FileDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadWeights(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::FileDataView, UserType>(),
            "Attempting to read the optional `weights` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadWeights` instead "
            "of `ReadWeights if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->weights.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::FileDataView>(pointer, output, message_);
    }
    inline void GetWeightsPathDataView(::mojo_base::mojom::FilePathDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadWeightsPath(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::FilePathDataView, UserType>(),
            "Attempting to read the optional `weights_path` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadWeightsPath` instead "
            "of `ReadWeightsPath if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->header_.version >= 1 ? data_->weights_path.Get() : nullptr;
        return mojo::internal::Deserialize<::mojo_base::mojom::FilePathDataView>(pointer, output, message_);
    }

private:
    internal::AdaptationAssets_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LanguageDetectionResultDataView {
public:
    LanguageDetectionResultDataView() = default;

    LanguageDetectionResultDataView(internal::LanguageDetectionResult_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetCodeDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCode(UserType* output)
    {

        auto* pointer = data_->code.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    float reliability() const
    {
        return data_->reliability;
    }

private:
    internal::LanguageDetectionResult_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class SafetyInfoDataView {
public:
    SafetyInfoDataView() = default;

    SafetyInfoDataView(internal::SafetyInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetClassScoresDataView(mojo::ArrayDataView<float>* output);

    template <typename UserType> [[nodiscard]] bool ReadClassScores(UserType* output)
    {

        auto* pointer = data_->class_scores.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<float>>(pointer, output, message_);
    }
    inline void GetLanguageDataView(LanguageDetectionResultDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLanguage(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::on_device_model::mojom::LanguageDetectionResultDataView, UserType>(),
            "Attempting to read the optional `language` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadLanguage` instead "
            "of `ReadLanguage if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->language.Get();
        return mojo::internal::Deserialize<::on_device_model::mojom::LanguageDetectionResultDataView>(pointer, output, message_);
    }

private:
    internal::SafetyInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ResponseChunkDataView {
public:
    ResponseChunkDataView() = default;

    ResponseChunkDataView(internal::ResponseChunk_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetTextDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadText(UserType* output)
    {

        auto* pointer = data_->text.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetSafetyInfoDataView(SafetyInfoDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSafetyInfo(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::on_device_model::mojom::SafetyInfoDataView, UserType>(),
            "Attempting to read the optional `safety_info` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSafetyInfo` instead "
            "of `ReadSafetyInfo if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->safety_info.Get();
        return mojo::internal::Deserialize<::on_device_model::mojom::SafetyInfoDataView>(pointer, output, message_);
    }

private:
    internal::ResponseChunk_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class ResponseSummaryDataView {
public:
    ResponseSummaryDataView() = default;

    ResponseSummaryDataView(internal::ResponseSummary_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetSafetyInfoDataView(SafetyInfoDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSafetyInfo(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::on_device_model::mojom::SafetyInfoDataView, UserType>(),
            "Attempting to read the optional `safety_info` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadSafetyInfo` instead "
            "of `ReadSafetyInfo if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->safety_info.Get();
        return mojo::internal::Deserialize<::on_device_model::mojom::SafetyInfoDataView>(pointer, output, message_);
    }
    uint32_t input_token_count() const
    {
        if (data_->header_.version < 1)
            return uint32_t {};
        return data_->input_token_count;
    }
    uint32_t output_token_count() const
    {
        if (data_->header_.version < 1)
            return uint32_t {};
        return data_->output_token_count;
    }

private:
    internal::ResponseSummary_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class LoadAdaptationParamsDataView {
public:
    LoadAdaptationParamsDataView() = default;

    LoadAdaptationParamsDataView(internal::LoadAdaptationParams_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetAssetsDataView(AdaptationAssetsDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAssets(UserType* output)
    {

        auto* pointer = data_->assets.Get();
        return mojo::internal::Deserialize<::on_device_model::mojom::AdaptationAssetsDataView>(pointer, output, message_);
    }

private:
    internal::LoadAdaptationParams_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class InputDataView {
public:
    InputDataView() = default;

    InputDataView(internal::Input_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetPiecesDataView(mojo::ArrayDataView<InputPieceDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadPieces(UserType* output)
    {

        auto* pointer = data_->pieces.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<::on_device_model::mojom::InputPieceDataView>>(pointer, output, message_);
    }

private:
    internal::Input_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class InputOptionsDataView {
public:
    InputOptionsDataView() = default;

    InputOptionsDataView(internal::InputOptions_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetTextDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadText(UserType* output)
    {

        auto* pointer = data_->text.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    std::optional<uint32_t> max_tokens() const
    {

        return data_->max_tokens_$flag ? std::make_optional(data_->max_tokens_$value) : std::nullopt;
    }
    std::optional<uint32_t> token_offset() const
    {

        return data_->token_offset_$flag ? std::make_optional(data_->token_offset_$value) : std::nullopt;
    }
    bool ignore_context() const
    {
        return data_->ignore_context;
    }
    std::optional<uint32_t> max_output_tokens() const
    {

        return data_->max_output_tokens_$flag ? std::make_optional(data_->max_output_tokens_$value) : std::nullopt;
    }
    std::optional<uint32_t> unused_safety_interval() const
    {

        return data_->unused_safety_interval_$flag ? std::make_optional(data_->unused_safety_interval_$value) : std::nullopt;
    }
    std::optional<uint32_t> top_k() const
    {

        return data_->top_k_$flag ? std::make_optional(data_->top_k_$value) : std::nullopt;
    }
    std::optional<float> temperature() const
    {

        return data_->temperature_$flag ? std::make_optional(data_->temperature_$value) : std::nullopt;
    }
    inline void GetInputDataView(InputDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadInput(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::on_device_model::mojom::InputDataView, UserType>(),
            "Attempting to read the optional `input` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadInput` instead "
            "of `ReadInput if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->header_.version >= 1 ? data_->input.Get() : nullptr;
        return mojo::internal::Deserialize<::on_device_model::mojom::InputDataView>(pointer, output, message_);
    }

private:
    internal::InputOptions_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class InputPieceDataView {
public:
    using Tag = internal::InputPiece_Data::InputPiece_Tag;

    InputPieceDataView() = default;

    InputPieceDataView(internal::InputPiece_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_token() const
    {
        return data_->tag == Tag::kToken;
    }
    template <typename UserType> [[nodiscard]] bool ReadToken(UserType* output) const
    {
        CHECK(is_token());
        return mojo::internal::Deserialize<::on_device_model::mojom::Token>(data_->data.f_token, output);
    }
    Token token() const
    {
        CHECK(is_token());
        // TODO(dcheng): This seems incorrect, as it bypasses enum traits.
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::Token>(data_->data.f_token));
    }
    bool is_text() const
    {
        return data_->tag == Tag::kText;
    }
    inline void GetTextDataView(mojo::StringDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadText(UserType* output) const
    {

        CHECK(is_text());
        return mojo::internal::Deserialize<mojo::StringDataView>(data_->data.f_text.Get(), output, message_);
    }

private:
    internal::InputPiece_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // on_device_model::mojom

namespace std {

template <> struct hash<::on_device_model::mojom::Token> : public mojo::internal::EnumHashImpl<::on_device_model::mojom::Token> { };

template <> struct hash<::on_device_model::mojom::PerformanceClass> : public mojo::internal::EnumHashImpl<::on_device_model::mojom::PerformanceClass> { };

template <> struct hash<::on_device_model::mojom::LoadModelResult> : public mojo::internal::EnumHashImpl<::on_device_model::mojom::LoadModelResult> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::Token, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::on_device_model::mojom::Token, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::Token>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::PerformanceClass, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::on_device_model::mojom::PerformanceClass, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::PerformanceClass>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::LoadModelResult, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::on_device_model::mojom::LoadModelResult, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::on_device_model::mojom::LoadModelResult>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::AdaptationAssetsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::AdaptationAssetsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::AdaptationAssets_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::weights(input)) in_weights = Traits::weights(input);
        mojo::internal::MessageFragment<typename decltype(fragment->weights)::BaseType> weights_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::FileDataView>(in_weights, weights_fragment);
        fragment->weights.Set(weights_fragment.is_null() ? nullptr : weights_fragment.data());
        decltype(Traits::weights_path(input)) in_weights_path = Traits::weights_path(input);
        mojo::internal::MessageFragment<typename decltype(fragment->weights_path)::BaseType> weights_path_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(in_weights_path, weights_path_fragment);
        fragment->weights_path.Set(weights_path_fragment.is_null() ? nullptr : weights_path_fragment.data());
    }

    static bool Deserialize(::on_device_model::mojom::internal::AdaptationAssets_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::AdaptationAssetsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::LanguageDetectionResultDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::LanguageDetectionResultDataView, UserType>;

    static void Serialize(
        MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::LanguageDetectionResult_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::code(input)) in_code = Traits::code(input);
        mojo::internal::MessageFragment<typename decltype(fragment->code)::BaseType> code_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_code, code_fragment);
        fragment->code.Set(code_fragment.is_null() ? nullptr : code_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->code.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null code in LanguageDetectionResult struct");
        fragment->reliability = Traits::reliability(input);
    }

    static bool Deserialize(::on_device_model::mojom::internal::LanguageDetectionResult_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::LanguageDetectionResultDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::SafetyInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::SafetyInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::SafetyInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::class_scores(input)) in_class_scores = Traits::class_scores(input);
        mojo::internal::MessageFragment<typename decltype(fragment->class_scores)::BaseType> class_scores_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& class_scores_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<float>>(in_class_scores, class_scores_fragment, &class_scores_validate_params);
        fragment->class_scores.Set(class_scores_fragment.is_null() ? nullptr : class_scores_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->class_scores.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null class_scores in SafetyInfo struct");
        decltype(Traits::language(input)) in_language = Traits::language(input);
        mojo::internal::MessageFragment<typename decltype(fragment->language)::BaseType> language_fragment(fragment.message());
        mojo::internal::Serialize<::on_device_model::mojom::LanguageDetectionResultDataView>(in_language, language_fragment);
        fragment->language.Set(language_fragment.is_null() ? nullptr : language_fragment.data());
    }

    static bool Deserialize(::on_device_model::mojom::internal::SafetyInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::SafetyInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::ResponseChunkDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::ResponseChunkDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::ResponseChunk_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::text(input)) in_text = Traits::text(input);
        mojo::internal::MessageFragment<typename decltype(fragment->text)::BaseType> text_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_text, text_fragment);
        fragment->text.Set(text_fragment.is_null() ? nullptr : text_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->text.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null text in ResponseChunk struct");
        decltype(Traits::safety_info(input)) in_safety_info = Traits::safety_info(input);
        mojo::internal::MessageFragment<typename decltype(fragment->safety_info)::BaseType> safety_info_fragment(fragment.message());
        mojo::internal::Serialize<::on_device_model::mojom::SafetyInfoDataView>(in_safety_info, safety_info_fragment);
        fragment->safety_info.Set(safety_info_fragment.is_null() ? nullptr : safety_info_fragment.data());
    }

    static bool Deserialize(::on_device_model::mojom::internal::ResponseChunk_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::ResponseChunkDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::ResponseSummaryDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::ResponseSummaryDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::ResponseSummary_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::safety_info(input)) in_safety_info = Traits::safety_info(input);
        mojo::internal::MessageFragment<typename decltype(fragment->safety_info)::BaseType> safety_info_fragment(fragment.message());
        mojo::internal::Serialize<::on_device_model::mojom::SafetyInfoDataView>(in_safety_info, safety_info_fragment);
        fragment->safety_info.Set(safety_info_fragment.is_null() ? nullptr : safety_info_fragment.data());
        fragment->input_token_count = Traits::input_token_count(input);
        fragment->output_token_count = Traits::output_token_count(input);
    }

    static bool Deserialize(::on_device_model::mojom::internal::ResponseSummary_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::ResponseSummaryDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::LoadAdaptationParamsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::LoadAdaptationParamsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::LoadAdaptationParams_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::assets(input)) in_assets = Traits::assets(input);
        mojo::internal::MessageFragment<typename decltype(fragment->assets)::BaseType> assets_fragment(fragment.message());
        mojo::internal::Serialize<::on_device_model::mojom::AdaptationAssetsDataView>(in_assets, assets_fragment);
        fragment->assets.Set(assets_fragment.is_null() ? nullptr : assets_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->assets.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null assets in LoadAdaptationParams struct");
    }

    static bool Deserialize(::on_device_model::mojom::internal::LoadAdaptationParams_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::LoadAdaptationParamsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::InputDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::InputDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::Input_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::pieces(input)) in_pieces = Traits::pieces(input);
        mojo::internal::MessageFragment<typename decltype(fragment->pieces)::BaseType> pieces_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& pieces_validate_params = mojo::internal::GetArrayValidator<0, false, nullptr>();
        mojo::internal::Serialize<mojo::ArrayDataView<::on_device_model::mojom::InputPieceDataView>>(in_pieces, pieces_fragment, &pieces_validate_params);
        fragment->pieces.Set(pieces_fragment.is_null() ? nullptr : pieces_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->pieces.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null pieces in Input struct");
    }

    static bool Deserialize(::on_device_model::mojom::internal::Input_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::InputDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::InputOptionsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::on_device_model::mojom::InputOptionsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::on_device_model::mojom::internal::InputOptions_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::text(input)) in_text = Traits::text(input);
        mojo::internal::MessageFragment<typename decltype(fragment->text)::BaseType> text_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_text, text_fragment);
        fragment->text.Set(text_fragment.is_null() ? nullptr : text_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->text.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null text in InputOptions struct");
        fragment->max_tokens_$flag = Traits::max_tokens(input).has_value();
        if (Traits::max_tokens(input).has_value()) {
            fragment->max_tokens_$value = Traits::max_tokens(input).value();
        }
        fragment->token_offset_$flag = Traits::token_offset(input).has_value();
        if (Traits::token_offset(input).has_value()) {
            fragment->token_offset_$value = Traits::token_offset(input).value();
        }
        fragment->ignore_context = Traits::ignore_context(input);
        fragment->max_output_tokens_$flag = Traits::max_output_tokens(input).has_value();
        if (Traits::max_output_tokens(input).has_value()) {
            fragment->max_output_tokens_$value = Traits::max_output_tokens(input).value();
        }
        fragment->unused_safety_interval_$flag = Traits::unused_safety_interval(input).has_value();
        if (Traits::unused_safety_interval(input).has_value()) {
            fragment->unused_safety_interval_$value = Traits::unused_safety_interval(input).value();
        }
        fragment->top_k_$flag = Traits::top_k(input).has_value();
        if (Traits::top_k(input).has_value()) {
            fragment->top_k_$value = Traits::top_k(input).value();
        }
        fragment->temperature_$flag = Traits::temperature(input).has_value();
        if (Traits::temperature(input).has_value()) {
            fragment->temperature_$value = Traits::temperature(input).value();
        }
        decltype(Traits::input(input)) in_input = Traits::input(input);
        mojo::internal::MessageFragment<typename decltype(fragment->input)::BaseType> input_fragment(fragment.message());
        mojo::internal::Serialize<::on_device_model::mojom::InputDataView>(in_input, input_fragment);
        fragment->input.Set(input_fragment.is_null() ? nullptr : input_fragment.data());
    }

    static bool Deserialize(::on_device_model::mojom::internal::InputOptions_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::InputOptionsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::on_device_model::mojom::InputPieceDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::on_device_model::mojom::InputPieceDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::on_device_model::mojom::internal::InputPiece_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::on_device_model::mojom::InputPieceDataView::Tag::kToken: {
            decltype(Traits::token(input)) in_token = Traits::token(input);
            mojo::internal::Serialize<::on_device_model::mojom::Token>(in_token, &fragment->data.f_token);
            break;
        }
        case ::on_device_model::mojom::InputPieceDataView::Tag::kText: {
            decltype(Traits::text(input)) in_text = Traits::text(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_text)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<mojo::StringDataView>(in_text, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null text in InputPiece union");
            fragment->data.f_text.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::on_device_model::mojom::internal::InputPiece_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::on_device_model::mojom::InputPieceDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace on_device_model::mojom {

inline void AdaptationAssetsDataView::GetWeightsDataView(::mojo_base::mojom::FileDataView* output)
{
    auto pointer = data_->weights.Get();
    *output = ::mojo_base::mojom::FileDataView(pointer, message_);
}
inline void AdaptationAssetsDataView::GetWeightsPathDataView(::mojo_base::mojom::FilePathDataView* output)
{
    auto pointer = data_->header_.version >= 1 ? data_->weights_path.Get() : nullptr;
    *output = ::mojo_base::mojom::FilePathDataView(pointer, message_);
}

inline void LanguageDetectionResultDataView::GetCodeDataView(mojo::StringDataView* output)
{
    auto pointer = data_->code.Get();
    *output = mojo::StringDataView(pointer, message_);
}

inline void SafetyInfoDataView::GetClassScoresDataView(mojo::ArrayDataView<float>* output)
{
    auto pointer = data_->class_scores.Get();
    *output = mojo::ArrayDataView<float>(pointer, message_);
}
inline void SafetyInfoDataView::GetLanguageDataView(LanguageDetectionResultDataView* output)
{
    auto pointer = data_->language.Get();
    *output = LanguageDetectionResultDataView(pointer, message_);
}

inline void ResponseChunkDataView::GetTextDataView(mojo::StringDataView* output)
{
    auto pointer = data_->text.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void ResponseChunkDataView::GetSafetyInfoDataView(SafetyInfoDataView* output)
{
    auto pointer = data_->safety_info.Get();
    *output = SafetyInfoDataView(pointer, message_);
}

inline void ResponseSummaryDataView::GetSafetyInfoDataView(SafetyInfoDataView* output)
{
    auto pointer = data_->safety_info.Get();
    *output = SafetyInfoDataView(pointer, message_);
}

inline void LoadAdaptationParamsDataView::GetAssetsDataView(AdaptationAssetsDataView* output)
{
    auto pointer = data_->assets.Get();
    *output = AdaptationAssetsDataView(pointer, message_);
}

inline void InputDataView::GetPiecesDataView(mojo::ArrayDataView<InputPieceDataView>* output)
{
    auto pointer = data_->pieces.Get();
    *output = mojo::ArrayDataView<InputPieceDataView>(pointer, message_);
}

inline void InputOptionsDataView::GetTextDataView(mojo::StringDataView* output)
{
    auto pointer = data_->text.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void InputOptionsDataView::GetInputDataView(InputDataView* output)
{
    auto pointer = data_->header_.version >= 1 ? data_->input.Get() : nullptr;
    *output = InputDataView(pointer, message_);
}

inline void InputPieceDataView::GetTextDataView(mojo::StringDataView* output) const
{
    CHECK(is_text());
    *output = mojo::StringDataView(data_->data.f_text.Get(), message_);
}

} // on_device_model::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct TraceFormatTraits<::on_device_model::mojom::Token> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::on_device_model::mojom::Token value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::on_device_model::mojom::PerformanceClass> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::on_device_model::mojom::PerformanceClass value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::on_device_model::mojom::LoadModelResult> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::on_device_model::mojom::LoadModelResult value);
};

} // namespace perfetto

#endif // SERVICES_ON_DEVICE_MODEL_PUBLIC_MOJOM_ON_DEVICE_MODEL_MOJOM_SHARED_H_
