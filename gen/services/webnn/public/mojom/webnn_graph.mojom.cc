// services/webnn/public/mojom/webnn_graph.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "services/webnn/public/mojom/webnn_graph.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/task/thread_pool/thread_pool_instance.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/features.h"
#include "mojo/public/cpp/bindings/lib/default_construct_tag_internal.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/cpp/bindings/urgent_message_scope.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "services/webnn/public/mojom/webnn_graph.mojom-params-data.h"
#include "services/webnn/public/mojom/webnn_graph.mojom-shared-message-ids.h"

#include "services/webnn/public/mojom/webnn_graph.mojom-import-headers.h"
#include "services/webnn/public/mojom/webnn_graph.mojom-test-utils.h"

namespace webnn::mojom {
OperandDescriptor::OperandDescriptor()
    : data_type()
    , shape()
{
}

OperandDescriptor::OperandDescriptor(DataType data_type_in, std::vector<uint32_t> shape_in)
    : data_type(std::move(data_type_in))
    , shape(std::move(shape_in))
{
}

OperandDescriptor::~OperandDescriptor() = default;

void OperandDescriptor::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("data_type"), this->data_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type DataType>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("shape"), this->shape,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint32_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool OperandDescriptor::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Operand::Operand()
    : kind()
    , descriptor(mojo::internal::DefaultConstructTag())
    , name()
{
}

Operand::Operand(Operand::Kind kind_in, const ::webnn::OperandDescriptor& descriptor_in, const std::optional<std::string>& name_in)
    : kind(std::move(kind_in))
    , descriptor(std::move(descriptor_in))
    , name(std::move(name_in))
{
}

Operand::~Operand() = default;

void Operand::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("kind"), this->kind,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Operand::Kind>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("descriptor"), this->descriptor,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const ::webnn::OperandDescriptor&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<std::string>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Operand::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ArgMinMax::ArgMinMax()
    : kind()
    , input_operand_id()
    , output_operand_id()
    , axis()
    , keep_dimensions(false)
    , label()
{
}

ArgMinMax::ArgMinMax(ArgMinMax::Kind kind_in, uint64_t input_operand_id_in, uint64_t output_operand_id_in, uint32_t axis_in, bool keep_dimensions_in,
    const std::string& label_in)
    : kind(std::move(kind_in))
    , input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , axis(std::move(axis_in))
    , keep_dimensions(std::move(keep_dimensions_in))
    , label(std::move(label_in))
{
}

ArgMinMax::~ArgMinMax() = default;
size_t ArgMinMax::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->kind);
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->axis);
    seed = mojo::internal::Hash(seed, this->keep_dimensions);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void ArgMinMax::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("kind"), this->kind,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ArgMinMax::Kind>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("keep_dimensions"), this->keep_dimensions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ArgMinMax::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
BatchNormalization::BatchNormalization()
    : input_operand_id()
    , mean_operand_id()
    , variance_operand_id()
    , output_operand_id()
    , scale_operand_id()
    , bias_operand_id()
    , axis(1U)
    , epsilon(1e-5f)
    , label()
{
}

BatchNormalization::BatchNormalization(uint64_t input_operand_id_in, uint64_t mean_operand_id_in, uint64_t variance_operand_id_in,
    uint64_t output_operand_id_in, std::optional<uint64_t> scale_operand_id_in, std::optional<uint64_t> bias_operand_id_in, uint32_t axis_in, float epsilon_in,
    const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , mean_operand_id(std::move(mean_operand_id_in))
    , variance_operand_id(std::move(variance_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , scale_operand_id(std::move(scale_operand_id_in))
    , bias_operand_id(std::move(bias_operand_id_in))
    , axis(std::move(axis_in))
    , epsilon(std::move(epsilon_in))
    , label(std::move(label_in))
{
}

BatchNormalization::~BatchNormalization() = default;

void BatchNormalization::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mean_operand_id"), this->mean_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("variance_operand_id"), this->variance_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scale_operand_id"), this->scale_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bias_operand_id"), this->bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("epsilon"), this->epsilon,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool BatchNormalization::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Clamp::Clamp()
    : input_operand_id()
    , output_operand_id()
    , min_value()
    , max_value()
    , label()
{
}

Clamp::Clamp(uint64_t input_operand_id_in, uint64_t output_operand_id_in, float min_value_in, float max_value_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , min_value(std::move(min_value_in))
    , max_value(std::move(max_value_in))
    , label(std::move(label_in))
{
}

Clamp::~Clamp() = default;
size_t Clamp::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->min_value);
    seed = mojo::internal::Hash(seed, this->max_value);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Clamp::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("min_value"), this->min_value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("max_value"), this->max_value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Clamp::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Concat::Concat()
    : input_operand_ids()
    , output_operand_id()
    , axis()
    , label()
{
}

Concat::Concat(std::vector<uint64_t> input_operand_ids_in, uint64_t output_operand_id_in, uint32_t axis_in, const std::string& label_in)
    : input_operand_ids(std::move(input_operand_ids_in))
    , output_operand_id(std::move(output_operand_id_in))
    , axis(std::move(axis_in))
    , label(std::move(label_in))
{
}

Concat::~Concat() = default;

void Concat::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_ids"), this->input_operand_ids,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint64_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Concat::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Size2d::Size2d()
    : height()
    , width()
{
}

Size2d::Size2d(uint32_t height_in, uint32_t width_in)
    : height(std::move(height_in))
    , width(std::move(width_in))
{
}

Size2d::~Size2d() = default;
size_t Size2d::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->height);
    seed = mojo::internal::Hash(seed, this->width);
    return seed;
}

void Size2d::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("height"), this->height,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("width"), this->width,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Size2d::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Padding2d::Padding2d()
    : beginning()
    , ending()
{
}

Padding2d::Padding2d(Size2dPtr beginning_in, Size2dPtr ending_in)
    : beginning(std::move(beginning_in))
    , ending(std::move(ending_in))
{
}

Padding2d::~Padding2d() = default;
size_t Padding2d::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->beginning);
    seed = mojo::internal::Hash(seed, this->ending);
    return seed;
}

void Padding2d::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("beginning"), this->beginning,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Size2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ending"), this->ending,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Size2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Padding2d::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Conv2d::Conv2d()
    : kind()
    , input_operand_id()
    , filter_operand_id()
    , output_operand_id()
    , padding()
    , strides()
    , dilations()
    , groups(1U)
    , bias_operand_id()
    , label()
{
}

Conv2d::Conv2d(Conv2d::Kind kind_in, uint64_t input_operand_id_in, uint64_t filter_operand_id_in, uint64_t output_operand_id_in, Padding2dPtr padding_in,
    Size2dPtr strides_in, Size2dPtr dilations_in, uint32_t groups_in, std::optional<uint64_t> bias_operand_id_in, const std::string& label_in)
    : kind(std::move(kind_in))
    , input_operand_id(std::move(input_operand_id_in))
    , filter_operand_id(std::move(filter_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , padding(std::move(padding_in))
    , strides(std::move(strides_in))
    , dilations(std::move(dilations_in))
    , groups(std::move(groups_in))
    , bias_operand_id(std::move(bias_operand_id_in))
    , label(std::move(label_in))
{
}

Conv2d::~Conv2d() = default;

void Conv2d::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("kind"), this->kind,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Conv2d::Kind>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("filter_operand_id"), this->filter_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("padding"), this->padding,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Padding2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("strides"), this->strides,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Size2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("dilations"), this->dilations,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Size2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("groups"), this->groups,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bias_operand_id"), this->bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Conv2d::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
CumulativeSum::CumulativeSum()
    : input_operand_id()
    , output_operand_id()
    , axis()
    , exclusive(false)
    , reversed(false)
    , label()
{
}

CumulativeSum::CumulativeSum(
    uint64_t input_operand_id_in, uint64_t output_operand_id_in, uint32_t axis_in, bool exclusive_in, bool reversed_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , axis(std::move(axis_in))
    , exclusive(std::move(exclusive_in))
    , reversed(std::move(reversed_in))
    , label(std::move(label_in))
{
}

CumulativeSum::~CumulativeSum() = default;
size_t CumulativeSum::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->axis);
    seed = mojo::internal::Hash(seed, this->exclusive);
    seed = mojo::internal::Hash(seed, this->reversed);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void CumulativeSum::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("exclusive"), this->exclusive,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("reversed"), this->reversed,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool CumulativeSum::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
DequantizeLinear::DequantizeLinear()
    : input_operand_id()
    , scale_operand_id()
    , zero_point_operand_id()
    , output_operand_id()
    , label()
{
}

DequantizeLinear::DequantizeLinear(
    uint64_t input_operand_id_in, uint64_t scale_operand_id_in, uint64_t zero_point_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , scale_operand_id(std::move(scale_operand_id_in))
    , zero_point_operand_id(std::move(zero_point_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

DequantizeLinear::~DequantizeLinear() = default;
size_t DequantizeLinear::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->scale_operand_id);
    seed = mojo::internal::Hash(seed, this->zero_point_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void DequantizeLinear::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scale_operand_id"), this->scale_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("zero_point_operand_id"), this->zero_point_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DequantizeLinear::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ElementWiseBinary::ElementWiseBinary()
    : kind()
    , lhs_operand_id()
    , rhs_operand_id()
    , output_operand_id()
    , label()
{
}

ElementWiseBinary::ElementWiseBinary(
    ElementWiseBinary::Kind kind_in, uint64_t lhs_operand_id_in, uint64_t rhs_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : kind(std::move(kind_in))
    , lhs_operand_id(std::move(lhs_operand_id_in))
    , rhs_operand_id(std::move(rhs_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

ElementWiseBinary::~ElementWiseBinary() = default;
size_t ElementWiseBinary::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->kind);
    seed = mojo::internal::Hash(seed, this->lhs_operand_id);
    seed = mojo::internal::Hash(seed, this->rhs_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void ElementWiseBinary::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("kind"), this->kind,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ElementWiseBinary::Kind>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("lhs_operand_id"), this->lhs_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("rhs_operand_id"), this->rhs_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ElementWiseBinary::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ElementWiseUnary::ElementWiseUnary()
    : kind()
    , input_operand_id()
    , output_operand_id()
    , label()
{
}

ElementWiseUnary::ElementWiseUnary(ElementWiseUnary::Kind kind_in, uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : kind(std::move(kind_in))
    , input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

ElementWiseUnary::~ElementWiseUnary() = default;
size_t ElementWiseUnary::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->kind);
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void ElementWiseUnary::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("kind"), this->kind,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ElementWiseUnary::Kind>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ElementWiseUnary::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Expand::Expand()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

Expand::Expand(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Expand::~Expand() = default;
size_t Expand::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Expand::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Expand::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ConstantPadding::ConstantPadding()
    : value(0)
{
}

ConstantPadding::ConstantPadding(float value_in)
    : value(std::move(value_in))
{
}

ConstantPadding::~ConstantPadding() = default;
size_t ConstantPadding::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->value);
    return seed;
}

void ConstantPadding::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ConstantPadding::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
EdgePadding::EdgePadding()
{
}

EdgePadding::~EdgePadding() = default;
size_t EdgePadding::Hash(size_t seed) const
{
    return seed;
}

void EdgePadding::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
}

bool EdgePadding::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ReflectionPadding::ReflectionPadding()
{
}

ReflectionPadding::~ReflectionPadding() = default;
size_t ReflectionPadding::Hash(size_t seed) const
{
    return seed;
}

void ReflectionPadding::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
}

bool ReflectionPadding::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
SymmetricPadding::SymmetricPadding()
{
}

SymmetricPadding::~SymmetricPadding() = default;
size_t SymmetricPadding::Hash(size_t seed) const
{
    return seed;
}

void SymmetricPadding::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
}

bool SymmetricPadding::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
InstanceNormalization::InstanceNormalization()
    : input_operand_id()
    , output_operand_id()
    , scale_operand_id()
    , bias_operand_id()
    , epsilon(1e-5f)
    , layout()
    , label()
{
}

InstanceNormalization::InstanceNormalization(uint64_t input_operand_id_in, uint64_t output_operand_id_in, std::optional<uint64_t> scale_operand_id_in,
    std::optional<uint64_t> bias_operand_id_in, float epsilon_in, ::webnn::mojom::InputOperandLayout layout_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , scale_operand_id(std::move(scale_operand_id_in))
    , bias_operand_id(std::move(bias_operand_id_in))
    , epsilon(std::move(epsilon_in))
    , layout(std::move(layout_in))
    , label(std::move(label_in))
{
}

InstanceNormalization::~InstanceNormalization() = default;

void InstanceNormalization::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scale_operand_id"), this->scale_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bias_operand_id"), this->bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("epsilon"), this->epsilon,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("layout"), this->layout,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type ::webnn::mojom::InputOperandLayout>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool InstanceNormalization::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Matmul::Matmul()
    : a_operand_id()
    , b_operand_id()
    , output_operand_id()
    , label()
{
}

Matmul::Matmul(uint64_t a_operand_id_in, uint64_t b_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : a_operand_id(std::move(a_operand_id_in))
    , b_operand_id(std::move(b_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Matmul::~Matmul() = default;
size_t Matmul::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->a_operand_id);
    seed = mojo::internal::Hash(seed, this->b_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Matmul::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("a_operand_id"), this->a_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("b_operand_id"), this->b_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Matmul::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Pad::Pad()
    : input_operand_id()
    , output_operand_id()
    , beginning_padding()
    , ending_padding()
    , mode()
    , label()
{
}

Pad::Pad(uint64_t input_operand_id_in, uint64_t output_operand_id_in, std::vector<uint32_t> beginning_padding_in, std::vector<uint32_t> ending_padding_in,
    PaddingModePtr mode_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , beginning_padding(std::move(beginning_padding_in))
    , ending_padding(std::move(ending_padding_in))
    , mode(std::move(mode_in))
    , label(std::move(label_in))
{
}

Pad::~Pad() = default;

void Pad::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("beginning_padding"), this->beginning_padding,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint32_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ending_padding"), this->ending_padding,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint32_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mode"), this->mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type PaddingModePtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Pad::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Reduce::Reduce()
    : kind()
    , input_operand_id()
    , output_operand_id()
    , axes()
    , keep_dimensions(false)
    , label()
{
}

Reduce::Reduce(Reduce::Kind kind_in, uint64_t input_operand_id_in, uint64_t output_operand_id_in, std::vector<uint32_t> axes_in, bool keep_dimensions_in,
    const std::string& label_in)
    : kind(std::move(kind_in))
    , input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , axes(std::move(axes_in))
    , keep_dimensions(std::move(keep_dimensions_in))
    , label(std::move(label_in))
{
}

Reduce::~Reduce() = default;

void Reduce::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("kind"), this->kind,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Reduce::Kind>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axes"), this->axes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint32_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("keep_dimensions"), this->keep_dimensions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Reduce::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Pool2d::Pool2d()
    : kind()
    , input_operand_id()
    , output_operand_id()
    , window_dimensions()
    , padding()
    , strides()
    , dilations()
    , label()
{
}

Pool2d::Pool2d(Pool2d::Kind kind_in, uint64_t input_operand_id_in, uint64_t output_operand_id_in, Size2dPtr window_dimensions_in, Padding2dPtr padding_in,
    Size2dPtr strides_in, Size2dPtr dilations_in, const std::string& label_in)
    : kind(std::move(kind_in))
    , input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , window_dimensions(std::move(window_dimensions_in))
    , padding(std::move(padding_in))
    , strides(std::move(strides_in))
    , dilations(std::move(dilations_in))
    , label(std::move(label_in))
{
}

Pool2d::~Pool2d() = default;
size_t Pool2d::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->kind);
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->window_dimensions);
    seed = mojo::internal::Hash(seed, this->padding);
    seed = mojo::internal::Hash(seed, this->strides);
    seed = mojo::internal::Hash(seed, this->dilations);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Pool2d::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("kind"), this->kind,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Pool2d::Kind>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("window_dimensions"), this->window_dimensions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Size2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("padding"), this->padding,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Padding2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("strides"), this->strides,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Size2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("dilations"), this->dilations,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Size2dPtr>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Pool2d::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Range::Range()
    : start()
    , size()
    , stride()
{
}

Range::Range(uint32_t start_in, uint32_t size_in, uint32_t stride_in)
    : start(std::move(start_in))
    , size(std::move(size_in))
    , stride(std::move(stride_in))
{
}

Range::~Range() = default;

void Range::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("start"), this->start,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("size"), this->size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("stride"), this->stride,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Range::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Slice::Slice()
    : input_operand_id()
    , output_operand_id()
    , ranges()
    , label()
{
}

Slice::Slice(uint64_t input_operand_id_in, uint64_t output_operand_id_in, std::vector<::webnn::Range> ranges_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , ranges(std::move(ranges_in))
    , label(std::move(label_in))
{
}

Slice::~Slice() = default;

void Slice::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("ranges"), this->ranges,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<::webnn::Range>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Slice::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Elu::Elu()
    : input_operand_id()
    , output_operand_id()
    , alpha(1.0f)
    , label()
{
}

Elu::Elu(uint64_t input_operand_id_in, uint64_t output_operand_id_in, float alpha_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , alpha(std::move(alpha_in))
    , label(std::move(label_in))
{
}

Elu::~Elu() = default;
size_t Elu::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->alpha);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Elu::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alpha"), this->alpha,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Elu::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Gather::Gather()
    : input_operand_id()
    , indices_operand_id()
    , output_operand_id()
    , axis(0U)
    , label()
{
}

Gather::Gather(uint64_t input_operand_id_in, uint64_t indices_operand_id_in, uint64_t output_operand_id_in, uint32_t axis_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , indices_operand_id(std::move(indices_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , axis(std::move(axis_in))
    , label(std::move(label_in))
{
}

Gather::~Gather() = default;
size_t Gather::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->indices_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->axis);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Gather::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("indices_operand_id"), this->indices_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Gather::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
GatherElements::GatherElements()
    : input_operand_id()
    , indices_operand_id()
    , output_operand_id()
    , axis(0U)
    , label()
{
}

GatherElements::GatherElements(
    uint64_t input_operand_id_in, uint64_t indices_operand_id_in, uint64_t output_operand_id_in, uint32_t axis_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , indices_operand_id(std::move(indices_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , axis(std::move(axis_in))
    , label(std::move(label_in))
{
}

GatherElements::~GatherElements() = default;
size_t GatherElements::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->indices_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->axis);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void GatherElements::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("indices_operand_id"), this->indices_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool GatherElements::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
GatherND::GatherND()
    : input_operand_id()
    , indices_operand_id()
    , output_operand_id()
    , label()
{
}

GatherND::GatherND(uint64_t input_operand_id_in, uint64_t indices_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , indices_operand_id(std::move(indices_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

GatherND::~GatherND() = default;
size_t GatherND::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->indices_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void GatherND::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("indices_operand_id"), this->indices_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool GatherND::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Gelu::Gelu()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

Gelu::Gelu(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Gelu::~Gelu() = default;
size_t Gelu::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Gelu::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Gelu::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Gru::Gru()
    : input_operand_id()
    , weight_operand_id()
    , recurrent_weight_operand_id()
    , steps()
    , hidden_size()
    , output_operand_ids()
    , bias_operand_id()
    , recurrent_bias_operand_id()
    , initial_hidden_state_operand_id()
    , reset_after()
    , return_sequence()
    , direction()
    , layout()
    , activations()
    , label()
{
}

Gru::Gru(uint64_t input_operand_id_in, uint64_t weight_operand_id_in, uint64_t recurrent_weight_operand_id_in, uint32_t steps_in, uint32_t hidden_size_in,
    std::vector<uint64_t> output_operand_ids_in, std::optional<uint64_t> bias_operand_id_in, std::optional<uint64_t> recurrent_bias_operand_id_in,
    std::optional<uint64_t> initial_hidden_state_operand_id_in, bool reset_after_in, bool return_sequence_in, RecurrentNetworkDirection direction_in,
    GruWeightLayout layout_in, std::vector<RecurrentNetworkActivation> activations_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , weight_operand_id(std::move(weight_operand_id_in))
    , recurrent_weight_operand_id(std::move(recurrent_weight_operand_id_in))
    , steps(std::move(steps_in))
    , hidden_size(std::move(hidden_size_in))
    , output_operand_ids(std::move(output_operand_ids_in))
    , bias_operand_id(std::move(bias_operand_id_in))
    , recurrent_bias_operand_id(std::move(recurrent_bias_operand_id_in))
    , initial_hidden_state_operand_id(std::move(initial_hidden_state_operand_id_in))
    , reset_after(std::move(reset_after_in))
    , return_sequence(std::move(return_sequence_in))
    , direction(std::move(direction_in))
    , layout(std::move(layout_in))
    , activations(std::move(activations_in))
    , label(std::move(label_in))
{
}

Gru::~Gru() = default;

void Gru::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("weight_operand_id"), this->weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("recurrent_weight_operand_id"), this->recurrent_weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("steps"), this->steps,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hidden_size"), this->hidden_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_ids"), this->output_operand_ids,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint64_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bias_operand_id"), this->bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("recurrent_bias_operand_id"), this->recurrent_bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("initial_hidden_state_operand_id"), this->initial_hidden_state_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("reset_after"), this->reset_after,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("return_sequence"), this->return_sequence,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("direction"), this->direction,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RecurrentNetworkDirection>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("layout"), this->layout,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type GruWeightLayout>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("activations"), this->activations,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<RecurrentNetworkActivation>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Gru::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
GruCell::GruCell()
    : input_operand_id()
    , weight_operand_id()
    , recurrent_weight_operand_id()
    , hidden_state_operand_id()
    , hidden_size()
    , output_operand_id()
    , bias_operand_id()
    , recurrent_bias_operand_id()
    , reset_after()
    , layout()
    , activations()
    , label()
{
}

GruCell::GruCell(uint64_t input_operand_id_in, uint64_t weight_operand_id_in, uint64_t recurrent_weight_operand_id_in, uint64_t hidden_state_operand_id_in,
    uint32_t hidden_size_in, uint64_t output_operand_id_in, std::optional<uint64_t> bias_operand_id_in, std::optional<uint64_t> recurrent_bias_operand_id_in,
    bool reset_after_in, GruWeightLayout layout_in, std::vector<RecurrentNetworkActivation> activations_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , weight_operand_id(std::move(weight_operand_id_in))
    , recurrent_weight_operand_id(std::move(recurrent_weight_operand_id_in))
    , hidden_state_operand_id(std::move(hidden_state_operand_id_in))
    , hidden_size(std::move(hidden_size_in))
    , output_operand_id(std::move(output_operand_id_in))
    , bias_operand_id(std::move(bias_operand_id_in))
    , recurrent_bias_operand_id(std::move(recurrent_bias_operand_id_in))
    , reset_after(std::move(reset_after_in))
    , layout(std::move(layout_in))
    , activations(std::move(activations_in))
    , label(std::move(label_in))
{
}

GruCell::~GruCell() = default;

void GruCell::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("weight_operand_id"), this->weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("recurrent_weight_operand_id"), this->recurrent_weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hidden_state_operand_id"), this->hidden_state_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hidden_size"), this->hidden_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bias_operand_id"), this->bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("recurrent_bias_operand_id"), this->recurrent_bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("reset_after"), this->reset_after,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("layout"), this->layout,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type GruWeightLayout>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("activations"), this->activations,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<RecurrentNetworkActivation>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool GruCell::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Gemm::Gemm()
    : a_operand_id()
    , b_operand_id()
    , output_operand_id()
    , c_operand_id()
    , alpha(1.0f)
    , beta(1.0f)
    , a_transpose(false)
    , b_transpose(false)
    , label()
{
}

Gemm::Gemm(uint64_t a_operand_id_in, uint64_t b_operand_id_in, uint64_t output_operand_id_in, std::optional<uint64_t> c_operand_id_in, float alpha_in,
    float beta_in, bool a_transpose_in, bool b_transpose_in, const std::string& label_in)
    : a_operand_id(std::move(a_operand_id_in))
    , b_operand_id(std::move(b_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , c_operand_id(std::move(c_operand_id_in))
    , alpha(std::move(alpha_in))
    , beta(std::move(beta_in))
    , a_transpose(std::move(a_transpose_in))
    , b_transpose(std::move(b_transpose_in))
    , label(std::move(label_in))
{
}

Gemm::~Gemm() = default;

void Gemm::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("a_operand_id"), this->a_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("b_operand_id"), this->b_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("c_operand_id"), this->c_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alpha"), this->alpha,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("beta"), this->beta,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("a_transpose"), this->a_transpose,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("b_transpose"), this->b_transpose,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Gemm::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
HardSigmoid::HardSigmoid()
    : input_operand_id()
    , output_operand_id()
    , alpha(0.2f)
    , beta(0.5f)
    , label()
{
}

HardSigmoid::HardSigmoid(uint64_t input_operand_id_in, uint64_t output_operand_id_in, float alpha_in, float beta_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , alpha(std::move(alpha_in))
    , beta(std::move(beta_in))
    , label(std::move(label_in))
{
}

HardSigmoid::~HardSigmoid() = default;
size_t HardSigmoid::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->alpha);
    seed = mojo::internal::Hash(seed, this->beta);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void HardSigmoid::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alpha"), this->alpha,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("beta"), this->beta,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool HardSigmoid::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
HardSwish::HardSwish()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

HardSwish::HardSwish(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

HardSwish::~HardSwish() = default;
size_t HardSwish::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void HardSwish::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool HardSwish::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
LayerNormalization::LayerNormalization()
    : input_operand_id()
    , output_operand_id()
    , scale_operand_id()
    , bias_operand_id()
    , axes()
    , epsilon(1e-5f)
    , label()
{
}

LayerNormalization::LayerNormalization(uint64_t input_operand_id_in, uint64_t output_operand_id_in, std::optional<uint64_t> scale_operand_id_in,
    std::optional<uint64_t> bias_operand_id_in, std::vector<uint32_t> axes_in, float epsilon_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , scale_operand_id(std::move(scale_operand_id_in))
    , bias_operand_id(std::move(bias_operand_id_in))
    , axes(std::move(axes_in))
    , epsilon(std::move(epsilon_in))
    , label(std::move(label_in))
{
}

LayerNormalization::~LayerNormalization() = default;

void LayerNormalization::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scale_operand_id"), this->scale_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bias_operand_id"), this->bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axes"), this->axes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint32_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("epsilon"), this->epsilon,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LayerNormalization::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
LeakyRelu::LeakyRelu()
    : input_operand_id()
    , output_operand_id()
    , alpha(0.01f)
    , label()
{
}

LeakyRelu::LeakyRelu(uint64_t input_operand_id_in, uint64_t output_operand_id_in, float alpha_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , alpha(std::move(alpha_in))
    , label(std::move(label_in))
{
}

LeakyRelu::~LeakyRelu() = default;
size_t LeakyRelu::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->alpha);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void LeakyRelu::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alpha"), this->alpha,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LeakyRelu::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Linear::Linear()
    : input_operand_id()
    , output_operand_id()
    , alpha(1.0f)
    , beta(0)
    , label()
{
}

Linear::Linear(uint64_t input_operand_id_in, uint64_t output_operand_id_in, float alpha_in, float beta_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , alpha(std::move(alpha_in))
    , beta(std::move(beta_in))
    , label(std::move(label_in))
{
}

Linear::~Linear() = default;
size_t Linear::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->alpha);
    seed = mojo::internal::Hash(seed, this->beta);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Linear::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("alpha"), this->alpha,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("beta"), this->beta,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type float>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Linear::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Lstm::Lstm()
    : input_operand_id()
    , weight_operand_id()
    , recurrent_weight_operand_id()
    , output_operand_ids()
    , steps()
    , hidden_size()
    , bias_operand_id()
    , recurrent_bias_operand_id()
    , peephole_weight_operand_id()
    , initial_hidden_state_operand_id()
    , initial_cell_state_operand_id()
    , return_sequence()
    , direction()
    , layout()
    , activations()
    , label()
{
}

Lstm::Lstm(uint64_t input_operand_id_in, uint64_t weight_operand_id_in, uint64_t recurrent_weight_operand_id_in, std::vector<uint64_t> output_operand_ids_in,
    uint32_t steps_in, uint32_t hidden_size_in, std::optional<uint64_t> bias_operand_id_in, std::optional<uint64_t> recurrent_bias_operand_id_in,
    std::optional<uint64_t> peephole_weight_operand_id_in, std::optional<uint64_t> initial_hidden_state_operand_id_in,
    std::optional<uint64_t> initial_cell_state_operand_id_in, bool return_sequence_in, RecurrentNetworkDirection direction_in, LstmWeightLayout layout_in,
    std::vector<RecurrentNetworkActivation> activations_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , weight_operand_id(std::move(weight_operand_id_in))
    , recurrent_weight_operand_id(std::move(recurrent_weight_operand_id_in))
    , output_operand_ids(std::move(output_operand_ids_in))
    , steps(std::move(steps_in))
    , hidden_size(std::move(hidden_size_in))
    , bias_operand_id(std::move(bias_operand_id_in))
    , recurrent_bias_operand_id(std::move(recurrent_bias_operand_id_in))
    , peephole_weight_operand_id(std::move(peephole_weight_operand_id_in))
    , initial_hidden_state_operand_id(std::move(initial_hidden_state_operand_id_in))
    , initial_cell_state_operand_id(std::move(initial_cell_state_operand_id_in))
    , return_sequence(std::move(return_sequence_in))
    , direction(std::move(direction_in))
    , layout(std::move(layout_in))
    , activations(std::move(activations_in))
    , label(std::move(label_in))
{
}

Lstm::~Lstm() = default;

void Lstm::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("weight_operand_id"), this->weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("recurrent_weight_operand_id"), this->recurrent_weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_ids"), this->output_operand_ids,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint64_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("steps"), this->steps,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hidden_size"), this->hidden_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bias_operand_id"), this->bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("recurrent_bias_operand_id"), this->recurrent_bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("peephole_weight_operand_id"), this->peephole_weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("initial_hidden_state_operand_id"), this->initial_hidden_state_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("initial_cell_state_operand_id"), this->initial_cell_state_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("return_sequence"), this->return_sequence,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("direction"), this->direction,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type RecurrentNetworkDirection>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("layout"), this->layout,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type LstmWeightLayout>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("activations"), this->activations,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<RecurrentNetworkActivation>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Lstm::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
LstmCell::LstmCell()
    : input_operand_id()
    , weight_operand_id()
    , recurrent_weight_operand_id()
    , hidden_state_operand_id()
    , cell_state_operand_id()
    , output_operand_ids()
    , hidden_size()
    , bias_operand_id()
    , recurrent_bias_operand_id()
    , peephole_weight_operand_id()
    , layout()
    , activations()
    , label()
{
}

LstmCell::LstmCell(uint64_t input_operand_id_in, uint64_t weight_operand_id_in, uint64_t recurrent_weight_operand_id_in, uint64_t hidden_state_operand_id_in,
    uint64_t cell_state_operand_id_in, std::vector<uint64_t> output_operand_ids_in, uint32_t hidden_size_in, std::optional<uint64_t> bias_operand_id_in,
    std::optional<uint64_t> recurrent_bias_operand_id_in, std::optional<uint64_t> peephole_weight_operand_id_in, LstmWeightLayout layout_in,
    std::vector<RecurrentNetworkActivation> activations_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , weight_operand_id(std::move(weight_operand_id_in))
    , recurrent_weight_operand_id(std::move(recurrent_weight_operand_id_in))
    , hidden_state_operand_id(std::move(hidden_state_operand_id_in))
    , cell_state_operand_id(std::move(cell_state_operand_id_in))
    , output_operand_ids(std::move(output_operand_ids_in))
    , hidden_size(std::move(hidden_size_in))
    , bias_operand_id(std::move(bias_operand_id_in))
    , recurrent_bias_operand_id(std::move(recurrent_bias_operand_id_in))
    , peephole_weight_operand_id(std::move(peephole_weight_operand_id_in))
    , layout(std::move(layout_in))
    , activations(std::move(activations_in))
    , label(std::move(label_in))
{
}

LstmCell::~LstmCell() = default;

void LstmCell::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("weight_operand_id"), this->weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("recurrent_weight_operand_id"), this->recurrent_weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hidden_state_operand_id"), this->hidden_state_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("cell_state_operand_id"), this->cell_state_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_ids"), this->output_operand_ids,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint64_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("hidden_size"), this->hidden_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("bias_operand_id"), this->bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("recurrent_bias_operand_id"), this->recurrent_bias_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("peephole_weight_operand_id"), this->peephole_weight_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::optional<uint64_t>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("layout"), this->layout,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type LstmWeightLayout>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("activations"), this->activations,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<RecurrentNetworkActivation>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LstmCell::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Prelu::Prelu()
    : input_operand_id()
    , slope_operand_id()
    , output_operand_id()
    , label()
{
}

Prelu::Prelu(uint64_t input_operand_id_in, uint64_t slope_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , slope_operand_id(std::move(slope_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Prelu::~Prelu() = default;
size_t Prelu::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->slope_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Prelu::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("slope_operand_id"), this->slope_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Prelu::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
QuantizeLinear::QuantizeLinear()
    : input_operand_id()
    , scale_operand_id()
    , zero_point_operand_id()
    , output_operand_id()
    , label()
{
}

QuantizeLinear::QuantizeLinear(
    uint64_t input_operand_id_in, uint64_t scale_operand_id_in, uint64_t zero_point_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , scale_operand_id(std::move(scale_operand_id_in))
    , zero_point_operand_id(std::move(zero_point_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

QuantizeLinear::~QuantizeLinear() = default;
size_t QuantizeLinear::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->scale_operand_id);
    seed = mojo::internal::Hash(seed, this->zero_point_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void QuantizeLinear::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scale_operand_id"), this->scale_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("zero_point_operand_id"), this->zero_point_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool QuantizeLinear::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Relu::Relu()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

Relu::Relu(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Relu::~Relu() = default;
size_t Relu::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Relu::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Relu::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Reshape::Reshape()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

Reshape::Reshape(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Reshape::~Reshape() = default;
size_t Reshape::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Reshape::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Reshape::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ScatterElements::ScatterElements()
    : input_operand_id()
    , indices_operand_id()
    , updates_operand_id()
    , output_operand_id()
    , axis(0U)
    , label()
{
}

ScatterElements::ScatterElements(uint64_t input_operand_id_in, uint64_t indices_operand_id_in, uint64_t updates_operand_id_in, uint64_t output_operand_id_in,
    uint32_t axis_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , indices_operand_id(std::move(indices_operand_id_in))
    , updates_operand_id(std::move(updates_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , axis(std::move(axis_in))
    , label(std::move(label_in))
{
}

ScatterElements::~ScatterElements() = default;
size_t ScatterElements::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->indices_operand_id);
    seed = mojo::internal::Hash(seed, this->updates_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->axis);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void ScatterElements::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("indices_operand_id"), this->indices_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("updates_operand_id"), this->updates_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ScatterElements::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
ScatterND::ScatterND()
    : input_operand_id()
    , indices_operand_id()
    , updates_operand_id()
    , output_operand_id()
    , label()
{
}

ScatterND::ScatterND(
    uint64_t input_operand_id_in, uint64_t indices_operand_id_in, uint64_t updates_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , indices_operand_id(std::move(indices_operand_id_in))
    , updates_operand_id(std::move(updates_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

ScatterND::~ScatterND() = default;
size_t ScatterND::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->indices_operand_id);
    seed = mojo::internal::Hash(seed, this->updates_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void ScatterND::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("indices_operand_id"), this->indices_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("updates_operand_id"), this->updates_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ScatterND::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Sigmoid::Sigmoid()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

Sigmoid::Sigmoid(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Sigmoid::~Sigmoid() = default;
size_t Sigmoid::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Sigmoid::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Sigmoid::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Softmax::Softmax()
    : input_operand_id()
    , output_operand_id()
    , axis()
    , label()
{
}

Softmax::Softmax(uint64_t input_operand_id_in, uint64_t output_operand_id_in, uint32_t axis_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , axis(std::move(axis_in))
    , label(std::move(label_in))
{
}

Softmax::~Softmax() = default;
size_t Softmax::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->axis);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Softmax::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Softmax::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Softplus::Softplus()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

Softplus::Softplus(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Softplus::~Softplus() = default;
size_t Softplus::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Softplus::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Softplus::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Softsign::Softsign()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

Softsign::Softsign(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Softsign::~Softsign() = default;
size_t Softsign::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Softsign::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Softsign::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Split::Split()
    : input_operand_id()
    , output_operand_ids()
    , axis(0U)
    , label()
{
}

Split::Split(uint64_t input_operand_id_in, std::vector<uint64_t> output_operand_ids_in, uint32_t axis_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_ids(std::move(output_operand_ids_in))
    , axis(std::move(axis_in))
    , label(std::move(label_in))
{
}

Split::~Split() = default;

void Split::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_ids"), this->output_operand_ids,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint64_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axis"), this->axis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Split::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Tanh::Tanh()
    : input_operand_id()
    , output_operand_id()
    , label()
{
}

Tanh::Tanh(uint64_t input_operand_id_in, uint64_t output_operand_id_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Tanh::~Tanh() = default;
size_t Tanh::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Tanh::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Tanh::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Tile::Tile()
    : input_operand_id()
    , output_operand_id()
    , repetitions()
    , label()
{
}

Tile::Tile(uint64_t input_operand_id_in, uint64_t output_operand_id_in, std::vector<uint32_t> repetitions_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , repetitions(std::move(repetitions_in))
    , label(std::move(label_in))
{
}

Tile::~Tile() = default;

void Tile::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("repetitions"), this->repetitions,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint32_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Tile::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Transpose::Transpose()
    : input_operand_id()
    , output_operand_id()
    , permutation()
    , label()
{
}

Transpose::Transpose(uint64_t input_operand_id_in, uint64_t output_operand_id_in, std::vector<uint32_t> permutation_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , permutation(std::move(permutation_in))
    , label(std::move(label_in))
{
}

Transpose::~Transpose() = default;

void Transpose::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("permutation"), this->permutation,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint32_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Transpose::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Triangular::Triangular()
    : input_operand_id()
    , output_operand_id()
    , upper()
    , diagonal()
    , label()
{
}

Triangular::Triangular(uint64_t input_operand_id_in, uint64_t output_operand_id_in, bool upper_in, int32_t diagonal_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , upper(std::move(upper_in))
    , diagonal(std::move(diagonal_in))
    , label(std::move(label_in))
{
}

Triangular::~Triangular() = default;
size_t Triangular::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->input_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->upper);
    seed = mojo::internal::Hash(seed, this->diagonal);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Triangular::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("upper"), this->upper,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type bool>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("diagonal"), this->diagonal,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type int32_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Triangular::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Resample2d::Resample2d()
    : input_operand_id()
    , output_operand_id()
    , mode()
    , scales()
    , axes()
    , label()
{
}

Resample2d::Resample2d(uint64_t input_operand_id_in, uint64_t output_operand_id_in, Resample2d::InterpolationMode mode_in,
    std::optional<std::vector<float>> scales_in, std::vector<uint32_t> axes_in, const std::string& label_in)
    : input_operand_id(std::move(input_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , mode(std::move(mode_in))
    , scales(std::move(scales_in))
    , axes(std::move(axes_in))
    , label(std::move(label_in))
{
}

Resample2d::~Resample2d() = default;

void Resample2d::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operand_id"), this->input_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("mode"), this->mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type Resample2d::InterpolationMode>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("scales"), this->scales,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::optional<std::vector<float>>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("axes"), this->axes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint32_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Resample2d::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
Where::Where()
    : condition_operand_id()
    , true_value_operand_id()
    , false_value_operand_id()
    , output_operand_id()
    , label()
{
}

Where::Where(uint64_t condition_operand_id_in, uint64_t true_value_operand_id_in, uint64_t false_value_operand_id_in, uint64_t output_operand_id_in,
    const std::string& label_in)
    : condition_operand_id(std::move(condition_operand_id_in))
    , true_value_operand_id(std::move(true_value_operand_id_in))
    , false_value_operand_id(std::move(false_value_operand_id_in))
    , output_operand_id(std::move(output_operand_id_in))
    , label(std::move(label_in))
{
}

Where::~Where() = default;
size_t Where::Hash(size_t seed) const
{
    seed = mojo::internal::Hash(seed, this->condition_operand_id);
    seed = mojo::internal::Hash(seed, this->true_value_operand_id);
    seed = mojo::internal::Hash(seed, this->false_value_operand_id);
    seed = mojo::internal::Hash(seed, this->output_operand_id);
    seed = mojo::internal::Hash(seed, this->label);
    return seed;
}

void Where::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("condition_operand_id"), this->condition_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("true_value_operand_id"), this->true_value_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("false_value_operand_id"), this->false_value_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operand_id"), this->output_operand_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type uint64_t>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("label"), this->label,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::string&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Where::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
GraphInfo::GraphInfo()
    : id_to_operand_map()
    , input_operands()
    , output_operands()
    , operations()
    , constant_id_to_buffer_map()
{
}

GraphInfo::GraphInfo(base::flat_map<uint64_t, OperandPtr> id_to_operand_map_in, std::vector<uint64_t> input_operands_in,
    std::vector<uint64_t> output_operands_in, std::vector<OperationPtr> operations_in,
    base::flat_map<uint64_t, ::mojo_base::BigBuffer> constant_id_to_buffer_map_in)
    : id_to_operand_map(std::move(id_to_operand_map_in))
    , input_operands(std::move(input_operands_in))
    , output_operands(std::move(output_operands_in))
    , operations(std::move(operations_in))
    , constant_id_to_buffer_map(std::move(constant_id_to_buffer_map_in))
{
}

GraphInfo::~GraphInfo() = default;

void GraphInfo::WriteIntoTrace(perfetto::TracedValue traced_context) const
{
    [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("id_to_operand_map"), this->id_to_operand_map,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type base::flat_map<uint64_t, OperandPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("input_operands"), this->input_operands,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint64_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("output_operands"), this->output_operands,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type const std::vector<uint64_t>&>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("operations"), this->operations,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type std::vector<OperationPtr>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
    perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("constant_id_to_buffer_map"), this->constant_id_to_buffer_map,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
        "<value of type base::flat_map<uint64_t, ::mojo_base::BigBuffer>>"
#else
        "<value>"
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool GraphInfo::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context);
}
PaddingMode::PaddingMode()
    : tag_(Tag::kConstant)
{
    data_.constant = new ConstantPaddingPtr;
}

PaddingMode::~PaddingMode()
{
    DestroyActive();
}

void PaddingMode::set_constant(ConstantPaddingPtr constant)
{
    if (tag_ == Tag::kConstant) {
        *(data_.constant) = std::move(constant);
    } else {
        DestroyActive();
        tag_ = Tag::kConstant;
        data_.constant = new ConstantPaddingPtr(std::move(constant));
    }
}
void PaddingMode::set_edge(EdgePaddingPtr edge)
{
    if (tag_ == Tag::kEdge) {
        *(data_.edge) = std::move(edge);
    } else {
        DestroyActive();
        tag_ = Tag::kEdge;
        data_.edge = new EdgePaddingPtr(std::move(edge));
    }
}
void PaddingMode::set_reflection(ReflectionPaddingPtr reflection)
{
    if (tag_ == Tag::kReflection) {
        *(data_.reflection) = std::move(reflection);
    } else {
        DestroyActive();
        tag_ = Tag::kReflection;
        data_.reflection = new ReflectionPaddingPtr(std::move(reflection));
    }
}
void PaddingMode::set_symmetric(SymmetricPaddingPtr symmetric)
{
    if (tag_ == Tag::kSymmetric) {
        *(data_.symmetric) = std::move(symmetric);
    } else {
        DestroyActive();
        tag_ = Tag::kSymmetric;
        data_.symmetric = new SymmetricPaddingPtr(std::move(symmetric));
    }
}

void PaddingMode::DestroyActive()
{
    switch (tag_) {

    case Tag::kConstant:

        delete data_.constant;
        break;
    case Tag::kEdge:

        delete data_.edge;
        break;
    case Tag::kReflection:

        delete data_.reflection;
        break;
    case Tag::kSymmetric:

        delete data_.symmetric;
        break;
    }
}
size_t PaddingMode::Hash(size_t seed) const
{
    seed = mojo::internal::HashCombine(seed, static_cast<uint32_t>(tag_));
    switch (tag_) {

    case Tag::kConstant:
        return mojo::internal::Hash(seed, *data_.constant);
    case Tag::kEdge:
        return mojo::internal::Hash(seed, *data_.edge);
    case Tag::kReflection:
        return mojo::internal::Hash(seed, *data_.reflection);
    case Tag::kSymmetric:
        return mojo::internal::Hash(seed, *data_.symmetric);
    default:
        NOTREACHED();
    }
}

bool PaddingMode::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
Operation::Operation()
    : tag_(Tag::kArgMinMax)
{
    data_.arg_min_max = new ArgMinMaxPtr;
}

Operation::~Operation()
{
    DestroyActive();
}

void Operation::set_arg_min_max(ArgMinMaxPtr arg_min_max)
{
    if (tag_ == Tag::kArgMinMax) {
        *(data_.arg_min_max) = std::move(arg_min_max);
    } else {
        DestroyActive();
        tag_ = Tag::kArgMinMax;
        data_.arg_min_max = new ArgMinMaxPtr(std::move(arg_min_max));
    }
}
void Operation::set_batch_normalization(BatchNormalizationPtr batch_normalization)
{
    if (tag_ == Tag::kBatchNormalization) {
        *(data_.batch_normalization) = std::move(batch_normalization);
    } else {
        DestroyActive();
        tag_ = Tag::kBatchNormalization;
        data_.batch_normalization = new BatchNormalizationPtr(std::move(batch_normalization));
    }
}
void Operation::set_clamp(ClampPtr clamp)
{
    if (tag_ == Tag::kClamp) {
        *(data_.clamp) = std::move(clamp);
    } else {
        DestroyActive();
        tag_ = Tag::kClamp;
        data_.clamp = new ClampPtr(std::move(clamp));
    }
}
void Operation::set_concat(ConcatPtr concat)
{
    if (tag_ == Tag::kConcat) {
        *(data_.concat) = std::move(concat);
    } else {
        DestroyActive();
        tag_ = Tag::kConcat;
        data_.concat = new ConcatPtr(std::move(concat));
    }
}
void Operation::set_conv2d(Conv2dPtr conv2d)
{
    if (tag_ == Tag::kConv2d) {
        *(data_.conv2d) = std::move(conv2d);
    } else {
        DestroyActive();
        tag_ = Tag::kConv2d;
        data_.conv2d = new Conv2dPtr(std::move(conv2d));
    }
}
void Operation::set_cumulative_sum(CumulativeSumPtr cumulative_sum)
{
    if (tag_ == Tag::kCumulativeSum) {
        *(data_.cumulative_sum) = std::move(cumulative_sum);
    } else {
        DestroyActive();
        tag_ = Tag::kCumulativeSum;
        data_.cumulative_sum = new CumulativeSumPtr(std::move(cumulative_sum));
    }
}
void Operation::set_dequantize_linear(DequantizeLinearPtr dequantize_linear)
{
    if (tag_ == Tag::kDequantizeLinear) {
        *(data_.dequantize_linear) = std::move(dequantize_linear);
    } else {
        DestroyActive();
        tag_ = Tag::kDequantizeLinear;
        data_.dequantize_linear = new DequantizeLinearPtr(std::move(dequantize_linear));
    }
}
void Operation::set_element_wise_binary(ElementWiseBinaryPtr element_wise_binary)
{
    if (tag_ == Tag::kElementWiseBinary) {
        *(data_.element_wise_binary) = std::move(element_wise_binary);
    } else {
        DestroyActive();
        tag_ = Tag::kElementWiseBinary;
        data_.element_wise_binary = new ElementWiseBinaryPtr(std::move(element_wise_binary));
    }
}
void Operation::set_elu(EluPtr elu)
{
    if (tag_ == Tag::kElu) {
        *(data_.elu) = std::move(elu);
    } else {
        DestroyActive();
        tag_ = Tag::kElu;
        data_.elu = new EluPtr(std::move(elu));
    }
}
void Operation::set_element_wise_unary(ElementWiseUnaryPtr element_wise_unary)
{
    if (tag_ == Tag::kElementWiseUnary) {
        *(data_.element_wise_unary) = std::move(element_wise_unary);
    } else {
        DestroyActive();
        tag_ = Tag::kElementWiseUnary;
        data_.element_wise_unary = new ElementWiseUnaryPtr(std::move(element_wise_unary));
    }
}
void Operation::set_expand(ExpandPtr expand)
{
    if (tag_ == Tag::kExpand) {
        *(data_.expand) = std::move(expand);
    } else {
        DestroyActive();
        tag_ = Tag::kExpand;
        data_.expand = new ExpandPtr(std::move(expand));
    }
}
void Operation::set_gather(GatherPtr gather)
{
    if (tag_ == Tag::kGather) {
        *(data_.gather) = std::move(gather);
    } else {
        DestroyActive();
        tag_ = Tag::kGather;
        data_.gather = new GatherPtr(std::move(gather));
    }
}
void Operation::set_gather_elements(GatherElementsPtr gather_elements)
{
    if (tag_ == Tag::kGatherElements) {
        *(data_.gather_elements) = std::move(gather_elements);
    } else {
        DestroyActive();
        tag_ = Tag::kGatherElements;
        data_.gather_elements = new GatherElementsPtr(std::move(gather_elements));
    }
}
void Operation::set_gather_nd(GatherNDPtr gather_nd)
{
    if (tag_ == Tag::kGatherNd) {
        *(data_.gather_nd) = std::move(gather_nd);
    } else {
        DestroyActive();
        tag_ = Tag::kGatherNd;
        data_.gather_nd = new GatherNDPtr(std::move(gather_nd));
    }
}
void Operation::set_gelu(GeluPtr gelu)
{
    if (tag_ == Tag::kGelu) {
        *(data_.gelu) = std::move(gelu);
    } else {
        DestroyActive();
        tag_ = Tag::kGelu;
        data_.gelu = new GeluPtr(std::move(gelu));
    }
}
void Operation::set_gemm(GemmPtr gemm)
{
    if (tag_ == Tag::kGemm) {
        *(data_.gemm) = std::move(gemm);
    } else {
        DestroyActive();
        tag_ = Tag::kGemm;
        data_.gemm = new GemmPtr(std::move(gemm));
    }
}
void Operation::set_gru(GruPtr gru)
{
    if (tag_ == Tag::kGru) {
        *(data_.gru) = std::move(gru);
    } else {
        DestroyActive();
        tag_ = Tag::kGru;
        data_.gru = new GruPtr(std::move(gru));
    }
}
void Operation::set_gru_cell(GruCellPtr gru_cell)
{
    if (tag_ == Tag::kGruCell) {
        *(data_.gru_cell) = std::move(gru_cell);
    } else {
        DestroyActive();
        tag_ = Tag::kGruCell;
        data_.gru_cell = new GruCellPtr(std::move(gru_cell));
    }
}
void Operation::set_hard_sigmoid(HardSigmoidPtr hard_sigmoid)
{
    if (tag_ == Tag::kHardSigmoid) {
        *(data_.hard_sigmoid) = std::move(hard_sigmoid);
    } else {
        DestroyActive();
        tag_ = Tag::kHardSigmoid;
        data_.hard_sigmoid = new HardSigmoidPtr(std::move(hard_sigmoid));
    }
}
void Operation::set_hard_swish(HardSwishPtr hard_swish)
{
    if (tag_ == Tag::kHardSwish) {
        *(data_.hard_swish) = std::move(hard_swish);
    } else {
        DestroyActive();
        tag_ = Tag::kHardSwish;
        data_.hard_swish = new HardSwishPtr(std::move(hard_swish));
    }
}
void Operation::set_layer_normalization(LayerNormalizationPtr layer_normalization)
{
    if (tag_ == Tag::kLayerNormalization) {
        *(data_.layer_normalization) = std::move(layer_normalization);
    } else {
        DestroyActive();
        tag_ = Tag::kLayerNormalization;
        data_.layer_normalization = new LayerNormalizationPtr(std::move(layer_normalization));
    }
}
void Operation::set_instance_normalization(InstanceNormalizationPtr instance_normalization)
{
    if (tag_ == Tag::kInstanceNormalization) {
        *(data_.instance_normalization) = std::move(instance_normalization);
    } else {
        DestroyActive();
        tag_ = Tag::kInstanceNormalization;
        data_.instance_normalization = new InstanceNormalizationPtr(std::move(instance_normalization));
    }
}
void Operation::set_leaky_relu(LeakyReluPtr leaky_relu)
{
    if (tag_ == Tag::kLeakyRelu) {
        *(data_.leaky_relu) = std::move(leaky_relu);
    } else {
        DestroyActive();
        tag_ = Tag::kLeakyRelu;
        data_.leaky_relu = new LeakyReluPtr(std::move(leaky_relu));
    }
}
void Operation::set_linear(LinearPtr linear)
{
    if (tag_ == Tag::kLinear) {
        *(data_.linear) = std::move(linear);
    } else {
        DestroyActive();
        tag_ = Tag::kLinear;
        data_.linear = new LinearPtr(std::move(linear));
    }
}
void Operation::set_lstm(LstmPtr lstm)
{
    if (tag_ == Tag::kLstm) {
        *(data_.lstm) = std::move(lstm);
    } else {
        DestroyActive();
        tag_ = Tag::kLstm;
        data_.lstm = new LstmPtr(std::move(lstm));
    }
}
void Operation::set_lstm_cell(LstmCellPtr lstm_cell)
{
    if (tag_ == Tag::kLstmCell) {
        *(data_.lstm_cell) = std::move(lstm_cell);
    } else {
        DestroyActive();
        tag_ = Tag::kLstmCell;
        data_.lstm_cell = new LstmCellPtr(std::move(lstm_cell));
    }
}
void Operation::set_matmul(MatmulPtr matmul)
{
    if (tag_ == Tag::kMatmul) {
        *(data_.matmul) = std::move(matmul);
    } else {
        DestroyActive();
        tag_ = Tag::kMatmul;
        data_.matmul = new MatmulPtr(std::move(matmul));
    }
}
void Operation::set_pad(PadPtr pad)
{
    if (tag_ == Tag::kPad) {
        *(data_.pad) = std::move(pad);
    } else {
        DestroyActive();
        tag_ = Tag::kPad;
        data_.pad = new PadPtr(std::move(pad));
    }
}
void Operation::set_pool2d(Pool2dPtr pool2d)
{
    if (tag_ == Tag::kPool2d) {
        *(data_.pool2d) = std::move(pool2d);
    } else {
        DestroyActive();
        tag_ = Tag::kPool2d;
        data_.pool2d = new Pool2dPtr(std::move(pool2d));
    }
}
void Operation::set_prelu(PreluPtr prelu)
{
    if (tag_ == Tag::kPrelu) {
        *(data_.prelu) = std::move(prelu);
    } else {
        DestroyActive();
        tag_ = Tag::kPrelu;
        data_.prelu = new PreluPtr(std::move(prelu));
    }
}
void Operation::set_quantize_linear(QuantizeLinearPtr quantize_linear)
{
    if (tag_ == Tag::kQuantizeLinear) {
        *(data_.quantize_linear) = std::move(quantize_linear);
    } else {
        DestroyActive();
        tag_ = Tag::kQuantizeLinear;
        data_.quantize_linear = new QuantizeLinearPtr(std::move(quantize_linear));
    }
}
void Operation::set_reduce(ReducePtr reduce)
{
    if (tag_ == Tag::kReduce) {
        *(data_.reduce) = std::move(reduce);
    } else {
        DestroyActive();
        tag_ = Tag::kReduce;
        data_.reduce = new ReducePtr(std::move(reduce));
    }
}
void Operation::set_relu(ReluPtr relu)
{
    if (tag_ == Tag::kRelu) {
        *(data_.relu) = std::move(relu);
    } else {
        DestroyActive();
        tag_ = Tag::kRelu;
        data_.relu = new ReluPtr(std::move(relu));
    }
}
void Operation::set_resample2d(Resample2dPtr resample2d)
{
    if (tag_ == Tag::kResample2d) {
        *(data_.resample2d) = std::move(resample2d);
    } else {
        DestroyActive();
        tag_ = Tag::kResample2d;
        data_.resample2d = new Resample2dPtr(std::move(resample2d));
    }
}
void Operation::set_reshape(ReshapePtr reshape)
{
    if (tag_ == Tag::kReshape) {
        *(data_.reshape) = std::move(reshape);
    } else {
        DestroyActive();
        tag_ = Tag::kReshape;
        data_.reshape = new ReshapePtr(std::move(reshape));
    }
}
void Operation::set_scatter_elements(ScatterElementsPtr scatter_elements)
{
    if (tag_ == Tag::kScatterElements) {
        *(data_.scatter_elements) = std::move(scatter_elements);
    } else {
        DestroyActive();
        tag_ = Tag::kScatterElements;
        data_.scatter_elements = new ScatterElementsPtr(std::move(scatter_elements));
    }
}
void Operation::set_scatter_nd(ScatterNDPtr scatter_nd)
{
    if (tag_ == Tag::kScatterNd) {
        *(data_.scatter_nd) = std::move(scatter_nd);
    } else {
        DestroyActive();
        tag_ = Tag::kScatterNd;
        data_.scatter_nd = new ScatterNDPtr(std::move(scatter_nd));
    }
}
void Operation::set_sigmoid(SigmoidPtr sigmoid)
{
    if (tag_ == Tag::kSigmoid) {
        *(data_.sigmoid) = std::move(sigmoid);
    } else {
        DestroyActive();
        tag_ = Tag::kSigmoid;
        data_.sigmoid = new SigmoidPtr(std::move(sigmoid));
    }
}
void Operation::set_slice(SlicePtr slice)
{
    if (tag_ == Tag::kSlice) {
        *(data_.slice) = std::move(slice);
    } else {
        DestroyActive();
        tag_ = Tag::kSlice;
        data_.slice = new SlicePtr(std::move(slice));
    }
}
void Operation::set_softmax(SoftmaxPtr softmax)
{
    if (tag_ == Tag::kSoftmax) {
        *(data_.softmax) = std::move(softmax);
    } else {
        DestroyActive();
        tag_ = Tag::kSoftmax;
        data_.softmax = new SoftmaxPtr(std::move(softmax));
    }
}
void Operation::set_softplus(SoftplusPtr softplus)
{
    if (tag_ == Tag::kSoftplus) {
        *(data_.softplus) = std::move(softplus);
    } else {
        DestroyActive();
        tag_ = Tag::kSoftplus;
        data_.softplus = new SoftplusPtr(std::move(softplus));
    }
}
void Operation::set_softsign(SoftsignPtr softsign)
{
    if (tag_ == Tag::kSoftsign) {
        *(data_.softsign) = std::move(softsign);
    } else {
        DestroyActive();
        tag_ = Tag::kSoftsign;
        data_.softsign = new SoftsignPtr(std::move(softsign));
    }
}
void Operation::set_split(SplitPtr split)
{
    if (tag_ == Tag::kSplit) {
        *(data_.split) = std::move(split);
    } else {
        DestroyActive();
        tag_ = Tag::kSplit;
        data_.split = new SplitPtr(std::move(split));
    }
}
void Operation::set_tanh(TanhPtr tanh)
{
    if (tag_ == Tag::kTanh) {
        *(data_.tanh) = std::move(tanh);
    } else {
        DestroyActive();
        tag_ = Tag::kTanh;
        data_.tanh = new TanhPtr(std::move(tanh));
    }
}
void Operation::set_tile(TilePtr tile)
{
    if (tag_ == Tag::kTile) {
        *(data_.tile) = std::move(tile);
    } else {
        DestroyActive();
        tag_ = Tag::kTile;
        data_.tile = new TilePtr(std::move(tile));
    }
}
void Operation::set_transpose(TransposePtr transpose)
{
    if (tag_ == Tag::kTranspose) {
        *(data_.transpose) = std::move(transpose);
    } else {
        DestroyActive();
        tag_ = Tag::kTranspose;
        data_.transpose = new TransposePtr(std::move(transpose));
    }
}
void Operation::set_triangular(TriangularPtr triangular)
{
    if (tag_ == Tag::kTriangular) {
        *(data_.triangular) = std::move(triangular);
    } else {
        DestroyActive();
        tag_ = Tag::kTriangular;
        data_.triangular = new TriangularPtr(std::move(triangular));
    }
}
void Operation::set_where(WherePtr where)
{
    if (tag_ == Tag::kWhere) {
        *(data_.where) = std::move(where);
    } else {
        DestroyActive();
        tag_ = Tag::kWhere;
        data_.where = new WherePtr(std::move(where));
    }
}

void Operation::DestroyActive()
{
    switch (tag_) {

    case Tag::kArgMinMax:

        delete data_.arg_min_max;
        break;
    case Tag::kBatchNormalization:

        delete data_.batch_normalization;
        break;
    case Tag::kClamp:

        delete data_.clamp;
        break;
    case Tag::kConcat:

        delete data_.concat;
        break;
    case Tag::kConv2d:

        delete data_.conv2d;
        break;
    case Tag::kCumulativeSum:

        delete data_.cumulative_sum;
        break;
    case Tag::kDequantizeLinear:

        delete data_.dequantize_linear;
        break;
    case Tag::kElementWiseBinary:

        delete data_.element_wise_binary;
        break;
    case Tag::kElu:

        delete data_.elu;
        break;
    case Tag::kElementWiseUnary:

        delete data_.element_wise_unary;
        break;
    case Tag::kExpand:

        delete data_.expand;
        break;
    case Tag::kGather:

        delete data_.gather;
        break;
    case Tag::kGatherElements:

        delete data_.gather_elements;
        break;
    case Tag::kGatherNd:

        delete data_.gather_nd;
        break;
    case Tag::kGelu:

        delete data_.gelu;
        break;
    case Tag::kGemm:

        delete data_.gemm;
        break;
    case Tag::kGru:

        delete data_.gru;
        break;
    case Tag::kGruCell:

        delete data_.gru_cell;
        break;
    case Tag::kHardSigmoid:

        delete data_.hard_sigmoid;
        break;
    case Tag::kHardSwish:

        delete data_.hard_swish;
        break;
    case Tag::kLayerNormalization:

        delete data_.layer_normalization;
        break;
    case Tag::kInstanceNormalization:

        delete data_.instance_normalization;
        break;
    case Tag::kLeakyRelu:

        delete data_.leaky_relu;
        break;
    case Tag::kLinear:

        delete data_.linear;
        break;
    case Tag::kLstm:

        delete data_.lstm;
        break;
    case Tag::kLstmCell:

        delete data_.lstm_cell;
        break;
    case Tag::kMatmul:

        delete data_.matmul;
        break;
    case Tag::kPad:

        delete data_.pad;
        break;
    case Tag::kPool2d:

        delete data_.pool2d;
        break;
    case Tag::kPrelu:

        delete data_.prelu;
        break;
    case Tag::kQuantizeLinear:

        delete data_.quantize_linear;
        break;
    case Tag::kReduce:

        delete data_.reduce;
        break;
    case Tag::kRelu:

        delete data_.relu;
        break;
    case Tag::kResample2d:

        delete data_.resample2d;
        break;
    case Tag::kReshape:

        delete data_.reshape;
        break;
    case Tag::kScatterElements:

        delete data_.scatter_elements;
        break;
    case Tag::kScatterNd:

        delete data_.scatter_nd;
        break;
    case Tag::kSigmoid:

        delete data_.sigmoid;
        break;
    case Tag::kSlice:

        delete data_.slice;
        break;
    case Tag::kSoftmax:

        delete data_.softmax;
        break;
    case Tag::kSoftplus:

        delete data_.softplus;
        break;
    case Tag::kSoftsign:

        delete data_.softsign;
        break;
    case Tag::kSplit:

        delete data_.split;
        break;
    case Tag::kTanh:

        delete data_.tanh;
        break;
    case Tag::kTile:

        delete data_.tile;
        break;
    case Tag::kTranspose:

        delete data_.transpose;
        break;
    case Tag::kTriangular:

        delete data_.triangular;
        break;
    case Tag::kWhere:

        delete data_.where;
        break;
    }
}

bool Operation::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
ComputeResult::ComputeResult()
    : tag_(Tag::kNamedOutputs)
{
    data_.named_outputs = new base::flat_map<std::string, ::mojo_base::BigBuffer>;
}

ComputeResult::~ComputeResult()
{
    DestroyActive();
}

void ComputeResult::set_named_outputs(base::flat_map<std::string, ::mojo_base::BigBuffer> named_outputs)
{
    if (tag_ == Tag::kNamedOutputs) {
        *(data_.named_outputs) = std::move(named_outputs);
    } else {
        DestroyActive();
        tag_ = Tag::kNamedOutputs;
        data_.named_outputs = new base::flat_map<std::string, ::mojo_base::BigBuffer>(std::move(named_outputs));
    }
}
void ComputeResult::set_error(::webnn::mojom::ErrorPtr error)
{
    if (tag_ == Tag::kError) {
        *(data_.error) = std::move(error);
    } else {
        DestroyActive();
        tag_ = Tag::kError;
        data_.error = new ::webnn::mojom::ErrorPtr(std::move(error));
    }
}

void ComputeResult::DestroyActive()
{
    switch (tag_) {

    case Tag::kNamedOutputs:

        delete data_.named_outputs;
        break;
    case Tag::kError:

        delete data_.error;
        break;
    }
}

bool ComputeResult::Validate(const void* data, mojo::internal::ValidationContext* validation_context)
{
    return Data_::Validate(data, validation_context, false);
}
const char WebNNGraph::Name_[] = "webnn.mojom.WebNNGraph";

WebNNGraph::IPCStableHashFunction WebNNGraph::MessageToMethodInfo_(mojo::Message& message)
{
#if !BUILDFLAG(IS_FUCHSIA)
    switch (static_cast<messages::WebNNGraph>(message.name())) {
    case messages::WebNNGraph::kCompute: {
        return &WebNNGraph::Compute_Sym::IPCStableHash;
    }
    case messages::WebNNGraph::kDispatch: {
        return &WebNNGraph::Dispatch_Sym::IPCStableHash;
    }
    }
#endif // !BUILDFLAG(IS_FUCHSIA)
    return nullptr;
}

const char* WebNNGraph::MessageToMethodName_(mojo::Message& message)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (!is_response) {
        switch (static_cast<messages::WebNNGraph>(message.name())) {
        case messages::WebNNGraph::kCompute:
            return "Receive webnn::mojom::WebNNGraph::Compute";
        case messages::WebNNGraph::kDispatch:
            return "Receive webnn::mojom::WebNNGraph::Dispatch";
        }
    } else {
        switch (static_cast<messages::WebNNGraph>(message.name())) {
        case messages::WebNNGraph::kCompute:
            return "Receive reply webnn::mojom::WebNNGraph::Compute";
        case messages::WebNNGraph::kDispatch:
            return "Receive reply webnn::mojom::WebNNGraph::Dispatch";
        }
    }
    return "Receive unknown mojo message";
#else
    bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
    if (is_response) {
        return "Receive mojo reply";
    } else {
        return "Receive mojo message";
    }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t WebNNGraph::Compute_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)webnn::mojom::WebNNGraph::Compute");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
uint32_t WebNNGraph::Dispatch_Sym::IPCStableHash()
{
    // This method's address is used for indetifiying the mojo method name after
    // symbolization. So each IPCStableHash should have a unique address.
    // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
    // __LINE__ value, which is not unique accross different mojo modules.
    // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
    // hash instead of __LINE__.
    constexpr uint32_t kHash = base::MD5Hash32Constexpr("(Impl)webnn::mojom::WebNNGraph::Dispatch");
    const uint32_t hash = kHash;
    base::debug::Alias(&hash);
    return hash;
}
#endif // !BUILDFLAG(IS_FUCHSIA)

class WebNNGraph_Compute_ForwardToCallback : public mojo::MessageReceiver {
public:
    WebNNGraph_Compute_ForwardToCallback(WebNNGraph::ComputeCallback callback)
        : callback_(std::move(callback))
    {
    }

    WebNNGraph_Compute_ForwardToCallback(const WebNNGraph_Compute_ForwardToCallback&) = delete;
    WebNNGraph_Compute_ForwardToCallback& operator=(const WebNNGraph_Compute_ForwardToCallback&) = delete;

    bool Accept(mojo::Message* message) override;

private:
    WebNNGraph::ComputeCallback callback_;
};

WebNNGraphProxy::WebNNGraphProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver)
{
}

void WebNNGraphProxy::Compute(base::flat_map<std::string, ::mojo_base::BigBuffer> in_named_inputs, ComputeCallback callback)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send webnn::mojom::WebNNGraph::Compute", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("named_inputs"), in_named_inputs, "<value of type base::flat_map<std::string, ::mojo_base::BigBuffer>>");
    });
#endif

    const bool kExpectsResponse = true;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::WebNNGraph::kCompute), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::webnn::mojom::internal::WebNNGraph_Compute_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->named_inputs)::BaseType> named_inputs_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& named_inputs_validate_params
        = mojo::internal::GetMapValidator<*&mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>(),
            *&mojo::internal::GetArrayValidator<0, false, nullptr>()>();
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::mojo_base::mojom::BigBufferDataView>>(
        in_named_inputs, named_inputs_fragment, &named_inputs_validate_params);
    params->named_inputs.Set(named_inputs_fragment.is_null() ? nullptr : named_inputs_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->named_inputs.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null named_inputs in WebNNGraph.Compute request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(WebNNGraph::Name_);
    message.set_method_name("Compute");
#endif
    std::unique_ptr<mojo::MessageReceiver> responder(new WebNNGraph_Compute_ForwardToCallback(std::move(callback)));
    ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void WebNNGraphProxy::Dispatch(const base::flat_map<std::string, ::blink::WebNNTensorToken>& in_named_inputs,
    const base::flat_map<std::string, ::blink::WebNNTensorToken>& in_named_outputs)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send webnn::mojom::WebNNGraph::Dispatch", "input_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("named_inputs"), in_named_inputs, "<value of type const base::flat_map<std::string, ::blink::WebNNTensorToken>&>");
        perfetto::WriteIntoTracedValueWithFallback(
            dict.AddItem("named_outputs"), in_named_outputs, "<value of type const base::flat_map<std::string, ::blink::WebNNTensorToken>&>");
    });
#endif

    const bool kExpectsResponse = false;
    const bool kIsSync = false;
    const bool kAllowInterrupt = true;
    const bool is_urgent = false;

    const uint32_t kFlags = ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) | ((kIsSync) ? mojo::Message::kFlagIsSync : 0)
        | ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt) | ((is_urgent) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::WebNNGraph::kDispatch), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::webnn::mojom::internal::WebNNGraph_Dispatch_Params_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<typename decltype(params->named_inputs)::BaseType> named_inputs_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& named_inputs_validate_params
        = mojo::internal::GetMapValidator<*&mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>(),
            *&mojo::internal::GetArrayValidator<0, false, nullptr>()>();
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::blink::mojom::WebNNTensorTokenDataView>>(
        in_named_inputs, named_inputs_fragment, &named_inputs_validate_params);
    params->named_inputs.Set(named_inputs_fragment.is_null() ? nullptr : named_inputs_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->named_inputs.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null named_inputs in WebNNGraph.Dispatch request");
    mojo::internal::MessageFragment<typename decltype(params->named_outputs)::BaseType> named_outputs_fragment(params.message());
    constexpr const mojo::internal::ContainerValidateParams& named_outputs_validate_params
        = mojo::internal::GetMapValidator<*&mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>(),
            *&mojo::internal::GetArrayValidator<0, false, nullptr>()>();
    mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, ::blink::mojom::WebNNTensorTokenDataView>>(
        in_named_outputs, named_outputs_fragment, &named_outputs_validate_params);
    params->named_outputs.Set(named_outputs_fragment.is_null() ? nullptr : named_outputs_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        params->named_outputs.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null named_outputs in WebNNGraph.Dispatch request");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(WebNNGraph::Name_);
    message.set_method_name("Dispatch");
#endif
    // This return value may be ignored as false implies the Connector has
    // encountered an error, which will be visible through other means.
    ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class WebNNGraph_Compute_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
public:
    static WebNNGraph::ComputeCallback CreateCallback(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
    {
        std::unique_ptr<WebNNGraph_Compute_ProxyToResponder> proxy(new WebNNGraph_Compute_ProxyToResponder(message, std::move(responder)));
        return base::BindOnce(&WebNNGraph_Compute_ProxyToResponder::Run, std::move(proxy));
    }

    ~WebNNGraph_Compute_ProxyToResponder()
    {
#if DCHECK_IS_ON()
        if (responder_) {
            // If we're being destroyed without being run, we want to ensure the
            // binding endpoint has been closed. This checks for that asynchronously.
            // We pass a bound generated callback to handle the response so that any
            // resulting DCHECK stack will have useful interface type information.
            // Instantiate a ScopedFizzleBlockShutdownTasks to allow this request to
            // fizzle if this happens after shutdown and the endpoint is bound to a
            // BLOCK_SHUTDOWN sequence.
            base::ThreadPoolInstance::ScopedFizzleBlockShutdownTasks fizzler;
            responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
        }
#endif
    }

private:
    WebNNGraph_Compute_ProxyToResponder(::mojo::Message& message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
        : ::mojo::internal::ProxyToResponder(message, std::move(responder))
    {
    }

#if DCHECK_IS_ON()
    static void OnIsConnectedComplete(bool connected)
    {
        DCHECK(!connected) << "WebNNGraph::ComputeCallback was destroyed without "
                           << "first either being run or its corresponding binding being closed. "
                           << "It is an error to drop response callbacks which still correspond "
                           << "to an open interface pipe.";
    }
#endif

    void Run(ComputeResultPtr in_result);
};

bool WebNNGraph_Compute_ForwardToCallback::Accept(mojo::Message* message)
{
    DCHECK(message->is_serialized());
    internal::WebNNGraph_Compute_ResponseParams_Data* params = reinterpret_cast<internal::WebNNGraph_Compute_ResponseParams_Data*>(message->mutable_payload());

    // Validation for WebNNGraph.0
    bool success = true;
    ComputeResultPtr p_result {};
    WebNNGraph_Compute_ResponseParamsDataView input_data_view(params, message);

    if (success && !input_data_view.ReadResult(&p_result))
        success = false;
    if (!success) {
        ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, WebNNGraph::Name_, 0, true);
        return false;
    }
    if (!callback_.is_null())
        std::move(callback_).Run(std::move(p_result));
    return true;
}

void WebNNGraph_Compute_ProxyToResponder::Run(ComputeResultPtr in_result)
{
#if BUILDFLAG(MOJO_TRACE_ENABLED)
    TRACE_EVENT1("mojom", "Send reply webnn::mojom::WebNNGraph::Compute", "async_response_parameters", [&](perfetto::TracedValue context) {
        auto dict = std::move(context).WriteDictionary();
        perfetto::WriteIntoTracedValueWithFallback(dict.AddItem("result"), in_result, "<value of type ComputeResultPtr>");
    });
#endif

    const uint32_t kFlags = mojo::Message::kFlagIsResponse | ((is_sync_) ? mojo::Message::kFlagIsSync : 0) | ((true) ? 0 : mojo::Message::kFlagNoInterrupt)
        | ((false) ? mojo::Message::kFlagIsUrgent : 0);

    const size_t estimated_payload_size = 0;
    mojo::Message message(base::to_underlying(messages::WebNNGraph::kCompute), kFlags, estimated_payload_size);
    mojo::internal::MessageFragment<::webnn::mojom::internal::WebNNGraph_Compute_ResponseParams_Data> params(message);
    params.Allocate();
    mojo::internal::MessageFragment<decltype(params->result)> result_fragment(params.message());
    result_fragment.Claim(&params->result);
    mojo::internal::Serialize<::webnn::mojom::ComputeResultDataView>(in_result, result_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(params->result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null result in ");

#if defined(ENABLE_IPC_FUZZER)
    message.set_interface_name(WebNNGraph::Name_);
    message.set_method_name("Compute");
#endif

    message.set_request_id(request_id_);
    message.set_trace_nonce(trace_nonce_);
    ::mojo::internal::SendMojoMessage(*responder_, message);
    // SendMojoMessage() fails silently if the responder connection is closed,
    // or if the message is malformed.
    //
    // TODO(darin): If Accept() returns false due to a malformed message, that
    // may be good reason to close the connection. However, we don't have a
    // way to do that from here. We should add a way.
    responder_ = nullptr;
}

// static
bool WebNNGraphStubDispatch::Accept(WebNNGraph* impl, mojo::Message* message)
{
    switch (static_cast<messages::WebNNGraph>(message->header()->name)) {
    case messages::WebNNGraph::kCompute: {
        break;
    }
    case messages::WebNNGraph::kDispatch: {
        DCHECK(message->is_serialized());
        internal::WebNNGraph_Dispatch_Params_Data* params = reinterpret_cast<internal::WebNNGraph_Dispatch_Params_Data*>(message->mutable_payload());

        // Validation for WebNNGraph.1
        bool success = true;
        base::flat_map<std::string, ::blink::WebNNTensorToken> p_named_inputs {};
        base::flat_map<std::string, ::blink::WebNNTensorToken> p_named_outputs {};
        WebNNGraph_Dispatch_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadNamedInputs(&p_named_inputs))
            success = false;
        if (success && !input_data_view.ReadNamedOutputs(&p_named_outputs))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, WebNNGraph::Name_, 1, false);
            return false;
        }
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Dispatch(std::move(p_named_inputs), std::move(p_named_outputs));
        return true;
    }
    }
    return false;
}

// static
bool WebNNGraphStubDispatch::AcceptWithResponder(WebNNGraph* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
{
    [[maybe_unused]] const bool message_is_sync = message->has_flag(mojo::Message::kFlagIsSync);
    [[maybe_unused]] const uint64_t request_id = message->request_id();
    switch (static_cast<messages::WebNNGraph>(message->header()->name)) {
    case messages::WebNNGraph::kCompute: {
        internal::WebNNGraph_Compute_Params_Data* params = reinterpret_cast<internal::WebNNGraph_Compute_Params_Data*>(message->mutable_payload());

        // Validation for WebNNGraph.0
        bool success = true;
        base::flat_map<std::string, ::mojo_base::BigBuffer> p_named_inputs {};
        WebNNGraph_Compute_ParamsDataView input_data_view(params, message);

        if (success && !input_data_view.ReadNamedInputs(&p_named_inputs))
            success = false;
        if (!success) {
            ReportValidationErrorForMessage(message, mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED, WebNNGraph::Name_, 0, false);
            return false;
        }
        WebNNGraph::ComputeCallback callback = WebNNGraph_Compute_ProxyToResponder::CreateCallback(*message, std::move(responder));
        // A null |impl| means no implementation was bound.
        DCHECK(impl);
        impl->Compute(std::move(p_named_inputs), std::move(callback));
        return true;
    }
    case messages::WebNNGraph::kDispatch: {
        break;
    }
    }
    return false;
}
namespace {
} // namespace
static const mojo::internal::GenericValidationInfo kWebNNGraphValidationInfo[] = {
    { &internal::WebNNGraph_Compute_Params_Data::Validate, &internal::WebNNGraph_Compute_ResponseParams_Data::Validate },
    { &internal::WebNNGraph_Dispatch_Params_Data::Validate, nullptr /* no response */ },
};

bool WebNNGraphRequestValidator::Accept(mojo::Message* message)
{
    const char* name = ::webnn::mojom::WebNNGraph::Name_;
    return mojo::internal::ValidateRequestGenericPacked(message, name, kWebNNGraphValidationInfo);
}

bool WebNNGraphResponseValidator::Accept(mojo::Message* message)
{
    const char* name = ::webnn::mojom::WebNNGraph::Name_;
    return mojo::internal::ValidateResponseGenericPacked(message, name, kWebNNGraphValidationInfo);
}

} // webnn::mojom

namespace mojo {

// static
bool StructTraits<::webnn::mojom::OperandDescriptor::DataView, ::webnn::mojom::OperandDescriptorPtr>::Read(
    ::webnn::mojom::OperandDescriptor::DataView input, ::webnn::mojom::OperandDescriptorPtr* output)
{
    bool success = true;
    ::webnn::mojom::OperandDescriptorPtr result(::webnn::mojom::OperandDescriptor::New());

    if (success && !input.ReadDataType(&result->data_type))
        success = false;
    if (success && !input.ReadShape(&result->shape))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Operand::DataView, ::webnn::mojom::OperandPtr>::Read(
    ::webnn::mojom::Operand::DataView input, ::webnn::mojom::OperandPtr* output)
{
    bool success = true;
    ::webnn::mojom::OperandPtr result(::webnn::mojom::Operand::New());

    if (success && !input.ReadKind(&result->kind))
        success = false;
    if (success && !input.ReadDescriptor(&result->descriptor))
        success = false;
    if (success && !input.ReadName(&result->name))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::ArgMinMax::DataView, ::webnn::mojom::ArgMinMaxPtr>::Read(
    ::webnn::mojom::ArgMinMax::DataView input, ::webnn::mojom::ArgMinMaxPtr* output)
{
    bool success = true;
    ::webnn::mojom::ArgMinMaxPtr result(::webnn::mojom::ArgMinMax::New());

    if (success && !input.ReadKind(&result->kind))
        success = false;
    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->axis = input.axis();
    if (success)
        result->keep_dimensions = input.keep_dimensions();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::BatchNormalization::DataView, ::webnn::mojom::BatchNormalizationPtr>::Read(
    ::webnn::mojom::BatchNormalization::DataView input, ::webnn::mojom::BatchNormalizationPtr* output)
{
    bool success = true;
    ::webnn::mojom::BatchNormalizationPtr result(::webnn::mojom::BatchNormalization::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->mean_operand_id = input.mean_operand_id();
    if (success)
        result->variance_operand_id = input.variance_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success) {
        result->scale_operand_id = input.scale_operand_id();
    }
    if (success) {
        result->bias_operand_id = input.bias_operand_id();
    }
    if (success)
        result->axis = input.axis();
    if (success)
        result->epsilon = input.epsilon();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Clamp::DataView, ::webnn::mojom::ClampPtr>::Read(::webnn::mojom::Clamp::DataView input, ::webnn::mojom::ClampPtr* output)
{
    bool success = true;
    ::webnn::mojom::ClampPtr result(::webnn::mojom::Clamp::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->min_value = input.min_value();
    if (success)
        result->max_value = input.max_value();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Concat::DataView, ::webnn::mojom::ConcatPtr>::Read(::webnn::mojom::Concat::DataView input, ::webnn::mojom::ConcatPtr* output)
{
    bool success = true;
    ::webnn::mojom::ConcatPtr result(::webnn::mojom::Concat::New());

    if (success && !input.ReadInputOperandIds(&result->input_operand_ids))
        success = false;
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->axis = input.axis();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Size2d::DataView, ::webnn::mojom::Size2dPtr>::Read(::webnn::mojom::Size2d::DataView input, ::webnn::mojom::Size2dPtr* output)
{
    bool success = true;
    ::webnn::mojom::Size2dPtr result(::webnn::mojom::Size2d::New());

    if (success)
        result->height = input.height();
    if (success)
        result->width = input.width();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Padding2d::DataView, ::webnn::mojom::Padding2dPtr>::Read(
    ::webnn::mojom::Padding2d::DataView input, ::webnn::mojom::Padding2dPtr* output)
{
    bool success = true;
    ::webnn::mojom::Padding2dPtr result(::webnn::mojom::Padding2d::New());

    if (success && !input.ReadBeginning(&result->beginning))
        success = false;
    if (success && !input.ReadEnding(&result->ending))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Conv2d::DataView, ::webnn::mojom::Conv2dPtr>::Read(::webnn::mojom::Conv2d::DataView input, ::webnn::mojom::Conv2dPtr* output)
{
    bool success = true;
    ::webnn::mojom::Conv2dPtr result(::webnn::mojom::Conv2d::New());

    if (success && !input.ReadKind(&result->kind))
        success = false;
    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->filter_operand_id = input.filter_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadPadding(&result->padding))
        success = false;
    if (success && !input.ReadStrides(&result->strides))
        success = false;
    if (success && !input.ReadDilations(&result->dilations))
        success = false;
    if (success)
        result->groups = input.groups();
    if (success) {
        result->bias_operand_id = input.bias_operand_id();
    }
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::CumulativeSum::DataView, ::webnn::mojom::CumulativeSumPtr>::Read(
    ::webnn::mojom::CumulativeSum::DataView input, ::webnn::mojom::CumulativeSumPtr* output)
{
    bool success = true;
    ::webnn::mojom::CumulativeSumPtr result(::webnn::mojom::CumulativeSum::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->axis = input.axis();
    if (success)
        result->exclusive = input.exclusive();
    if (success)
        result->reversed = input.reversed();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::DequantizeLinear::DataView, ::webnn::mojom::DequantizeLinearPtr>::Read(
    ::webnn::mojom::DequantizeLinear::DataView input, ::webnn::mojom::DequantizeLinearPtr* output)
{
    bool success = true;
    ::webnn::mojom::DequantizeLinearPtr result(::webnn::mojom::DequantizeLinear::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->scale_operand_id = input.scale_operand_id();
    if (success)
        result->zero_point_operand_id = input.zero_point_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::ElementWiseBinary::DataView, ::webnn::mojom::ElementWiseBinaryPtr>::Read(
    ::webnn::mojom::ElementWiseBinary::DataView input, ::webnn::mojom::ElementWiseBinaryPtr* output)
{
    bool success = true;
    ::webnn::mojom::ElementWiseBinaryPtr result(::webnn::mojom::ElementWiseBinary::New());

    if (success && !input.ReadKind(&result->kind))
        success = false;
    if (success)
        result->lhs_operand_id = input.lhs_operand_id();
    if (success)
        result->rhs_operand_id = input.rhs_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::ElementWiseUnary::DataView, ::webnn::mojom::ElementWiseUnaryPtr>::Read(
    ::webnn::mojom::ElementWiseUnary::DataView input, ::webnn::mojom::ElementWiseUnaryPtr* output)
{
    bool success = true;
    ::webnn::mojom::ElementWiseUnaryPtr result(::webnn::mojom::ElementWiseUnary::New());

    if (success && !input.ReadKind(&result->kind))
        success = false;
    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Expand::DataView, ::webnn::mojom::ExpandPtr>::Read(::webnn::mojom::Expand::DataView input, ::webnn::mojom::ExpandPtr* output)
{
    bool success = true;
    ::webnn::mojom::ExpandPtr result(::webnn::mojom::Expand::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::ConstantPadding::DataView, ::webnn::mojom::ConstantPaddingPtr>::Read(
    ::webnn::mojom::ConstantPadding::DataView input, ::webnn::mojom::ConstantPaddingPtr* output)
{
    bool success = true;
    ::webnn::mojom::ConstantPaddingPtr result(::webnn::mojom::ConstantPadding::New());

    if (success)
        result->value = input.value();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::EdgePadding::DataView, ::webnn::mojom::EdgePaddingPtr>::Read(
    ::webnn::mojom::EdgePadding::DataView input, ::webnn::mojom::EdgePaddingPtr* output)
{
    bool success = true;
    ::webnn::mojom::EdgePaddingPtr result(::webnn::mojom::EdgePadding::New());

    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::ReflectionPadding::DataView, ::webnn::mojom::ReflectionPaddingPtr>::Read(
    ::webnn::mojom::ReflectionPadding::DataView input, ::webnn::mojom::ReflectionPaddingPtr* output)
{
    bool success = true;
    ::webnn::mojom::ReflectionPaddingPtr result(::webnn::mojom::ReflectionPadding::New());

    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::SymmetricPadding::DataView, ::webnn::mojom::SymmetricPaddingPtr>::Read(
    ::webnn::mojom::SymmetricPadding::DataView input, ::webnn::mojom::SymmetricPaddingPtr* output)
{
    bool success = true;
    ::webnn::mojom::SymmetricPaddingPtr result(::webnn::mojom::SymmetricPadding::New());

    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::InstanceNormalization::DataView, ::webnn::mojom::InstanceNormalizationPtr>::Read(
    ::webnn::mojom::InstanceNormalization::DataView input, ::webnn::mojom::InstanceNormalizationPtr* output)
{
    bool success = true;
    ::webnn::mojom::InstanceNormalizationPtr result(::webnn::mojom::InstanceNormalization::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success) {
        result->scale_operand_id = input.scale_operand_id();
    }
    if (success) {
        result->bias_operand_id = input.bias_operand_id();
    }
    if (success)
        result->epsilon = input.epsilon();
    if (success && !input.ReadLayout(&result->layout))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Matmul::DataView, ::webnn::mojom::MatmulPtr>::Read(::webnn::mojom::Matmul::DataView input, ::webnn::mojom::MatmulPtr* output)
{
    bool success = true;
    ::webnn::mojom::MatmulPtr result(::webnn::mojom::Matmul::New());

    if (success)
        result->a_operand_id = input.a_operand_id();
    if (success)
        result->b_operand_id = input.b_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Pad::DataView, ::webnn::mojom::PadPtr>::Read(::webnn::mojom::Pad::DataView input, ::webnn::mojom::PadPtr* output)
{
    bool success = true;
    ::webnn::mojom::PadPtr result(::webnn::mojom::Pad::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadBeginningPadding(&result->beginning_padding))
        success = false;
    if (success && !input.ReadEndingPadding(&result->ending_padding))
        success = false;
    if (success && !input.ReadMode(&result->mode))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Reduce::DataView, ::webnn::mojom::ReducePtr>::Read(::webnn::mojom::Reduce::DataView input, ::webnn::mojom::ReducePtr* output)
{
    bool success = true;
    ::webnn::mojom::ReducePtr result(::webnn::mojom::Reduce::New());

    if (success && !input.ReadKind(&result->kind))
        success = false;
    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadAxes(&result->axes))
        success = false;
    if (success)
        result->keep_dimensions = input.keep_dimensions();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Pool2d::DataView, ::webnn::mojom::Pool2dPtr>::Read(::webnn::mojom::Pool2d::DataView input, ::webnn::mojom::Pool2dPtr* output)
{
    bool success = true;
    ::webnn::mojom::Pool2dPtr result(::webnn::mojom::Pool2d::New());

    if (success && !input.ReadKind(&result->kind))
        success = false;
    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadWindowDimensions(&result->window_dimensions))
        success = false;
    if (success && !input.ReadPadding(&result->padding))
        success = false;
    if (success && !input.ReadStrides(&result->strides))
        success = false;
    if (success && !input.ReadDilations(&result->dilations))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Range::DataView, ::webnn::mojom::RangePtr>::Read(::webnn::mojom::Range::DataView input, ::webnn::mojom::RangePtr* output)
{
    bool success = true;
    ::webnn::mojom::RangePtr result(::webnn::mojom::Range::New());

    if (success)
        result->start = input.start();
    if (success)
        result->size = input.size();
    if (success)
        result->stride = input.stride();
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Slice::DataView, ::webnn::mojom::SlicePtr>::Read(::webnn::mojom::Slice::DataView input, ::webnn::mojom::SlicePtr* output)
{
    bool success = true;
    ::webnn::mojom::SlicePtr result(::webnn::mojom::Slice::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadRanges(&result->ranges))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Elu::DataView, ::webnn::mojom::EluPtr>::Read(::webnn::mojom::Elu::DataView input, ::webnn::mojom::EluPtr* output)
{
    bool success = true;
    ::webnn::mojom::EluPtr result(::webnn::mojom::Elu::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->alpha = input.alpha();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Gather::DataView, ::webnn::mojom::GatherPtr>::Read(::webnn::mojom::Gather::DataView input, ::webnn::mojom::GatherPtr* output)
{
    bool success = true;
    ::webnn::mojom::GatherPtr result(::webnn::mojom::Gather::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->indices_operand_id = input.indices_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->axis = input.axis();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::GatherElements::DataView, ::webnn::mojom::GatherElementsPtr>::Read(
    ::webnn::mojom::GatherElements::DataView input, ::webnn::mojom::GatherElementsPtr* output)
{
    bool success = true;
    ::webnn::mojom::GatherElementsPtr result(::webnn::mojom::GatherElements::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->indices_operand_id = input.indices_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->axis = input.axis();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::GatherND::DataView, ::webnn::mojom::GatherNDPtr>::Read(
    ::webnn::mojom::GatherND::DataView input, ::webnn::mojom::GatherNDPtr* output)
{
    bool success = true;
    ::webnn::mojom::GatherNDPtr result(::webnn::mojom::GatherND::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->indices_operand_id = input.indices_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Gelu::DataView, ::webnn::mojom::GeluPtr>::Read(::webnn::mojom::Gelu::DataView input, ::webnn::mojom::GeluPtr* output)
{
    bool success = true;
    ::webnn::mojom::GeluPtr result(::webnn::mojom::Gelu::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Gru::DataView, ::webnn::mojom::GruPtr>::Read(::webnn::mojom::Gru::DataView input, ::webnn::mojom::GruPtr* output)
{
    bool success = true;
    ::webnn::mojom::GruPtr result(::webnn::mojom::Gru::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->weight_operand_id = input.weight_operand_id();
    if (success)
        result->recurrent_weight_operand_id = input.recurrent_weight_operand_id();
    if (success)
        result->steps = input.steps();
    if (success)
        result->hidden_size = input.hidden_size();
    if (success && !input.ReadOutputOperandIds(&result->output_operand_ids))
        success = false;
    if (success) {
        result->bias_operand_id = input.bias_operand_id();
    }
    if (success) {
        result->recurrent_bias_operand_id = input.recurrent_bias_operand_id();
    }
    if (success) {
        result->initial_hidden_state_operand_id = input.initial_hidden_state_operand_id();
    }
    if (success)
        result->reset_after = input.reset_after();
    if (success)
        result->return_sequence = input.return_sequence();
    if (success && !input.ReadDirection(&result->direction))
        success = false;
    if (success && !input.ReadLayout(&result->layout))
        success = false;
    if (success && !input.ReadActivations(&result->activations))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::GruCell::DataView, ::webnn::mojom::GruCellPtr>::Read(
    ::webnn::mojom::GruCell::DataView input, ::webnn::mojom::GruCellPtr* output)
{
    bool success = true;
    ::webnn::mojom::GruCellPtr result(::webnn::mojom::GruCell::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->weight_operand_id = input.weight_operand_id();
    if (success)
        result->recurrent_weight_operand_id = input.recurrent_weight_operand_id();
    if (success)
        result->hidden_state_operand_id = input.hidden_state_operand_id();
    if (success)
        result->hidden_size = input.hidden_size();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success) {
        result->bias_operand_id = input.bias_operand_id();
    }
    if (success) {
        result->recurrent_bias_operand_id = input.recurrent_bias_operand_id();
    }
    if (success)
        result->reset_after = input.reset_after();
    if (success && !input.ReadLayout(&result->layout))
        success = false;
    if (success && !input.ReadActivations(&result->activations))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Gemm::DataView, ::webnn::mojom::GemmPtr>::Read(::webnn::mojom::Gemm::DataView input, ::webnn::mojom::GemmPtr* output)
{
    bool success = true;
    ::webnn::mojom::GemmPtr result(::webnn::mojom::Gemm::New());

    if (success)
        result->a_operand_id = input.a_operand_id();
    if (success)
        result->b_operand_id = input.b_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success) {
        result->c_operand_id = input.c_operand_id();
    }
    if (success)
        result->alpha = input.alpha();
    if (success)
        result->beta = input.beta();
    if (success)
        result->a_transpose = input.a_transpose();
    if (success)
        result->b_transpose = input.b_transpose();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::HardSigmoid::DataView, ::webnn::mojom::HardSigmoidPtr>::Read(
    ::webnn::mojom::HardSigmoid::DataView input, ::webnn::mojom::HardSigmoidPtr* output)
{
    bool success = true;
    ::webnn::mojom::HardSigmoidPtr result(::webnn::mojom::HardSigmoid::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->alpha = input.alpha();
    if (success)
        result->beta = input.beta();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::HardSwish::DataView, ::webnn::mojom::HardSwishPtr>::Read(
    ::webnn::mojom::HardSwish::DataView input, ::webnn::mojom::HardSwishPtr* output)
{
    bool success = true;
    ::webnn::mojom::HardSwishPtr result(::webnn::mojom::HardSwish::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::LayerNormalization::DataView, ::webnn::mojom::LayerNormalizationPtr>::Read(
    ::webnn::mojom::LayerNormalization::DataView input, ::webnn::mojom::LayerNormalizationPtr* output)
{
    bool success = true;
    ::webnn::mojom::LayerNormalizationPtr result(::webnn::mojom::LayerNormalization::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success) {
        result->scale_operand_id = input.scale_operand_id();
    }
    if (success) {
        result->bias_operand_id = input.bias_operand_id();
    }
    if (success && !input.ReadAxes(&result->axes))
        success = false;
    if (success)
        result->epsilon = input.epsilon();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::LeakyRelu::DataView, ::webnn::mojom::LeakyReluPtr>::Read(
    ::webnn::mojom::LeakyRelu::DataView input, ::webnn::mojom::LeakyReluPtr* output)
{
    bool success = true;
    ::webnn::mojom::LeakyReluPtr result(::webnn::mojom::LeakyRelu::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->alpha = input.alpha();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Linear::DataView, ::webnn::mojom::LinearPtr>::Read(::webnn::mojom::Linear::DataView input, ::webnn::mojom::LinearPtr* output)
{
    bool success = true;
    ::webnn::mojom::LinearPtr result(::webnn::mojom::Linear::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->alpha = input.alpha();
    if (success)
        result->beta = input.beta();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Lstm::DataView, ::webnn::mojom::LstmPtr>::Read(::webnn::mojom::Lstm::DataView input, ::webnn::mojom::LstmPtr* output)
{
    bool success = true;
    ::webnn::mojom::LstmPtr result(::webnn::mojom::Lstm::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->weight_operand_id = input.weight_operand_id();
    if (success)
        result->recurrent_weight_operand_id = input.recurrent_weight_operand_id();
    if (success && !input.ReadOutputOperandIds(&result->output_operand_ids))
        success = false;
    if (success)
        result->steps = input.steps();
    if (success)
        result->hidden_size = input.hidden_size();
    if (success) {
        result->bias_operand_id = input.bias_operand_id();
    }
    if (success) {
        result->recurrent_bias_operand_id = input.recurrent_bias_operand_id();
    }
    if (success) {
        result->peephole_weight_operand_id = input.peephole_weight_operand_id();
    }
    if (success) {
        result->initial_hidden_state_operand_id = input.initial_hidden_state_operand_id();
    }
    if (success) {
        result->initial_cell_state_operand_id = input.initial_cell_state_operand_id();
    }
    if (success)
        result->return_sequence = input.return_sequence();
    if (success && !input.ReadDirection(&result->direction))
        success = false;
    if (success && !input.ReadLayout(&result->layout))
        success = false;
    if (success && !input.ReadActivations(&result->activations))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::LstmCell::DataView, ::webnn::mojom::LstmCellPtr>::Read(
    ::webnn::mojom::LstmCell::DataView input, ::webnn::mojom::LstmCellPtr* output)
{
    bool success = true;
    ::webnn::mojom::LstmCellPtr result(::webnn::mojom::LstmCell::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->weight_operand_id = input.weight_operand_id();
    if (success)
        result->recurrent_weight_operand_id = input.recurrent_weight_operand_id();
    if (success)
        result->hidden_state_operand_id = input.hidden_state_operand_id();
    if (success)
        result->cell_state_operand_id = input.cell_state_operand_id();
    if (success && !input.ReadOutputOperandIds(&result->output_operand_ids))
        success = false;
    if (success)
        result->hidden_size = input.hidden_size();
    if (success) {
        result->bias_operand_id = input.bias_operand_id();
    }
    if (success) {
        result->recurrent_bias_operand_id = input.recurrent_bias_operand_id();
    }
    if (success) {
        result->peephole_weight_operand_id = input.peephole_weight_operand_id();
    }
    if (success && !input.ReadLayout(&result->layout))
        success = false;
    if (success && !input.ReadActivations(&result->activations))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Prelu::DataView, ::webnn::mojom::PreluPtr>::Read(::webnn::mojom::Prelu::DataView input, ::webnn::mojom::PreluPtr* output)
{
    bool success = true;
    ::webnn::mojom::PreluPtr result(::webnn::mojom::Prelu::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->slope_operand_id = input.slope_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::QuantizeLinear::DataView, ::webnn::mojom::QuantizeLinearPtr>::Read(
    ::webnn::mojom::QuantizeLinear::DataView input, ::webnn::mojom::QuantizeLinearPtr* output)
{
    bool success = true;
    ::webnn::mojom::QuantizeLinearPtr result(::webnn::mojom::QuantizeLinear::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->scale_operand_id = input.scale_operand_id();
    if (success)
        result->zero_point_operand_id = input.zero_point_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Relu::DataView, ::webnn::mojom::ReluPtr>::Read(::webnn::mojom::Relu::DataView input, ::webnn::mojom::ReluPtr* output)
{
    bool success = true;
    ::webnn::mojom::ReluPtr result(::webnn::mojom::Relu::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Reshape::DataView, ::webnn::mojom::ReshapePtr>::Read(
    ::webnn::mojom::Reshape::DataView input, ::webnn::mojom::ReshapePtr* output)
{
    bool success = true;
    ::webnn::mojom::ReshapePtr result(::webnn::mojom::Reshape::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::ScatterElements::DataView, ::webnn::mojom::ScatterElementsPtr>::Read(
    ::webnn::mojom::ScatterElements::DataView input, ::webnn::mojom::ScatterElementsPtr* output)
{
    bool success = true;
    ::webnn::mojom::ScatterElementsPtr result(::webnn::mojom::ScatterElements::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->indices_operand_id = input.indices_operand_id();
    if (success)
        result->updates_operand_id = input.updates_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->axis = input.axis();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::ScatterND::DataView, ::webnn::mojom::ScatterNDPtr>::Read(
    ::webnn::mojom::ScatterND::DataView input, ::webnn::mojom::ScatterNDPtr* output)
{
    bool success = true;
    ::webnn::mojom::ScatterNDPtr result(::webnn::mojom::ScatterND::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->indices_operand_id = input.indices_operand_id();
    if (success)
        result->updates_operand_id = input.updates_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Sigmoid::DataView, ::webnn::mojom::SigmoidPtr>::Read(
    ::webnn::mojom::Sigmoid::DataView input, ::webnn::mojom::SigmoidPtr* output)
{
    bool success = true;
    ::webnn::mojom::SigmoidPtr result(::webnn::mojom::Sigmoid::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Softmax::DataView, ::webnn::mojom::SoftmaxPtr>::Read(
    ::webnn::mojom::Softmax::DataView input, ::webnn::mojom::SoftmaxPtr* output)
{
    bool success = true;
    ::webnn::mojom::SoftmaxPtr result(::webnn::mojom::Softmax::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->axis = input.axis();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Softplus::DataView, ::webnn::mojom::SoftplusPtr>::Read(
    ::webnn::mojom::Softplus::DataView input, ::webnn::mojom::SoftplusPtr* output)
{
    bool success = true;
    ::webnn::mojom::SoftplusPtr result(::webnn::mojom::Softplus::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Softsign::DataView, ::webnn::mojom::SoftsignPtr>::Read(
    ::webnn::mojom::Softsign::DataView input, ::webnn::mojom::SoftsignPtr* output)
{
    bool success = true;
    ::webnn::mojom::SoftsignPtr result(::webnn::mojom::Softsign::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Split::DataView, ::webnn::mojom::SplitPtr>::Read(::webnn::mojom::Split::DataView input, ::webnn::mojom::SplitPtr* output)
{
    bool success = true;
    ::webnn::mojom::SplitPtr result(::webnn::mojom::Split::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success && !input.ReadOutputOperandIds(&result->output_operand_ids))
        success = false;
    if (success)
        result->axis = input.axis();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Tanh::DataView, ::webnn::mojom::TanhPtr>::Read(::webnn::mojom::Tanh::DataView input, ::webnn::mojom::TanhPtr* output)
{
    bool success = true;
    ::webnn::mojom::TanhPtr result(::webnn::mojom::Tanh::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Tile::DataView, ::webnn::mojom::TilePtr>::Read(::webnn::mojom::Tile::DataView input, ::webnn::mojom::TilePtr* output)
{
    bool success = true;
    ::webnn::mojom::TilePtr result(::webnn::mojom::Tile::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadRepetitions(&result->repetitions))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Transpose::DataView, ::webnn::mojom::TransposePtr>::Read(
    ::webnn::mojom::Transpose::DataView input, ::webnn::mojom::TransposePtr* output)
{
    bool success = true;
    ::webnn::mojom::TransposePtr result(::webnn::mojom::Transpose::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadPermutation(&result->permutation))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Triangular::DataView, ::webnn::mojom::TriangularPtr>::Read(
    ::webnn::mojom::Triangular::DataView input, ::webnn::mojom::TriangularPtr* output)
{
    bool success = true;
    ::webnn::mojom::TriangularPtr result(::webnn::mojom::Triangular::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success)
        result->upper = input.upper();
    if (success)
        result->diagonal = input.diagonal();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Resample2d::DataView, ::webnn::mojom::Resample2dPtr>::Read(
    ::webnn::mojom::Resample2d::DataView input, ::webnn::mojom::Resample2dPtr* output)
{
    bool success = true;
    ::webnn::mojom::Resample2dPtr result(::webnn::mojom::Resample2d::New());

    if (success)
        result->input_operand_id = input.input_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadMode(&result->mode))
        success = false;
    if (success && !input.ReadScales(&result->scales))
        success = false;
    if (success && !input.ReadAxes(&result->axes))
        success = false;
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::Where::DataView, ::webnn::mojom::WherePtr>::Read(::webnn::mojom::Where::DataView input, ::webnn::mojom::WherePtr* output)
{
    bool success = true;
    ::webnn::mojom::WherePtr result(::webnn::mojom::Where::New());

    if (success)
        result->condition_operand_id = input.condition_operand_id();
    if (success)
        result->true_value_operand_id = input.true_value_operand_id();
    if (success)
        result->false_value_operand_id = input.false_value_operand_id();
    if (success)
        result->output_operand_id = input.output_operand_id();
    if (success && !input.ReadLabel(&result->label))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool StructTraits<::webnn::mojom::GraphInfo::DataView, ::webnn::mojom::GraphInfoPtr>::Read(
    ::webnn::mojom::GraphInfo::DataView input, ::webnn::mojom::GraphInfoPtr* output)
{
    bool success = true;
    ::webnn::mojom::GraphInfoPtr result(::webnn::mojom::GraphInfo::New());

    if (success && !input.ReadIdToOperandMap(&result->id_to_operand_map))
        success = false;
    if (success && !input.ReadInputOperands(&result->input_operands))
        success = false;
    if (success && !input.ReadOutputOperands(&result->output_operands))
        success = false;
    if (success && !input.ReadOperations(&result->operations))
        success = false;
    if (success && !input.ReadConstantIdToBufferMap(&result->constant_id_to_buffer_map))
        success = false;
    *output = std::move(result);
    return success;
}

// static
bool UnionTraits<::webnn::mojom::PaddingMode::DataView, ::webnn::mojom::PaddingModePtr>::Read(
    ::webnn::mojom::PaddingMode::DataView input, ::webnn::mojom::PaddingModePtr* output)
{
    using UnionType = ::webnn::mojom::PaddingMode;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kConstant: {
        ::webnn::mojom::ConstantPaddingPtr result_constant;
        if (!input.ReadConstant(&result_constant))
            return false;

        *output = UnionType::NewConstant(std::move(result_constant));
        break;
    }
    case Tag::kEdge: {
        ::webnn::mojom::EdgePaddingPtr result_edge;
        if (!input.ReadEdge(&result_edge))
            return false;

        *output = UnionType::NewEdge(std::move(result_edge));
        break;
    }
    case Tag::kReflection: {
        ::webnn::mojom::ReflectionPaddingPtr result_reflection;
        if (!input.ReadReflection(&result_reflection))
            return false;

        *output = UnionType::NewReflection(std::move(result_reflection));
        break;
    }
    case Tag::kSymmetric: {
        ::webnn::mojom::SymmetricPaddingPtr result_symmetric;
        if (!input.ReadSymmetric(&result_symmetric))
            return false;

        *output = UnionType::NewSymmetric(std::move(result_symmetric));
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::webnn::mojom::Operation::DataView, ::webnn::mojom::OperationPtr>::Read(
    ::webnn::mojom::Operation::DataView input, ::webnn::mojom::OperationPtr* output)
{
    using UnionType = ::webnn::mojom::Operation;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kArgMinMax: {
        ::webnn::mojom::ArgMinMaxPtr result_arg_min_max;
        if (!input.ReadArgMinMax(&result_arg_min_max))
            return false;

        *output = UnionType::NewArgMinMax(std::move(result_arg_min_max));
        break;
    }
    case Tag::kBatchNormalization: {
        ::webnn::mojom::BatchNormalizationPtr result_batch_normalization;
        if (!input.ReadBatchNormalization(&result_batch_normalization))
            return false;

        *output = UnionType::NewBatchNormalization(std::move(result_batch_normalization));
        break;
    }
    case Tag::kClamp: {
        ::webnn::mojom::ClampPtr result_clamp;
        if (!input.ReadClamp(&result_clamp))
            return false;

        *output = UnionType::NewClamp(std::move(result_clamp));
        break;
    }
    case Tag::kConcat: {
        ::webnn::mojom::ConcatPtr result_concat;
        if (!input.ReadConcat(&result_concat))
            return false;

        *output = UnionType::NewConcat(std::move(result_concat));
        break;
    }
    case Tag::kConv2d: {
        ::webnn::mojom::Conv2dPtr result_conv2d;
        if (!input.ReadConv2d(&result_conv2d))
            return false;

        *output = UnionType::NewConv2d(std::move(result_conv2d));
        break;
    }
    case Tag::kCumulativeSum: {
        ::webnn::mojom::CumulativeSumPtr result_cumulative_sum;
        if (!input.ReadCumulativeSum(&result_cumulative_sum))
            return false;

        *output = UnionType::NewCumulativeSum(std::move(result_cumulative_sum));
        break;
    }
    case Tag::kDequantizeLinear: {
        ::webnn::mojom::DequantizeLinearPtr result_dequantize_linear;
        if (!input.ReadDequantizeLinear(&result_dequantize_linear))
            return false;

        *output = UnionType::NewDequantizeLinear(std::move(result_dequantize_linear));
        break;
    }
    case Tag::kElementWiseBinary: {
        ::webnn::mojom::ElementWiseBinaryPtr result_element_wise_binary;
        if (!input.ReadElementWiseBinary(&result_element_wise_binary))
            return false;

        *output = UnionType::NewElementWiseBinary(std::move(result_element_wise_binary));
        break;
    }
    case Tag::kElu: {
        ::webnn::mojom::EluPtr result_elu;
        if (!input.ReadElu(&result_elu))
            return false;

        *output = UnionType::NewElu(std::move(result_elu));
        break;
    }
    case Tag::kElementWiseUnary: {
        ::webnn::mojom::ElementWiseUnaryPtr result_element_wise_unary;
        if (!input.ReadElementWiseUnary(&result_element_wise_unary))
            return false;

        *output = UnionType::NewElementWiseUnary(std::move(result_element_wise_unary));
        break;
    }
    case Tag::kExpand: {
        ::webnn::mojom::ExpandPtr result_expand;
        if (!input.ReadExpand(&result_expand))
            return false;

        *output = UnionType::NewExpand(std::move(result_expand));
        break;
    }
    case Tag::kGather: {
        ::webnn::mojom::GatherPtr result_gather;
        if (!input.ReadGather(&result_gather))
            return false;

        *output = UnionType::NewGather(std::move(result_gather));
        break;
    }
    case Tag::kGatherElements: {
        ::webnn::mojom::GatherElementsPtr result_gather_elements;
        if (!input.ReadGatherElements(&result_gather_elements))
            return false;

        *output = UnionType::NewGatherElements(std::move(result_gather_elements));
        break;
    }
    case Tag::kGatherNd: {
        ::webnn::mojom::GatherNDPtr result_gather_nd;
        if (!input.ReadGatherNd(&result_gather_nd))
            return false;

        *output = UnionType::NewGatherNd(std::move(result_gather_nd));
        break;
    }
    case Tag::kGelu: {
        ::webnn::mojom::GeluPtr result_gelu;
        if (!input.ReadGelu(&result_gelu))
            return false;

        *output = UnionType::NewGelu(std::move(result_gelu));
        break;
    }
    case Tag::kGemm: {
        ::webnn::mojom::GemmPtr result_gemm;
        if (!input.ReadGemm(&result_gemm))
            return false;

        *output = UnionType::NewGemm(std::move(result_gemm));
        break;
    }
    case Tag::kGru: {
        ::webnn::mojom::GruPtr result_gru;
        if (!input.ReadGru(&result_gru))
            return false;

        *output = UnionType::NewGru(std::move(result_gru));
        break;
    }
    case Tag::kGruCell: {
        ::webnn::mojom::GruCellPtr result_gru_cell;
        if (!input.ReadGruCell(&result_gru_cell))
            return false;

        *output = UnionType::NewGruCell(std::move(result_gru_cell));
        break;
    }
    case Tag::kHardSigmoid: {
        ::webnn::mojom::HardSigmoidPtr result_hard_sigmoid;
        if (!input.ReadHardSigmoid(&result_hard_sigmoid))
            return false;

        *output = UnionType::NewHardSigmoid(std::move(result_hard_sigmoid));
        break;
    }
    case Tag::kHardSwish: {
        ::webnn::mojom::HardSwishPtr result_hard_swish;
        if (!input.ReadHardSwish(&result_hard_swish))
            return false;

        *output = UnionType::NewHardSwish(std::move(result_hard_swish));
        break;
    }
    case Tag::kLayerNormalization: {
        ::webnn::mojom::LayerNormalizationPtr result_layer_normalization;
        if (!input.ReadLayerNormalization(&result_layer_normalization))
            return false;

        *output = UnionType::NewLayerNormalization(std::move(result_layer_normalization));
        break;
    }
    case Tag::kInstanceNormalization: {
        ::webnn::mojom::InstanceNormalizationPtr result_instance_normalization;
        if (!input.ReadInstanceNormalization(&result_instance_normalization))
            return false;

        *output = UnionType::NewInstanceNormalization(std::move(result_instance_normalization));
        break;
    }
    case Tag::kLeakyRelu: {
        ::webnn::mojom::LeakyReluPtr result_leaky_relu;
        if (!input.ReadLeakyRelu(&result_leaky_relu))
            return false;

        *output = UnionType::NewLeakyRelu(std::move(result_leaky_relu));
        break;
    }
    case Tag::kLinear: {
        ::webnn::mojom::LinearPtr result_linear;
        if (!input.ReadLinear(&result_linear))
            return false;

        *output = UnionType::NewLinear(std::move(result_linear));
        break;
    }
    case Tag::kLstm: {
        ::webnn::mojom::LstmPtr result_lstm;
        if (!input.ReadLstm(&result_lstm))
            return false;

        *output = UnionType::NewLstm(std::move(result_lstm));
        break;
    }
    case Tag::kLstmCell: {
        ::webnn::mojom::LstmCellPtr result_lstm_cell;
        if (!input.ReadLstmCell(&result_lstm_cell))
            return false;

        *output = UnionType::NewLstmCell(std::move(result_lstm_cell));
        break;
    }
    case Tag::kMatmul: {
        ::webnn::mojom::MatmulPtr result_matmul;
        if (!input.ReadMatmul(&result_matmul))
            return false;

        *output = UnionType::NewMatmul(std::move(result_matmul));
        break;
    }
    case Tag::kPad: {
        ::webnn::mojom::PadPtr result_pad;
        if (!input.ReadPad(&result_pad))
            return false;

        *output = UnionType::NewPad(std::move(result_pad));
        break;
    }
    case Tag::kPool2d: {
        ::webnn::mojom::Pool2dPtr result_pool2d;
        if (!input.ReadPool2d(&result_pool2d))
            return false;

        *output = UnionType::NewPool2d(std::move(result_pool2d));
        break;
    }
    case Tag::kPrelu: {
        ::webnn::mojom::PreluPtr result_prelu;
        if (!input.ReadPrelu(&result_prelu))
            return false;

        *output = UnionType::NewPrelu(std::move(result_prelu));
        break;
    }
    case Tag::kQuantizeLinear: {
        ::webnn::mojom::QuantizeLinearPtr result_quantize_linear;
        if (!input.ReadQuantizeLinear(&result_quantize_linear))
            return false;

        *output = UnionType::NewQuantizeLinear(std::move(result_quantize_linear));
        break;
    }
    case Tag::kReduce: {
        ::webnn::mojom::ReducePtr result_reduce;
        if (!input.ReadReduce(&result_reduce))
            return false;

        *output = UnionType::NewReduce(std::move(result_reduce));
        break;
    }
    case Tag::kRelu: {
        ::webnn::mojom::ReluPtr result_relu;
        if (!input.ReadRelu(&result_relu))
            return false;

        *output = UnionType::NewRelu(std::move(result_relu));
        break;
    }
    case Tag::kResample2d: {
        ::webnn::mojom::Resample2dPtr result_resample2d;
        if (!input.ReadResample2d(&result_resample2d))
            return false;

        *output = UnionType::NewResample2d(std::move(result_resample2d));
        break;
    }
    case Tag::kReshape: {
        ::webnn::mojom::ReshapePtr result_reshape;
        if (!input.ReadReshape(&result_reshape))
            return false;

        *output = UnionType::NewReshape(std::move(result_reshape));
        break;
    }
    case Tag::kScatterElements: {
        ::webnn::mojom::ScatterElementsPtr result_scatter_elements;
        if (!input.ReadScatterElements(&result_scatter_elements))
            return false;

        *output = UnionType::NewScatterElements(std::move(result_scatter_elements));
        break;
    }
    case Tag::kScatterNd: {
        ::webnn::mojom::ScatterNDPtr result_scatter_nd;
        if (!input.ReadScatterNd(&result_scatter_nd))
            return false;

        *output = UnionType::NewScatterNd(std::move(result_scatter_nd));
        break;
    }
    case Tag::kSigmoid: {
        ::webnn::mojom::SigmoidPtr result_sigmoid;
        if (!input.ReadSigmoid(&result_sigmoid))
            return false;

        *output = UnionType::NewSigmoid(std::move(result_sigmoid));
        break;
    }
    case Tag::kSlice: {
        ::webnn::mojom::SlicePtr result_slice;
        if (!input.ReadSlice(&result_slice))
            return false;

        *output = UnionType::NewSlice(std::move(result_slice));
        break;
    }
    case Tag::kSoftmax: {
        ::webnn::mojom::SoftmaxPtr result_softmax;
        if (!input.ReadSoftmax(&result_softmax))
            return false;

        *output = UnionType::NewSoftmax(std::move(result_softmax));
        break;
    }
    case Tag::kSoftplus: {
        ::webnn::mojom::SoftplusPtr result_softplus;
        if (!input.ReadSoftplus(&result_softplus))
            return false;

        *output = UnionType::NewSoftplus(std::move(result_softplus));
        break;
    }
    case Tag::kSoftsign: {
        ::webnn::mojom::SoftsignPtr result_softsign;
        if (!input.ReadSoftsign(&result_softsign))
            return false;

        *output = UnionType::NewSoftsign(std::move(result_softsign));
        break;
    }
    case Tag::kSplit: {
        ::webnn::mojom::SplitPtr result_split;
        if (!input.ReadSplit(&result_split))
            return false;

        *output = UnionType::NewSplit(std::move(result_split));
        break;
    }
    case Tag::kTanh: {
        ::webnn::mojom::TanhPtr result_tanh;
        if (!input.ReadTanh(&result_tanh))
            return false;

        *output = UnionType::NewTanh(std::move(result_tanh));
        break;
    }
    case Tag::kTile: {
        ::webnn::mojom::TilePtr result_tile;
        if (!input.ReadTile(&result_tile))
            return false;

        *output = UnionType::NewTile(std::move(result_tile));
        break;
    }
    case Tag::kTranspose: {
        ::webnn::mojom::TransposePtr result_transpose;
        if (!input.ReadTranspose(&result_transpose))
            return false;

        *output = UnionType::NewTranspose(std::move(result_transpose));
        break;
    }
    case Tag::kTriangular: {
        ::webnn::mojom::TriangularPtr result_triangular;
        if (!input.ReadTriangular(&result_triangular))
            return false;

        *output = UnionType::NewTriangular(std::move(result_triangular));
        break;
    }
    case Tag::kWhere: {
        ::webnn::mojom::WherePtr result_where;
        if (!input.ReadWhere(&result_where))
            return false;

        *output = UnionType::NewWhere(std::move(result_where));
        break;
    }
    default:

        return false;
    }
    return true;
}

// static
bool UnionTraits<::webnn::mojom::ComputeResult::DataView, ::webnn::mojom::ComputeResultPtr>::Read(
    ::webnn::mojom::ComputeResult::DataView input, ::webnn::mojom::ComputeResultPtr* output)
{
    using UnionType = ::webnn::mojom::ComputeResult;
    using Tag = UnionType::Tag;

    switch (input.tag()) {
    case Tag::kNamedOutputs: {
        base::flat_map<std::string, ::mojo_base::BigBuffer> result_named_outputs;
        if (!input.ReadNamedOutputs(&result_named_outputs))
            return false;

        *output = UnionType::NewNamedOutputs(std::move(result_named_outputs));
        break;
    }
    case Tag::kError: {
        ::webnn::mojom::ErrorPtr result_error;
        if (!input.ReadError(&result_error))
            return false;

        *output = UnionType::NewError(std::move(result_error));
        break;
    }
    default:

        return false;
    }
    return true;
}

} // namespace mojo

// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.

namespace webnn::mojom {

void WebNNGraphInterceptorForTesting::Compute(base::flat_map<std::string, ::mojo_base::BigBuffer> named_inputs, ComputeCallback callback)
{
    GetForwardingInterface()->Compute(std::move(named_inputs), std::move(callback));
}
void WebNNGraphInterceptorForTesting::Dispatch(
    const base::flat_map<std::string, ::blink::WebNNTensorToken>& named_inputs, const base::flat_map<std::string, ::blink::WebNNTensorToken>& named_outputs)
{
    GetForwardingInterface()->Dispatch(std::move(named_inputs), std::move(named_outputs));
}
WebNNGraphAsyncWaiter::WebNNGraphAsyncWaiter(WebNNGraph* proxy)
    : proxy_(proxy)
{
}

WebNNGraphAsyncWaiter::~WebNNGraphAsyncWaiter() = default;

void WebNNGraphAsyncWaiter::Compute(base::flat_map<std::string, ::mojo_base::BigBuffer> named_inputs, ComputeResultPtr* out_result)
{
    base::RunLoop loop;
    proxy_->Compute(std::move(named_inputs),
        base::BindOnce(
            [](base::RunLoop* loop, ComputeResultPtr* out_result, ComputeResultPtr result) {
                *out_result = std::move(result);
                loop->Quit();
            },
            &loop, out_result));
    loop.Run();
}

ComputeResultPtr WebNNGraphAsyncWaiter::Compute(base::flat_map<std::string, ::mojo_base::BigBuffer> named_inputs)
{
    ComputeResultPtr async_wait_result;
    Compute(std::move(named_inputs), &async_wait_result);
    return async_wait_result;
}

} // webnn::mojom

#if defined(__clang__)
#pragma clang diagnostic pop
#endif