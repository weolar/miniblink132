// services/webnn/public/mojom/webnn_graph.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_WEBNN_PUBLIC_MOJOM_WEBNN_GRAPH_MOJOM_BLINK_H_
#define SERVICES_WEBNN_PUBLIC_MOJOM_WEBNN_GRAPH_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/webnn/public/mojom/webnn_graph.mojom-features.h" // IWYU pragma: export
#include "services/webnn/public/mojom/webnn_graph.mojom-shared.h" // IWYU pragma: export
#include "services/webnn/public/mojom/webnn_graph.mojom-blink-forward.h" // IWYU pragma: export
#include "mojo/public/mojom/base/big_buffer.mojom-blink.h"
#include "services/webnn/public/mojom/webnn_context_properties.mojom-blink-forward.h"
#include "services/webnn/public/mojom/webnn_error.mojom-blink.h"
#include "third_party/blink/public/mojom/tokens/tokens.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "services/webnn/public/mojom/context_properties_mojom_traits.h"
#include "services/webnn/public/mojom/data_type_limits_mojom_traits.h"
#include "services/webnn/public/mojom/operand_descriptor_mojom_traits.h"
#include "services/webnn/public/mojom/range_traits.h"
#include "services/webnn/public/mojom/supported_data_types_mojom_traits.h"
#include "services/webnn/public/mojom/tensor_usage_mojom_traits.h"
#include "base/component_export.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace webnn::mojom::blink {

class WebNNGraphProxy;

template <typename ImplRefTraits> class WebNNGraphStub;

class WebNNGraphRequestValidator;
class WebNNGraphResponseValidator;

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) WebNNGraph : public WebNNGraphInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = WebNNGraphInterfaceBase;
    using Proxy_ = WebNNGraphProxy;

    template <typename ImplRefTraits> using Stub_ = WebNNGraphStub<ImplRefTraits>;

    using RequestValidator_ = WebNNGraphRequestValidator;
    using ResponseValidator_ = WebNNGraphResponseValidator;
    enum MethodMinVersions : uint32_t {
        kComputeMinVersion = 0,
        kDispatchMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct Compute_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Dispatch_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~WebNNGraph() = default;

    using ComputeCallback = base::OnceCallback<void(ComputeResultPtr)>;

    virtual void Compute(WTF::HashMap<WTF::String, ::mojo_base::BigBuffer> named_inputs, ComputeCallback callback) = 0;

    virtual void Dispatch(
        const WTF::HashMap<WTF::String, ::blink::WebNNTensorToken>& named_inputs, const WTF::HashMap<WTF::String, ::blink::WebNNTensorToken>& named_outputs)
        = 0;
};

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) WebNNGraphProxy : public WebNNGraph {
public:
    using InterfaceType = WebNNGraph;

    explicit WebNNGraphProxy(mojo::MessageReceiverWithResponder* receiver);

    void Compute(WTF::HashMap<WTF::String, ::mojo_base::BigBuffer> named_inputs, ComputeCallback callback) final;

    void Dispatch(const WTF::HashMap<WTF::String, ::blink::WebNNTensorToken>& named_inputs,
        const WTF::HashMap<WTF::String, ::blink::WebNNTensorToken>& named_outputs) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};
class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) WebNNGraphStubDispatch {
public:
    static bool Accept(WebNNGraph* impl, mojo::Message* message);
    static bool AcceptWithResponder(WebNNGraph* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<WebNNGraph>> class WebNNGraphStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    WebNNGraphStub() = default;
//    ~WebNNGraphStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebNNGraphStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return WebNNGraphStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) WebNNGraphRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) WebNNGraphResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Size2d {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Size2d, T>::value>;
    using DataView = Size2dDataView;
    using Data_ = internal::Size2d_Data;

    template <typename... Args> static Size2dPtr New(Args&&... args)
    {
        return Size2dPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static Size2dPtr From(const U& u)
    {
        return mojo::TypeConverter<Size2dPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Size2d>::Convert(*this);
    }

    Size2d();

    Size2d(uint32_t height, uint32_t width);

    ~Size2d();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = Size2dPtr> Size2dPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Size2d::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Size2d::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Size2d::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Size2d::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Size2d::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Size2d_UnserializedMessageContext<UserType, Size2d::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Size2d::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Size2d::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Size2d_UnserializedMessageContext<UserType, Size2d::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Size2d::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint32_t height;

    uint32_t width;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Size2d::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Size2d::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Size2d::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Size2d::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) ElementWiseUnary {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ElementWiseUnary, T>::value>;
    using DataView = ElementWiseUnaryDataView;
    using Data_ = internal::ElementWiseUnary_Data;
    using Kind = ElementWiseUnary_Kind;

    template <typename... Args> static ElementWiseUnaryPtr New(Args&&... args)
    {
        return ElementWiseUnaryPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ElementWiseUnaryPtr From(const U& u)
    {
        return mojo::TypeConverter<ElementWiseUnaryPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ElementWiseUnary>::Convert(*this);
    }

    ElementWiseUnary();

    ElementWiseUnary(ElementWiseUnary::Kind kind, uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~ElementWiseUnary();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ElementWiseUnaryPtr> ElementWiseUnaryPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ElementWiseUnary::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ElementWiseUnary::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ElementWiseUnary::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ElementWiseUnary::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ElementWiseUnary::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ElementWiseUnary_UnserializedMessageContext<UserType, ElementWiseUnary::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ElementWiseUnary::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ElementWiseUnary::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ElementWiseUnary_UnserializedMessageContext<UserType, ElementWiseUnary::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ElementWiseUnary::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ElementWiseUnary::Kind kind;

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ElementWiseUnary::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ElementWiseUnary::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ElementWiseUnary::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ElementWiseUnary::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Expand {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Expand, T>::value>;
    using DataView = ExpandDataView;
    using Data_ = internal::Expand_Data;

    template <typename... Args> static ExpandPtr New(Args&&... args)
    {
        return ExpandPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ExpandPtr From(const U& u)
    {
        return mojo::TypeConverter<ExpandPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Expand>::Convert(*this);
    }

    Expand();

    Expand(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Expand();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ExpandPtr> ExpandPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Expand::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Expand::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Expand::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Expand::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Expand::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Expand_UnserializedMessageContext<UserType, Expand::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Expand::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Expand::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Expand_UnserializedMessageContext<UserType, Expand::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Expand::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Expand::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Expand::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Expand::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Expand::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) ConstantPadding {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ConstantPadding, T>::value>;
    using DataView = ConstantPaddingDataView;
    using Data_ = internal::ConstantPadding_Data;

    template <typename... Args> static ConstantPaddingPtr New(Args&&... args)
    {
        return ConstantPaddingPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ConstantPaddingPtr From(const U& u)
    {
        return mojo::TypeConverter<ConstantPaddingPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ConstantPadding>::Convert(*this);
    }

    ConstantPadding();

    explicit ConstantPadding(float value);

    ~ConstantPadding();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ConstantPaddingPtr> ConstantPaddingPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ConstantPadding::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ConstantPadding::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ConstantPadding::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ConstantPadding::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ConstantPadding::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ConstantPadding_UnserializedMessageContext<UserType, ConstantPadding::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ConstantPadding::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ConstantPadding::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ConstantPadding_UnserializedMessageContext<UserType, ConstantPadding::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ConstantPadding::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    float value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ConstantPadding::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ConstantPadding::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ConstantPadding::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ConstantPadding::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) EdgePadding {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<EdgePadding, T>::value>;
    using DataView = EdgePaddingDataView;
    using Data_ = internal::EdgePadding_Data;

    template <typename... Args> static EdgePaddingPtr New(Args&&... args)
    {
        return EdgePaddingPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static EdgePaddingPtr From(const U& u)
    {
        return mojo::TypeConverter<EdgePaddingPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, EdgePadding>::Convert(*this);
    }

    EdgePadding();

    ~EdgePadding();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = EdgePaddingPtr> EdgePaddingPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, EdgePadding::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, EdgePadding::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, EdgePadding::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<EdgePadding::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<EdgePadding::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::EdgePadding_UnserializedMessageContext<UserType, EdgePadding::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<EdgePadding::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return EdgePadding::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::EdgePadding_UnserializedMessageContext<UserType, EdgePadding::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<EdgePadding::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EdgePadding::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, EdgePadding::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, EdgePadding::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, EdgePadding::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) ReflectionPadding {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ReflectionPadding, T>::value>;
    using DataView = ReflectionPaddingDataView;
    using Data_ = internal::ReflectionPadding_Data;

    template <typename... Args> static ReflectionPaddingPtr New(Args&&... args)
    {
        return ReflectionPaddingPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ReflectionPaddingPtr From(const U& u)
    {
        return mojo::TypeConverter<ReflectionPaddingPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ReflectionPadding>::Convert(*this);
    }

    ReflectionPadding();

    ~ReflectionPadding();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ReflectionPaddingPtr> ReflectionPaddingPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ReflectionPadding::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ReflectionPadding::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ReflectionPadding::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ReflectionPadding::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ReflectionPadding::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ReflectionPadding_UnserializedMessageContext<UserType, ReflectionPadding::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ReflectionPadding::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ReflectionPadding::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ReflectionPadding_UnserializedMessageContext<UserType, ReflectionPadding::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ReflectionPadding::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ReflectionPadding::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ReflectionPadding::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ReflectionPadding::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ReflectionPadding::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) SymmetricPadding {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SymmetricPadding, T>::value>;
    using DataView = SymmetricPaddingDataView;
    using Data_ = internal::SymmetricPadding_Data;

    template <typename... Args> static SymmetricPaddingPtr New(Args&&... args)
    {
        return SymmetricPaddingPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SymmetricPaddingPtr From(const U& u)
    {
        return mojo::TypeConverter<SymmetricPaddingPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SymmetricPadding>::Convert(*this);
    }

    SymmetricPadding();

    ~SymmetricPadding();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SymmetricPaddingPtr> SymmetricPaddingPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SymmetricPadding::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SymmetricPadding::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SymmetricPadding::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SymmetricPadding::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SymmetricPadding::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::SymmetricPadding_UnserializedMessageContext<UserType, SymmetricPadding::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SymmetricPadding::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SymmetricPadding::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::SymmetricPadding_UnserializedMessageContext<UserType, SymmetricPadding::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SymmetricPadding::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SymmetricPadding::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SymmetricPadding::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SymmetricPadding::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SymmetricPadding::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Matmul {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Matmul, T>::value>;
    using DataView = MatmulDataView;
    using Data_ = internal::Matmul_Data;

    template <typename... Args> static MatmulPtr New(Args&&... args)
    {
        return MatmulPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static MatmulPtr From(const U& u)
    {
        return mojo::TypeConverter<MatmulPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Matmul>::Convert(*this);
    }

    Matmul();

    Matmul(uint64_t a_operand_id, uint64_t b_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Matmul();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = MatmulPtr> MatmulPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Matmul::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Matmul::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Matmul::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Matmul::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Matmul::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Matmul_UnserializedMessageContext<UserType, Matmul::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Matmul::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Matmul::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Matmul_UnserializedMessageContext<UserType, Matmul::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Matmul::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t a_operand_id;

    uint64_t b_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Matmul::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Matmul::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Matmul::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Matmul::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Range {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Range, T>::value>;
    using DataView = RangeDataView;
    using Data_ = internal::Range_Data;

    template <typename... Args> static RangePtr New(Args&&... args)
    {
        return RangePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static RangePtr From(const U& u)
    {
        return mojo::TypeConverter<RangePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Range>::Convert(*this);
    }

    Range();

    Range(uint32_t start, uint32_t size, uint32_t stride);

    ~Range();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = RangePtr> RangePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Range::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Range::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Range::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Range::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Range::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Range_UnserializedMessageContext<UserType, Range::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Range::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Range::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Range_UnserializedMessageContext<UserType, Range::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Range::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint32_t start;

    uint32_t size;

    uint32_t stride;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Range::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Range::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Range::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Range::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Elu {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Elu, T>::value>;
    using DataView = EluDataView;
    using Data_ = internal::Elu_Data;

    template <typename... Args> static EluPtr New(Args&&... args)
    {
        return EluPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static EluPtr From(const U& u)
    {
        return mojo::TypeConverter<EluPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Elu>::Convert(*this);
    }

    Elu();

    Elu(uint64_t input_operand_id, uint64_t output_operand_id, float alpha, const WTF::String& label);

    ~Elu();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = EluPtr> EluPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Elu::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Elu::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Elu::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Elu::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Elu::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Elu_UnserializedMessageContext<UserType, Elu::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Elu::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Elu::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Elu_UnserializedMessageContext<UserType, Elu::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Elu::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    float alpha;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Elu::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Elu::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Elu::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Elu::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) GatherND {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GatherND, T>::value>;
    using DataView = GatherNDDataView;
    using Data_ = internal::GatherND_Data;

    template <typename... Args> static GatherNDPtr New(Args&&... args)
    {
        return GatherNDPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GatherNDPtr From(const U& u)
    {
        return mojo::TypeConverter<GatherNDPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GatherND>::Convert(*this);
    }

    GatherND();

    GatherND(uint64_t input_operand_id, uint64_t indices_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~GatherND();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GatherNDPtr> GatherNDPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GatherND::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GatherND::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GatherND::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<GatherND::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GatherND::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::GatherND_UnserializedMessageContext<UserType, GatherND::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GatherND::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GatherND::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GatherND_UnserializedMessageContext<UserType, GatherND::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GatherND::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t indices_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GatherND::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GatherND::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GatherND::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GatherND::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Gelu {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Gelu, T>::value>;
    using DataView = GeluDataView;
    using Data_ = internal::Gelu_Data;

    template <typename... Args> static GeluPtr New(Args&&... args)
    {
        return GeluPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GeluPtr From(const U& u)
    {
        return mojo::TypeConverter<GeluPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Gelu>::Convert(*this);
    }

    Gelu();

    Gelu(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Gelu();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GeluPtr> GeluPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Gelu::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Gelu::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Gelu::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Gelu::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Gelu::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Gelu_UnserializedMessageContext<UserType, Gelu::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Gelu::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Gelu::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Gelu_UnserializedMessageContext<UserType, Gelu::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Gelu::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Gelu::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Gelu::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Gelu::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Gelu::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) HardSwish {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<HardSwish, T>::value>;
    using DataView = HardSwishDataView;
    using Data_ = internal::HardSwish_Data;

    template <typename... Args> static HardSwishPtr New(Args&&... args)
    {
        return HardSwishPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static HardSwishPtr From(const U& u)
    {
        return mojo::TypeConverter<HardSwishPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, HardSwish>::Convert(*this);
    }

    HardSwish();

    HardSwish(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~HardSwish();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = HardSwishPtr> HardSwishPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, HardSwish::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, HardSwish::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, HardSwish::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<HardSwish::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<HardSwish::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::HardSwish_UnserializedMessageContext<UserType, HardSwish::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<HardSwish::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return HardSwish::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::HardSwish_UnserializedMessageContext<UserType, HardSwish::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<HardSwish::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HardSwish::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, HardSwish::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, HardSwish::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, HardSwish::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) LeakyRelu {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<LeakyRelu, T>::value>;
    using DataView = LeakyReluDataView;
    using Data_ = internal::LeakyRelu_Data;

    template <typename... Args> static LeakyReluPtr New(Args&&... args)
    {
        return LeakyReluPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LeakyReluPtr From(const U& u)
    {
        return mojo::TypeConverter<LeakyReluPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, LeakyRelu>::Convert(*this);
    }

    LeakyRelu();

    LeakyRelu(uint64_t input_operand_id, uint64_t output_operand_id, float alpha, const WTF::String& label);

    ~LeakyRelu();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LeakyReluPtr> LeakyReluPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, LeakyRelu::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, LeakyRelu::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, LeakyRelu::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<LeakyRelu::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<LeakyRelu::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::LeakyRelu_UnserializedMessageContext<UserType, LeakyRelu::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<LeakyRelu::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return LeakyRelu::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::LeakyRelu_UnserializedMessageContext<UserType, LeakyRelu::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<LeakyRelu::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    float alpha;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LeakyRelu::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, LeakyRelu::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, LeakyRelu::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, LeakyRelu::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Prelu {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Prelu, T>::value>;
    using DataView = PreluDataView;
    using Data_ = internal::Prelu_Data;

    template <typename... Args> static PreluPtr New(Args&&... args)
    {
        return PreluPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PreluPtr From(const U& u)
    {
        return mojo::TypeConverter<PreluPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Prelu>::Convert(*this);
    }

    Prelu();

    Prelu(uint64_t input_operand_id, uint64_t slope_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Prelu();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PreluPtr> PreluPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Prelu::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Prelu::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Prelu::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Prelu::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Prelu::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Prelu_UnserializedMessageContext<UserType, Prelu::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Prelu::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Prelu::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Prelu_UnserializedMessageContext<UserType, Prelu::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Prelu::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t slope_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Prelu::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Prelu::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Prelu::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Prelu::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Relu {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Relu, T>::value>;
    using DataView = ReluDataView;
    using Data_ = internal::Relu_Data;

    template <typename... Args> static ReluPtr New(Args&&... args)
    {
        return ReluPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ReluPtr From(const U& u)
    {
        return mojo::TypeConverter<ReluPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Relu>::Convert(*this);
    }

    Relu();

    Relu(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Relu();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ReluPtr> ReluPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Relu::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Relu::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Relu::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Relu::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Relu::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Relu_UnserializedMessageContext<UserType, Relu::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Relu::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Relu::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Relu_UnserializedMessageContext<UserType, Relu::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Relu::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Relu::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Relu::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Relu::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Relu::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Reshape {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Reshape, T>::value>;
    using DataView = ReshapeDataView;
    using Data_ = internal::Reshape_Data;

    template <typename... Args> static ReshapePtr New(Args&&... args)
    {
        return ReshapePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ReshapePtr From(const U& u)
    {
        return mojo::TypeConverter<ReshapePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Reshape>::Convert(*this);
    }

    Reshape();

    Reshape(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Reshape();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ReshapePtr> ReshapePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Reshape::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Reshape::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Reshape::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Reshape::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Reshape::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Reshape_UnserializedMessageContext<UserType, Reshape::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Reshape::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Reshape::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Reshape_UnserializedMessageContext<UserType, Reshape::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Reshape::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Reshape::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Reshape::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Reshape::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Reshape::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Sigmoid {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Sigmoid, T>::value>;
    using DataView = SigmoidDataView;
    using Data_ = internal::Sigmoid_Data;

    template <typename... Args> static SigmoidPtr New(Args&&... args)
    {
        return SigmoidPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SigmoidPtr From(const U& u)
    {
        return mojo::TypeConverter<SigmoidPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Sigmoid>::Convert(*this);
    }

    Sigmoid();

    Sigmoid(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Sigmoid();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SigmoidPtr> SigmoidPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Sigmoid::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Sigmoid::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Sigmoid::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Sigmoid::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Sigmoid::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Sigmoid_UnserializedMessageContext<UserType, Sigmoid::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Sigmoid::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Sigmoid::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Sigmoid_UnserializedMessageContext<UserType, Sigmoid::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Sigmoid::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Sigmoid::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Sigmoid::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Sigmoid::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Sigmoid::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Softmax {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Softmax, T>::value>;
    using DataView = SoftmaxDataView;
    using Data_ = internal::Softmax_Data;

    template <typename... Args> static SoftmaxPtr New(Args&&... args)
    {
        return SoftmaxPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SoftmaxPtr From(const U& u)
    {
        return mojo::TypeConverter<SoftmaxPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Softmax>::Convert(*this);
    }

    Softmax();

    Softmax(uint64_t input_operand_id, uint64_t output_operand_id, uint32_t axis, const WTF::String& label);

    ~Softmax();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SoftmaxPtr> SoftmaxPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Softmax::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Softmax::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Softmax::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Softmax::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Softmax::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Softmax_UnserializedMessageContext<UserType, Softmax::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Softmax::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Softmax::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Softmax_UnserializedMessageContext<UserType, Softmax::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Softmax::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    uint32_t axis;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Softmax::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Softmax::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Softmax::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Softmax::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Softplus {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Softplus, T>::value>;
    using DataView = SoftplusDataView;
    using Data_ = internal::Softplus_Data;

    template <typename... Args> static SoftplusPtr New(Args&&... args)
    {
        return SoftplusPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SoftplusPtr From(const U& u)
    {
        return mojo::TypeConverter<SoftplusPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Softplus>::Convert(*this);
    }

    Softplus();

    Softplus(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Softplus();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SoftplusPtr> SoftplusPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Softplus::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Softplus::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Softplus::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Softplus::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Softplus::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::Softplus_UnserializedMessageContext<UserType, Softplus::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Softplus::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Softplus::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Softplus_UnserializedMessageContext<UserType, Softplus::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Softplus::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Softplus::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Softplus::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Softplus::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Softplus::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Softsign {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Softsign, T>::value>;
    using DataView = SoftsignDataView;
    using Data_ = internal::Softsign_Data;

    template <typename... Args> static SoftsignPtr New(Args&&... args)
    {
        return SoftsignPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SoftsignPtr From(const U& u)
    {
        return mojo::TypeConverter<SoftsignPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Softsign>::Convert(*this);
    }

    Softsign();

    Softsign(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Softsign();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SoftsignPtr> SoftsignPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Softsign::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Softsign::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Softsign::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Softsign::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Softsign::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::Softsign_UnserializedMessageContext<UserType, Softsign::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Softsign::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Softsign::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Softsign_UnserializedMessageContext<UserType, Softsign::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Softsign::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Softsign::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Softsign::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Softsign::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Softsign::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Tanh {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Tanh, T>::value>;
    using DataView = TanhDataView;
    using Data_ = internal::Tanh_Data;

    template <typename... Args> static TanhPtr New(Args&&... args)
    {
        return TanhPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TanhPtr From(const U& u)
    {
        return mojo::TypeConverter<TanhPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Tanh>::Convert(*this);
    }

    Tanh();

    Tanh(uint64_t input_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Tanh();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TanhPtr> TanhPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Tanh::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Tanh::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Tanh::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Tanh::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Tanh::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Tanh_UnserializedMessageContext<UserType, Tanh::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Tanh::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Tanh::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Tanh_UnserializedMessageContext<UserType, Tanh::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Tanh::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Tanh::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Tanh::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Tanh::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Tanh::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) PaddingMode {
public:
    using DataView = PaddingModeDataView;
    using Data_ = internal::PaddingMode_Data;
    using Tag = Data_::PaddingMode_Tag;

    template <typename... Args> static PaddingModePtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |constant|.
    static PaddingModePtr NewConstant(ConstantPaddingPtr value)
    {
        auto result = PaddingModePtr(std::in_place);
        result->set_constant(std::move(value));
        return result;
    }
    // Construct an instance holding |edge|.
    static PaddingModePtr NewEdge(EdgePaddingPtr value)
    {
        auto result = PaddingModePtr(std::in_place);
        result->set_edge(std::move(value));
        return result;
    }
    // Construct an instance holding |reflection|.
    static PaddingModePtr NewReflection(ReflectionPaddingPtr value)
    {
        auto result = PaddingModePtr(std::in_place);
        result->set_reflection(std::move(value));
        return result;
    }
    // Construct an instance holding |symmetric|.
    static PaddingModePtr NewSymmetric(SymmetricPaddingPtr value)
    {
        auto result = PaddingModePtr(std::in_place);
        result->set_symmetric(std::move(value));
        return result;
    }

    template <typename U> static PaddingModePtr From(const U& u)
    {
        return mojo::TypeConverter<PaddingModePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, PaddingMode>::Convert(*this);
    }

    PaddingMode();
    ~PaddingMode();
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    PaddingMode(const PaddingMode& other) = delete;
    PaddingMode& operator=(const PaddingMode& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = PaddingModePtr> PaddingModePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, PaddingMode>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, PaddingMode>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }
    size_t Hash(size_t seed) const;

    Tag which() const
    {
        return tag_;
    }

    bool is_constant() const
    {
        return tag_ == Tag::kConstant;
    }

    ConstantPaddingPtr& get_constant() const
    {
        CHECK(tag_ == Tag::kConstant);
        return *(data_.constant);
    }

    void set_constant(ConstantPaddingPtr constant);

    bool is_edge() const
    {
        return tag_ == Tag::kEdge;
    }

    EdgePaddingPtr& get_edge() const
    {
        CHECK(tag_ == Tag::kEdge);
        return *(data_.edge);
    }

    void set_edge(EdgePaddingPtr edge);

    bool is_reflection() const
    {
        return tag_ == Tag::kReflection;
    }

    ReflectionPaddingPtr& get_reflection() const
    {
        CHECK(tag_ == Tag::kReflection);
        return *(data_.reflection);
    }

    void set_reflection(ReflectionPaddingPtr reflection);

    bool is_symmetric() const
    {
        return tag_ == Tag::kSymmetric;
    }

    SymmetricPaddingPtr& get_symmetric() const
    {
        CHECK(tag_ == Tag::kSymmetric);
        return *(data_.symmetric);
    }

    void set_symmetric(SymmetricPaddingPtr symmetric);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<PaddingMode::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<PaddingMode::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        ConstantPaddingPtr* constant;
        EdgePaddingPtr* edge;
        ReflectionPaddingPtr* reflection;
        SymmetricPaddingPtr* symmetric;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Operation {
public:
    using DataView = OperationDataView;
    using Data_ = internal::Operation_Data;
    using Tag = Data_::Operation_Tag;

    template <typename... Args> static OperationPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |arg_min_max|.
    static OperationPtr NewArgMinMax(ArgMinMaxPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_arg_min_max(std::move(value));
        return result;
    }
    // Construct an instance holding |batch_normalization|.
    static OperationPtr NewBatchNormalization(BatchNormalizationPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_batch_normalization(std::move(value));
        return result;
    }
    // Construct an instance holding |clamp|.
    static OperationPtr NewClamp(ClampPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_clamp(std::move(value));
        return result;
    }
    // Construct an instance holding |concat|.
    static OperationPtr NewConcat(ConcatPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_concat(std::move(value));
        return result;
    }
    // Construct an instance holding |conv2d|.
    static OperationPtr NewConv2d(Conv2dPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_conv2d(std::move(value));
        return result;
    }
    // Construct an instance holding |cumulative_sum|.
    static OperationPtr NewCumulativeSum(CumulativeSumPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_cumulative_sum(std::move(value));
        return result;
    }
    // Construct an instance holding |dequantize_linear|.
    static OperationPtr NewDequantizeLinear(DequantizeLinearPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_dequantize_linear(std::move(value));
        return result;
    }
    // Construct an instance holding |element_wise_binary|.
    static OperationPtr NewElementWiseBinary(ElementWiseBinaryPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_element_wise_binary(std::move(value));
        return result;
    }
    // Construct an instance holding |elu|.
    static OperationPtr NewElu(EluPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_elu(std::move(value));
        return result;
    }
    // Construct an instance holding |element_wise_unary|.
    static OperationPtr NewElementWiseUnary(ElementWiseUnaryPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_element_wise_unary(std::move(value));
        return result;
    }
    // Construct an instance holding |expand|.
    static OperationPtr NewExpand(ExpandPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_expand(std::move(value));
        return result;
    }
    // Construct an instance holding |gather|.
    static OperationPtr NewGather(GatherPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_gather(std::move(value));
        return result;
    }
    // Construct an instance holding |gather_elements|.
    static OperationPtr NewGatherElements(GatherElementsPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_gather_elements(std::move(value));
        return result;
    }
    // Construct an instance holding |gather_nd|.
    static OperationPtr NewGatherNd(GatherNDPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_gather_nd(std::move(value));
        return result;
    }
    // Construct an instance holding |gelu|.
    static OperationPtr NewGelu(GeluPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_gelu(std::move(value));
        return result;
    }
    // Construct an instance holding |gemm|.
    static OperationPtr NewGemm(GemmPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_gemm(std::move(value));
        return result;
    }
    // Construct an instance holding |gru|.
    static OperationPtr NewGru(GruPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_gru(std::move(value));
        return result;
    }
    // Construct an instance holding |gru_cell|.
    static OperationPtr NewGruCell(GruCellPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_gru_cell(std::move(value));
        return result;
    }
    // Construct an instance holding |hard_sigmoid|.
    static OperationPtr NewHardSigmoid(HardSigmoidPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_hard_sigmoid(std::move(value));
        return result;
    }
    // Construct an instance holding |hard_swish|.
    static OperationPtr NewHardSwish(HardSwishPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_hard_swish(std::move(value));
        return result;
    }
    // Construct an instance holding |layer_normalization|.
    static OperationPtr NewLayerNormalization(LayerNormalizationPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_layer_normalization(std::move(value));
        return result;
    }
    // Construct an instance holding |instance_normalization|.
    static OperationPtr NewInstanceNormalization(InstanceNormalizationPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_instance_normalization(std::move(value));
        return result;
    }
    // Construct an instance holding |leaky_relu|.
    static OperationPtr NewLeakyRelu(LeakyReluPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_leaky_relu(std::move(value));
        return result;
    }
    // Construct an instance holding |linear|.
    static OperationPtr NewLinear(LinearPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_linear(std::move(value));
        return result;
    }
    // Construct an instance holding |lstm|.
    static OperationPtr NewLstm(LstmPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_lstm(std::move(value));
        return result;
    }
    // Construct an instance holding |lstm_cell|.
    static OperationPtr NewLstmCell(LstmCellPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_lstm_cell(std::move(value));
        return result;
    }
    // Construct an instance holding |matmul|.
    static OperationPtr NewMatmul(MatmulPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_matmul(std::move(value));
        return result;
    }
    // Construct an instance holding |pad|.
    static OperationPtr NewPad(PadPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_pad(std::move(value));
        return result;
    }
    // Construct an instance holding |pool2d|.
    static OperationPtr NewPool2d(Pool2dPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_pool2d(std::move(value));
        return result;
    }
    // Construct an instance holding |prelu|.
    static OperationPtr NewPrelu(PreluPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_prelu(std::move(value));
        return result;
    }
    // Construct an instance holding |quantize_linear|.
    static OperationPtr NewQuantizeLinear(QuantizeLinearPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_quantize_linear(std::move(value));
        return result;
    }
    // Construct an instance holding |reduce|.
    static OperationPtr NewReduce(ReducePtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_reduce(std::move(value));
        return result;
    }
    // Construct an instance holding |relu|.
    static OperationPtr NewRelu(ReluPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_relu(std::move(value));
        return result;
    }
    // Construct an instance holding |resample2d|.
    static OperationPtr NewResample2d(Resample2dPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_resample2d(std::move(value));
        return result;
    }
    // Construct an instance holding |reshape|.
    static OperationPtr NewReshape(ReshapePtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_reshape(std::move(value));
        return result;
    }
    // Construct an instance holding |scatter_elements|.
    static OperationPtr NewScatterElements(ScatterElementsPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_scatter_elements(std::move(value));
        return result;
    }
    // Construct an instance holding |scatter_nd|.
    static OperationPtr NewScatterNd(ScatterNDPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_scatter_nd(std::move(value));
        return result;
    }
    // Construct an instance holding |sigmoid|.
    static OperationPtr NewSigmoid(SigmoidPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_sigmoid(std::move(value));
        return result;
    }
    // Construct an instance holding |slice|.
    static OperationPtr NewSlice(SlicePtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_slice(std::move(value));
        return result;
    }
    // Construct an instance holding |softmax|.
    static OperationPtr NewSoftmax(SoftmaxPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_softmax(std::move(value));
        return result;
    }
    // Construct an instance holding |softplus|.
    static OperationPtr NewSoftplus(SoftplusPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_softplus(std::move(value));
        return result;
    }
    // Construct an instance holding |softsign|.
    static OperationPtr NewSoftsign(SoftsignPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_softsign(std::move(value));
        return result;
    }
    // Construct an instance holding |split|.
    static OperationPtr NewSplit(SplitPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_split(std::move(value));
        return result;
    }
    // Construct an instance holding |tanh|.
    static OperationPtr NewTanh(TanhPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_tanh(std::move(value));
        return result;
    }
    // Construct an instance holding |tile|.
    static OperationPtr NewTile(TilePtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_tile(std::move(value));
        return result;
    }
    // Construct an instance holding |transpose|.
    static OperationPtr NewTranspose(TransposePtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_transpose(std::move(value));
        return result;
    }
    // Construct an instance holding |triangular|.
    static OperationPtr NewTriangular(TriangularPtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_triangular(std::move(value));
        return result;
    }
    // Construct an instance holding |where|.
    static OperationPtr NewWhere(WherePtr value)
    {
        auto result = OperationPtr(std::in_place);
        result->set_where(std::move(value));
        return result;
    }

    template <typename U> static OperationPtr From(const U& u)
    {
        return mojo::TypeConverter<OperationPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Operation>::Convert(*this);
    }

    Operation();
    ~Operation();
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    Operation(const Operation& other) = delete;
    Operation& operator=(const Operation& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = OperationPtr> OperationPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, Operation>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, Operation>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_arg_min_max() const
    {
        return tag_ == Tag::kArgMinMax;
    }

    ArgMinMaxPtr& get_arg_min_max() const
    {
        CHECK(tag_ == Tag::kArgMinMax);
        return *(data_.arg_min_max);
    }

    void set_arg_min_max(ArgMinMaxPtr arg_min_max);

    bool is_batch_normalization() const
    {
        return tag_ == Tag::kBatchNormalization;
    }

    BatchNormalizationPtr& get_batch_normalization() const
    {
        CHECK(tag_ == Tag::kBatchNormalization);
        return *(data_.batch_normalization);
    }

    void set_batch_normalization(BatchNormalizationPtr batch_normalization);

    bool is_clamp() const
    {
        return tag_ == Tag::kClamp;
    }

    ClampPtr& get_clamp() const
    {
        CHECK(tag_ == Tag::kClamp);
        return *(data_.clamp);
    }

    void set_clamp(ClampPtr clamp);

    bool is_concat() const
    {
        return tag_ == Tag::kConcat;
    }

    ConcatPtr& get_concat() const
    {
        CHECK(tag_ == Tag::kConcat);
        return *(data_.concat);
    }

    void set_concat(ConcatPtr concat);

    bool is_conv2d() const
    {
        return tag_ == Tag::kConv2d;
    }

    Conv2dPtr& get_conv2d() const
    {
        CHECK(tag_ == Tag::kConv2d);
        return *(data_.conv2d);
    }

    void set_conv2d(Conv2dPtr conv2d);

    bool is_cumulative_sum() const
    {
        return tag_ == Tag::kCumulativeSum;
    }

    CumulativeSumPtr& get_cumulative_sum() const
    {
        CHECK(tag_ == Tag::kCumulativeSum);
        return *(data_.cumulative_sum);
    }

    void set_cumulative_sum(CumulativeSumPtr cumulative_sum);

    bool is_dequantize_linear() const
    {
        return tag_ == Tag::kDequantizeLinear;
    }

    DequantizeLinearPtr& get_dequantize_linear() const
    {
        CHECK(tag_ == Tag::kDequantizeLinear);
        return *(data_.dequantize_linear);
    }

    void set_dequantize_linear(DequantizeLinearPtr dequantize_linear);

    bool is_element_wise_binary() const
    {
        return tag_ == Tag::kElementWiseBinary;
    }

    ElementWiseBinaryPtr& get_element_wise_binary() const
    {
        CHECK(tag_ == Tag::kElementWiseBinary);
        return *(data_.element_wise_binary);
    }

    void set_element_wise_binary(ElementWiseBinaryPtr element_wise_binary);

    bool is_elu() const
    {
        return tag_ == Tag::kElu;
    }

    EluPtr& get_elu() const
    {
        CHECK(tag_ == Tag::kElu);
        return *(data_.elu);
    }

    void set_elu(EluPtr elu);

    bool is_element_wise_unary() const
    {
        return tag_ == Tag::kElementWiseUnary;
    }

    ElementWiseUnaryPtr& get_element_wise_unary() const
    {
        CHECK(tag_ == Tag::kElementWiseUnary);
        return *(data_.element_wise_unary);
    }

    void set_element_wise_unary(ElementWiseUnaryPtr element_wise_unary);

    bool is_expand() const
    {
        return tag_ == Tag::kExpand;
    }

    ExpandPtr& get_expand() const
    {
        CHECK(tag_ == Tag::kExpand);
        return *(data_.expand);
    }

    void set_expand(ExpandPtr expand);

    bool is_gather() const
    {
        return tag_ == Tag::kGather;
    }

    GatherPtr& get_gather() const
    {
        CHECK(tag_ == Tag::kGather);
        return *(data_.gather);
    }

    void set_gather(GatherPtr gather);

    bool is_gather_elements() const
    {
        return tag_ == Tag::kGatherElements;
    }

    GatherElementsPtr& get_gather_elements() const
    {
        CHECK(tag_ == Tag::kGatherElements);
        return *(data_.gather_elements);
    }

    void set_gather_elements(GatherElementsPtr gather_elements);

    bool is_gather_nd() const
    {
        return tag_ == Tag::kGatherNd;
    }

    GatherNDPtr& get_gather_nd() const
    {
        CHECK(tag_ == Tag::kGatherNd);
        return *(data_.gather_nd);
    }

    void set_gather_nd(GatherNDPtr gather_nd);

    bool is_gelu() const
    {
        return tag_ == Tag::kGelu;
    }

    GeluPtr& get_gelu() const
    {
        CHECK(tag_ == Tag::kGelu);
        return *(data_.gelu);
    }

    void set_gelu(GeluPtr gelu);

    bool is_gemm() const
    {
        return tag_ == Tag::kGemm;
    }

    GemmPtr& get_gemm() const
    {
        CHECK(tag_ == Tag::kGemm);
        return *(data_.gemm);
    }

    void set_gemm(GemmPtr gemm);

    bool is_gru() const
    {
        return tag_ == Tag::kGru;
    }

    GruPtr& get_gru() const
    {
        CHECK(tag_ == Tag::kGru);
        return *(data_.gru);
    }

    void set_gru(GruPtr gru);

    bool is_gru_cell() const
    {
        return tag_ == Tag::kGruCell;
    }

    GruCellPtr& get_gru_cell() const
    {
        CHECK(tag_ == Tag::kGruCell);
        return *(data_.gru_cell);
    }

    void set_gru_cell(GruCellPtr gru_cell);

    bool is_hard_sigmoid() const
    {
        return tag_ == Tag::kHardSigmoid;
    }

    HardSigmoidPtr& get_hard_sigmoid() const
    {
        CHECK(tag_ == Tag::kHardSigmoid);
        return *(data_.hard_sigmoid);
    }

    void set_hard_sigmoid(HardSigmoidPtr hard_sigmoid);

    bool is_hard_swish() const
    {
        return tag_ == Tag::kHardSwish;
    }

    HardSwishPtr& get_hard_swish() const
    {
        CHECK(tag_ == Tag::kHardSwish);
        return *(data_.hard_swish);
    }

    void set_hard_swish(HardSwishPtr hard_swish);

    bool is_layer_normalization() const
    {
        return tag_ == Tag::kLayerNormalization;
    }

    LayerNormalizationPtr& get_layer_normalization() const
    {
        CHECK(tag_ == Tag::kLayerNormalization);
        return *(data_.layer_normalization);
    }

    void set_layer_normalization(LayerNormalizationPtr layer_normalization);

    bool is_instance_normalization() const
    {
        return tag_ == Tag::kInstanceNormalization;
    }

    InstanceNormalizationPtr& get_instance_normalization() const
    {
        CHECK(tag_ == Tag::kInstanceNormalization);
        return *(data_.instance_normalization);
    }

    void set_instance_normalization(InstanceNormalizationPtr instance_normalization);

    bool is_leaky_relu() const
    {
        return tag_ == Tag::kLeakyRelu;
    }

    LeakyReluPtr& get_leaky_relu() const
    {
        CHECK(tag_ == Tag::kLeakyRelu);
        return *(data_.leaky_relu);
    }

    void set_leaky_relu(LeakyReluPtr leaky_relu);

    bool is_linear() const
    {
        return tag_ == Tag::kLinear;
    }

    LinearPtr& get_linear() const
    {
        CHECK(tag_ == Tag::kLinear);
        return *(data_.linear);
    }

    void set_linear(LinearPtr linear);

    bool is_lstm() const
    {
        return tag_ == Tag::kLstm;
    }

    LstmPtr& get_lstm() const
    {
        CHECK(tag_ == Tag::kLstm);
        return *(data_.lstm);
    }

    void set_lstm(LstmPtr lstm);

    bool is_lstm_cell() const
    {
        return tag_ == Tag::kLstmCell;
    }

    LstmCellPtr& get_lstm_cell() const
    {
        CHECK(tag_ == Tag::kLstmCell);
        return *(data_.lstm_cell);
    }

    void set_lstm_cell(LstmCellPtr lstm_cell);

    bool is_matmul() const
    {
        return tag_ == Tag::kMatmul;
    }

    MatmulPtr& get_matmul() const
    {
        CHECK(tag_ == Tag::kMatmul);
        return *(data_.matmul);
    }

    void set_matmul(MatmulPtr matmul);

    bool is_pad() const
    {
        return tag_ == Tag::kPad;
    }

    PadPtr& get_pad() const
    {
        CHECK(tag_ == Tag::kPad);
        return *(data_.pad);
    }

    void set_pad(PadPtr pad);

    bool is_pool2d() const
    {
        return tag_ == Tag::kPool2d;
    }

    Pool2dPtr& get_pool2d() const
    {
        CHECK(tag_ == Tag::kPool2d);
        return *(data_.pool2d);
    }

    void set_pool2d(Pool2dPtr pool2d);

    bool is_prelu() const
    {
        return tag_ == Tag::kPrelu;
    }

    PreluPtr& get_prelu() const
    {
        CHECK(tag_ == Tag::kPrelu);
        return *(data_.prelu);
    }

    void set_prelu(PreluPtr prelu);

    bool is_quantize_linear() const
    {
        return tag_ == Tag::kQuantizeLinear;
    }

    QuantizeLinearPtr& get_quantize_linear() const
    {
        CHECK(tag_ == Tag::kQuantizeLinear);
        return *(data_.quantize_linear);
    }

    void set_quantize_linear(QuantizeLinearPtr quantize_linear);

    bool is_reduce() const
    {
        return tag_ == Tag::kReduce;
    }

    ReducePtr& get_reduce() const
    {
        CHECK(tag_ == Tag::kReduce);
        return *(data_.reduce);
    }

    void set_reduce(ReducePtr reduce);

    bool is_relu() const
    {
        return tag_ == Tag::kRelu;
    }

    ReluPtr& get_relu() const
    {
        CHECK(tag_ == Tag::kRelu);
        return *(data_.relu);
    }

    void set_relu(ReluPtr relu);

    bool is_resample2d() const
    {
        return tag_ == Tag::kResample2d;
    }

    Resample2dPtr& get_resample2d() const
    {
        CHECK(tag_ == Tag::kResample2d);
        return *(data_.resample2d);
    }

    void set_resample2d(Resample2dPtr resample2d);

    bool is_reshape() const
    {
        return tag_ == Tag::kReshape;
    }

    ReshapePtr& get_reshape() const
    {
        CHECK(tag_ == Tag::kReshape);
        return *(data_.reshape);
    }

    void set_reshape(ReshapePtr reshape);

    bool is_scatter_elements() const
    {
        return tag_ == Tag::kScatterElements;
    }

    ScatterElementsPtr& get_scatter_elements() const
    {
        CHECK(tag_ == Tag::kScatterElements);
        return *(data_.scatter_elements);
    }

    void set_scatter_elements(ScatterElementsPtr scatter_elements);

    bool is_scatter_nd() const
    {
        return tag_ == Tag::kScatterNd;
    }

    ScatterNDPtr& get_scatter_nd() const
    {
        CHECK(tag_ == Tag::kScatterNd);
        return *(data_.scatter_nd);
    }

    void set_scatter_nd(ScatterNDPtr scatter_nd);

    bool is_sigmoid() const
    {
        return tag_ == Tag::kSigmoid;
    }

    SigmoidPtr& get_sigmoid() const
    {
        CHECK(tag_ == Tag::kSigmoid);
        return *(data_.sigmoid);
    }

    void set_sigmoid(SigmoidPtr sigmoid);

    bool is_slice() const
    {
        return tag_ == Tag::kSlice;
    }

    SlicePtr& get_slice() const
    {
        CHECK(tag_ == Tag::kSlice);
        return *(data_.slice);
    }

    void set_slice(SlicePtr slice);

    bool is_softmax() const
    {
        return tag_ == Tag::kSoftmax;
    }

    SoftmaxPtr& get_softmax() const
    {
        CHECK(tag_ == Tag::kSoftmax);
        return *(data_.softmax);
    }

    void set_softmax(SoftmaxPtr softmax);

    bool is_softplus() const
    {
        return tag_ == Tag::kSoftplus;
    }

    SoftplusPtr& get_softplus() const
    {
        CHECK(tag_ == Tag::kSoftplus);
        return *(data_.softplus);
    }

    void set_softplus(SoftplusPtr softplus);

    bool is_softsign() const
    {
        return tag_ == Tag::kSoftsign;
    }

    SoftsignPtr& get_softsign() const
    {
        CHECK(tag_ == Tag::kSoftsign);
        return *(data_.softsign);
    }

    void set_softsign(SoftsignPtr softsign);

    bool is_split() const
    {
        return tag_ == Tag::kSplit;
    }

    SplitPtr& get_split() const
    {
        CHECK(tag_ == Tag::kSplit);
        return *(data_.split);
    }

    void set_split(SplitPtr split);

    bool is_tanh() const
    {
        return tag_ == Tag::kTanh;
    }

    TanhPtr& get_tanh() const
    {
        CHECK(tag_ == Tag::kTanh);
        return *(data_.tanh);
    }

    void set_tanh(TanhPtr tanh);

    bool is_tile() const
    {
        return tag_ == Tag::kTile;
    }

    TilePtr& get_tile() const
    {
        CHECK(tag_ == Tag::kTile);
        return *(data_.tile);
    }

    void set_tile(TilePtr tile);

    bool is_transpose() const
    {
        return tag_ == Tag::kTranspose;
    }

    TransposePtr& get_transpose() const
    {
        CHECK(tag_ == Tag::kTranspose);
        return *(data_.transpose);
    }

    void set_transpose(TransposePtr transpose);

    bool is_triangular() const
    {
        return tag_ == Tag::kTriangular;
    }

    TriangularPtr& get_triangular() const
    {
        CHECK(tag_ == Tag::kTriangular);
        return *(data_.triangular);
    }

    void set_triangular(TriangularPtr triangular);

    bool is_where() const
    {
        return tag_ == Tag::kWhere;
    }

    WherePtr& get_where() const
    {
        CHECK(tag_ == Tag::kWhere);
        return *(data_.where);
    }

    void set_where(WherePtr where);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Operation::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<Operation::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        ArgMinMaxPtr* arg_min_max;
        BatchNormalizationPtr* batch_normalization;
        ClampPtr* clamp;
        ConcatPtr* concat;
        Conv2dPtr* conv2d;
        CumulativeSumPtr* cumulative_sum;
        DequantizeLinearPtr* dequantize_linear;
        ElementWiseBinaryPtr* element_wise_binary;
        EluPtr* elu;
        ElementWiseUnaryPtr* element_wise_unary;
        ExpandPtr* expand;
        GatherPtr* gather;
        GatherElementsPtr* gather_elements;
        GatherNDPtr* gather_nd;
        GeluPtr* gelu;
        GemmPtr* gemm;
        GruPtr* gru;
        GruCellPtr* gru_cell;
        HardSigmoidPtr* hard_sigmoid;
        HardSwishPtr* hard_swish;
        LayerNormalizationPtr* layer_normalization;
        InstanceNormalizationPtr* instance_normalization;
        LeakyReluPtr* leaky_relu;
        LinearPtr* linear;
        LstmPtr* lstm;
        LstmCellPtr* lstm_cell;
        MatmulPtr* matmul;
        PadPtr* pad;
        Pool2dPtr* pool2d;
        PreluPtr* prelu;
        QuantizeLinearPtr* quantize_linear;
        ReducePtr* reduce;
        ReluPtr* relu;
        Resample2dPtr* resample2d;
        ReshapePtr* reshape;
        ScatterElementsPtr* scatter_elements;
        ScatterNDPtr* scatter_nd;
        SigmoidPtr* sigmoid;
        SlicePtr* slice;
        SoftmaxPtr* softmax;
        SoftplusPtr* softplus;
        SoftsignPtr* softsign;
        SplitPtr* split;
        TanhPtr* tanh;
        TilePtr* tile;
        TransposePtr* transpose;
        TriangularPtr* triangular;
        WherePtr* where;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) ComputeResult {
public:
    using DataView = ComputeResultDataView;
    using Data_ = internal::ComputeResult_Data;
    using Tag = Data_::ComputeResult_Tag;

    template <typename... Args> static ComputeResultPtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |named_outputs|.
    static ComputeResultPtr NewNamedOutputs(WTF::HashMap<WTF::String, ::mojo_base::BigBuffer> value)
    {
        auto result = ComputeResultPtr(std::in_place);
        result->set_named_outputs(std::move(value));
        return result;
    }
    // Construct an instance holding |error|.
    static ComputeResultPtr NewError(::webnn::mojom::blink::ErrorPtr value)
    {
        auto result = ComputeResultPtr(std::in_place);
        result->set_error(std::move(value));
        return result;
    }

    template <typename U> static ComputeResultPtr From(const U& u)
    {
        return mojo::TypeConverter<ComputeResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ComputeResult>::Convert(*this);
    }

    ComputeResult();
    ~ComputeResult();
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    ComputeResult(const ComputeResult& other) = delete;
    ComputeResult& operator=(const ComputeResult& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = ComputeResultPtr> ComputeResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, ComputeResult>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, ComputeResult>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_named_outputs() const
    {
        return tag_ == Tag::kNamedOutputs;
    }

    WTF::HashMap<WTF::String, ::mojo_base::BigBuffer>& get_named_outputs() const
    {
        CHECK(tag_ == Tag::kNamedOutputs);
        return *(data_.named_outputs);
    }

    void set_named_outputs(WTF::HashMap<WTF::String, ::mojo_base::BigBuffer> named_outputs);

    bool is_error() const
    {
        return tag_ == Tag::kError;
    }

    ::webnn::mojom::blink::ErrorPtr& get_error() const
    {
        CHECK(tag_ == Tag::kError);
        return *(data_.error);
    }

    void set_error(::webnn::mojom::blink::ErrorPtr error);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ComputeResult::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<ComputeResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        WTF::HashMap<WTF::String, ::mojo_base::BigBuffer>* named_outputs;
        ::webnn::mojom::blink::ErrorPtr* error;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) OperandDescriptor {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<OperandDescriptor, T>::value>;
    using DataView = OperandDescriptorDataView;
    using Data_ = internal::OperandDescriptor_Data;

    template <typename... Args> static OperandDescriptorPtr New(Args&&... args)
    {
        return OperandDescriptorPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static OperandDescriptorPtr From(const U& u)
    {
        return mojo::TypeConverter<OperandDescriptorPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, OperandDescriptor>::Convert(*this);
    }

    OperandDescriptor();

    OperandDescriptor(DataType data_type, WTF::Vector<uint32_t> shape);

    ~OperandDescriptor();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = OperandDescriptorPtr> OperandDescriptorPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, OperandDescriptor::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, OperandDescriptor::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, OperandDescriptor::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<OperandDescriptor::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<OperandDescriptor::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::OperandDescriptor_UnserializedMessageContext<UserType, OperandDescriptor::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<OperandDescriptor::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return OperandDescriptor::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::OperandDescriptor_UnserializedMessageContext<UserType, OperandDescriptor::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<OperandDescriptor::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    DataType data_type;

    WTF::Vector<uint32_t> shape;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, OperandDescriptor::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, OperandDescriptor::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, OperandDescriptor::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, OperandDescriptor::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Operand {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Operand, T>::value>;
    using DataView = OperandDataView;
    using Data_ = internal::Operand_Data;
    using Kind = Operand_Kind;

    template <typename... Args> static OperandPtr New(Args&&... args)
    {
        return OperandPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static OperandPtr From(const U& u)
    {
        return mojo::TypeConverter<OperandPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Operand>::Convert(*this);
    }

    Operand();

    Operand(Operand::Kind kind, const ::webnn::OperandDescriptor& descriptor, const WTF::String& name);

    ~Operand();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = OperandPtr> OperandPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Operand::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Operand::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Operand::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Operand::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Operand::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Operand_UnserializedMessageContext<UserType, Operand::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Operand::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Operand::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Operand_UnserializedMessageContext<UserType, Operand::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Operand::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    Operand::Kind kind;

    ::webnn::OperandDescriptor descriptor;

    WTF::String name;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Operand::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Operand::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Operand::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Operand::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) ArgMinMax {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ArgMinMax, T>::value>;
    using DataView = ArgMinMaxDataView;
    using Data_ = internal::ArgMinMax_Data;
    using Kind = ArgMinMax_Kind;

    template <typename... Args> static ArgMinMaxPtr New(Args&&... args)
    {
        return ArgMinMaxPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ArgMinMaxPtr From(const U& u)
    {
        return mojo::TypeConverter<ArgMinMaxPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ArgMinMax>::Convert(*this);
    }

    ArgMinMax();

    ArgMinMax(ArgMinMax::Kind kind, uint64_t input_operand_id, uint64_t output_operand_id, uint32_t axis, bool keep_dimensions, const WTF::String& label);

    ~ArgMinMax();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ArgMinMaxPtr> ArgMinMaxPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ArgMinMax::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ArgMinMax::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ArgMinMax::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ArgMinMax::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ArgMinMax::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::ArgMinMax_UnserializedMessageContext<UserType, ArgMinMax::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ArgMinMax::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ArgMinMax::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ArgMinMax_UnserializedMessageContext<UserType, ArgMinMax::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ArgMinMax::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ArgMinMax::Kind kind;

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    uint32_t axis;

    bool keep_dimensions;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ArgMinMax::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ArgMinMax::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ArgMinMax::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ArgMinMax::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) BatchNormalization {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<BatchNormalization, T>::value>;
    using DataView = BatchNormalizationDataView;
    using Data_ = internal::BatchNormalization_Data;

    template <typename... Args> static BatchNormalizationPtr New(Args&&... args)
    {
        return BatchNormalizationPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static BatchNormalizationPtr From(const U& u)
    {
        return mojo::TypeConverter<BatchNormalizationPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, BatchNormalization>::Convert(*this);
    }

    BatchNormalization();

    BatchNormalization(uint64_t input_operand_id, uint64_t mean_operand_id, uint64_t variance_operand_id, uint64_t output_operand_id,
        std::optional<uint64_t> scale_operand_id, std::optional<uint64_t> bias_operand_id, uint32_t axis, float epsilon, const WTF::String& label);

    ~BatchNormalization();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = BatchNormalizationPtr> BatchNormalizationPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, BatchNormalization::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, BatchNormalization::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, BatchNormalization::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<BatchNormalization::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<BatchNormalization::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::BatchNormalization_UnserializedMessageContext<UserType, BatchNormalization::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<BatchNormalization::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return BatchNormalization::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::BatchNormalization_UnserializedMessageContext<UserType, BatchNormalization::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<BatchNormalization::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t mean_operand_id;

    uint64_t variance_operand_id;

    uint64_t output_operand_id;

    std::optional<uint64_t> scale_operand_id;

    std::optional<uint64_t> bias_operand_id;

    uint32_t axis;

    float epsilon;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BatchNormalization::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, BatchNormalization::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, BatchNormalization::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, BatchNormalization::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Clamp {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Clamp, T>::value>;
    using DataView = ClampDataView;
    using Data_ = internal::Clamp_Data;

    template <typename... Args> static ClampPtr New(Args&&... args)
    {
        return ClampPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ClampPtr From(const U& u)
    {
        return mojo::TypeConverter<ClampPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Clamp>::Convert(*this);
    }

    Clamp();

    Clamp(uint64_t input_operand_id, uint64_t output_operand_id, float min_value, float max_value, const WTF::String& label);

    ~Clamp();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ClampPtr> ClampPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Clamp::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Clamp::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Clamp::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Clamp::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Clamp::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Clamp_UnserializedMessageContext<UserType, Clamp::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Clamp::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Clamp::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Clamp_UnserializedMessageContext<UserType, Clamp::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Clamp::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    float min_value;

    float max_value;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Clamp::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Clamp::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Clamp::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Clamp::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Concat {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Concat, T>::value>;
    using DataView = ConcatDataView;
    using Data_ = internal::Concat_Data;

    template <typename... Args> static ConcatPtr New(Args&&... args)
    {
        return ConcatPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ConcatPtr From(const U& u)
    {
        return mojo::TypeConverter<ConcatPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Concat>::Convert(*this);
    }

    Concat();

    Concat(WTF::Vector<uint64_t> input_operand_ids, uint64_t output_operand_id, uint32_t axis, const WTF::String& label);

    ~Concat();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ConcatPtr> ConcatPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Concat::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Concat::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Concat::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Concat::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Concat::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Concat_UnserializedMessageContext<UserType, Concat::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Concat::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Concat::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Concat_UnserializedMessageContext<UserType, Concat::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Concat::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::Vector<uint64_t> input_operand_ids;

    uint64_t output_operand_id;

    uint32_t axis;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Concat::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Concat::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Concat::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Concat::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Padding2d {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Padding2d, T>::value>;
    using DataView = Padding2dDataView;
    using Data_ = internal::Padding2d_Data;

    template <typename... Args> static Padding2dPtr New(Args&&... args)
    {
        return Padding2dPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static Padding2dPtr From(const U& u)
    {
        return mojo::TypeConverter<Padding2dPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Padding2d>::Convert(*this);
    }

    Padding2d();

    Padding2d(Size2dPtr beginning, Size2dPtr ending);

    Padding2d(const Padding2d&) = delete;
    Padding2d& operator=(const Padding2d&) = delete;

    ~Padding2d();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = Padding2dPtr> Padding2dPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Padding2d::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Padding2d::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Padding2d::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Padding2d::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Padding2d::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::Padding2d_UnserializedMessageContext<UserType, Padding2d::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Padding2d::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Padding2d::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Padding2d_UnserializedMessageContext<UserType, Padding2d::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Padding2d::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    Size2dPtr beginning;

    Size2dPtr ending;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Padding2d::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Padding2d::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Padding2d::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Padding2d::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Conv2d {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Conv2d, T>::value>;
    using DataView = Conv2dDataView;
    using Data_ = internal::Conv2d_Data;
    using Kind = Conv2d_Kind;

    template <typename... Args> static Conv2dPtr New(Args&&... args)
    {
        return Conv2dPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static Conv2dPtr From(const U& u)
    {
        return mojo::TypeConverter<Conv2dPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Conv2d>::Convert(*this);
    }

    Conv2d();

    Conv2d(Conv2d::Kind kind, uint64_t input_operand_id, uint64_t filter_operand_id, uint64_t output_operand_id, Padding2dPtr padding, Size2dPtr strides,
        Size2dPtr dilations, uint32_t groups, std::optional<uint64_t> bias_operand_id, const WTF::String& label);

    Conv2d(const Conv2d&) = delete;
    Conv2d& operator=(const Conv2d&) = delete;

    ~Conv2d();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = Conv2dPtr> Conv2dPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Conv2d::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Conv2d::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Conv2d::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Conv2d::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Conv2d::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Conv2d_UnserializedMessageContext<UserType, Conv2d::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Conv2d::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Conv2d::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Conv2d_UnserializedMessageContext<UserType, Conv2d::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Conv2d::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    Conv2d::Kind kind;

    uint64_t input_operand_id;

    uint64_t filter_operand_id;

    uint64_t output_operand_id;

    Padding2dPtr padding;

    Size2dPtr strides;

    Size2dPtr dilations;

    uint32_t groups;

    std::optional<uint64_t> bias_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Conv2d::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Conv2d::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Conv2d::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Conv2d::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) CumulativeSum {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CumulativeSum, T>::value>;
    using DataView = CumulativeSumDataView;
    using Data_ = internal::CumulativeSum_Data;

    template <typename... Args> static CumulativeSumPtr New(Args&&... args)
    {
        return CumulativeSumPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CumulativeSumPtr From(const U& u)
    {
        return mojo::TypeConverter<CumulativeSumPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CumulativeSum>::Convert(*this);
    }

    CumulativeSum();

    CumulativeSum(uint64_t input_operand_id, uint64_t output_operand_id, uint32_t axis, bool exclusive, bool reversed, const WTF::String& label);

    ~CumulativeSum();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CumulativeSumPtr> CumulativeSumPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CumulativeSum::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CumulativeSum::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CumulativeSum::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CumulativeSum::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CumulativeSum::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::CumulativeSum_UnserializedMessageContext<UserType, CumulativeSum::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CumulativeSum::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CumulativeSum::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CumulativeSum_UnserializedMessageContext<UserType, CumulativeSum::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CumulativeSum::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    uint32_t axis;

    bool exclusive;

    bool reversed;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CumulativeSum::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CumulativeSum::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CumulativeSum::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CumulativeSum::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) DequantizeLinear {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<DequantizeLinear, T>::value>;
    using DataView = DequantizeLinearDataView;
    using Data_ = internal::DequantizeLinear_Data;

    template <typename... Args> static DequantizeLinearPtr New(Args&&... args)
    {
        return DequantizeLinearPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static DequantizeLinearPtr From(const U& u)
    {
        return mojo::TypeConverter<DequantizeLinearPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, DequantizeLinear>::Convert(*this);
    }

    DequantizeLinear();

    DequantizeLinear(
        uint64_t input_operand_id, uint64_t scale_operand_id, uint64_t zero_point_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~DequantizeLinear();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = DequantizeLinearPtr> DequantizeLinearPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, DequantizeLinear::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, DequantizeLinear::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, DequantizeLinear::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<DequantizeLinear::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<DequantizeLinear::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::DequantizeLinear_UnserializedMessageContext<UserType, DequantizeLinear::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<DequantizeLinear::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return DequantizeLinear::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::DequantizeLinear_UnserializedMessageContext<UserType, DequantizeLinear::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<DequantizeLinear::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t scale_operand_id;

    uint64_t zero_point_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DequantizeLinear::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, DequantizeLinear::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, DequantizeLinear::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, DequantizeLinear::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) ElementWiseBinary {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ElementWiseBinary, T>::value>;
    using DataView = ElementWiseBinaryDataView;
    using Data_ = internal::ElementWiseBinary_Data;
    using Kind = ElementWiseBinary_Kind;

    template <typename... Args> static ElementWiseBinaryPtr New(Args&&... args)
    {
        return ElementWiseBinaryPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ElementWiseBinaryPtr From(const U& u)
    {
        return mojo::TypeConverter<ElementWiseBinaryPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ElementWiseBinary>::Convert(*this);
    }

    ElementWiseBinary();

    ElementWiseBinary(ElementWiseBinary::Kind kind, uint64_t lhs_operand_id, uint64_t rhs_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~ElementWiseBinary();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ElementWiseBinaryPtr> ElementWiseBinaryPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ElementWiseBinary::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ElementWiseBinary::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ElementWiseBinary::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ElementWiseBinary::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ElementWiseBinary::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ElementWiseBinary_UnserializedMessageContext<UserType, ElementWiseBinary::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ElementWiseBinary::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ElementWiseBinary::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ElementWiseBinary_UnserializedMessageContext<UserType, ElementWiseBinary::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ElementWiseBinary::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ElementWiseBinary::Kind kind;

    uint64_t lhs_operand_id;

    uint64_t rhs_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ElementWiseBinary::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ElementWiseBinary::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ElementWiseBinary::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ElementWiseBinary::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) InstanceNormalization {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<InstanceNormalization, T>::value>;
    using DataView = InstanceNormalizationDataView;
    using Data_ = internal::InstanceNormalization_Data;

    template <typename... Args> static InstanceNormalizationPtr New(Args&&... args)
    {
        return InstanceNormalizationPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static InstanceNormalizationPtr From(const U& u)
    {
        return mojo::TypeConverter<InstanceNormalizationPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, InstanceNormalization>::Convert(*this);
    }

    InstanceNormalization();

    InstanceNormalization(uint64_t input_operand_id, uint64_t output_operand_id, std::optional<uint64_t> scale_operand_id,
        std::optional<uint64_t> bias_operand_id, float epsilon, ::webnn::mojom::blink::InputOperandLayout layout, const WTF::String& label);

    ~InstanceNormalization();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = InstanceNormalizationPtr> InstanceNormalizationPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, InstanceNormalization::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, InstanceNormalization::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, InstanceNormalization::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<InstanceNormalization::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<InstanceNormalization::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::InstanceNormalization_UnserializedMessageContext<UserType, InstanceNormalization::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<InstanceNormalization::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return InstanceNormalization::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::InstanceNormalization_UnserializedMessageContext<UserType, InstanceNormalization::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<InstanceNormalization::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    std::optional<uint64_t> scale_operand_id;

    std::optional<uint64_t> bias_operand_id;

    float epsilon;

    ::webnn::mojom::blink::InputOperandLayout layout;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, InstanceNormalization::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, InstanceNormalization::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, InstanceNormalization::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, InstanceNormalization::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Pad {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Pad, T>::value>;
    using DataView = PadDataView;
    using Data_ = internal::Pad_Data;

    template <typename... Args> static PadPtr New(Args&&... args)
    {
        return PadPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static PadPtr From(const U& u)
    {
        return mojo::TypeConverter<PadPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Pad>::Convert(*this);
    }

    Pad();

    Pad(uint64_t input_operand_id, uint64_t output_operand_id, WTF::Vector<uint32_t> beginning_padding, WTF::Vector<uint32_t> ending_padding,
        PaddingModePtr mode, const WTF::String& label);

    Pad(const Pad&) = delete;
    Pad& operator=(const Pad&) = delete;

    ~Pad();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = PadPtr> PadPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Pad::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Pad::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Pad::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Pad::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Pad::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Pad_UnserializedMessageContext<UserType, Pad::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Pad::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Pad::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Pad_UnserializedMessageContext<UserType, Pad::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Pad::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::Vector<uint32_t> beginning_padding;

    WTF::Vector<uint32_t> ending_padding;

    PaddingModePtr mode;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Pad::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Pad::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Pad::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Pad::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Reduce {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Reduce, T>::value>;
    using DataView = ReduceDataView;
    using Data_ = internal::Reduce_Data;
    using Kind = Reduce_Kind;

    template <typename... Args> static ReducePtr New(Args&&... args)
    {
        return ReducePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ReducePtr From(const U& u)
    {
        return mojo::TypeConverter<ReducePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Reduce>::Convert(*this);
    }

    Reduce();

    Reduce(
        Reduce::Kind kind, uint64_t input_operand_id, uint64_t output_operand_id, WTF::Vector<uint32_t> axes, bool keep_dimensions, const WTF::String& label);

    ~Reduce();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ReducePtr> ReducePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Reduce::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Reduce::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Reduce::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Reduce::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Reduce::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Reduce_UnserializedMessageContext<UserType, Reduce::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Reduce::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Reduce::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Reduce_UnserializedMessageContext<UserType, Reduce::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Reduce::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    Reduce::Kind kind;

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::Vector<uint32_t> axes;

    bool keep_dimensions;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Reduce::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Reduce::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Reduce::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Reduce::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Pool2d {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Pool2d, T>::value>;
    using DataView = Pool2dDataView;
    using Data_ = internal::Pool2d_Data;
    using Kind = Pool2d_Kind;

    template <typename... Args> static Pool2dPtr New(Args&&... args)
    {
        return Pool2dPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static Pool2dPtr From(const U& u)
    {
        return mojo::TypeConverter<Pool2dPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Pool2d>::Convert(*this);
    }

    Pool2d();

    Pool2d(Pool2d::Kind kind, uint64_t input_operand_id, uint64_t output_operand_id, Size2dPtr window_dimensions, Padding2dPtr padding, Size2dPtr strides,
        Size2dPtr dilations, const WTF::String& label);

    Pool2d(const Pool2d&) = delete;
    Pool2d& operator=(const Pool2d&) = delete;

    ~Pool2d();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = Pool2dPtr> Pool2dPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Pool2d::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Pool2d::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Pool2d::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Pool2d::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Pool2d::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Pool2d_UnserializedMessageContext<UserType, Pool2d::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Pool2d::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Pool2d::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Pool2d_UnserializedMessageContext<UserType, Pool2d::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Pool2d::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    Pool2d::Kind kind;

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    Size2dPtr window_dimensions;

    Padding2dPtr padding;

    Size2dPtr strides;

    Size2dPtr dilations;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Pool2d::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Pool2d::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Pool2d::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Pool2d::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Slice {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Slice, T>::value>;
    using DataView = SliceDataView;
    using Data_ = internal::Slice_Data;

    template <typename... Args> static SlicePtr New(Args&&... args)
    {
        return SlicePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SlicePtr From(const U& u)
    {
        return mojo::TypeConverter<SlicePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Slice>::Convert(*this);
    }

    Slice();

    Slice(uint64_t input_operand_id, uint64_t output_operand_id, WTF::Vector<::webnn::Range> ranges, const WTF::String& label);

    ~Slice();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SlicePtr> SlicePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Slice::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Slice::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Slice::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Slice::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Slice::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Slice_UnserializedMessageContext<UserType, Slice::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Slice::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Slice::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Slice_UnserializedMessageContext<UserType, Slice::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Slice::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::Vector<::webnn::Range> ranges;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Slice::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Slice::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Slice::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Slice::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Gather {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Gather, T>::value>;
    using DataView = GatherDataView;
    using Data_ = internal::Gather_Data;

    template <typename... Args> static GatherPtr New(Args&&... args)
    {
        return GatherPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GatherPtr From(const U& u)
    {
        return mojo::TypeConverter<GatherPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Gather>::Convert(*this);
    }

    Gather();

    Gather(uint64_t input_operand_id, uint64_t indices_operand_id, uint64_t output_operand_id, uint32_t axis, const WTF::String& label);

    ~Gather();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GatherPtr> GatherPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Gather::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Gather::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Gather::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Gather::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Gather::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Gather_UnserializedMessageContext<UserType, Gather::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Gather::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Gather::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Gather_UnserializedMessageContext<UserType, Gather::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Gather::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t indices_operand_id;

    uint64_t output_operand_id;

    uint32_t axis;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Gather::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Gather::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Gather::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Gather::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) GatherElements {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GatherElements, T>::value>;
    using DataView = GatherElementsDataView;
    using Data_ = internal::GatherElements_Data;

    template <typename... Args> static GatherElementsPtr New(Args&&... args)
    {
        return GatherElementsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GatherElementsPtr From(const U& u)
    {
        return mojo::TypeConverter<GatherElementsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GatherElements>::Convert(*this);
    }

    GatherElements();

    GatherElements(uint64_t input_operand_id, uint64_t indices_operand_id, uint64_t output_operand_id, uint32_t axis, const WTF::String& label);

    ~GatherElements();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GatherElementsPtr> GatherElementsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GatherElements::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GatherElements::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GatherElements::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<GatherElements::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GatherElements::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::GatherElements_UnserializedMessageContext<UserType, GatherElements::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GatherElements::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GatherElements::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GatherElements_UnserializedMessageContext<UserType, GatherElements::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GatherElements::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t indices_operand_id;

    uint64_t output_operand_id;

    uint32_t axis;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GatherElements::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GatherElements::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GatherElements::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GatherElements::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Gru {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Gru, T>::value>;
    using DataView = GruDataView;
    using Data_ = internal::Gru_Data;

    template <typename... Args> static GruPtr New(Args&&... args)
    {
        return GruPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GruPtr From(const U& u)
    {
        return mojo::TypeConverter<GruPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Gru>::Convert(*this);
    }

    Gru();

    Gru(uint64_t input_operand_id, uint64_t weight_operand_id, uint64_t recurrent_weight_operand_id, uint32_t steps, uint32_t hidden_size,
        WTF::Vector<uint64_t> output_operand_ids, std::optional<uint64_t> bias_operand_id, std::optional<uint64_t> recurrent_bias_operand_id,
        std::optional<uint64_t> initial_hidden_state_operand_id, bool reset_after, bool return_sequence, RecurrentNetworkDirection direction,
        GruWeightLayout layout, WTF::Vector<RecurrentNetworkActivation> activations, const WTF::String& label);

    ~Gru();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GruPtr> GruPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Gru::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Gru::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Gru::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Gru::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Gru::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Gru_UnserializedMessageContext<UserType, Gru::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Gru::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Gru::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Gru_UnserializedMessageContext<UserType, Gru::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Gru::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t weight_operand_id;

    uint64_t recurrent_weight_operand_id;

    uint32_t steps;

    uint32_t hidden_size;

    WTF::Vector<uint64_t> output_operand_ids;

    std::optional<uint64_t> bias_operand_id;

    std::optional<uint64_t> recurrent_bias_operand_id;

    std::optional<uint64_t> initial_hidden_state_operand_id;

    bool reset_after;

    bool return_sequence;

    RecurrentNetworkDirection direction;

    GruWeightLayout layout;

    WTF::Vector<RecurrentNetworkActivation> activations;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Gru::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Gru::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Gru::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Gru::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) GruCell {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GruCell, T>::value>;
    using DataView = GruCellDataView;
    using Data_ = internal::GruCell_Data;

    template <typename... Args> static GruCellPtr New(Args&&... args)
    {
        return GruCellPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GruCellPtr From(const U& u)
    {
        return mojo::TypeConverter<GruCellPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GruCell>::Convert(*this);
    }

    GruCell();

    GruCell(uint64_t input_operand_id, uint64_t weight_operand_id, uint64_t recurrent_weight_operand_id, uint64_t hidden_state_operand_id, uint32_t hidden_size,
        uint64_t output_operand_id, std::optional<uint64_t> bias_operand_id, std::optional<uint64_t> recurrent_bias_operand_id, bool reset_after,
        GruWeightLayout layout, WTF::Vector<RecurrentNetworkActivation> activations, const WTF::String& label);

    ~GruCell();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GruCellPtr> GruCellPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GruCell::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GruCell::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GruCell::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<GruCell::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GruCell::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::GruCell_UnserializedMessageContext<UserType, GruCell::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GruCell::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GruCell::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GruCell_UnserializedMessageContext<UserType, GruCell::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GruCell::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t weight_operand_id;

    uint64_t recurrent_weight_operand_id;

    uint64_t hidden_state_operand_id;

    uint32_t hidden_size;

    uint64_t output_operand_id;

    std::optional<uint64_t> bias_operand_id;

    std::optional<uint64_t> recurrent_bias_operand_id;

    bool reset_after;

    GruWeightLayout layout;

    WTF::Vector<RecurrentNetworkActivation> activations;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GruCell::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GruCell::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GruCell::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GruCell::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Gemm {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Gemm, T>::value>;
    using DataView = GemmDataView;
    using Data_ = internal::Gemm_Data;

    template <typename... Args> static GemmPtr New(Args&&... args)
    {
        return GemmPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GemmPtr From(const U& u)
    {
        return mojo::TypeConverter<GemmPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Gemm>::Convert(*this);
    }

    Gemm();

    Gemm(uint64_t a_operand_id, uint64_t b_operand_id, uint64_t output_operand_id, std::optional<uint64_t> c_operand_id, float alpha, float beta,
        bool a_transpose, bool b_transpose, const WTF::String& label);

    ~Gemm();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GemmPtr> GemmPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Gemm::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Gemm::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Gemm::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Gemm::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Gemm::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Gemm_UnserializedMessageContext<UserType, Gemm::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Gemm::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Gemm::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Gemm_UnserializedMessageContext<UserType, Gemm::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Gemm::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t a_operand_id;

    uint64_t b_operand_id;

    uint64_t output_operand_id;

    std::optional<uint64_t> c_operand_id;

    float alpha;

    float beta;

    bool a_transpose;

    bool b_transpose;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Gemm::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Gemm::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Gemm::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Gemm::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) HardSigmoid {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<HardSigmoid, T>::value>;
    using DataView = HardSigmoidDataView;
    using Data_ = internal::HardSigmoid_Data;

    template <typename... Args> static HardSigmoidPtr New(Args&&... args)
    {
        return HardSigmoidPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static HardSigmoidPtr From(const U& u)
    {
        return mojo::TypeConverter<HardSigmoidPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, HardSigmoid>::Convert(*this);
    }

    HardSigmoid();

    HardSigmoid(uint64_t input_operand_id, uint64_t output_operand_id, float alpha, float beta, const WTF::String& label);

    ~HardSigmoid();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = HardSigmoidPtr> HardSigmoidPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, HardSigmoid::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, HardSigmoid::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, HardSigmoid::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<HardSigmoid::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<HardSigmoid::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::HardSigmoid_UnserializedMessageContext<UserType, HardSigmoid::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<HardSigmoid::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return HardSigmoid::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::HardSigmoid_UnserializedMessageContext<UserType, HardSigmoid::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<HardSigmoid::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    float alpha;

    float beta;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HardSigmoid::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, HardSigmoid::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, HardSigmoid::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, HardSigmoid::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) LayerNormalization {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<LayerNormalization, T>::value>;
    using DataView = LayerNormalizationDataView;
    using Data_ = internal::LayerNormalization_Data;

    template <typename... Args> static LayerNormalizationPtr New(Args&&... args)
    {
        return LayerNormalizationPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LayerNormalizationPtr From(const U& u)
    {
        return mojo::TypeConverter<LayerNormalizationPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, LayerNormalization>::Convert(*this);
    }

    LayerNormalization();

    LayerNormalization(uint64_t input_operand_id, uint64_t output_operand_id, std::optional<uint64_t> scale_operand_id, std::optional<uint64_t> bias_operand_id,
        WTF::Vector<uint32_t> axes, float epsilon, const WTF::String& label);

    ~LayerNormalization();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LayerNormalizationPtr> LayerNormalizationPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, LayerNormalization::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, LayerNormalization::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, LayerNormalization::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<LayerNormalization::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<LayerNormalization::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::LayerNormalization_UnserializedMessageContext<UserType, LayerNormalization::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<LayerNormalization::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return LayerNormalization::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::LayerNormalization_UnserializedMessageContext<UserType, LayerNormalization::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<LayerNormalization::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    std::optional<uint64_t> scale_operand_id;

    std::optional<uint64_t> bias_operand_id;

    WTF::Vector<uint32_t> axes;

    float epsilon;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LayerNormalization::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, LayerNormalization::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, LayerNormalization::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, LayerNormalization::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Linear {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Linear, T>::value>;
    using DataView = LinearDataView;
    using Data_ = internal::Linear_Data;

    template <typename... Args> static LinearPtr New(Args&&... args)
    {
        return LinearPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LinearPtr From(const U& u)
    {
        return mojo::TypeConverter<LinearPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Linear>::Convert(*this);
    }

    Linear();

    Linear(uint64_t input_operand_id, uint64_t output_operand_id, float alpha, float beta, const WTF::String& label);

    ~Linear();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LinearPtr> LinearPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Linear::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Linear::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Linear::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Linear::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Linear::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Linear_UnserializedMessageContext<UserType, Linear::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Linear::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Linear::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Linear_UnserializedMessageContext<UserType, Linear::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Linear::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    float alpha;

    float beta;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Linear::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Linear::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Linear::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Linear::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Lstm {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Lstm, T>::value>;
    using DataView = LstmDataView;
    using Data_ = internal::Lstm_Data;

    template <typename... Args> static LstmPtr New(Args&&... args)
    {
        return LstmPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LstmPtr From(const U& u)
    {
        return mojo::TypeConverter<LstmPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Lstm>::Convert(*this);
    }

    Lstm();

    Lstm(uint64_t input_operand_id, uint64_t weight_operand_id, uint64_t recurrent_weight_operand_id, WTF::Vector<uint64_t> output_operand_ids, uint32_t steps,
        uint32_t hidden_size, std::optional<uint64_t> bias_operand_id, std::optional<uint64_t> recurrent_bias_operand_id,
        std::optional<uint64_t> peephole_weight_operand_id, std::optional<uint64_t> initial_hidden_state_operand_id,
        std::optional<uint64_t> initial_cell_state_operand_id, bool return_sequence, RecurrentNetworkDirection direction, LstmWeightLayout layout,
        WTF::Vector<RecurrentNetworkActivation> activations, const WTF::String& label);

    ~Lstm();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LstmPtr> LstmPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Lstm::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Lstm::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Lstm::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Lstm::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Lstm::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Lstm_UnserializedMessageContext<UserType, Lstm::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Lstm::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Lstm::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Lstm_UnserializedMessageContext<UserType, Lstm::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Lstm::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t weight_operand_id;

    uint64_t recurrent_weight_operand_id;

    WTF::Vector<uint64_t> output_operand_ids;

    uint32_t steps;

    uint32_t hidden_size;

    std::optional<uint64_t> bias_operand_id;

    std::optional<uint64_t> recurrent_bias_operand_id;

    std::optional<uint64_t> peephole_weight_operand_id;

    std::optional<uint64_t> initial_hidden_state_operand_id;

    std::optional<uint64_t> initial_cell_state_operand_id;

    bool return_sequence;

    RecurrentNetworkDirection direction;

    LstmWeightLayout layout;

    WTF::Vector<RecurrentNetworkActivation> activations;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Lstm::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Lstm::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Lstm::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Lstm::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) LstmCell {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<LstmCell, T>::value>;
    using DataView = LstmCellDataView;
    using Data_ = internal::LstmCell_Data;

    template <typename... Args> static LstmCellPtr New(Args&&... args)
    {
        return LstmCellPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LstmCellPtr From(const U& u)
    {
        return mojo::TypeConverter<LstmCellPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, LstmCell>::Convert(*this);
    }

    LstmCell();

    LstmCell(uint64_t input_operand_id, uint64_t weight_operand_id, uint64_t recurrent_weight_operand_id, uint64_t hidden_state_operand_id,
        uint64_t cell_state_operand_id, WTF::Vector<uint64_t> output_operand_ids, uint32_t hidden_size, std::optional<uint64_t> bias_operand_id,
        std::optional<uint64_t> recurrent_bias_operand_id, std::optional<uint64_t> peephole_weight_operand_id, LstmWeightLayout layout,
        WTF::Vector<RecurrentNetworkActivation> activations, const WTF::String& label);

    ~LstmCell();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LstmCellPtr> LstmCellPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, LstmCell::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, LstmCell::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, LstmCell::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<LstmCell::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<LstmCell::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::LstmCell_UnserializedMessageContext<UserType, LstmCell::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<LstmCell::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return LstmCell::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::LstmCell_UnserializedMessageContext<UserType, LstmCell::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<LstmCell::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t weight_operand_id;

    uint64_t recurrent_weight_operand_id;

    uint64_t hidden_state_operand_id;

    uint64_t cell_state_operand_id;

    WTF::Vector<uint64_t> output_operand_ids;

    uint32_t hidden_size;

    std::optional<uint64_t> bias_operand_id;

    std::optional<uint64_t> recurrent_bias_operand_id;

    std::optional<uint64_t> peephole_weight_operand_id;

    LstmWeightLayout layout;

    WTF::Vector<RecurrentNetworkActivation> activations;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LstmCell::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, LstmCell::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, LstmCell::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, LstmCell::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) QuantizeLinear {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<QuantizeLinear, T>::value>;
    using DataView = QuantizeLinearDataView;
    using Data_ = internal::QuantizeLinear_Data;

    template <typename... Args> static QuantizeLinearPtr New(Args&&... args)
    {
        return QuantizeLinearPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static QuantizeLinearPtr From(const U& u)
    {
        return mojo::TypeConverter<QuantizeLinearPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, QuantizeLinear>::Convert(*this);
    }

    QuantizeLinear();

    QuantizeLinear(uint64_t input_operand_id, uint64_t scale_operand_id, uint64_t zero_point_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~QuantizeLinear();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = QuantizeLinearPtr> QuantizeLinearPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, QuantizeLinear::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, QuantizeLinear::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, QuantizeLinear::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<QuantizeLinear::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<QuantizeLinear::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::QuantizeLinear_UnserializedMessageContext<UserType, QuantizeLinear::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<QuantizeLinear::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return QuantizeLinear::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::QuantizeLinear_UnserializedMessageContext<UserType, QuantizeLinear::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<QuantizeLinear::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t scale_operand_id;

    uint64_t zero_point_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, QuantizeLinear::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, QuantizeLinear::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, QuantizeLinear::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, QuantizeLinear::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) ScatterElements {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ScatterElements, T>::value>;
    using DataView = ScatterElementsDataView;
    using Data_ = internal::ScatterElements_Data;

    template <typename... Args> static ScatterElementsPtr New(Args&&... args)
    {
        return ScatterElementsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ScatterElementsPtr From(const U& u)
    {
        return mojo::TypeConverter<ScatterElementsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ScatterElements>::Convert(*this);
    }

    ScatterElements();

    ScatterElements(uint64_t input_operand_id, uint64_t indices_operand_id, uint64_t updates_operand_id, uint64_t output_operand_id, uint32_t axis,
        const WTF::String& label);

    ~ScatterElements();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ScatterElementsPtr> ScatterElementsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ScatterElements::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ScatterElements::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ScatterElements::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ScatterElements::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ScatterElements::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::ScatterElements_UnserializedMessageContext<UserType, ScatterElements::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ScatterElements::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ScatterElements::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ScatterElements_UnserializedMessageContext<UserType, ScatterElements::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ScatterElements::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t indices_operand_id;

    uint64_t updates_operand_id;

    uint64_t output_operand_id;

    uint32_t axis;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ScatterElements::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ScatterElements::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ScatterElements::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ScatterElements::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) ScatterND {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<ScatterND, T>::value>;
    using DataView = ScatterNDDataView;
    using Data_ = internal::ScatterND_Data;

    template <typename... Args> static ScatterNDPtr New(Args&&... args)
    {
        return ScatterNDPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static ScatterNDPtr From(const U& u)
    {
        return mojo::TypeConverter<ScatterNDPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, ScatterND>::Convert(*this);
    }

    ScatterND();

    ScatterND(uint64_t input_operand_id, uint64_t indices_operand_id, uint64_t updates_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~ScatterND();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = ScatterNDPtr> ScatterNDPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, ScatterND::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, ScatterND::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, ScatterND::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<ScatterND::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<ScatterND::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::ScatterND_UnserializedMessageContext<UserType, ScatterND::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<ScatterND::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return ScatterND::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::ScatterND_UnserializedMessageContext<UserType, ScatterND::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<ScatterND::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t indices_operand_id;

    uint64_t updates_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ScatterND::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, ScatterND::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, ScatterND::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, ScatterND::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Split {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Split, T>::value>;
    using DataView = SplitDataView;
    using Data_ = internal::Split_Data;

    template <typename... Args> static SplitPtr New(Args&&... args)
    {
        return SplitPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SplitPtr From(const U& u)
    {
        return mojo::TypeConverter<SplitPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Split>::Convert(*this);
    }

    Split();

    Split(uint64_t input_operand_id, WTF::Vector<uint64_t> output_operand_ids, uint32_t axis, const WTF::String& label);

    ~Split();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SplitPtr> SplitPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Split::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Split::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Split::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Split::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Split::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Split_UnserializedMessageContext<UserType, Split::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Split::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Split::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Split_UnserializedMessageContext<UserType, Split::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Split::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    WTF::Vector<uint64_t> output_operand_ids;

    uint32_t axis;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Split::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Split::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Split::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Split::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Tile {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Tile, T>::value>;
    using DataView = TileDataView;
    using Data_ = internal::Tile_Data;

    template <typename... Args> static TilePtr New(Args&&... args)
    {
        return TilePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TilePtr From(const U& u)
    {
        return mojo::TypeConverter<TilePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Tile>::Convert(*this);
    }

    Tile();

    Tile(uint64_t input_operand_id, uint64_t output_operand_id, WTF::Vector<uint32_t> repetitions, const WTF::String& label);

    ~Tile();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TilePtr> TilePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Tile::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Tile::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Tile::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Tile::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Tile::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Tile_UnserializedMessageContext<UserType, Tile::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Tile::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Tile::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Tile_UnserializedMessageContext<UserType, Tile::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Tile::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::Vector<uint32_t> repetitions;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Tile::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Tile::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Tile::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Tile::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Transpose {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Transpose, T>::value>;
    using DataView = TransposeDataView;
    using Data_ = internal::Transpose_Data;

    template <typename... Args> static TransposePtr New(Args&&... args)
    {
        return TransposePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TransposePtr From(const U& u)
    {
        return mojo::TypeConverter<TransposePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Transpose>::Convert(*this);
    }

    Transpose();

    Transpose(uint64_t input_operand_id, uint64_t output_operand_id, WTF::Vector<uint32_t> permutation, const WTF::String& label);

    ~Transpose();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TransposePtr> TransposePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Transpose::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Transpose::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Transpose::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Transpose::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Transpose::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::Transpose_UnserializedMessageContext<UserType, Transpose::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Transpose::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Transpose::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Transpose_UnserializedMessageContext<UserType, Transpose::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Transpose::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    WTF::Vector<uint32_t> permutation;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Transpose::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Transpose::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Transpose::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Transpose::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Triangular {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Triangular, T>::value>;
    using DataView = TriangularDataView;
    using Data_ = internal::Triangular_Data;

    template <typename... Args> static TriangularPtr New(Args&&... args)
    {
        return TriangularPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static TriangularPtr From(const U& u)
    {
        return mojo::TypeConverter<TriangularPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Triangular>::Convert(*this);
    }

    Triangular();

    Triangular(uint64_t input_operand_id, uint64_t output_operand_id, bool upper, int32_t diagonal, const WTF::String& label);

    ~Triangular();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = TriangularPtr> TriangularPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Triangular::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Triangular::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Triangular::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Triangular::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Triangular::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::Triangular_UnserializedMessageContext<UserType, Triangular::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Triangular::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Triangular::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Triangular_UnserializedMessageContext<UserType, Triangular::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Triangular::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    bool upper;

    int32_t diagonal;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Triangular::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Triangular::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Triangular::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Triangular::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Resample2d {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Resample2d, T>::value>;
    using DataView = Resample2dDataView;
    using Data_ = internal::Resample2d_Data;
    using InterpolationMode = Resample2d_InterpolationMode;

    template <typename... Args> static Resample2dPtr New(Args&&... args)
    {
        return Resample2dPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static Resample2dPtr From(const U& u)
    {
        return mojo::TypeConverter<Resample2dPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Resample2d>::Convert(*this);
    }

    Resample2d();

    Resample2d(uint64_t input_operand_id, uint64_t output_operand_id, Resample2d::InterpolationMode mode, std::optional<WTF::Vector<float>> scales,
        WTF::Vector<uint32_t> axes, const WTF::String& label);

    ~Resample2d();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = Resample2dPtr> Resample2dPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Resample2d::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Resample2d::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Resample2d::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Resample2d::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Resample2d::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::Resample2d_UnserializedMessageContext<UserType, Resample2d::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Resample2d::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Resample2d::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Resample2d_UnserializedMessageContext<UserType, Resample2d::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Resample2d::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t input_operand_id;

    uint64_t output_operand_id;

    Resample2d::InterpolationMode mode;

    std::optional<WTF::Vector<float>> scales;

    WTF::Vector<uint32_t> axes;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Resample2d::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Resample2d::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Resample2d::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Resample2d::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) Where {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<Where, T>::value>;
    using DataView = WhereDataView;
    using Data_ = internal::Where_Data;

    template <typename... Args> static WherePtr New(Args&&... args)
    {
        return WherePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static WherePtr From(const U& u)
    {
        return mojo::TypeConverter<WherePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, Where>::Convert(*this);
    }

    Where();

    Where(uint64_t condition_operand_id, uint64_t true_value_operand_id, uint64_t false_value_operand_id, uint64_t output_operand_id, const WTF::String& label);

    ~Where();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = WherePtr> WherePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, Where::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, Where::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, Where::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<Where::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<Where::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::Where_UnserializedMessageContext<UserType, Where::DataView>>(0, 0, std::move(input)), MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<Where::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return Where::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::Where_UnserializedMessageContext<UserType, Where::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<Where::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint64_t condition_operand_id;

    uint64_t true_value_operand_id;

    uint64_t false_value_operand_id;

    uint64_t output_operand_id;

    WTF::String label;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Where::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, Where::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, Where::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, Where::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) GraphInfo {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<GraphInfo, T>::value>;
    using DataView = GraphInfoDataView;
    using Data_ = internal::GraphInfo_Data;

    template <typename... Args> static GraphInfoPtr New(Args&&... args)
    {
        return GraphInfoPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static GraphInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<GraphInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, GraphInfo>::Convert(*this);
    }

    GraphInfo();

    GraphInfo(WTF::HashMap<uint64_t, OperandPtr> id_to_operand_map, WTF::Vector<uint64_t> input_operands, WTF::Vector<uint64_t> output_operands,
        WTF::Vector<OperationPtr> operations, WTF::HashMap<uint64_t, ::mojo_base::BigBuffer> constant_id_to_buffer_map);

    GraphInfo(const GraphInfo&) = delete;
    GraphInfo& operator=(const GraphInfo&) = delete;

    ~GraphInfo();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = GraphInfoPtr> GraphInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, GraphInfo::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, GraphInfo::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, GraphInfo::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<GraphInfo::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::GraphInfo_UnserializedMessageContext<UserType, GraphInfo::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<GraphInfo::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return GraphInfo::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::GraphInfo_UnserializedMessageContext<UserType, GraphInfo::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<GraphInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::HashMap<uint64_t, OperandPtr> id_to_operand_map;

    WTF::Vector<uint64_t> input_operands;

    WTF::Vector<uint64_t> output_operands;

    WTF::Vector<OperationPtr> operations;

    WTF::HashMap<uint64_t, ::mojo_base::BigBuffer> constant_id_to_buffer_map;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GraphInfo::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, GraphInfo::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, GraphInfo::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, GraphInfo::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename UnionPtrType> PaddingModePtr PaddingMode::Clone() const
{
    switch (tag_) {
    case Tag::kConstant:
        return NewConstant(mojo::Clone(*data_.constant));
    case Tag::kEdge:
        return NewEdge(mojo::Clone(*data_.edge));
    case Tag::kReflection:
        return NewReflection(mojo::Clone(*data_.reflection));
    case Tag::kSymmetric:
        return NewSymmetric(mojo::Clone(*data_.symmetric));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, PaddingMode>::value>::type*> bool PaddingMode::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kConstant:
        return mojo::Equals(*(data_.constant), *(other.data_.constant));
    case Tag::kEdge:
        return mojo::Equals(*(data_.edge), *(other.data_.edge));
    case Tag::kReflection:
        return mojo::Equals(*(data_.reflection), *(other.data_.reflection));
    case Tag::kSymmetric:
        return mojo::Equals(*(data_.symmetric), *(other.data_.symmetric));
    }

    return false;
}
template <typename UnionPtrType> OperationPtr Operation::Clone() const
{
    switch (tag_) {
    case Tag::kArgMinMax:
        return NewArgMinMax(mojo::Clone(*data_.arg_min_max));
    case Tag::kBatchNormalization:
        return NewBatchNormalization(mojo::Clone(*data_.batch_normalization));
    case Tag::kClamp:
        return NewClamp(mojo::Clone(*data_.clamp));
    case Tag::kConcat:
        return NewConcat(mojo::Clone(*data_.concat));
    case Tag::kConv2d:
        return NewConv2d(mojo::Clone(*data_.conv2d));
    case Tag::kCumulativeSum:
        return NewCumulativeSum(mojo::Clone(*data_.cumulative_sum));
    case Tag::kDequantizeLinear:
        return NewDequantizeLinear(mojo::Clone(*data_.dequantize_linear));
    case Tag::kElementWiseBinary:
        return NewElementWiseBinary(mojo::Clone(*data_.element_wise_binary));
    case Tag::kElu:
        return NewElu(mojo::Clone(*data_.elu));
    case Tag::kElementWiseUnary:
        return NewElementWiseUnary(mojo::Clone(*data_.element_wise_unary));
    case Tag::kExpand:
        return NewExpand(mojo::Clone(*data_.expand));
    case Tag::kGather:
        return NewGather(mojo::Clone(*data_.gather));
    case Tag::kGatherElements:
        return NewGatherElements(mojo::Clone(*data_.gather_elements));
    case Tag::kGatherNd:
        return NewGatherNd(mojo::Clone(*data_.gather_nd));
    case Tag::kGelu:
        return NewGelu(mojo::Clone(*data_.gelu));
    case Tag::kGemm:
        return NewGemm(mojo::Clone(*data_.gemm));
    case Tag::kGru:
        return NewGru(mojo::Clone(*data_.gru));
    case Tag::kGruCell:
        return NewGruCell(mojo::Clone(*data_.gru_cell));
    case Tag::kHardSigmoid:
        return NewHardSigmoid(mojo::Clone(*data_.hard_sigmoid));
    case Tag::kHardSwish:
        return NewHardSwish(mojo::Clone(*data_.hard_swish));
    case Tag::kLayerNormalization:
        return NewLayerNormalization(mojo::Clone(*data_.layer_normalization));
    case Tag::kInstanceNormalization:
        return NewInstanceNormalization(mojo::Clone(*data_.instance_normalization));
    case Tag::kLeakyRelu:
        return NewLeakyRelu(mojo::Clone(*data_.leaky_relu));
    case Tag::kLinear:
        return NewLinear(mojo::Clone(*data_.linear));
    case Tag::kLstm:
        return NewLstm(mojo::Clone(*data_.lstm));
    case Tag::kLstmCell:
        return NewLstmCell(mojo::Clone(*data_.lstm_cell));
    case Tag::kMatmul:
        return NewMatmul(mojo::Clone(*data_.matmul));
    case Tag::kPad:
        return NewPad(mojo::Clone(*data_.pad));
    case Tag::kPool2d:
        return NewPool2d(mojo::Clone(*data_.pool2d));
    case Tag::kPrelu:
        return NewPrelu(mojo::Clone(*data_.prelu));
    case Tag::kQuantizeLinear:
        return NewQuantizeLinear(mojo::Clone(*data_.quantize_linear));
    case Tag::kReduce:
        return NewReduce(mojo::Clone(*data_.reduce));
    case Tag::kRelu:
        return NewRelu(mojo::Clone(*data_.relu));
    case Tag::kResample2d:
        return NewResample2d(mojo::Clone(*data_.resample2d));
    case Tag::kReshape:
        return NewReshape(mojo::Clone(*data_.reshape));
    case Tag::kScatterElements:
        return NewScatterElements(mojo::Clone(*data_.scatter_elements));
    case Tag::kScatterNd:
        return NewScatterNd(mojo::Clone(*data_.scatter_nd));
    case Tag::kSigmoid:
        return NewSigmoid(mojo::Clone(*data_.sigmoid));
    case Tag::kSlice:
        return NewSlice(mojo::Clone(*data_.slice));
    case Tag::kSoftmax:
        return NewSoftmax(mojo::Clone(*data_.softmax));
    case Tag::kSoftplus:
        return NewSoftplus(mojo::Clone(*data_.softplus));
    case Tag::kSoftsign:
        return NewSoftsign(mojo::Clone(*data_.softsign));
    case Tag::kSplit:
        return NewSplit(mojo::Clone(*data_.split));
    case Tag::kTanh:
        return NewTanh(mojo::Clone(*data_.tanh));
    case Tag::kTile:
        return NewTile(mojo::Clone(*data_.tile));
    case Tag::kTranspose:
        return NewTranspose(mojo::Clone(*data_.transpose));
    case Tag::kTriangular:
        return NewTriangular(mojo::Clone(*data_.triangular));
    case Tag::kWhere:
        return NewWhere(mojo::Clone(*data_.where));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, Operation>::value>::type*> bool Operation::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kArgMinMax:
        return mojo::Equals(*(data_.arg_min_max), *(other.data_.arg_min_max));
    case Tag::kBatchNormalization:
        return mojo::Equals(*(data_.batch_normalization), *(other.data_.batch_normalization));
    case Tag::kClamp:
        return mojo::Equals(*(data_.clamp), *(other.data_.clamp));
    case Tag::kConcat:
        return mojo::Equals(*(data_.concat), *(other.data_.concat));
    case Tag::kConv2d:
        return mojo::Equals(*(data_.conv2d), *(other.data_.conv2d));
    case Tag::kCumulativeSum:
        return mojo::Equals(*(data_.cumulative_sum), *(other.data_.cumulative_sum));
    case Tag::kDequantizeLinear:
        return mojo::Equals(*(data_.dequantize_linear), *(other.data_.dequantize_linear));
    case Tag::kElementWiseBinary:
        return mojo::Equals(*(data_.element_wise_binary), *(other.data_.element_wise_binary));
    case Tag::kElu:
        return mojo::Equals(*(data_.elu), *(other.data_.elu));
    case Tag::kElementWiseUnary:
        return mojo::Equals(*(data_.element_wise_unary), *(other.data_.element_wise_unary));
    case Tag::kExpand:
        return mojo::Equals(*(data_.expand), *(other.data_.expand));
    case Tag::kGather:
        return mojo::Equals(*(data_.gather), *(other.data_.gather));
    case Tag::kGatherElements:
        return mojo::Equals(*(data_.gather_elements), *(other.data_.gather_elements));
    case Tag::kGatherNd:
        return mojo::Equals(*(data_.gather_nd), *(other.data_.gather_nd));
    case Tag::kGelu:
        return mojo::Equals(*(data_.gelu), *(other.data_.gelu));
    case Tag::kGemm:
        return mojo::Equals(*(data_.gemm), *(other.data_.gemm));
    case Tag::kGru:
        return mojo::Equals(*(data_.gru), *(other.data_.gru));
    case Tag::kGruCell:
        return mojo::Equals(*(data_.gru_cell), *(other.data_.gru_cell));
    case Tag::kHardSigmoid:
        return mojo::Equals(*(data_.hard_sigmoid), *(other.data_.hard_sigmoid));
    case Tag::kHardSwish:
        return mojo::Equals(*(data_.hard_swish), *(other.data_.hard_swish));
    case Tag::kLayerNormalization:
        return mojo::Equals(*(data_.layer_normalization), *(other.data_.layer_normalization));
    case Tag::kInstanceNormalization:
        return mojo::Equals(*(data_.instance_normalization), *(other.data_.instance_normalization));
    case Tag::kLeakyRelu:
        return mojo::Equals(*(data_.leaky_relu), *(other.data_.leaky_relu));
    case Tag::kLinear:
        return mojo::Equals(*(data_.linear), *(other.data_.linear));
    case Tag::kLstm:
        return mojo::Equals(*(data_.lstm), *(other.data_.lstm));
    case Tag::kLstmCell:
        return mojo::Equals(*(data_.lstm_cell), *(other.data_.lstm_cell));
    case Tag::kMatmul:
        return mojo::Equals(*(data_.matmul), *(other.data_.matmul));
    case Tag::kPad:
        return mojo::Equals(*(data_.pad), *(other.data_.pad));
    case Tag::kPool2d:
        return mojo::Equals(*(data_.pool2d), *(other.data_.pool2d));
    case Tag::kPrelu:
        return mojo::Equals(*(data_.prelu), *(other.data_.prelu));
    case Tag::kQuantizeLinear:
        return mojo::Equals(*(data_.quantize_linear), *(other.data_.quantize_linear));
    case Tag::kReduce:
        return mojo::Equals(*(data_.reduce), *(other.data_.reduce));
    case Tag::kRelu:
        return mojo::Equals(*(data_.relu), *(other.data_.relu));
    case Tag::kResample2d:
        return mojo::Equals(*(data_.resample2d), *(other.data_.resample2d));
    case Tag::kReshape:
        return mojo::Equals(*(data_.reshape), *(other.data_.reshape));
    case Tag::kScatterElements:
        return mojo::Equals(*(data_.scatter_elements), *(other.data_.scatter_elements));
    case Tag::kScatterNd:
        return mojo::Equals(*(data_.scatter_nd), *(other.data_.scatter_nd));
    case Tag::kSigmoid:
        return mojo::Equals(*(data_.sigmoid), *(other.data_.sigmoid));
    case Tag::kSlice:
        return mojo::Equals(*(data_.slice), *(other.data_.slice));
    case Tag::kSoftmax:
        return mojo::Equals(*(data_.softmax), *(other.data_.softmax));
    case Tag::kSoftplus:
        return mojo::Equals(*(data_.softplus), *(other.data_.softplus));
    case Tag::kSoftsign:
        return mojo::Equals(*(data_.softsign), *(other.data_.softsign));
    case Tag::kSplit:
        return mojo::Equals(*(data_.split), *(other.data_.split));
    case Tag::kTanh:
        return mojo::Equals(*(data_.tanh), *(other.data_.tanh));
    case Tag::kTile:
        return mojo::Equals(*(data_.tile), *(other.data_.tile));
    case Tag::kTranspose:
        return mojo::Equals(*(data_.transpose), *(other.data_.transpose));
    case Tag::kTriangular:
        return mojo::Equals(*(data_.triangular), *(other.data_.triangular));
    case Tag::kWhere:
        return mojo::Equals(*(data_.where), *(other.data_.where));
    }

    return false;
}
template <typename UnionPtrType> ComputeResultPtr ComputeResult::Clone() const
{
    switch (tag_) {
    case Tag::kNamedOutputs:
        return NewNamedOutputs(mojo::Clone(*data_.named_outputs));
    case Tag::kError:
        return NewError(mojo::Clone(*data_.error));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, ComputeResult>::value>::type*> bool ComputeResult::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kNamedOutputs:
        return mojo::Equals(*(data_.named_outputs), *(other.data_.named_outputs));
    case Tag::kError:
        return mojo::Equals(*(data_.error), *(other.data_.error));
    }

    return false;
}
template <typename StructPtrType> OperandDescriptorPtr OperandDescriptor::Clone() const
{
    return New(mojo::Clone(data_type), mojo::Clone(shape));
}

template <typename T, OperandDescriptor::EnableIfSame<T>*> bool OperandDescriptor::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->data_type, other_struct.data_type))
        return false;
    if (!mojo::Equals(this->shape, other_struct.shape))
        return false;
    return true;
}

template <typename T, OperandDescriptor::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.data_type < rhs.data_type)
        return true;
    if (rhs.data_type < lhs.data_type)
        return false;
    if (lhs.shape < rhs.shape)
        return true;
    if (rhs.shape < lhs.shape)
        return false;
    return false;
}
template <typename StructPtrType> OperandPtr Operand::Clone() const
{
    return New(mojo::Clone(kind), mojo::Clone(descriptor), mojo::Clone(name));
}

template <typename T, Operand::EnableIfSame<T>*> bool Operand::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->kind, other_struct.kind))
        return false;
    if (!mojo::Equals(this->descriptor, other_struct.descriptor))
        return false;
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    return true;
}

template <typename T, Operand::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.kind < rhs.kind)
        return true;
    if (rhs.kind < lhs.kind)
        return false;
    if (lhs.descriptor < rhs.descriptor)
        return true;
    if (rhs.descriptor < lhs.descriptor)
        return false;
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    return false;
}
template <typename StructPtrType> ArgMinMaxPtr ArgMinMax::Clone() const
{
    return New(
        mojo::Clone(kind), mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(axis), mojo::Clone(keep_dimensions), mojo::Clone(label));
}

template <typename T, ArgMinMax::EnableIfSame<T>*> bool ArgMinMax::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->kind, other_struct.kind))
        return false;
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->keep_dimensions, other_struct.keep_dimensions))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, ArgMinMax::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.kind < rhs.kind)
        return true;
    if (rhs.kind < lhs.kind)
        return false;
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.keep_dimensions < rhs.keep_dimensions)
        return true;
    if (rhs.keep_dimensions < lhs.keep_dimensions)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> BatchNormalizationPtr BatchNormalization::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(mean_operand_id), mojo::Clone(variance_operand_id), mojo::Clone(output_operand_id),
        mojo::Clone(scale_operand_id), mojo::Clone(bias_operand_id), mojo::Clone(axis), mojo::Clone(epsilon), mojo::Clone(label));
}

template <typename T, BatchNormalization::EnableIfSame<T>*> bool BatchNormalization::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->mean_operand_id, other_struct.mean_operand_id))
        return false;
    if (!mojo::Equals(this->variance_operand_id, other_struct.variance_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->scale_operand_id, other_struct.scale_operand_id))
        return false;
    if (!mojo::Equals(this->bias_operand_id, other_struct.bias_operand_id))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->epsilon, other_struct.epsilon))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, BatchNormalization::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.mean_operand_id < rhs.mean_operand_id)
        return true;
    if (rhs.mean_operand_id < lhs.mean_operand_id)
        return false;
    if (lhs.variance_operand_id < rhs.variance_operand_id)
        return true;
    if (rhs.variance_operand_id < lhs.variance_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.scale_operand_id < rhs.scale_operand_id)
        return true;
    if (rhs.scale_operand_id < lhs.scale_operand_id)
        return false;
    if (lhs.bias_operand_id < rhs.bias_operand_id)
        return true;
    if (rhs.bias_operand_id < lhs.bias_operand_id)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.epsilon < rhs.epsilon)
        return true;
    if (rhs.epsilon < lhs.epsilon)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ClampPtr Clamp::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(min_value), mojo::Clone(max_value), mojo::Clone(label));
}

template <typename T, Clamp::EnableIfSame<T>*> bool Clamp::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->min_value, other_struct.min_value))
        return false;
    if (!mojo::Equals(this->max_value, other_struct.max_value))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Clamp::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.min_value < rhs.min_value)
        return true;
    if (rhs.min_value < lhs.min_value)
        return false;
    if (lhs.max_value < rhs.max_value)
        return true;
    if (rhs.max_value < lhs.max_value)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ConcatPtr Concat::Clone() const
{
    return New(mojo::Clone(input_operand_ids), mojo::Clone(output_operand_id), mojo::Clone(axis), mojo::Clone(label));
}

template <typename T, Concat::EnableIfSame<T>*> bool Concat::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_ids, other_struct.input_operand_ids))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Concat::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_ids < rhs.input_operand_ids)
        return true;
    if (rhs.input_operand_ids < lhs.input_operand_ids)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> Size2dPtr Size2d::Clone() const
{
    return New(mojo::Clone(height), mojo::Clone(width));
}

template <typename T, Size2d::EnableIfSame<T>*> bool Size2d::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->height, other_struct.height))
        return false;
    if (!mojo::Equals(this->width, other_struct.width))
        return false;
    return true;
}

template <typename T, Size2d::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.height < rhs.height)
        return true;
    if (rhs.height < lhs.height)
        return false;
    if (lhs.width < rhs.width)
        return true;
    if (rhs.width < lhs.width)
        return false;
    return false;
}
template <typename StructPtrType> Padding2dPtr Padding2d::Clone() const
{
    return New(mojo::Clone(beginning), mojo::Clone(ending));
}

template <typename T, Padding2d::EnableIfSame<T>*> bool Padding2d::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->beginning, other_struct.beginning))
        return false;
    if (!mojo::Equals(this->ending, other_struct.ending))
        return false;
    return true;
}

template <typename T, Padding2d::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.beginning < rhs.beginning)
        return true;
    if (rhs.beginning < lhs.beginning)
        return false;
    if (lhs.ending < rhs.ending)
        return true;
    if (rhs.ending < lhs.ending)
        return false;
    return false;
}
template <typename StructPtrType> Conv2dPtr Conv2d::Clone() const
{
    return New(mojo::Clone(kind), mojo::Clone(input_operand_id), mojo::Clone(filter_operand_id), mojo::Clone(output_operand_id), mojo::Clone(padding),
        mojo::Clone(strides), mojo::Clone(dilations), mojo::Clone(groups), mojo::Clone(bias_operand_id), mojo::Clone(label));
}

template <typename T, Conv2d::EnableIfSame<T>*> bool Conv2d::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->kind, other_struct.kind))
        return false;
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->filter_operand_id, other_struct.filter_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->padding, other_struct.padding))
        return false;
    if (!mojo::Equals(this->strides, other_struct.strides))
        return false;
    if (!mojo::Equals(this->dilations, other_struct.dilations))
        return false;
    if (!mojo::Equals(this->groups, other_struct.groups))
        return false;
    if (!mojo::Equals(this->bias_operand_id, other_struct.bias_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Conv2d::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.kind < rhs.kind)
        return true;
    if (rhs.kind < lhs.kind)
        return false;
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.filter_operand_id < rhs.filter_operand_id)
        return true;
    if (rhs.filter_operand_id < lhs.filter_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.padding < rhs.padding)
        return true;
    if (rhs.padding < lhs.padding)
        return false;
    if (lhs.strides < rhs.strides)
        return true;
    if (rhs.strides < lhs.strides)
        return false;
    if (lhs.dilations < rhs.dilations)
        return true;
    if (rhs.dilations < lhs.dilations)
        return false;
    if (lhs.groups < rhs.groups)
        return true;
    if (rhs.groups < lhs.groups)
        return false;
    if (lhs.bias_operand_id < rhs.bias_operand_id)
        return true;
    if (rhs.bias_operand_id < lhs.bias_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> CumulativeSumPtr CumulativeSum::Clone() const
{
    return New(
        mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(axis), mojo::Clone(exclusive), mojo::Clone(reversed), mojo::Clone(label));
}

template <typename T, CumulativeSum::EnableIfSame<T>*> bool CumulativeSum::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->exclusive, other_struct.exclusive))
        return false;
    if (!mojo::Equals(this->reversed, other_struct.reversed))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, CumulativeSum::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.exclusive < rhs.exclusive)
        return true;
    if (rhs.exclusive < lhs.exclusive)
        return false;
    if (lhs.reversed < rhs.reversed)
        return true;
    if (rhs.reversed < lhs.reversed)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> DequantizeLinearPtr DequantizeLinear::Clone() const
{
    return New(
        mojo::Clone(input_operand_id), mojo::Clone(scale_operand_id), mojo::Clone(zero_point_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, DequantizeLinear::EnableIfSame<T>*> bool DequantizeLinear::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->scale_operand_id, other_struct.scale_operand_id))
        return false;
    if (!mojo::Equals(this->zero_point_operand_id, other_struct.zero_point_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, DequantizeLinear::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.scale_operand_id < rhs.scale_operand_id)
        return true;
    if (rhs.scale_operand_id < lhs.scale_operand_id)
        return false;
    if (lhs.zero_point_operand_id < rhs.zero_point_operand_id)
        return true;
    if (rhs.zero_point_operand_id < lhs.zero_point_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ElementWiseBinaryPtr ElementWiseBinary::Clone() const
{
    return New(mojo::Clone(kind), mojo::Clone(lhs_operand_id), mojo::Clone(rhs_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, ElementWiseBinary::EnableIfSame<T>*> bool ElementWiseBinary::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->kind, other_struct.kind))
        return false;
    if (!mojo::Equals(this->lhs_operand_id, other_struct.lhs_operand_id))
        return false;
    if (!mojo::Equals(this->rhs_operand_id, other_struct.rhs_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, ElementWiseBinary::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.kind < rhs.kind)
        return true;
    if (rhs.kind < lhs.kind)
        return false;
    if (lhs.lhs_operand_id < rhs.lhs_operand_id)
        return true;
    if (rhs.lhs_operand_id < lhs.lhs_operand_id)
        return false;
    if (lhs.rhs_operand_id < rhs.rhs_operand_id)
        return true;
    if (rhs.rhs_operand_id < lhs.rhs_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ElementWiseUnaryPtr ElementWiseUnary::Clone() const
{
    return New(mojo::Clone(kind), mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, ElementWiseUnary::EnableIfSame<T>*> bool ElementWiseUnary::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->kind, other_struct.kind))
        return false;
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, ElementWiseUnary::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.kind < rhs.kind)
        return true;
    if (rhs.kind < lhs.kind)
        return false;
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ExpandPtr Expand::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Expand::EnableIfSame<T>*> bool Expand::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Expand::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ConstantPaddingPtr ConstantPadding::Clone() const
{
    return New(mojo::Clone(value));
}

template <typename T, ConstantPadding::EnableIfSame<T>*> bool ConstantPadding::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, ConstantPadding::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> EdgePaddingPtr EdgePadding::Clone() const
{
    return New();
}

template <typename T, EdgePadding::EnableIfSame<T>*> bool EdgePadding::Equals(const T& other_struct) const
{
    return true;
}

template <typename T, EdgePadding::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    return false;
}
template <typename StructPtrType> ReflectionPaddingPtr ReflectionPadding::Clone() const
{
    return New();
}

template <typename T, ReflectionPadding::EnableIfSame<T>*> bool ReflectionPadding::Equals(const T& other_struct) const
{
    return true;
}

template <typename T, ReflectionPadding::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    return false;
}
template <typename StructPtrType> SymmetricPaddingPtr SymmetricPadding::Clone() const
{
    return New();
}

template <typename T, SymmetricPadding::EnableIfSame<T>*> bool SymmetricPadding::Equals(const T& other_struct) const
{
    return true;
}

template <typename T, SymmetricPadding::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    return false;
}
template <typename StructPtrType> InstanceNormalizationPtr InstanceNormalization::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(scale_operand_id), mojo::Clone(bias_operand_id), mojo::Clone(epsilon),
        mojo::Clone(layout), mojo::Clone(label));
}

template <typename T, InstanceNormalization::EnableIfSame<T>*> bool InstanceNormalization::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->scale_operand_id, other_struct.scale_operand_id))
        return false;
    if (!mojo::Equals(this->bias_operand_id, other_struct.bias_operand_id))
        return false;
    if (!mojo::Equals(this->epsilon, other_struct.epsilon))
        return false;
    if (!mojo::Equals(this->layout, other_struct.layout))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, InstanceNormalization::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.scale_operand_id < rhs.scale_operand_id)
        return true;
    if (rhs.scale_operand_id < lhs.scale_operand_id)
        return false;
    if (lhs.bias_operand_id < rhs.bias_operand_id)
        return true;
    if (rhs.bias_operand_id < lhs.bias_operand_id)
        return false;
    if (lhs.epsilon < rhs.epsilon)
        return true;
    if (rhs.epsilon < lhs.epsilon)
        return false;
    if (lhs.layout < rhs.layout)
        return true;
    if (rhs.layout < lhs.layout)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> MatmulPtr Matmul::Clone() const
{
    return New(mojo::Clone(a_operand_id), mojo::Clone(b_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Matmul::EnableIfSame<T>*> bool Matmul::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->a_operand_id, other_struct.a_operand_id))
        return false;
    if (!mojo::Equals(this->b_operand_id, other_struct.b_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Matmul::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.a_operand_id < rhs.a_operand_id)
        return true;
    if (rhs.a_operand_id < lhs.a_operand_id)
        return false;
    if (lhs.b_operand_id < rhs.b_operand_id)
        return true;
    if (rhs.b_operand_id < lhs.b_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> PadPtr Pad::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(beginning_padding), mojo::Clone(ending_padding), mojo::Clone(mode),
        mojo::Clone(label));
}

template <typename T, Pad::EnableIfSame<T>*> bool Pad::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->beginning_padding, other_struct.beginning_padding))
        return false;
    if (!mojo::Equals(this->ending_padding, other_struct.ending_padding))
        return false;
    if (!mojo::Equals(this->mode, other_struct.mode))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Pad::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.beginning_padding < rhs.beginning_padding)
        return true;
    if (rhs.beginning_padding < lhs.beginning_padding)
        return false;
    if (lhs.ending_padding < rhs.ending_padding)
        return true;
    if (rhs.ending_padding < lhs.ending_padding)
        return false;
    if (lhs.mode < rhs.mode)
        return true;
    if (rhs.mode < lhs.mode)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ReducePtr Reduce::Clone() const
{
    return New(
        mojo::Clone(kind), mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(axes), mojo::Clone(keep_dimensions), mojo::Clone(label));
}

template <typename T, Reduce::EnableIfSame<T>*> bool Reduce::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->kind, other_struct.kind))
        return false;
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->axes, other_struct.axes))
        return false;
    if (!mojo::Equals(this->keep_dimensions, other_struct.keep_dimensions))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Reduce::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.kind < rhs.kind)
        return true;
    if (rhs.kind < lhs.kind)
        return false;
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.axes < rhs.axes)
        return true;
    if (rhs.axes < lhs.axes)
        return false;
    if (lhs.keep_dimensions < rhs.keep_dimensions)
        return true;
    if (rhs.keep_dimensions < lhs.keep_dimensions)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> Pool2dPtr Pool2d::Clone() const
{
    return New(mojo::Clone(kind), mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(window_dimensions), mojo::Clone(padding),
        mojo::Clone(strides), mojo::Clone(dilations), mojo::Clone(label));
}

template <typename T, Pool2d::EnableIfSame<T>*> bool Pool2d::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->kind, other_struct.kind))
        return false;
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->window_dimensions, other_struct.window_dimensions))
        return false;
    if (!mojo::Equals(this->padding, other_struct.padding))
        return false;
    if (!mojo::Equals(this->strides, other_struct.strides))
        return false;
    if (!mojo::Equals(this->dilations, other_struct.dilations))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Pool2d::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.kind < rhs.kind)
        return true;
    if (rhs.kind < lhs.kind)
        return false;
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.window_dimensions < rhs.window_dimensions)
        return true;
    if (rhs.window_dimensions < lhs.window_dimensions)
        return false;
    if (lhs.padding < rhs.padding)
        return true;
    if (rhs.padding < lhs.padding)
        return false;
    if (lhs.strides < rhs.strides)
        return true;
    if (rhs.strides < lhs.strides)
        return false;
    if (lhs.dilations < rhs.dilations)
        return true;
    if (rhs.dilations < lhs.dilations)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> RangePtr Range::Clone() const
{
    return New(mojo::Clone(start), mojo::Clone(size), mojo::Clone(stride));
}

template <typename T, Range::EnableIfSame<T>*> bool Range::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->start, other_struct.start))
        return false;
    if (!mojo::Equals(this->size, other_struct.size))
        return false;
    if (!mojo::Equals(this->stride, other_struct.stride))
        return false;
    return true;
}

template <typename T, Range::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.start < rhs.start)
        return true;
    if (rhs.start < lhs.start)
        return false;
    if (lhs.size < rhs.size)
        return true;
    if (rhs.size < lhs.size)
        return false;
    if (lhs.stride < rhs.stride)
        return true;
    if (rhs.stride < lhs.stride)
        return false;
    return false;
}
template <typename StructPtrType> SlicePtr Slice::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(ranges), mojo::Clone(label));
}

template <typename T, Slice::EnableIfSame<T>*> bool Slice::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->ranges, other_struct.ranges))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Slice::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.ranges < rhs.ranges)
        return true;
    if (rhs.ranges < lhs.ranges)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> EluPtr Elu::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(alpha), mojo::Clone(label));
}

template <typename T, Elu::EnableIfSame<T>*> bool Elu::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->alpha, other_struct.alpha))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Elu::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.alpha < rhs.alpha)
        return true;
    if (rhs.alpha < lhs.alpha)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> GatherPtr Gather::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(indices_operand_id), mojo::Clone(output_operand_id), mojo::Clone(axis), mojo::Clone(label));
}

template <typename T, Gather::EnableIfSame<T>*> bool Gather::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->indices_operand_id, other_struct.indices_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Gather::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.indices_operand_id < rhs.indices_operand_id)
        return true;
    if (rhs.indices_operand_id < lhs.indices_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> GatherElementsPtr GatherElements::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(indices_operand_id), mojo::Clone(output_operand_id), mojo::Clone(axis), mojo::Clone(label));
}

template <typename T, GatherElements::EnableIfSame<T>*> bool GatherElements::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->indices_operand_id, other_struct.indices_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, GatherElements::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.indices_operand_id < rhs.indices_operand_id)
        return true;
    if (rhs.indices_operand_id < lhs.indices_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> GatherNDPtr GatherND::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(indices_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, GatherND::EnableIfSame<T>*> bool GatherND::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->indices_operand_id, other_struct.indices_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, GatherND::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.indices_operand_id < rhs.indices_operand_id)
        return true;
    if (rhs.indices_operand_id < lhs.indices_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> GeluPtr Gelu::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Gelu::EnableIfSame<T>*> bool Gelu::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Gelu::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> GruPtr Gru::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(weight_operand_id), mojo::Clone(recurrent_weight_operand_id), mojo::Clone(steps),
        mojo::Clone(hidden_size), mojo::Clone(output_operand_ids), mojo::Clone(bias_operand_id), mojo::Clone(recurrent_bias_operand_id),
        mojo::Clone(initial_hidden_state_operand_id), mojo::Clone(reset_after), mojo::Clone(return_sequence), mojo::Clone(direction), mojo::Clone(layout),
        mojo::Clone(activations), mojo::Clone(label));
}

template <typename T, Gru::EnableIfSame<T>*> bool Gru::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->weight_operand_id, other_struct.weight_operand_id))
        return false;
    if (!mojo::Equals(this->recurrent_weight_operand_id, other_struct.recurrent_weight_operand_id))
        return false;
    if (!mojo::Equals(this->steps, other_struct.steps))
        return false;
    if (!mojo::Equals(this->hidden_size, other_struct.hidden_size))
        return false;
    if (!mojo::Equals(this->output_operand_ids, other_struct.output_operand_ids))
        return false;
    if (!mojo::Equals(this->bias_operand_id, other_struct.bias_operand_id))
        return false;
    if (!mojo::Equals(this->recurrent_bias_operand_id, other_struct.recurrent_bias_operand_id))
        return false;
    if (!mojo::Equals(this->initial_hidden_state_operand_id, other_struct.initial_hidden_state_operand_id))
        return false;
    if (!mojo::Equals(this->reset_after, other_struct.reset_after))
        return false;
    if (!mojo::Equals(this->return_sequence, other_struct.return_sequence))
        return false;
    if (!mojo::Equals(this->direction, other_struct.direction))
        return false;
    if (!mojo::Equals(this->layout, other_struct.layout))
        return false;
    if (!mojo::Equals(this->activations, other_struct.activations))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Gru::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.weight_operand_id < rhs.weight_operand_id)
        return true;
    if (rhs.weight_operand_id < lhs.weight_operand_id)
        return false;
    if (lhs.recurrent_weight_operand_id < rhs.recurrent_weight_operand_id)
        return true;
    if (rhs.recurrent_weight_operand_id < lhs.recurrent_weight_operand_id)
        return false;
    if (lhs.steps < rhs.steps)
        return true;
    if (rhs.steps < lhs.steps)
        return false;
    if (lhs.hidden_size < rhs.hidden_size)
        return true;
    if (rhs.hidden_size < lhs.hidden_size)
        return false;
    if (lhs.output_operand_ids < rhs.output_operand_ids)
        return true;
    if (rhs.output_operand_ids < lhs.output_operand_ids)
        return false;
    if (lhs.bias_operand_id < rhs.bias_operand_id)
        return true;
    if (rhs.bias_operand_id < lhs.bias_operand_id)
        return false;
    if (lhs.recurrent_bias_operand_id < rhs.recurrent_bias_operand_id)
        return true;
    if (rhs.recurrent_bias_operand_id < lhs.recurrent_bias_operand_id)
        return false;
    if (lhs.initial_hidden_state_operand_id < rhs.initial_hidden_state_operand_id)
        return true;
    if (rhs.initial_hidden_state_operand_id < lhs.initial_hidden_state_operand_id)
        return false;
    if (lhs.reset_after < rhs.reset_after)
        return true;
    if (rhs.reset_after < lhs.reset_after)
        return false;
    if (lhs.return_sequence < rhs.return_sequence)
        return true;
    if (rhs.return_sequence < lhs.return_sequence)
        return false;
    if (lhs.direction < rhs.direction)
        return true;
    if (rhs.direction < lhs.direction)
        return false;
    if (lhs.layout < rhs.layout)
        return true;
    if (rhs.layout < lhs.layout)
        return false;
    if (lhs.activations < rhs.activations)
        return true;
    if (rhs.activations < lhs.activations)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> GruCellPtr GruCell::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(weight_operand_id), mojo::Clone(recurrent_weight_operand_id), mojo::Clone(hidden_state_operand_id),
        mojo::Clone(hidden_size), mojo::Clone(output_operand_id), mojo::Clone(bias_operand_id), mojo::Clone(recurrent_bias_operand_id),
        mojo::Clone(reset_after), mojo::Clone(layout), mojo::Clone(activations), mojo::Clone(label));
}

template <typename T, GruCell::EnableIfSame<T>*> bool GruCell::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->weight_operand_id, other_struct.weight_operand_id))
        return false;
    if (!mojo::Equals(this->recurrent_weight_operand_id, other_struct.recurrent_weight_operand_id))
        return false;
    if (!mojo::Equals(this->hidden_state_operand_id, other_struct.hidden_state_operand_id))
        return false;
    if (!mojo::Equals(this->hidden_size, other_struct.hidden_size))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->bias_operand_id, other_struct.bias_operand_id))
        return false;
    if (!mojo::Equals(this->recurrent_bias_operand_id, other_struct.recurrent_bias_operand_id))
        return false;
    if (!mojo::Equals(this->reset_after, other_struct.reset_after))
        return false;
    if (!mojo::Equals(this->layout, other_struct.layout))
        return false;
    if (!mojo::Equals(this->activations, other_struct.activations))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, GruCell::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.weight_operand_id < rhs.weight_operand_id)
        return true;
    if (rhs.weight_operand_id < lhs.weight_operand_id)
        return false;
    if (lhs.recurrent_weight_operand_id < rhs.recurrent_weight_operand_id)
        return true;
    if (rhs.recurrent_weight_operand_id < lhs.recurrent_weight_operand_id)
        return false;
    if (lhs.hidden_state_operand_id < rhs.hidden_state_operand_id)
        return true;
    if (rhs.hidden_state_operand_id < lhs.hidden_state_operand_id)
        return false;
    if (lhs.hidden_size < rhs.hidden_size)
        return true;
    if (rhs.hidden_size < lhs.hidden_size)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.bias_operand_id < rhs.bias_operand_id)
        return true;
    if (rhs.bias_operand_id < lhs.bias_operand_id)
        return false;
    if (lhs.recurrent_bias_operand_id < rhs.recurrent_bias_operand_id)
        return true;
    if (rhs.recurrent_bias_operand_id < lhs.recurrent_bias_operand_id)
        return false;
    if (lhs.reset_after < rhs.reset_after)
        return true;
    if (rhs.reset_after < lhs.reset_after)
        return false;
    if (lhs.layout < rhs.layout)
        return true;
    if (rhs.layout < lhs.layout)
        return false;
    if (lhs.activations < rhs.activations)
        return true;
    if (rhs.activations < lhs.activations)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> GemmPtr Gemm::Clone() const
{
    return New(mojo::Clone(a_operand_id), mojo::Clone(b_operand_id), mojo::Clone(output_operand_id), mojo::Clone(c_operand_id), mojo::Clone(alpha),
        mojo::Clone(beta), mojo::Clone(a_transpose), mojo::Clone(b_transpose), mojo::Clone(label));
}

template <typename T, Gemm::EnableIfSame<T>*> bool Gemm::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->a_operand_id, other_struct.a_operand_id))
        return false;
    if (!mojo::Equals(this->b_operand_id, other_struct.b_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->c_operand_id, other_struct.c_operand_id))
        return false;
    if (!mojo::Equals(this->alpha, other_struct.alpha))
        return false;
    if (!mojo::Equals(this->beta, other_struct.beta))
        return false;
    if (!mojo::Equals(this->a_transpose, other_struct.a_transpose))
        return false;
    if (!mojo::Equals(this->b_transpose, other_struct.b_transpose))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Gemm::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.a_operand_id < rhs.a_operand_id)
        return true;
    if (rhs.a_operand_id < lhs.a_operand_id)
        return false;
    if (lhs.b_operand_id < rhs.b_operand_id)
        return true;
    if (rhs.b_operand_id < lhs.b_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.c_operand_id < rhs.c_operand_id)
        return true;
    if (rhs.c_operand_id < lhs.c_operand_id)
        return false;
    if (lhs.alpha < rhs.alpha)
        return true;
    if (rhs.alpha < lhs.alpha)
        return false;
    if (lhs.beta < rhs.beta)
        return true;
    if (rhs.beta < lhs.beta)
        return false;
    if (lhs.a_transpose < rhs.a_transpose)
        return true;
    if (rhs.a_transpose < lhs.a_transpose)
        return false;
    if (lhs.b_transpose < rhs.b_transpose)
        return true;
    if (rhs.b_transpose < lhs.b_transpose)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> HardSigmoidPtr HardSigmoid::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(alpha), mojo::Clone(beta), mojo::Clone(label));
}

template <typename T, HardSigmoid::EnableIfSame<T>*> bool HardSigmoid::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->alpha, other_struct.alpha))
        return false;
    if (!mojo::Equals(this->beta, other_struct.beta))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, HardSigmoid::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.alpha < rhs.alpha)
        return true;
    if (rhs.alpha < lhs.alpha)
        return false;
    if (lhs.beta < rhs.beta)
        return true;
    if (rhs.beta < lhs.beta)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> HardSwishPtr HardSwish::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, HardSwish::EnableIfSame<T>*> bool HardSwish::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, HardSwish::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> LayerNormalizationPtr LayerNormalization::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(scale_operand_id), mojo::Clone(bias_operand_id), mojo::Clone(axes),
        mojo::Clone(epsilon), mojo::Clone(label));
}

template <typename T, LayerNormalization::EnableIfSame<T>*> bool LayerNormalization::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->scale_operand_id, other_struct.scale_operand_id))
        return false;
    if (!mojo::Equals(this->bias_operand_id, other_struct.bias_operand_id))
        return false;
    if (!mojo::Equals(this->axes, other_struct.axes))
        return false;
    if (!mojo::Equals(this->epsilon, other_struct.epsilon))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, LayerNormalization::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.scale_operand_id < rhs.scale_operand_id)
        return true;
    if (rhs.scale_operand_id < lhs.scale_operand_id)
        return false;
    if (lhs.bias_operand_id < rhs.bias_operand_id)
        return true;
    if (rhs.bias_operand_id < lhs.bias_operand_id)
        return false;
    if (lhs.axes < rhs.axes)
        return true;
    if (rhs.axes < lhs.axes)
        return false;
    if (lhs.epsilon < rhs.epsilon)
        return true;
    if (rhs.epsilon < lhs.epsilon)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> LeakyReluPtr LeakyRelu::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(alpha), mojo::Clone(label));
}

template <typename T, LeakyRelu::EnableIfSame<T>*> bool LeakyRelu::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->alpha, other_struct.alpha))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, LeakyRelu::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.alpha < rhs.alpha)
        return true;
    if (rhs.alpha < lhs.alpha)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> LinearPtr Linear::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(alpha), mojo::Clone(beta), mojo::Clone(label));
}

template <typename T, Linear::EnableIfSame<T>*> bool Linear::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->alpha, other_struct.alpha))
        return false;
    if (!mojo::Equals(this->beta, other_struct.beta))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Linear::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.alpha < rhs.alpha)
        return true;
    if (rhs.alpha < lhs.alpha)
        return false;
    if (lhs.beta < rhs.beta)
        return true;
    if (rhs.beta < lhs.beta)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> LstmPtr Lstm::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(weight_operand_id), mojo::Clone(recurrent_weight_operand_id), mojo::Clone(output_operand_ids),
        mojo::Clone(steps), mojo::Clone(hidden_size), mojo::Clone(bias_operand_id), mojo::Clone(recurrent_bias_operand_id),
        mojo::Clone(peephole_weight_operand_id), mojo::Clone(initial_hidden_state_operand_id), mojo::Clone(initial_cell_state_operand_id),
        mojo::Clone(return_sequence), mojo::Clone(direction), mojo::Clone(layout), mojo::Clone(activations), mojo::Clone(label));
}

template <typename T, Lstm::EnableIfSame<T>*> bool Lstm::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->weight_operand_id, other_struct.weight_operand_id))
        return false;
    if (!mojo::Equals(this->recurrent_weight_operand_id, other_struct.recurrent_weight_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_ids, other_struct.output_operand_ids))
        return false;
    if (!mojo::Equals(this->steps, other_struct.steps))
        return false;
    if (!mojo::Equals(this->hidden_size, other_struct.hidden_size))
        return false;
    if (!mojo::Equals(this->bias_operand_id, other_struct.bias_operand_id))
        return false;
    if (!mojo::Equals(this->recurrent_bias_operand_id, other_struct.recurrent_bias_operand_id))
        return false;
    if (!mojo::Equals(this->peephole_weight_operand_id, other_struct.peephole_weight_operand_id))
        return false;
    if (!mojo::Equals(this->initial_hidden_state_operand_id, other_struct.initial_hidden_state_operand_id))
        return false;
    if (!mojo::Equals(this->initial_cell_state_operand_id, other_struct.initial_cell_state_operand_id))
        return false;
    if (!mojo::Equals(this->return_sequence, other_struct.return_sequence))
        return false;
    if (!mojo::Equals(this->direction, other_struct.direction))
        return false;
    if (!mojo::Equals(this->layout, other_struct.layout))
        return false;
    if (!mojo::Equals(this->activations, other_struct.activations))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Lstm::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.weight_operand_id < rhs.weight_operand_id)
        return true;
    if (rhs.weight_operand_id < lhs.weight_operand_id)
        return false;
    if (lhs.recurrent_weight_operand_id < rhs.recurrent_weight_operand_id)
        return true;
    if (rhs.recurrent_weight_operand_id < lhs.recurrent_weight_operand_id)
        return false;
    if (lhs.output_operand_ids < rhs.output_operand_ids)
        return true;
    if (rhs.output_operand_ids < lhs.output_operand_ids)
        return false;
    if (lhs.steps < rhs.steps)
        return true;
    if (rhs.steps < lhs.steps)
        return false;
    if (lhs.hidden_size < rhs.hidden_size)
        return true;
    if (rhs.hidden_size < lhs.hidden_size)
        return false;
    if (lhs.bias_operand_id < rhs.bias_operand_id)
        return true;
    if (rhs.bias_operand_id < lhs.bias_operand_id)
        return false;
    if (lhs.recurrent_bias_operand_id < rhs.recurrent_bias_operand_id)
        return true;
    if (rhs.recurrent_bias_operand_id < lhs.recurrent_bias_operand_id)
        return false;
    if (lhs.peephole_weight_operand_id < rhs.peephole_weight_operand_id)
        return true;
    if (rhs.peephole_weight_operand_id < lhs.peephole_weight_operand_id)
        return false;
    if (lhs.initial_hidden_state_operand_id < rhs.initial_hidden_state_operand_id)
        return true;
    if (rhs.initial_hidden_state_operand_id < lhs.initial_hidden_state_operand_id)
        return false;
    if (lhs.initial_cell_state_operand_id < rhs.initial_cell_state_operand_id)
        return true;
    if (rhs.initial_cell_state_operand_id < lhs.initial_cell_state_operand_id)
        return false;
    if (lhs.return_sequence < rhs.return_sequence)
        return true;
    if (rhs.return_sequence < lhs.return_sequence)
        return false;
    if (lhs.direction < rhs.direction)
        return true;
    if (rhs.direction < lhs.direction)
        return false;
    if (lhs.layout < rhs.layout)
        return true;
    if (rhs.layout < lhs.layout)
        return false;
    if (lhs.activations < rhs.activations)
        return true;
    if (rhs.activations < lhs.activations)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> LstmCellPtr LstmCell::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(weight_operand_id), mojo::Clone(recurrent_weight_operand_id), mojo::Clone(hidden_state_operand_id),
        mojo::Clone(cell_state_operand_id), mojo::Clone(output_operand_ids), mojo::Clone(hidden_size), mojo::Clone(bias_operand_id),
        mojo::Clone(recurrent_bias_operand_id), mojo::Clone(peephole_weight_operand_id), mojo::Clone(layout), mojo::Clone(activations), mojo::Clone(label));
}

template <typename T, LstmCell::EnableIfSame<T>*> bool LstmCell::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->weight_operand_id, other_struct.weight_operand_id))
        return false;
    if (!mojo::Equals(this->recurrent_weight_operand_id, other_struct.recurrent_weight_operand_id))
        return false;
    if (!mojo::Equals(this->hidden_state_operand_id, other_struct.hidden_state_operand_id))
        return false;
    if (!mojo::Equals(this->cell_state_operand_id, other_struct.cell_state_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_ids, other_struct.output_operand_ids))
        return false;
    if (!mojo::Equals(this->hidden_size, other_struct.hidden_size))
        return false;
    if (!mojo::Equals(this->bias_operand_id, other_struct.bias_operand_id))
        return false;
    if (!mojo::Equals(this->recurrent_bias_operand_id, other_struct.recurrent_bias_operand_id))
        return false;
    if (!mojo::Equals(this->peephole_weight_operand_id, other_struct.peephole_weight_operand_id))
        return false;
    if (!mojo::Equals(this->layout, other_struct.layout))
        return false;
    if (!mojo::Equals(this->activations, other_struct.activations))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, LstmCell::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.weight_operand_id < rhs.weight_operand_id)
        return true;
    if (rhs.weight_operand_id < lhs.weight_operand_id)
        return false;
    if (lhs.recurrent_weight_operand_id < rhs.recurrent_weight_operand_id)
        return true;
    if (rhs.recurrent_weight_operand_id < lhs.recurrent_weight_operand_id)
        return false;
    if (lhs.hidden_state_operand_id < rhs.hidden_state_operand_id)
        return true;
    if (rhs.hidden_state_operand_id < lhs.hidden_state_operand_id)
        return false;
    if (lhs.cell_state_operand_id < rhs.cell_state_operand_id)
        return true;
    if (rhs.cell_state_operand_id < lhs.cell_state_operand_id)
        return false;
    if (lhs.output_operand_ids < rhs.output_operand_ids)
        return true;
    if (rhs.output_operand_ids < lhs.output_operand_ids)
        return false;
    if (lhs.hidden_size < rhs.hidden_size)
        return true;
    if (rhs.hidden_size < lhs.hidden_size)
        return false;
    if (lhs.bias_operand_id < rhs.bias_operand_id)
        return true;
    if (rhs.bias_operand_id < lhs.bias_operand_id)
        return false;
    if (lhs.recurrent_bias_operand_id < rhs.recurrent_bias_operand_id)
        return true;
    if (rhs.recurrent_bias_operand_id < lhs.recurrent_bias_operand_id)
        return false;
    if (lhs.peephole_weight_operand_id < rhs.peephole_weight_operand_id)
        return true;
    if (rhs.peephole_weight_operand_id < lhs.peephole_weight_operand_id)
        return false;
    if (lhs.layout < rhs.layout)
        return true;
    if (rhs.layout < lhs.layout)
        return false;
    if (lhs.activations < rhs.activations)
        return true;
    if (rhs.activations < lhs.activations)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> PreluPtr Prelu::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(slope_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Prelu::EnableIfSame<T>*> bool Prelu::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->slope_operand_id, other_struct.slope_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Prelu::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.slope_operand_id < rhs.slope_operand_id)
        return true;
    if (rhs.slope_operand_id < lhs.slope_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> QuantizeLinearPtr QuantizeLinear::Clone() const
{
    return New(
        mojo::Clone(input_operand_id), mojo::Clone(scale_operand_id), mojo::Clone(zero_point_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, QuantizeLinear::EnableIfSame<T>*> bool QuantizeLinear::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->scale_operand_id, other_struct.scale_operand_id))
        return false;
    if (!mojo::Equals(this->zero_point_operand_id, other_struct.zero_point_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, QuantizeLinear::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.scale_operand_id < rhs.scale_operand_id)
        return true;
    if (rhs.scale_operand_id < lhs.scale_operand_id)
        return false;
    if (lhs.zero_point_operand_id < rhs.zero_point_operand_id)
        return true;
    if (rhs.zero_point_operand_id < lhs.zero_point_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ReluPtr Relu::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Relu::EnableIfSame<T>*> bool Relu::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Relu::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ReshapePtr Reshape::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Reshape::EnableIfSame<T>*> bool Reshape::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Reshape::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ScatterElementsPtr ScatterElements::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(indices_operand_id), mojo::Clone(updates_operand_id), mojo::Clone(output_operand_id),
        mojo::Clone(axis), mojo::Clone(label));
}

template <typename T, ScatterElements::EnableIfSame<T>*> bool ScatterElements::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->indices_operand_id, other_struct.indices_operand_id))
        return false;
    if (!mojo::Equals(this->updates_operand_id, other_struct.updates_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, ScatterElements::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.indices_operand_id < rhs.indices_operand_id)
        return true;
    if (rhs.indices_operand_id < lhs.indices_operand_id)
        return false;
    if (lhs.updates_operand_id < rhs.updates_operand_id)
        return true;
    if (rhs.updates_operand_id < lhs.updates_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> ScatterNDPtr ScatterND::Clone() const
{
    return New(
        mojo::Clone(input_operand_id), mojo::Clone(indices_operand_id), mojo::Clone(updates_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, ScatterND::EnableIfSame<T>*> bool ScatterND::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->indices_operand_id, other_struct.indices_operand_id))
        return false;
    if (!mojo::Equals(this->updates_operand_id, other_struct.updates_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, ScatterND::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.indices_operand_id < rhs.indices_operand_id)
        return true;
    if (rhs.indices_operand_id < lhs.indices_operand_id)
        return false;
    if (lhs.updates_operand_id < rhs.updates_operand_id)
        return true;
    if (rhs.updates_operand_id < lhs.updates_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> SigmoidPtr Sigmoid::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Sigmoid::EnableIfSame<T>*> bool Sigmoid::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Sigmoid::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> SoftmaxPtr Softmax::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(axis), mojo::Clone(label));
}

template <typename T, Softmax::EnableIfSame<T>*> bool Softmax::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Softmax::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> SoftplusPtr Softplus::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Softplus::EnableIfSame<T>*> bool Softplus::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Softplus::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> SoftsignPtr Softsign::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Softsign::EnableIfSame<T>*> bool Softsign::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Softsign::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> SplitPtr Split::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_ids), mojo::Clone(axis), mojo::Clone(label));
}

template <typename T, Split::EnableIfSame<T>*> bool Split::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_ids, other_struct.output_operand_ids))
        return false;
    if (!mojo::Equals(this->axis, other_struct.axis))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Split::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_ids < rhs.output_operand_ids)
        return true;
    if (rhs.output_operand_ids < lhs.output_operand_ids)
        return false;
    if (lhs.axis < rhs.axis)
        return true;
    if (rhs.axis < lhs.axis)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> TanhPtr Tanh::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(label));
}

template <typename T, Tanh::EnableIfSame<T>*> bool Tanh::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Tanh::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> TilePtr Tile::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(repetitions), mojo::Clone(label));
}

template <typename T, Tile::EnableIfSame<T>*> bool Tile::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->repetitions, other_struct.repetitions))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Tile::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.repetitions < rhs.repetitions)
        return true;
    if (rhs.repetitions < lhs.repetitions)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> TransposePtr Transpose::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(permutation), mojo::Clone(label));
}

template <typename T, Transpose::EnableIfSame<T>*> bool Transpose::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->permutation, other_struct.permutation))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Transpose::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.permutation < rhs.permutation)
        return true;
    if (rhs.permutation < lhs.permutation)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> TriangularPtr Triangular::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(upper), mojo::Clone(diagonal), mojo::Clone(label));
}

template <typename T, Triangular::EnableIfSame<T>*> bool Triangular::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->upper, other_struct.upper))
        return false;
    if (!mojo::Equals(this->diagonal, other_struct.diagonal))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Triangular::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.upper < rhs.upper)
        return true;
    if (rhs.upper < lhs.upper)
        return false;
    if (lhs.diagonal < rhs.diagonal)
        return true;
    if (rhs.diagonal < lhs.diagonal)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> Resample2dPtr Resample2d::Clone() const
{
    return New(mojo::Clone(input_operand_id), mojo::Clone(output_operand_id), mojo::Clone(mode), mojo::Clone(scales), mojo::Clone(axes), mojo::Clone(label));
}

template <typename T, Resample2d::EnableIfSame<T>*> bool Resample2d::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->input_operand_id, other_struct.input_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->mode, other_struct.mode))
        return false;
    if (!mojo::Equals(this->scales, other_struct.scales))
        return false;
    if (!mojo::Equals(this->axes, other_struct.axes))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Resample2d::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.input_operand_id < rhs.input_operand_id)
        return true;
    if (rhs.input_operand_id < lhs.input_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.mode < rhs.mode)
        return true;
    if (rhs.mode < lhs.mode)
        return false;
    if (lhs.scales < rhs.scales)
        return true;
    if (rhs.scales < lhs.scales)
        return false;
    if (lhs.axes < rhs.axes)
        return true;
    if (rhs.axes < lhs.axes)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> WherePtr Where::Clone() const
{
    return New(mojo::Clone(condition_operand_id), mojo::Clone(true_value_operand_id), mojo::Clone(false_value_operand_id), mojo::Clone(output_operand_id),
        mojo::Clone(label));
}

template <typename T, Where::EnableIfSame<T>*> bool Where::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->condition_operand_id, other_struct.condition_operand_id))
        return false;
    if (!mojo::Equals(this->true_value_operand_id, other_struct.true_value_operand_id))
        return false;
    if (!mojo::Equals(this->false_value_operand_id, other_struct.false_value_operand_id))
        return false;
    if (!mojo::Equals(this->output_operand_id, other_struct.output_operand_id))
        return false;
    if (!mojo::Equals(this->label, other_struct.label))
        return false;
    return true;
}

template <typename T, Where::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.condition_operand_id < rhs.condition_operand_id)
        return true;
    if (rhs.condition_operand_id < lhs.condition_operand_id)
        return false;
    if (lhs.true_value_operand_id < rhs.true_value_operand_id)
        return true;
    if (rhs.true_value_operand_id < lhs.true_value_operand_id)
        return false;
    if (lhs.false_value_operand_id < rhs.false_value_operand_id)
        return true;
    if (rhs.false_value_operand_id < lhs.false_value_operand_id)
        return false;
    if (lhs.output_operand_id < rhs.output_operand_id)
        return true;
    if (rhs.output_operand_id < lhs.output_operand_id)
        return false;
    if (lhs.label < rhs.label)
        return true;
    if (rhs.label < lhs.label)
        return false;
    return false;
}
template <typename StructPtrType> GraphInfoPtr GraphInfo::Clone() const
{
    return New(mojo::Clone(id_to_operand_map), mojo::Clone(input_operands), mojo::Clone(output_operands), mojo::Clone(operations),
        mojo::Clone(constant_id_to_buffer_map));
}

template <typename T, GraphInfo::EnableIfSame<T>*> bool GraphInfo::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->id_to_operand_map, other_struct.id_to_operand_map))
        return false;
    if (!mojo::Equals(this->input_operands, other_struct.input_operands))
        return false;
    if (!mojo::Equals(this->output_operands, other_struct.output_operands))
        return false;
    if (!mojo::Equals(this->operations, other_struct.operations))
        return false;
    if (!mojo::Equals(this->constant_id_to_buffer_map, other_struct.constant_id_to_buffer_map))
        return false;
    return true;
}

template <typename T, GraphInfo::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.id_to_operand_map < rhs.id_to_operand_map)
        return true;
    if (rhs.id_to_operand_map < lhs.id_to_operand_map)
        return false;
    if (lhs.input_operands < rhs.input_operands)
        return true;
    if (rhs.input_operands < lhs.input_operands)
        return false;
    if (lhs.output_operands < rhs.output_operands)
        return true;
    if (rhs.output_operands < lhs.output_operands)
        return false;
    if (lhs.operations < rhs.operations)
        return true;
    if (rhs.operations < lhs.operations)
        return false;
    if (lhs.constant_id_to_buffer_map < rhs.constant_id_to_buffer_map)
        return true;
    if (rhs.constant_id_to_buffer_map < lhs.constant_id_to_buffer_map)
        return false;
    return false;
}

} // webnn::mojom::blink

namespace mojo {

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::OperandDescriptor::DataView, ::webnn::mojom::blink::OperandDescriptorPtr> {
    static bool IsNull(const ::webnn::mojom::blink::OperandDescriptorPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::OperandDescriptorPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::OperandDescriptor::data_type) data_type(const ::webnn::mojom::blink::OperandDescriptorPtr& input)
    {
        return input->data_type;
    }

    static const decltype(::webnn::mojom::blink::OperandDescriptor::shape)& shape(const ::webnn::mojom::blink::OperandDescriptorPtr& input)
    {
        return input->shape;
    }

    static bool Read(::webnn::mojom::blink::OperandDescriptor::DataView input, ::webnn::mojom::blink::OperandDescriptorPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Operand::DataView, ::webnn::mojom::blink::OperandPtr> {
    static bool IsNull(const ::webnn::mojom::blink::OperandPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::OperandPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Operand::kind) kind(const ::webnn::mojom::blink::OperandPtr& input)
    {
        return input->kind;
    }

    static const decltype(::webnn::mojom::blink::Operand::descriptor)& descriptor(const ::webnn::mojom::blink::OperandPtr& input)
    {
        return input->descriptor;
    }

    static const decltype(::webnn::mojom::blink::Operand::name)& name(const ::webnn::mojom::blink::OperandPtr& input)
    {
        return input->name;
    }

    static bool Read(::webnn::mojom::blink::Operand::DataView input, ::webnn::mojom::blink::OperandPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::ArgMinMax::DataView, ::webnn::mojom::blink::ArgMinMaxPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ArgMinMaxPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ArgMinMaxPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::ArgMinMax::kind) kind(const ::webnn::mojom::blink::ArgMinMaxPtr& input)
    {
        return input->kind;
    }

    static decltype(::webnn::mojom::blink::ArgMinMax::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ArgMinMaxPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::ArgMinMax::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ArgMinMaxPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::ArgMinMax::axis) axis(const ::webnn::mojom::blink::ArgMinMaxPtr& input)
    {
        return input->axis;
    }

    static decltype(::webnn::mojom::blink::ArgMinMax::keep_dimensions) keep_dimensions(const ::webnn::mojom::blink::ArgMinMaxPtr& input)
    {
        return input->keep_dimensions;
    }

    static const decltype(::webnn::mojom::blink::ArgMinMax::label)& label(const ::webnn::mojom::blink::ArgMinMaxPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::ArgMinMax::DataView input, ::webnn::mojom::blink::ArgMinMaxPtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::BatchNormalization::DataView, ::webnn::mojom::blink::BatchNormalizationPtr> {
    static bool IsNull(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::BatchNormalizationPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::BatchNormalization::input_operand_id) input_operand_id(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::BatchNormalization::mean_operand_id) mean_operand_id(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->mean_operand_id;
    }

    static decltype(::webnn::mojom::blink::BatchNormalization::variance_operand_id) variance_operand_id(
        const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->variance_operand_id;
    }

    static decltype(::webnn::mojom::blink::BatchNormalization::output_operand_id) output_operand_id(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::BatchNormalization::scale_operand_id) scale_operand_id(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->scale_operand_id;
    }

    static decltype(::webnn::mojom::blink::BatchNormalization::bias_operand_id) bias_operand_id(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::BatchNormalization::axis) axis(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->axis;
    }

    static decltype(::webnn::mojom::blink::BatchNormalization::epsilon) epsilon(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->epsilon;
    }

    static const decltype(::webnn::mojom::blink::BatchNormalization::label)& label(const ::webnn::mojom::blink::BatchNormalizationPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::BatchNormalization::DataView input, ::webnn::mojom::blink::BatchNormalizationPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Clamp::DataView, ::webnn::mojom::blink::ClampPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ClampPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ClampPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Clamp::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ClampPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Clamp::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ClampPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Clamp::min_value) min_value(const ::webnn::mojom::blink::ClampPtr& input)
    {
        return input->min_value;
    }

    static decltype(::webnn::mojom::blink::Clamp::max_value) max_value(const ::webnn::mojom::blink::ClampPtr& input)
    {
        return input->max_value;
    }

    static const decltype(::webnn::mojom::blink::Clamp::label)& label(const ::webnn::mojom::blink::ClampPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Clamp::DataView input, ::webnn::mojom::blink::ClampPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Concat::DataView, ::webnn::mojom::blink::ConcatPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ConcatPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ConcatPtr* output)
    {
        output->reset();
    }

    static const decltype(::webnn::mojom::blink::Concat::input_operand_ids)& input_operand_ids(const ::webnn::mojom::blink::ConcatPtr& input)
    {
        return input->input_operand_ids;
    }

    static decltype(::webnn::mojom::blink::Concat::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ConcatPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Concat::axis) axis(const ::webnn::mojom::blink::ConcatPtr& input)
    {
        return input->axis;
    }

    static const decltype(::webnn::mojom::blink::Concat::label)& label(const ::webnn::mojom::blink::ConcatPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Concat::DataView input, ::webnn::mojom::blink::ConcatPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Size2d::DataView, ::webnn::mojom::blink::Size2dPtr> {
    static bool IsNull(const ::webnn::mojom::blink::Size2dPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::Size2dPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Size2d::height) height(const ::webnn::mojom::blink::Size2dPtr& input)
    {
        return input->height;
    }

    static decltype(::webnn::mojom::blink::Size2d::width) width(const ::webnn::mojom::blink::Size2dPtr& input)
    {
        return input->width;
    }

    static bool Read(::webnn::mojom::blink::Size2d::DataView input, ::webnn::mojom::blink::Size2dPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Padding2d::DataView, ::webnn::mojom::blink::Padding2dPtr> {
    static bool IsNull(const ::webnn::mojom::blink::Padding2dPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::Padding2dPtr* output)
    {
        output->reset();
    }

    static const decltype(::webnn::mojom::blink::Padding2d::beginning)& beginning(const ::webnn::mojom::blink::Padding2dPtr& input)
    {
        return input->beginning;
    }

    static const decltype(::webnn::mojom::blink::Padding2d::ending)& ending(const ::webnn::mojom::blink::Padding2dPtr& input)
    {
        return input->ending;
    }

    static bool Read(::webnn::mojom::blink::Padding2d::DataView input, ::webnn::mojom::blink::Padding2dPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Conv2d::DataView, ::webnn::mojom::blink::Conv2dPtr> {
    static bool IsNull(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::Conv2dPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Conv2d::kind) kind(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->kind;
    }

    static decltype(::webnn::mojom::blink::Conv2d::input_operand_id) input_operand_id(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Conv2d::filter_operand_id) filter_operand_id(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->filter_operand_id;
    }

    static decltype(::webnn::mojom::blink::Conv2d::output_operand_id) output_operand_id(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Conv2d::padding)& padding(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->padding;
    }

    static const decltype(::webnn::mojom::blink::Conv2d::strides)& strides(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->strides;
    }

    static const decltype(::webnn::mojom::blink::Conv2d::dilations)& dilations(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->dilations;
    }

    static decltype(::webnn::mojom::blink::Conv2d::groups) groups(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->groups;
    }

    static decltype(::webnn::mojom::blink::Conv2d::bias_operand_id) bias_operand_id(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->bias_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Conv2d::label)& label(const ::webnn::mojom::blink::Conv2dPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Conv2d::DataView input, ::webnn::mojom::blink::Conv2dPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::CumulativeSum::DataView, ::webnn::mojom::blink::CumulativeSumPtr> {
    static bool IsNull(const ::webnn::mojom::blink::CumulativeSumPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::CumulativeSumPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::CumulativeSum::input_operand_id) input_operand_id(const ::webnn::mojom::blink::CumulativeSumPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::CumulativeSum::output_operand_id) output_operand_id(const ::webnn::mojom::blink::CumulativeSumPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::CumulativeSum::axis) axis(const ::webnn::mojom::blink::CumulativeSumPtr& input)
    {
        return input->axis;
    }

    static decltype(::webnn::mojom::blink::CumulativeSum::exclusive) exclusive(const ::webnn::mojom::blink::CumulativeSumPtr& input)
    {
        return input->exclusive;
    }

    static decltype(::webnn::mojom::blink::CumulativeSum::reversed) reversed(const ::webnn::mojom::blink::CumulativeSumPtr& input)
    {
        return input->reversed;
    }

    static const decltype(::webnn::mojom::blink::CumulativeSum::label)& label(const ::webnn::mojom::blink::CumulativeSumPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::CumulativeSum::DataView input, ::webnn::mojom::blink::CumulativeSumPtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::DequantizeLinear::DataView, ::webnn::mojom::blink::DequantizeLinearPtr> {
    static bool IsNull(const ::webnn::mojom::blink::DequantizeLinearPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::DequantizeLinearPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::DequantizeLinear::input_operand_id) input_operand_id(const ::webnn::mojom::blink::DequantizeLinearPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::DequantizeLinear::scale_operand_id) scale_operand_id(const ::webnn::mojom::blink::DequantizeLinearPtr& input)
    {
        return input->scale_operand_id;
    }

    static decltype(::webnn::mojom::blink::DequantizeLinear::zero_point_operand_id) zero_point_operand_id(
        const ::webnn::mojom::blink::DequantizeLinearPtr& input)
    {
        return input->zero_point_operand_id;
    }

    static decltype(::webnn::mojom::blink::DequantizeLinear::output_operand_id) output_operand_id(const ::webnn::mojom::blink::DequantizeLinearPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::DequantizeLinear::label)& label(const ::webnn::mojom::blink::DequantizeLinearPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::DequantizeLinear::DataView input, ::webnn::mojom::blink::DequantizeLinearPtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::ElementWiseBinary::DataView, ::webnn::mojom::blink::ElementWiseBinaryPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ElementWiseBinaryPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ElementWiseBinaryPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::ElementWiseBinary::kind) kind(const ::webnn::mojom::blink::ElementWiseBinaryPtr& input)
    {
        return input->kind;
    }

    static decltype(::webnn::mojom::blink::ElementWiseBinary::lhs_operand_id) lhs_operand_id(const ::webnn::mojom::blink::ElementWiseBinaryPtr& input)
    {
        return input->lhs_operand_id;
    }

    static decltype(::webnn::mojom::blink::ElementWiseBinary::rhs_operand_id) rhs_operand_id(const ::webnn::mojom::blink::ElementWiseBinaryPtr& input)
    {
        return input->rhs_operand_id;
    }

    static decltype(::webnn::mojom::blink::ElementWiseBinary::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ElementWiseBinaryPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::ElementWiseBinary::label)& label(const ::webnn::mojom::blink::ElementWiseBinaryPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::ElementWiseBinary::DataView input, ::webnn::mojom::blink::ElementWiseBinaryPtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::ElementWiseUnary::DataView, ::webnn::mojom::blink::ElementWiseUnaryPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ElementWiseUnaryPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ElementWiseUnaryPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::ElementWiseUnary::kind) kind(const ::webnn::mojom::blink::ElementWiseUnaryPtr& input)
    {
        return input->kind;
    }

    static decltype(::webnn::mojom::blink::ElementWiseUnary::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ElementWiseUnaryPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::ElementWiseUnary::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ElementWiseUnaryPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::ElementWiseUnary::label)& label(const ::webnn::mojom::blink::ElementWiseUnaryPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::ElementWiseUnary::DataView input, ::webnn::mojom::blink::ElementWiseUnaryPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Expand::DataView, ::webnn::mojom::blink::ExpandPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ExpandPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ExpandPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Expand::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ExpandPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Expand::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ExpandPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Expand::label)& label(const ::webnn::mojom::blink::ExpandPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Expand::DataView input, ::webnn::mojom::blink::ExpandPtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::ConstantPadding::DataView, ::webnn::mojom::blink::ConstantPaddingPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ConstantPaddingPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ConstantPaddingPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::ConstantPadding::value) value(const ::webnn::mojom::blink::ConstantPaddingPtr& input)
    {
        return input->value;
    }

    static bool Read(::webnn::mojom::blink::ConstantPadding::DataView input, ::webnn::mojom::blink::ConstantPaddingPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::EdgePadding::DataView, ::webnn::mojom::blink::EdgePaddingPtr> {
    static bool IsNull(const ::webnn::mojom::blink::EdgePaddingPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::EdgePaddingPtr* output)
    {
        output->reset();
    }

    static bool Read(::webnn::mojom::blink::EdgePadding::DataView input, ::webnn::mojom::blink::EdgePaddingPtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::ReflectionPadding::DataView, ::webnn::mojom::blink::ReflectionPaddingPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ReflectionPaddingPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ReflectionPaddingPtr* output)
    {
        output->reset();
    }

    static bool Read(::webnn::mojom::blink::ReflectionPadding::DataView input, ::webnn::mojom::blink::ReflectionPaddingPtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::SymmetricPadding::DataView, ::webnn::mojom::blink::SymmetricPaddingPtr> {
    static bool IsNull(const ::webnn::mojom::blink::SymmetricPaddingPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::SymmetricPaddingPtr* output)
    {
        output->reset();
    }

    static bool Read(::webnn::mojom::blink::SymmetricPadding::DataView input, ::webnn::mojom::blink::SymmetricPaddingPtr* output);
};

template <>
struct COMPONENT_EXPORT(
    WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::InstanceNormalization::DataView, ::webnn::mojom::blink::InstanceNormalizationPtr> {
    static bool IsNull(const ::webnn::mojom::blink::InstanceNormalizationPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::InstanceNormalizationPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::InstanceNormalization::input_operand_id) input_operand_id(
        const ::webnn::mojom::blink::InstanceNormalizationPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::InstanceNormalization::output_operand_id) output_operand_id(
        const ::webnn::mojom::blink::InstanceNormalizationPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::InstanceNormalization::scale_operand_id) scale_operand_id(
        const ::webnn::mojom::blink::InstanceNormalizationPtr& input)
    {
        return input->scale_operand_id;
    }

    static decltype(::webnn::mojom::blink::InstanceNormalization::bias_operand_id) bias_operand_id(const ::webnn::mojom::blink::InstanceNormalizationPtr& input)
    {
        return input->bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::InstanceNormalization::epsilon) epsilon(const ::webnn::mojom::blink::InstanceNormalizationPtr& input)
    {
        return input->epsilon;
    }

    static decltype(::webnn::mojom::blink::InstanceNormalization::layout) layout(const ::webnn::mojom::blink::InstanceNormalizationPtr& input)
    {
        return input->layout;
    }

    static const decltype(::webnn::mojom::blink::InstanceNormalization::label)& label(const ::webnn::mojom::blink::InstanceNormalizationPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::InstanceNormalization::DataView input, ::webnn::mojom::blink::InstanceNormalizationPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Matmul::DataView, ::webnn::mojom::blink::MatmulPtr> {
    static bool IsNull(const ::webnn::mojom::blink::MatmulPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::MatmulPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Matmul::a_operand_id) a_operand_id(const ::webnn::mojom::blink::MatmulPtr& input)
    {
        return input->a_operand_id;
    }

    static decltype(::webnn::mojom::blink::Matmul::b_operand_id) b_operand_id(const ::webnn::mojom::blink::MatmulPtr& input)
    {
        return input->b_operand_id;
    }

    static decltype(::webnn::mojom::blink::Matmul::output_operand_id) output_operand_id(const ::webnn::mojom::blink::MatmulPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Matmul::label)& label(const ::webnn::mojom::blink::MatmulPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Matmul::DataView input, ::webnn::mojom::blink::MatmulPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Pad::DataView, ::webnn::mojom::blink::PadPtr> {
    static bool IsNull(const ::webnn::mojom::blink::PadPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::PadPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Pad::input_operand_id) input_operand_id(const ::webnn::mojom::blink::PadPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Pad::output_operand_id) output_operand_id(const ::webnn::mojom::blink::PadPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Pad::beginning_padding)& beginning_padding(const ::webnn::mojom::blink::PadPtr& input)
    {
        return input->beginning_padding;
    }

    static const decltype(::webnn::mojom::blink::Pad::ending_padding)& ending_padding(const ::webnn::mojom::blink::PadPtr& input)
    {
        return input->ending_padding;
    }

    static const decltype(::webnn::mojom::blink::Pad::mode)& mode(const ::webnn::mojom::blink::PadPtr& input)
    {
        return input->mode;
    }

    static const decltype(::webnn::mojom::blink::Pad::label)& label(const ::webnn::mojom::blink::PadPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Pad::DataView input, ::webnn::mojom::blink::PadPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Reduce::DataView, ::webnn::mojom::blink::ReducePtr> {
    static bool IsNull(const ::webnn::mojom::blink::ReducePtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ReducePtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Reduce::kind) kind(const ::webnn::mojom::blink::ReducePtr& input)
    {
        return input->kind;
    }

    static decltype(::webnn::mojom::blink::Reduce::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ReducePtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Reduce::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ReducePtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Reduce::axes)& axes(const ::webnn::mojom::blink::ReducePtr& input)
    {
        return input->axes;
    }

    static decltype(::webnn::mojom::blink::Reduce::keep_dimensions) keep_dimensions(const ::webnn::mojom::blink::ReducePtr& input)
    {
        return input->keep_dimensions;
    }

    static const decltype(::webnn::mojom::blink::Reduce::label)& label(const ::webnn::mojom::blink::ReducePtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Reduce::DataView input, ::webnn::mojom::blink::ReducePtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Pool2d::DataView, ::webnn::mojom::blink::Pool2dPtr> {
    static bool IsNull(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::Pool2dPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Pool2d::kind) kind(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return input->kind;
    }

    static decltype(::webnn::mojom::blink::Pool2d::input_operand_id) input_operand_id(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Pool2d::output_operand_id) output_operand_id(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Pool2d::window_dimensions)& window_dimensions(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return input->window_dimensions;
    }

    static const decltype(::webnn::mojom::blink::Pool2d::padding)& padding(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return input->padding;
    }

    static const decltype(::webnn::mojom::blink::Pool2d::strides)& strides(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return input->strides;
    }

    static const decltype(::webnn::mojom::blink::Pool2d::dilations)& dilations(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return input->dilations;
    }

    static const decltype(::webnn::mojom::blink::Pool2d::label)& label(const ::webnn::mojom::blink::Pool2dPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Pool2d::DataView input, ::webnn::mojom::blink::Pool2dPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Range::DataView, ::webnn::mojom::blink::RangePtr> {
    static bool IsNull(const ::webnn::mojom::blink::RangePtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::RangePtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Range::start) start(const ::webnn::mojom::blink::RangePtr& input)
    {
        return input->start;
    }

    static decltype(::webnn::mojom::blink::Range::size) size(const ::webnn::mojom::blink::RangePtr& input)
    {
        return input->size;
    }

    static decltype(::webnn::mojom::blink::Range::stride) stride(const ::webnn::mojom::blink::RangePtr& input)
    {
        return input->stride;
    }

    static bool Read(::webnn::mojom::blink::Range::DataView input, ::webnn::mojom::blink::RangePtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Slice::DataView, ::webnn::mojom::blink::SlicePtr> {
    static bool IsNull(const ::webnn::mojom::blink::SlicePtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::SlicePtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Slice::input_operand_id) input_operand_id(const ::webnn::mojom::blink::SlicePtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Slice::output_operand_id) output_operand_id(const ::webnn::mojom::blink::SlicePtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Slice::ranges)& ranges(const ::webnn::mojom::blink::SlicePtr& input)
    {
        return input->ranges;
    }

    static const decltype(::webnn::mojom::blink::Slice::label)& label(const ::webnn::mojom::blink::SlicePtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Slice::DataView input, ::webnn::mojom::blink::SlicePtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Elu::DataView, ::webnn::mojom::blink::EluPtr> {
    static bool IsNull(const ::webnn::mojom::blink::EluPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::EluPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Elu::input_operand_id) input_operand_id(const ::webnn::mojom::blink::EluPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Elu::output_operand_id) output_operand_id(const ::webnn::mojom::blink::EluPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Elu::alpha) alpha(const ::webnn::mojom::blink::EluPtr& input)
    {
        return input->alpha;
    }

    static const decltype(::webnn::mojom::blink::Elu::label)& label(const ::webnn::mojom::blink::EluPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Elu::DataView input, ::webnn::mojom::blink::EluPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Gather::DataView, ::webnn::mojom::blink::GatherPtr> {
    static bool IsNull(const ::webnn::mojom::blink::GatherPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::GatherPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Gather::input_operand_id) input_operand_id(const ::webnn::mojom::blink::GatherPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gather::indices_operand_id) indices_operand_id(const ::webnn::mojom::blink::GatherPtr& input)
    {
        return input->indices_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gather::output_operand_id) output_operand_id(const ::webnn::mojom::blink::GatherPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gather::axis) axis(const ::webnn::mojom::blink::GatherPtr& input)
    {
        return input->axis;
    }

    static const decltype(::webnn::mojom::blink::Gather::label)& label(const ::webnn::mojom::blink::GatherPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Gather::DataView input, ::webnn::mojom::blink::GatherPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::GatherElements::DataView, ::webnn::mojom::blink::GatherElementsPtr> {
    static bool IsNull(const ::webnn::mojom::blink::GatherElementsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::GatherElementsPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::GatherElements::input_operand_id) input_operand_id(const ::webnn::mojom::blink::GatherElementsPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::GatherElements::indices_operand_id) indices_operand_id(const ::webnn::mojom::blink::GatherElementsPtr& input)
    {
        return input->indices_operand_id;
    }

    static decltype(::webnn::mojom::blink::GatherElements::output_operand_id) output_operand_id(const ::webnn::mojom::blink::GatherElementsPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::GatherElements::axis) axis(const ::webnn::mojom::blink::GatherElementsPtr& input)
    {
        return input->axis;
    }

    static const decltype(::webnn::mojom::blink::GatherElements::label)& label(const ::webnn::mojom::blink::GatherElementsPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::GatherElements::DataView input, ::webnn::mojom::blink::GatherElementsPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::GatherND::DataView, ::webnn::mojom::blink::GatherNDPtr> {
    static bool IsNull(const ::webnn::mojom::blink::GatherNDPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::GatherNDPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::GatherND::input_operand_id) input_operand_id(const ::webnn::mojom::blink::GatherNDPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::GatherND::indices_operand_id) indices_operand_id(const ::webnn::mojom::blink::GatherNDPtr& input)
    {
        return input->indices_operand_id;
    }

    static decltype(::webnn::mojom::blink::GatherND::output_operand_id) output_operand_id(const ::webnn::mojom::blink::GatherNDPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::GatherND::label)& label(const ::webnn::mojom::blink::GatherNDPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::GatherND::DataView input, ::webnn::mojom::blink::GatherNDPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Gelu::DataView, ::webnn::mojom::blink::GeluPtr> {
    static bool IsNull(const ::webnn::mojom::blink::GeluPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::GeluPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Gelu::input_operand_id) input_operand_id(const ::webnn::mojom::blink::GeluPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gelu::output_operand_id) output_operand_id(const ::webnn::mojom::blink::GeluPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Gelu::label)& label(const ::webnn::mojom::blink::GeluPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Gelu::DataView input, ::webnn::mojom::blink::GeluPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Gru::DataView, ::webnn::mojom::blink::GruPtr> {
    static bool IsNull(const ::webnn::mojom::blink::GruPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::GruPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Gru::input_operand_id) input_operand_id(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gru::weight_operand_id) weight_operand_id(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gru::recurrent_weight_operand_id) recurrent_weight_operand_id(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->recurrent_weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gru::steps) steps(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->steps;
    }

    static decltype(::webnn::mojom::blink::Gru::hidden_size) hidden_size(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->hidden_size;
    }

    static const decltype(::webnn::mojom::blink::Gru::output_operand_ids)& output_operand_ids(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->output_operand_ids;
    }

    static decltype(::webnn::mojom::blink::Gru::bias_operand_id) bias_operand_id(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gru::recurrent_bias_operand_id) recurrent_bias_operand_id(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->recurrent_bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gru::initial_hidden_state_operand_id) initial_hidden_state_operand_id(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->initial_hidden_state_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gru::reset_after) reset_after(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->reset_after;
    }

    static decltype(::webnn::mojom::blink::Gru::return_sequence) return_sequence(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->return_sequence;
    }

    static decltype(::webnn::mojom::blink::Gru::direction) direction(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->direction;
    }

    static decltype(::webnn::mojom::blink::Gru::layout) layout(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->layout;
    }

    static const decltype(::webnn::mojom::blink::Gru::activations)& activations(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->activations;
    }

    static const decltype(::webnn::mojom::blink::Gru::label)& label(const ::webnn::mojom::blink::GruPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Gru::DataView input, ::webnn::mojom::blink::GruPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::GruCell::DataView, ::webnn::mojom::blink::GruCellPtr> {
    static bool IsNull(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::GruCellPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::GruCell::input_operand_id) input_operand_id(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::GruCell::weight_operand_id) weight_operand_id(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::GruCell::recurrent_weight_operand_id) recurrent_weight_operand_id(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->recurrent_weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::GruCell::hidden_state_operand_id) hidden_state_operand_id(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->hidden_state_operand_id;
    }

    static decltype(::webnn::mojom::blink::GruCell::hidden_size) hidden_size(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->hidden_size;
    }

    static decltype(::webnn::mojom::blink::GruCell::output_operand_id) output_operand_id(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::GruCell::bias_operand_id) bias_operand_id(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::GruCell::recurrent_bias_operand_id) recurrent_bias_operand_id(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->recurrent_bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::GruCell::reset_after) reset_after(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->reset_after;
    }

    static decltype(::webnn::mojom::blink::GruCell::layout) layout(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->layout;
    }

    static const decltype(::webnn::mojom::blink::GruCell::activations)& activations(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->activations;
    }

    static const decltype(::webnn::mojom::blink::GruCell::label)& label(const ::webnn::mojom::blink::GruCellPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::GruCell::DataView input, ::webnn::mojom::blink::GruCellPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Gemm::DataView, ::webnn::mojom::blink::GemmPtr> {
    static bool IsNull(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::GemmPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Gemm::a_operand_id) a_operand_id(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->a_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gemm::b_operand_id) b_operand_id(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->b_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gemm::output_operand_id) output_operand_id(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gemm::c_operand_id) c_operand_id(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->c_operand_id;
    }

    static decltype(::webnn::mojom::blink::Gemm::alpha) alpha(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->alpha;
    }

    static decltype(::webnn::mojom::blink::Gemm::beta) beta(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->beta;
    }

    static decltype(::webnn::mojom::blink::Gemm::a_transpose) a_transpose(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->a_transpose;
    }

    static decltype(::webnn::mojom::blink::Gemm::b_transpose) b_transpose(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->b_transpose;
    }

    static const decltype(::webnn::mojom::blink::Gemm::label)& label(const ::webnn::mojom::blink::GemmPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Gemm::DataView input, ::webnn::mojom::blink::GemmPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::HardSigmoid::DataView, ::webnn::mojom::blink::HardSigmoidPtr> {
    static bool IsNull(const ::webnn::mojom::blink::HardSigmoidPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::HardSigmoidPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::HardSigmoid::input_operand_id) input_operand_id(const ::webnn::mojom::blink::HardSigmoidPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::HardSigmoid::output_operand_id) output_operand_id(const ::webnn::mojom::blink::HardSigmoidPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::HardSigmoid::alpha) alpha(const ::webnn::mojom::blink::HardSigmoidPtr& input)
    {
        return input->alpha;
    }

    static decltype(::webnn::mojom::blink::HardSigmoid::beta) beta(const ::webnn::mojom::blink::HardSigmoidPtr& input)
    {
        return input->beta;
    }

    static const decltype(::webnn::mojom::blink::HardSigmoid::label)& label(const ::webnn::mojom::blink::HardSigmoidPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::HardSigmoid::DataView input, ::webnn::mojom::blink::HardSigmoidPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::HardSwish::DataView, ::webnn::mojom::blink::HardSwishPtr> {
    static bool IsNull(const ::webnn::mojom::blink::HardSwishPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::HardSwishPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::HardSwish::input_operand_id) input_operand_id(const ::webnn::mojom::blink::HardSwishPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::HardSwish::output_operand_id) output_operand_id(const ::webnn::mojom::blink::HardSwishPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::HardSwish::label)& label(const ::webnn::mojom::blink::HardSwishPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::HardSwish::DataView input, ::webnn::mojom::blink::HardSwishPtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::LayerNormalization::DataView, ::webnn::mojom::blink::LayerNormalizationPtr> {
    static bool IsNull(const ::webnn::mojom::blink::LayerNormalizationPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::LayerNormalizationPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::LayerNormalization::input_operand_id) input_operand_id(const ::webnn::mojom::blink::LayerNormalizationPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::LayerNormalization::output_operand_id) output_operand_id(const ::webnn::mojom::blink::LayerNormalizationPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::LayerNormalization::scale_operand_id) scale_operand_id(const ::webnn::mojom::blink::LayerNormalizationPtr& input)
    {
        return input->scale_operand_id;
    }

    static decltype(::webnn::mojom::blink::LayerNormalization::bias_operand_id) bias_operand_id(const ::webnn::mojom::blink::LayerNormalizationPtr& input)
    {
        return input->bias_operand_id;
    }

    static const decltype(::webnn::mojom::blink::LayerNormalization::axes)& axes(const ::webnn::mojom::blink::LayerNormalizationPtr& input)
    {
        return input->axes;
    }

    static decltype(::webnn::mojom::blink::LayerNormalization::epsilon) epsilon(const ::webnn::mojom::blink::LayerNormalizationPtr& input)
    {
        return input->epsilon;
    }

    static const decltype(::webnn::mojom::blink::LayerNormalization::label)& label(const ::webnn::mojom::blink::LayerNormalizationPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::LayerNormalization::DataView input, ::webnn::mojom::blink::LayerNormalizationPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::LeakyRelu::DataView, ::webnn::mojom::blink::LeakyReluPtr> {
    static bool IsNull(const ::webnn::mojom::blink::LeakyReluPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::LeakyReluPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::LeakyRelu::input_operand_id) input_operand_id(const ::webnn::mojom::blink::LeakyReluPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::LeakyRelu::output_operand_id) output_operand_id(const ::webnn::mojom::blink::LeakyReluPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::LeakyRelu::alpha) alpha(const ::webnn::mojom::blink::LeakyReluPtr& input)
    {
        return input->alpha;
    }

    static const decltype(::webnn::mojom::blink::LeakyRelu::label)& label(const ::webnn::mojom::blink::LeakyReluPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::LeakyRelu::DataView input, ::webnn::mojom::blink::LeakyReluPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Linear::DataView, ::webnn::mojom::blink::LinearPtr> {
    static bool IsNull(const ::webnn::mojom::blink::LinearPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::LinearPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Linear::input_operand_id) input_operand_id(const ::webnn::mojom::blink::LinearPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Linear::output_operand_id) output_operand_id(const ::webnn::mojom::blink::LinearPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Linear::alpha) alpha(const ::webnn::mojom::blink::LinearPtr& input)
    {
        return input->alpha;
    }

    static decltype(::webnn::mojom::blink::Linear::beta) beta(const ::webnn::mojom::blink::LinearPtr& input)
    {
        return input->beta;
    }

    static const decltype(::webnn::mojom::blink::Linear::label)& label(const ::webnn::mojom::blink::LinearPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Linear::DataView input, ::webnn::mojom::blink::LinearPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Lstm::DataView, ::webnn::mojom::blink::LstmPtr> {
    static bool IsNull(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::LstmPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Lstm::input_operand_id) input_operand_id(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Lstm::weight_operand_id) weight_operand_id(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::Lstm::recurrent_weight_operand_id) recurrent_weight_operand_id(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->recurrent_weight_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Lstm::output_operand_ids)& output_operand_ids(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->output_operand_ids;
    }

    static decltype(::webnn::mojom::blink::Lstm::steps) steps(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->steps;
    }

    static decltype(::webnn::mojom::blink::Lstm::hidden_size) hidden_size(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->hidden_size;
    }

    static decltype(::webnn::mojom::blink::Lstm::bias_operand_id) bias_operand_id(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::Lstm::recurrent_bias_operand_id) recurrent_bias_operand_id(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->recurrent_bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::Lstm::peephole_weight_operand_id) peephole_weight_operand_id(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->peephole_weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::Lstm::initial_hidden_state_operand_id) initial_hidden_state_operand_id(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->initial_hidden_state_operand_id;
    }

    static decltype(::webnn::mojom::blink::Lstm::initial_cell_state_operand_id) initial_cell_state_operand_id(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->initial_cell_state_operand_id;
    }

    static decltype(::webnn::mojom::blink::Lstm::return_sequence) return_sequence(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->return_sequence;
    }

    static decltype(::webnn::mojom::blink::Lstm::direction) direction(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->direction;
    }

    static decltype(::webnn::mojom::blink::Lstm::layout) layout(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->layout;
    }

    static const decltype(::webnn::mojom::blink::Lstm::activations)& activations(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->activations;
    }

    static const decltype(::webnn::mojom::blink::Lstm::label)& label(const ::webnn::mojom::blink::LstmPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Lstm::DataView input, ::webnn::mojom::blink::LstmPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::LstmCell::DataView, ::webnn::mojom::blink::LstmCellPtr> {
    static bool IsNull(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::LstmCellPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::LstmCell::input_operand_id) input_operand_id(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::LstmCell::weight_operand_id) weight_operand_id(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::LstmCell::recurrent_weight_operand_id) recurrent_weight_operand_id(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->recurrent_weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::LstmCell::hidden_state_operand_id) hidden_state_operand_id(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->hidden_state_operand_id;
    }

    static decltype(::webnn::mojom::blink::LstmCell::cell_state_operand_id) cell_state_operand_id(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->cell_state_operand_id;
    }

    static const decltype(::webnn::mojom::blink::LstmCell::output_operand_ids)& output_operand_ids(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->output_operand_ids;
    }

    static decltype(::webnn::mojom::blink::LstmCell::hidden_size) hidden_size(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->hidden_size;
    }

    static decltype(::webnn::mojom::blink::LstmCell::bias_operand_id) bias_operand_id(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::LstmCell::recurrent_bias_operand_id) recurrent_bias_operand_id(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->recurrent_bias_operand_id;
    }

    static decltype(::webnn::mojom::blink::LstmCell::peephole_weight_operand_id) peephole_weight_operand_id(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->peephole_weight_operand_id;
    }

    static decltype(::webnn::mojom::blink::LstmCell::layout) layout(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->layout;
    }

    static const decltype(::webnn::mojom::blink::LstmCell::activations)& activations(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->activations;
    }

    static const decltype(::webnn::mojom::blink::LstmCell::label)& label(const ::webnn::mojom::blink::LstmCellPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::LstmCell::DataView input, ::webnn::mojom::blink::LstmCellPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Prelu::DataView, ::webnn::mojom::blink::PreluPtr> {
    static bool IsNull(const ::webnn::mojom::blink::PreluPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::PreluPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Prelu::input_operand_id) input_operand_id(const ::webnn::mojom::blink::PreluPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Prelu::slope_operand_id) slope_operand_id(const ::webnn::mojom::blink::PreluPtr& input)
    {
        return input->slope_operand_id;
    }

    static decltype(::webnn::mojom::blink::Prelu::output_operand_id) output_operand_id(const ::webnn::mojom::blink::PreluPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Prelu::label)& label(const ::webnn::mojom::blink::PreluPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Prelu::DataView input, ::webnn::mojom::blink::PreluPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::QuantizeLinear::DataView, ::webnn::mojom::blink::QuantizeLinearPtr> {
    static bool IsNull(const ::webnn::mojom::blink::QuantizeLinearPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::QuantizeLinearPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::QuantizeLinear::input_operand_id) input_operand_id(const ::webnn::mojom::blink::QuantizeLinearPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::QuantizeLinear::scale_operand_id) scale_operand_id(const ::webnn::mojom::blink::QuantizeLinearPtr& input)
    {
        return input->scale_operand_id;
    }

    static decltype(::webnn::mojom::blink::QuantizeLinear::zero_point_operand_id) zero_point_operand_id(const ::webnn::mojom::blink::QuantizeLinearPtr& input)
    {
        return input->zero_point_operand_id;
    }

    static decltype(::webnn::mojom::blink::QuantizeLinear::output_operand_id) output_operand_id(const ::webnn::mojom::blink::QuantizeLinearPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::QuantizeLinear::label)& label(const ::webnn::mojom::blink::QuantizeLinearPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::QuantizeLinear::DataView input, ::webnn::mojom::blink::QuantizeLinearPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Relu::DataView, ::webnn::mojom::blink::ReluPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ReluPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ReluPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Relu::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ReluPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Relu::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ReluPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Relu::label)& label(const ::webnn::mojom::blink::ReluPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Relu::DataView input, ::webnn::mojom::blink::ReluPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Reshape::DataView, ::webnn::mojom::blink::ReshapePtr> {
    static bool IsNull(const ::webnn::mojom::blink::ReshapePtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ReshapePtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Reshape::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ReshapePtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Reshape::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ReshapePtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Reshape::label)& label(const ::webnn::mojom::blink::ReshapePtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Reshape::DataView input, ::webnn::mojom::blink::ReshapePtr* output);
};

template <>
struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::ScatterElements::DataView, ::webnn::mojom::blink::ScatterElementsPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ScatterElementsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ScatterElementsPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::ScatterElements::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ScatterElementsPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::ScatterElements::indices_operand_id) indices_operand_id(const ::webnn::mojom::blink::ScatterElementsPtr& input)
    {
        return input->indices_operand_id;
    }

    static decltype(::webnn::mojom::blink::ScatterElements::updates_operand_id) updates_operand_id(const ::webnn::mojom::blink::ScatterElementsPtr& input)
    {
        return input->updates_operand_id;
    }

    static decltype(::webnn::mojom::blink::ScatterElements::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ScatterElementsPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::ScatterElements::axis) axis(const ::webnn::mojom::blink::ScatterElementsPtr& input)
    {
        return input->axis;
    }

    static const decltype(::webnn::mojom::blink::ScatterElements::label)& label(const ::webnn::mojom::blink::ScatterElementsPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::ScatterElements::DataView input, ::webnn::mojom::blink::ScatterElementsPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::ScatterND::DataView, ::webnn::mojom::blink::ScatterNDPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ScatterNDPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ScatterNDPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::ScatterND::input_operand_id) input_operand_id(const ::webnn::mojom::blink::ScatterNDPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::ScatterND::indices_operand_id) indices_operand_id(const ::webnn::mojom::blink::ScatterNDPtr& input)
    {
        return input->indices_operand_id;
    }

    static decltype(::webnn::mojom::blink::ScatterND::updates_operand_id) updates_operand_id(const ::webnn::mojom::blink::ScatterNDPtr& input)
    {
        return input->updates_operand_id;
    }

    static decltype(::webnn::mojom::blink::ScatterND::output_operand_id) output_operand_id(const ::webnn::mojom::blink::ScatterNDPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::ScatterND::label)& label(const ::webnn::mojom::blink::ScatterNDPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::ScatterND::DataView input, ::webnn::mojom::blink::ScatterNDPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Sigmoid::DataView, ::webnn::mojom::blink::SigmoidPtr> {
    static bool IsNull(const ::webnn::mojom::blink::SigmoidPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::SigmoidPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Sigmoid::input_operand_id) input_operand_id(const ::webnn::mojom::blink::SigmoidPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Sigmoid::output_operand_id) output_operand_id(const ::webnn::mojom::blink::SigmoidPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Sigmoid::label)& label(const ::webnn::mojom::blink::SigmoidPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Sigmoid::DataView input, ::webnn::mojom::blink::SigmoidPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Softmax::DataView, ::webnn::mojom::blink::SoftmaxPtr> {
    static bool IsNull(const ::webnn::mojom::blink::SoftmaxPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::SoftmaxPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Softmax::input_operand_id) input_operand_id(const ::webnn::mojom::blink::SoftmaxPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Softmax::output_operand_id) output_operand_id(const ::webnn::mojom::blink::SoftmaxPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Softmax::axis) axis(const ::webnn::mojom::blink::SoftmaxPtr& input)
    {
        return input->axis;
    }

    static const decltype(::webnn::mojom::blink::Softmax::label)& label(const ::webnn::mojom::blink::SoftmaxPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Softmax::DataView input, ::webnn::mojom::blink::SoftmaxPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Softplus::DataView, ::webnn::mojom::blink::SoftplusPtr> {
    static bool IsNull(const ::webnn::mojom::blink::SoftplusPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::SoftplusPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Softplus::input_operand_id) input_operand_id(const ::webnn::mojom::blink::SoftplusPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Softplus::output_operand_id) output_operand_id(const ::webnn::mojom::blink::SoftplusPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Softplus::label)& label(const ::webnn::mojom::blink::SoftplusPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Softplus::DataView input, ::webnn::mojom::blink::SoftplusPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Softsign::DataView, ::webnn::mojom::blink::SoftsignPtr> {
    static bool IsNull(const ::webnn::mojom::blink::SoftsignPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::SoftsignPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Softsign::input_operand_id) input_operand_id(const ::webnn::mojom::blink::SoftsignPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Softsign::output_operand_id) output_operand_id(const ::webnn::mojom::blink::SoftsignPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Softsign::label)& label(const ::webnn::mojom::blink::SoftsignPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Softsign::DataView input, ::webnn::mojom::blink::SoftsignPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Split::DataView, ::webnn::mojom::blink::SplitPtr> {
    static bool IsNull(const ::webnn::mojom::blink::SplitPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::SplitPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Split::input_operand_id) input_operand_id(const ::webnn::mojom::blink::SplitPtr& input)
    {
        return input->input_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Split::output_operand_ids)& output_operand_ids(const ::webnn::mojom::blink::SplitPtr& input)
    {
        return input->output_operand_ids;
    }

    static decltype(::webnn::mojom::blink::Split::axis) axis(const ::webnn::mojom::blink::SplitPtr& input)
    {
        return input->axis;
    }

    static const decltype(::webnn::mojom::blink::Split::label)& label(const ::webnn::mojom::blink::SplitPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Split::DataView input, ::webnn::mojom::blink::SplitPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Tanh::DataView, ::webnn::mojom::blink::TanhPtr> {
    static bool IsNull(const ::webnn::mojom::blink::TanhPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::TanhPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Tanh::input_operand_id) input_operand_id(const ::webnn::mojom::blink::TanhPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Tanh::output_operand_id) output_operand_id(const ::webnn::mojom::blink::TanhPtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Tanh::label)& label(const ::webnn::mojom::blink::TanhPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Tanh::DataView input, ::webnn::mojom::blink::TanhPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Tile::DataView, ::webnn::mojom::blink::TilePtr> {
    static bool IsNull(const ::webnn::mojom::blink::TilePtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::TilePtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Tile::input_operand_id) input_operand_id(const ::webnn::mojom::blink::TilePtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Tile::output_operand_id) output_operand_id(const ::webnn::mojom::blink::TilePtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Tile::repetitions)& repetitions(const ::webnn::mojom::blink::TilePtr& input)
    {
        return input->repetitions;
    }

    static const decltype(::webnn::mojom::blink::Tile::label)& label(const ::webnn::mojom::blink::TilePtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Tile::DataView input, ::webnn::mojom::blink::TilePtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Transpose::DataView, ::webnn::mojom::blink::TransposePtr> {
    static bool IsNull(const ::webnn::mojom::blink::TransposePtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::TransposePtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Transpose::input_operand_id) input_operand_id(const ::webnn::mojom::blink::TransposePtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Transpose::output_operand_id) output_operand_id(const ::webnn::mojom::blink::TransposePtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Transpose::permutation)& permutation(const ::webnn::mojom::blink::TransposePtr& input)
    {
        return input->permutation;
    }

    static const decltype(::webnn::mojom::blink::Transpose::label)& label(const ::webnn::mojom::blink::TransposePtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Transpose::DataView input, ::webnn::mojom::blink::TransposePtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Triangular::DataView, ::webnn::mojom::blink::TriangularPtr> {
    static bool IsNull(const ::webnn::mojom::blink::TriangularPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::TriangularPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Triangular::input_operand_id) input_operand_id(const ::webnn::mojom::blink::TriangularPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Triangular::output_operand_id) output_operand_id(const ::webnn::mojom::blink::TriangularPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Triangular::upper) upper(const ::webnn::mojom::blink::TriangularPtr& input)
    {
        return input->upper;
    }

    static decltype(::webnn::mojom::blink::Triangular::diagonal) diagonal(const ::webnn::mojom::blink::TriangularPtr& input)
    {
        return input->diagonal;
    }

    static const decltype(::webnn::mojom::blink::Triangular::label)& label(const ::webnn::mojom::blink::TriangularPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Triangular::DataView input, ::webnn::mojom::blink::TriangularPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Resample2d::DataView, ::webnn::mojom::blink::Resample2dPtr> {
    static bool IsNull(const ::webnn::mojom::blink::Resample2dPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::Resample2dPtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Resample2d::input_operand_id) input_operand_id(const ::webnn::mojom::blink::Resample2dPtr& input)
    {
        return input->input_operand_id;
    }

    static decltype(::webnn::mojom::blink::Resample2d::output_operand_id) output_operand_id(const ::webnn::mojom::blink::Resample2dPtr& input)
    {
        return input->output_operand_id;
    }

    static decltype(::webnn::mojom::blink::Resample2d::mode) mode(const ::webnn::mojom::blink::Resample2dPtr& input)
    {
        return input->mode;
    }

    static const decltype(::webnn::mojom::blink::Resample2d::scales)& scales(const ::webnn::mojom::blink::Resample2dPtr& input)
    {
        return input->scales;
    }

    static const decltype(::webnn::mojom::blink::Resample2d::axes)& axes(const ::webnn::mojom::blink::Resample2dPtr& input)
    {
        return input->axes;
    }

    static const decltype(::webnn::mojom::blink::Resample2d::label)& label(const ::webnn::mojom::blink::Resample2dPtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Resample2d::DataView input, ::webnn::mojom::blink::Resample2dPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::Where::DataView, ::webnn::mojom::blink::WherePtr> {
    static bool IsNull(const ::webnn::mojom::blink::WherePtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::WherePtr* output)
    {
        output->reset();
    }

    static decltype(::webnn::mojom::blink::Where::condition_operand_id) condition_operand_id(const ::webnn::mojom::blink::WherePtr& input)
    {
        return input->condition_operand_id;
    }

    static decltype(::webnn::mojom::blink::Where::true_value_operand_id) true_value_operand_id(const ::webnn::mojom::blink::WherePtr& input)
    {
        return input->true_value_operand_id;
    }

    static decltype(::webnn::mojom::blink::Where::false_value_operand_id) false_value_operand_id(const ::webnn::mojom::blink::WherePtr& input)
    {
        return input->false_value_operand_id;
    }

    static decltype(::webnn::mojom::blink::Where::output_operand_id) output_operand_id(const ::webnn::mojom::blink::WherePtr& input)
    {
        return input->output_operand_id;
    }

    static const decltype(::webnn::mojom::blink::Where::label)& label(const ::webnn::mojom::blink::WherePtr& input)
    {
        return input->label;
    }

    static bool Read(::webnn::mojom::blink::Where::DataView input, ::webnn::mojom::blink::WherePtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) StructTraits<::webnn::mojom::blink::GraphInfo::DataView, ::webnn::mojom::blink::GraphInfoPtr> {
    static bool IsNull(const ::webnn::mojom::blink::GraphInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::GraphInfoPtr* output)
    {
        output->reset();
    }

    static const decltype(::webnn::mojom::blink::GraphInfo::id_to_operand_map)& id_to_operand_map(const ::webnn::mojom::blink::GraphInfoPtr& input)
    {
        return input->id_to_operand_map;
    }

    static const decltype(::webnn::mojom::blink::GraphInfo::input_operands)& input_operands(const ::webnn::mojom::blink::GraphInfoPtr& input)
    {
        return input->input_operands;
    }

    static const decltype(::webnn::mojom::blink::GraphInfo::output_operands)& output_operands(const ::webnn::mojom::blink::GraphInfoPtr& input)
    {
        return input->output_operands;
    }

    static const decltype(::webnn::mojom::blink::GraphInfo::operations)& operations(const ::webnn::mojom::blink::GraphInfoPtr& input)
    {
        return input->operations;
    }

    static decltype(::webnn::mojom::blink::GraphInfo::constant_id_to_buffer_map)& constant_id_to_buffer_map(::webnn::mojom::blink::GraphInfoPtr& input)
    {
        return input->constant_id_to_buffer_map;
    }

    static bool Read(::webnn::mojom::blink::GraphInfo::DataView input, ::webnn::mojom::blink::GraphInfoPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) UnionTraits<::webnn::mojom::blink::PaddingMode::DataView, ::webnn::mojom::blink::PaddingModePtr> {
    static bool IsNull(const ::webnn::mojom::blink::PaddingModePtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::PaddingModePtr* output)
    {
        output->reset();
    }

    static ::webnn::mojom::blink::PaddingMode::Tag GetTag(const ::webnn::mojom::blink::PaddingModePtr& input)
    {
        return input->which();
    }

    static const ::webnn::mojom::blink::ConstantPaddingPtr& constant(const ::webnn::mojom::blink::PaddingModePtr& input)
    {
        return input->get_constant();
    }

    static const ::webnn::mojom::blink::EdgePaddingPtr& edge(const ::webnn::mojom::blink::PaddingModePtr& input)
    {
        return input->get_edge();
    }

    static const ::webnn::mojom::blink::ReflectionPaddingPtr& reflection(const ::webnn::mojom::blink::PaddingModePtr& input)
    {
        return input->get_reflection();
    }

    static const ::webnn::mojom::blink::SymmetricPaddingPtr& symmetric(const ::webnn::mojom::blink::PaddingModePtr& input)
    {
        return input->get_symmetric();
    }

    static bool Read(::webnn::mojom::blink::PaddingMode::DataView input, ::webnn::mojom::blink::PaddingModePtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) UnionTraits<::webnn::mojom::blink::Operation::DataView, ::webnn::mojom::blink::OperationPtr> {
    static bool IsNull(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::OperationPtr* output)
    {
        output->reset();
    }

    static ::webnn::mojom::blink::Operation::Tag GetTag(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->which();
    }

    static const ::webnn::mojom::blink::ArgMinMaxPtr& arg_min_max(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_arg_min_max();
    }

    static const ::webnn::mojom::blink::BatchNormalizationPtr& batch_normalization(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_batch_normalization();
    }

    static const ::webnn::mojom::blink::ClampPtr& clamp(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_clamp();
    }

    static const ::webnn::mojom::blink::ConcatPtr& concat(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_concat();
    }

    static const ::webnn::mojom::blink::Conv2dPtr& conv2d(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_conv2d();
    }

    static const ::webnn::mojom::blink::CumulativeSumPtr& cumulative_sum(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_cumulative_sum();
    }

    static const ::webnn::mojom::blink::DequantizeLinearPtr& dequantize_linear(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_dequantize_linear();
    }

    static const ::webnn::mojom::blink::ElementWiseBinaryPtr& element_wise_binary(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_element_wise_binary();
    }

    static const ::webnn::mojom::blink::EluPtr& elu(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_elu();
    }

    static const ::webnn::mojom::blink::ElementWiseUnaryPtr& element_wise_unary(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_element_wise_unary();
    }

    static const ::webnn::mojom::blink::ExpandPtr& expand(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_expand();
    }

    static const ::webnn::mojom::blink::GatherPtr& gather(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_gather();
    }

    static const ::webnn::mojom::blink::GatherElementsPtr& gather_elements(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_gather_elements();
    }

    static const ::webnn::mojom::blink::GatherNDPtr& gather_nd(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_gather_nd();
    }

    static const ::webnn::mojom::blink::GeluPtr& gelu(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_gelu();
    }

    static const ::webnn::mojom::blink::GemmPtr& gemm(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_gemm();
    }

    static const ::webnn::mojom::blink::GruPtr& gru(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_gru();
    }

    static const ::webnn::mojom::blink::GruCellPtr& gru_cell(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_gru_cell();
    }

    static const ::webnn::mojom::blink::HardSigmoidPtr& hard_sigmoid(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_hard_sigmoid();
    }

    static const ::webnn::mojom::blink::HardSwishPtr& hard_swish(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_hard_swish();
    }

    static const ::webnn::mojom::blink::LayerNormalizationPtr& layer_normalization(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_layer_normalization();
    }

    static const ::webnn::mojom::blink::InstanceNormalizationPtr& instance_normalization(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_instance_normalization();
    }

    static const ::webnn::mojom::blink::LeakyReluPtr& leaky_relu(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_leaky_relu();
    }

    static const ::webnn::mojom::blink::LinearPtr& linear(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_linear();
    }

    static const ::webnn::mojom::blink::LstmPtr& lstm(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_lstm();
    }

    static const ::webnn::mojom::blink::LstmCellPtr& lstm_cell(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_lstm_cell();
    }

    static const ::webnn::mojom::blink::MatmulPtr& matmul(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_matmul();
    }

    static const ::webnn::mojom::blink::PadPtr& pad(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_pad();
    }

    static const ::webnn::mojom::blink::Pool2dPtr& pool2d(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_pool2d();
    }

    static const ::webnn::mojom::blink::PreluPtr& prelu(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_prelu();
    }

    static const ::webnn::mojom::blink::QuantizeLinearPtr& quantize_linear(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_quantize_linear();
    }

    static const ::webnn::mojom::blink::ReducePtr& reduce(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_reduce();
    }

    static const ::webnn::mojom::blink::ReluPtr& relu(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_relu();
    }

    static const ::webnn::mojom::blink::Resample2dPtr& resample2d(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_resample2d();
    }

    static const ::webnn::mojom::blink::ReshapePtr& reshape(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_reshape();
    }

    static const ::webnn::mojom::blink::ScatterElementsPtr& scatter_elements(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_scatter_elements();
    }

    static const ::webnn::mojom::blink::ScatterNDPtr& scatter_nd(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_scatter_nd();
    }

    static const ::webnn::mojom::blink::SigmoidPtr& sigmoid(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_sigmoid();
    }

    static const ::webnn::mojom::blink::SlicePtr& slice(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_slice();
    }

    static const ::webnn::mojom::blink::SoftmaxPtr& softmax(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_softmax();
    }

    static const ::webnn::mojom::blink::SoftplusPtr& softplus(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_softplus();
    }

    static const ::webnn::mojom::blink::SoftsignPtr& softsign(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_softsign();
    }

    static const ::webnn::mojom::blink::SplitPtr& split(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_split();
    }

    static const ::webnn::mojom::blink::TanhPtr& tanh(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_tanh();
    }

    static const ::webnn::mojom::blink::TilePtr& tile(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_tile();
    }

    static const ::webnn::mojom::blink::TransposePtr& transpose(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_transpose();
    }

    static const ::webnn::mojom::blink::TriangularPtr& triangular(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_triangular();
    }

    static const ::webnn::mojom::blink::WherePtr& where(const ::webnn::mojom::blink::OperationPtr& input)
    {
        return input->get_where();
    }

    static bool Read(::webnn::mojom::blink::Operation::DataView input, ::webnn::mojom::blink::OperationPtr* output);
};

template <> struct COMPONENT_EXPORT(WEBNN_MOJOM_BLINK) UnionTraits<::webnn::mojom::blink::ComputeResult::DataView, ::webnn::mojom::blink::ComputeResultPtr> {
    static bool IsNull(const ::webnn::mojom::blink::ComputeResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::webnn::mojom::blink::ComputeResultPtr* output)
    {
        output->reset();
    }

    static ::webnn::mojom::blink::ComputeResult::Tag GetTag(const ::webnn::mojom::blink::ComputeResultPtr& input)
    {
        return input->which();
    }

    static WTF::HashMap<WTF::String, ::mojo_base::BigBuffer>& named_outputs(::webnn::mojom::blink::ComputeResultPtr& input)
    {
        return input->get_named_outputs();
    }

    static const ::webnn::mojom::blink::ErrorPtr& error(const ::webnn::mojom::blink::ComputeResultPtr& input)
    {
        return input->get_error();
    }

    static bool Read(::webnn::mojom::blink::ComputeResult::DataView input, ::webnn::mojom::blink::ComputeResultPtr* output);
};

} // namespace mojo

#endif // SERVICES_WEBNN_PUBLIC_MOJOM_WEBNN_GRAPH_MOJOM_BLINK_H_
