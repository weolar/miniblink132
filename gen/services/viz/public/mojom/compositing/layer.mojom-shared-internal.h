// services/viz/public/mojom/compositing/layer.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_LAYER_MOJOM_SHARED_INTERNAL_H_
#define SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_LAYER_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "cc/mojom/element_id.mojom-shared-internal.h"
#include "cc/mojom/layer_type.mojom-shared-internal.h"
#include "skia/public/mojom/skcolor4f.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared-internal.h"
#include "ui/gfx/mojom/transform.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"

namespace mojo {
namespace internal {
class ValidationContext;
}
}

namespace viz::mojom {
namespace internal {
class Layer_Data;
class AnchorPositionScrollData_Data;
class StickyPositionNodeData_Data;
class TransformTreeUpdate_Data;
class TransformNode_Data;
class ClipNode_Data;
class EffectNode_Data;
class ScrollNode_Data;

#pragma pack(push, 1)
class Layer_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int64_t id;
    int32_t type;
    uint8_t contents_opaque : 1;
    uint8_t contents_opaque_for_text : 1;
    uint8_t is_drawable : 1;
    uint8_t pad4_[3];
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> bounds;
    mojo::internal::Pointer<::skia::mojom::internal::SkColor4f_Data> background_color;
    mojo::internal::Pointer<::skia::mojom::internal::SkColor4f_Data> safe_opaque_background_color;
    mojo::internal::Pointer<::cc::mojom::internal::ElementId_Data> element_id;
    mojo::internal::Pointer<::gfx::mojom::internal::Rect_Data> update_rect;
    mojo::internal::Pointer<::gfx::mojom::internal::Vector2dF_Data> offset_to_transform_parent;
    int32_t transform_tree_index;
    int32_t clip_tree_index;
    int32_t effect_tree_index;
    int32_t scroll_tree_index;

private:
    friend class mojo::internal::MessageFragment<Layer_Data>;

    Layer_Data();
    ~Layer_Data() = delete;
};
static_assert(sizeof(Layer_Data) == 88, "Bad sizeof(Layer_Data)");
// Used by Layer::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct Layer_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    Layer_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~Layer_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<Layer_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag Layer_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class AnchorPositionScrollData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<::cc::mojom::internal::ElementId_Data>>> adjustment_container_ids;
    mojo::internal::Pointer<::gfx::mojom::internal::Vector2d_Data> accumulated_scroll_origin;
    uint8_t needs_scroll_adjustment_in_x : 1;
    uint8_t needs_scroll_adjustment_in_y : 1;
    uint8_t padfinal_[7];

private:
    friend class mojo::internal::MessageFragment<AnchorPositionScrollData_Data>;

    AnchorPositionScrollData_Data();
    ~AnchorPositionScrollData_Data() = delete;
};
static_assert(sizeof(AnchorPositionScrollData_Data) == 32, "Bad sizeof(AnchorPositionScrollData_Data)");
// Used by AnchorPositionScrollData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct AnchorPositionScrollData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    AnchorPositionScrollData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~AnchorPositionScrollData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<AnchorPositionScrollData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag AnchorPositionScrollData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class StickyPositionNodeData_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t scroll_ancestor;
    uint8_t is_anchored_left : 1;
    uint8_t is_anchored_right : 1;
    uint8_t is_anchored_top : 1;
    uint8_t is_anchored_bottom : 1;
    uint8_t pad4_[3];
    float left_offset;
    float right_offset;
    float top_offset;
    float bottom_offset;
    mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> constraint_box_rect;
    mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> scroll_container_relative_sticky_box_rect;
    mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> scroll_container_relative_containing_block_rect;
    int32_t nearest_node_shifting_sticky_box;
    int32_t nearest_node_shifting_containing_block;
    mojo::internal::Pointer<::gfx::mojom::internal::Vector2dF_Data> total_sticky_box_sticky_offset;
    mojo::internal::Pointer<::gfx::mojom::internal::Vector2dF_Data> total_containing_block_sticky_offset;

private:
    friend class mojo::internal::MessageFragment<StickyPositionNodeData_Data>;

    StickyPositionNodeData_Data();
    ~StickyPositionNodeData_Data() = delete;
};
static_assert(sizeof(StickyPositionNodeData_Data) == 80, "Bad sizeof(StickyPositionNodeData_Data)");
// Used by StickyPositionNodeData::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct StickyPositionNodeData_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    StickyPositionNodeData_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~StickyPositionNodeData_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<StickyPositionNodeData_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag StickyPositionNodeData_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class TransformTreeUpdate_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    float page_scale_factor;
    float device_scale_factor;
    float device_transform_scale_factor;
    uint8_t pad2_[4];
    mojo::internal::Pointer<mojo::internal::Array_Data<int32_t>> nodes_affected_by_outer_viewport_bounds_delta;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::StickyPositionNodeData_Data>>> sticky_position_data;
    mojo::internal::Pointer<mojo::internal::Array_Data<mojo::internal::Pointer<internal::AnchorPositionScrollData_Data>>> anchor_position_scroll_data;

private:
    friend class mojo::internal::MessageFragment<TransformTreeUpdate_Data>;

    TransformTreeUpdate_Data();
    ~TransformTreeUpdate_Data() = delete;
};
static_assert(sizeof(TransformTreeUpdate_Data) == 48, "Bad sizeof(TransformTreeUpdate_Data)");
// Used by TransformTreeUpdate::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct TransformTreeUpdate_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    TransformTreeUpdate_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~TransformTreeUpdate_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<TransformTreeUpdate_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag TransformTreeUpdate_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class TransformNode_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t id;
    int32_t parent_id;
    int32_t parent_frame_id;
    uint8_t sticky_position_constraint_id_$flag : 1;
    uint8_t anchor_position_scroll_data_id_$flag : 1;
    uint8_t has_potential_animation : 1;
    uint8_t is_currently_animating : 1;
    uint8_t flattens_inherited_transform : 1;
    uint8_t scrolls : 1;
    uint8_t should_undo_overscroll : 1;
    uint8_t should_be_snapped : 1;
    uint8_t moved_by_outer_viewport_bounds_delta_y : 1;
    uint8_t in_subtree_of_page_scale_layer : 1;
    uint8_t transform_changed : 1;
    uint8_t delegates_to_parent_for_backface : 1;
    uint8_t will_change_transform : 1;
    uint8_t pad15_[2];
    mojo::internal::Pointer<::cc::mojom::internal::ElementId_Data> element_id;
    mojo::internal::Pointer<::gfx::mojom::internal::Transform_Data> local;
    mojo::internal::Pointer<::gfx::mojom::internal::Point3F_Data> origin;
    mojo::internal::Pointer<::gfx::mojom::internal::PointF_Data> scroll_offset;
    mojo::internal::Pointer<::gfx::mojom::internal::Vector2dF_Data> snap_amount;
    uint32_t sticky_position_constraint_id_$value;
    uint32_t anchor_position_scroll_data_id_$value;
    int32_t sorting_context_id;
    uint8_t pad23_[4];
    mojo::internal::Pointer<::cc::mojom::internal::ElementId_Data> visible_frame_element_id;

private:
    friend class mojo::internal::MessageFragment<TransformNode_Data>;

    TransformNode_Data();
    ~TransformNode_Data() = delete;
};
static_assert(sizeof(TransformNode_Data) == 88, "Bad sizeof(TransformNode_Data)");
// Used by TransformNode::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct TransformNode_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    TransformNode_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~TransformNode_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<TransformNode_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag TransformNode_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class ClipNode_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t id;
    int32_t parent_id;
    int32_t transform_id;
    int32_t pixel_moving_filter_id;
    mojo::internal::Pointer<::gfx::mojom::internal::RectF_Data> clip;

private:
    friend class mojo::internal::MessageFragment<ClipNode_Data>;

    ClipNode_Data();
    ~ClipNode_Data() = delete;
};
static_assert(sizeof(ClipNode_Data) == 32, "Bad sizeof(ClipNode_Data)");
// Used by ClipNode::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ClipNode_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ClipNode_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ClipNode_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ClipNode_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ClipNode_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class EffectNode_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t id;
    int32_t parent_id;
    int32_t transform_id;
    int32_t clip_id;
    mojo::internal::Pointer<::cc::mojom::internal::ElementId_Data> element_id;
    float opacity;
    uint8_t has_render_surface : 1;
    uint8_t pad6_[3];
    mojo::internal::Pointer<::gfx::mojom::internal::Vector2dF_Data> surface_contents_scale;
    uint32_t blend_mode;
    int32_t target_id;

private:
    friend class mojo::internal::MessageFragment<EffectNode_Data>;

    EffectNode_Data();
    ~EffectNode_Data() = delete;
};
static_assert(sizeof(EffectNode_Data) == 56, "Bad sizeof(EffectNode_Data)");
// Used by EffectNode::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct EffectNode_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    EffectNode_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~EffectNode_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<EffectNode_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag EffectNode_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class ScrollNode_Data {
public:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    mojo::internal::StructHeader header_;
    int32_t id;
    int32_t parent_id;
    int32_t transform_id;
    uint8_t max_scroll_offset_affected_by_page_scale : 1;
    uint8_t scrolls_inner_viewport : 1;
    uint8_t scrolls_outer_viewport : 1;
    uint8_t prevent_viewport_scrolling_from_inner : 1;
    uint8_t user_scrollable_horizontal : 1;
    uint8_t user_scrollable_vertical : 1;
    uint8_t is_composited : 1;
    uint8_t pad9_[3];
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> container_bounds;
    mojo::internal::Pointer<::gfx::mojom::internal::Size_Data> bounds;
    mojo::internal::Pointer<::cc::mojom::internal::ElementId_Data> element_id;

private:
    friend class mojo::internal::MessageFragment<ScrollNode_Data>;

    ScrollNode_Data();
    ~ScrollNode_Data() = delete;
};
static_assert(sizeof(ScrollNode_Data) == 48, "Bad sizeof(ScrollNode_Data)");
// Used by ScrollNode::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView> struct ScrollNode_UnserializedMessageContext : public mojo::internal::UnserializedMessageContext {
public:
    static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

    ScrollNode_UnserializedMessageContext(uint32_t message_name, uint32_t message_flags, UserType input)
        : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
        , user_data_(std::move(input))
    {
    }
    ~ScrollNode_UnserializedMessageContext() override = default;

    UserType TakeData()
    {
        return std::move(user_data_);
    }

private:
    // mojo::internal::UnserializedMessageContext:
    void Serialize(mojo::Message& message) override
    {
        mojo::internal::MessageFragment<ScrollNode_Data> fragment(message);
        mojo::internal::Serialize<DataView>(user_data_, fragment);
    }

    UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag ScrollNode_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

} // namespace internal

} // viz::mojom

#endif // SERVICES_VIZ_PUBLIC_MOJOM_COMPOSITING_LAYER_MOJOM_SHARED_INTERNAL_H_
