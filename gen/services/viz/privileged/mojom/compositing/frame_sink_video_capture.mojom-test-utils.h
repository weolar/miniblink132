// services/viz/privileged/mojom/compositing/frame_sink_video_capture.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_FRAME_SINK_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_
#define SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_FRAME_SINK_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_

#include "services/viz/privileged/mojom/compositing/frame_sink_video_capture.mojom.h"

namespace viz::mojom {

class FrameSinkVideoConsumerFrameCallbacksInterceptorForTesting : public FrameSinkVideoConsumerFrameCallbacks {
    virtual FrameSinkVideoConsumerFrameCallbacks* GetForwardingInterface() = 0;
    void Done() override;
    void ProvideFeedback(const ::media::VideoCaptureFeedback& feedback) override;
};
class FrameSinkVideoConsumerFrameCallbacksAsyncWaiter {
public:
    explicit FrameSinkVideoConsumerFrameCallbacksAsyncWaiter(FrameSinkVideoConsumerFrameCallbacks* proxy);

    FrameSinkVideoConsumerFrameCallbacksAsyncWaiter(const FrameSinkVideoConsumerFrameCallbacksAsyncWaiter&) = delete;
    FrameSinkVideoConsumerFrameCallbacksAsyncWaiter& operator=(const FrameSinkVideoConsumerFrameCallbacksAsyncWaiter&) = delete;

    ~FrameSinkVideoConsumerFrameCallbacksAsyncWaiter();

private:
    FrameSinkVideoConsumerFrameCallbacks* const proxy_;
};

class FrameSinkVideoConsumerInterceptorForTesting : public FrameSinkVideoConsumer {
    virtual FrameSinkVideoConsumer* GetForwardingInterface() = 0;
    void OnFrameCaptured(::media::mojom::VideoBufferHandlePtr data, ::media::mojom::VideoFrameInfoPtr info, const ::gfx::Rect& content_rect,
        ::mojo::PendingRemote<FrameSinkVideoConsumerFrameCallbacks> callbacks) override;
    void OnNewSubCaptureTargetVersion(uint32_t sub_capture_target_version) override;
    void OnFrameWithEmptyRegionCapture() override;
    void OnStopped() override;
    void OnLog(const std::string& message) override;
};
class FrameSinkVideoConsumerAsyncWaiter {
public:
    explicit FrameSinkVideoConsumerAsyncWaiter(FrameSinkVideoConsumer* proxy);

    FrameSinkVideoConsumerAsyncWaiter(const FrameSinkVideoConsumerAsyncWaiter&) = delete;
    FrameSinkVideoConsumerAsyncWaiter& operator=(const FrameSinkVideoConsumerAsyncWaiter&) = delete;

    ~FrameSinkVideoConsumerAsyncWaiter();

private:
    FrameSinkVideoConsumer* const proxy_;
};

class FrameSinkVideoCapturerInterceptorForTesting : public FrameSinkVideoCapturer {
    virtual FrameSinkVideoCapturer* GetForwardingInterface() = 0;
    void SetFormat(::media::VideoPixelFormat format) override;
    void SetMinCapturePeriod(::base::TimeDelta min_period) override;
    void SetMinSizeChangePeriod(::base::TimeDelta min_period) override;
    void SetResolutionConstraints(const ::gfx::Size& min_size, const ::gfx::Size& max_size, bool use_fixed_aspect_ratio) override;
    void SetAutoThrottlingEnabled(bool enabled) override;
    void ChangeTarget(const std::optional<::viz::VideoCaptureTarget>& target, uint32_t sub_capture_target_version) override;
    void Start(::mojo::PendingRemote<FrameSinkVideoConsumer> consumer, BufferFormatPreference buffer_format_preference) override;
    void Stop() override;
    void RequestRefreshFrame() override;
    void CreateOverlay(int32_t stacking_index, ::mojo::PendingReceiver<FrameSinkVideoCaptureOverlay> receiver) override;
};
class FrameSinkVideoCapturerAsyncWaiter {
public:
    explicit FrameSinkVideoCapturerAsyncWaiter(FrameSinkVideoCapturer* proxy);

    FrameSinkVideoCapturerAsyncWaiter(const FrameSinkVideoCapturerAsyncWaiter&) = delete;
    FrameSinkVideoCapturerAsyncWaiter& operator=(const FrameSinkVideoCapturerAsyncWaiter&) = delete;

    ~FrameSinkVideoCapturerAsyncWaiter();

private:
    FrameSinkVideoCapturer* const proxy_;
};

class FrameSinkVideoCaptureOverlayInterceptorForTesting : public FrameSinkVideoCaptureOverlay {
    virtual FrameSinkVideoCaptureOverlay* GetForwardingInterface() = 0;
    void SetImageAndBounds(const ::SkBitmap& image, const ::gfx::RectF& bounds) override;
    void SetBounds(const ::gfx::RectF& bounds) override;
    void OnCapturedMouseEvent(const ::gfx::Point& coordinates) override;
};
class FrameSinkVideoCaptureOverlayAsyncWaiter {
public:
    explicit FrameSinkVideoCaptureOverlayAsyncWaiter(FrameSinkVideoCaptureOverlay* proxy);

    FrameSinkVideoCaptureOverlayAsyncWaiter(const FrameSinkVideoCaptureOverlayAsyncWaiter&) = delete;
    FrameSinkVideoCaptureOverlayAsyncWaiter& operator=(const FrameSinkVideoCaptureOverlayAsyncWaiter&) = delete;

    ~FrameSinkVideoCaptureOverlayAsyncWaiter();

private:
    FrameSinkVideoCaptureOverlay* const proxy_;
};

} // viz::mojom

#endif // SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_FRAME_SINK_VIDEO_CAPTURE_MOJOM_TEST_UTILS_H_
