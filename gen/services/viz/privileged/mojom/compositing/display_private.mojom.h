// services/viz/privileged/mojom/compositing/display_private.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_DISPLAY_PRIVATE_MOJOM_H_
#define SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_DISPLAY_PRIVATE_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/viz/privileged/mojom/compositing/display_private.mojom-features.h" // IWYU pragma: export
#include "services/viz/privileged/mojom/compositing/display_private.mojom-shared.h" // IWYU pragma: export
#include "services/viz/privileged/mojom/compositing/display_private.mojom-forward.h" // IWYU pragma: export
#include "gpu/ipc/common/context_result.mojom-forward.h"
#include "gpu/ipc/common/surface_handle.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "ui/display/mojom/display_constants.mojom.h"
#include "ui/gfx/mojom/ca_layer_params.mojom-forward.h"
#include "ui/gfx/mojom/delegated_ink_point_renderer.mojom-forward.h"
#include "ui/gfx/mojom/display_color_spaces.mojom.h"
#include "ui/gfx/mojom/overlay_transform.mojom-forward.h"
#include "ui/gfx/mojom/transform.mojom.h"
#include "ui/gfx/geometry/mojom/geometry.mojom.h"
#include "ui/latency/mojom/latency_info.mojom-forward.h"
#include "services/viz/privileged/mojom/compositing/begin_frame_observer.mojom-forward.h"
#include "services/viz/privileged/mojom/compositing/layered_window_updater.mojom-forward.h"
#include "services/viz/privileged/mojom/compositing/vsync_parameter_observer.mojom-forward.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

namespace viz::mojom {

class DisplayPrivateProxy;

template <typename ImplRefTraits> class DisplayPrivateStub;

class DisplayPrivateRequestValidator;
class DisplayPrivateResponseValidator;

class DisplayPrivate : public DisplayPrivateInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static inline constexpr uint32_t kSyncMethodOrdinals[] = { 1 };
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = DisplayPrivateInterfaceBase;
    using Proxy_ = DisplayPrivateProxy;

    template <typename ImplRefTraits> using Stub_ = DisplayPrivateStub<ImplRefTraits>;

    using RequestValidator_ = DisplayPrivateRequestValidator;
    using ResponseValidator_ = DisplayPrivateResponseValidator;
    enum MethodMinVersions : uint32_t {
        kSetDisplayVisibleMinVersion = 0,
        kDisableSwapUntilResizeMinVersion = 0,
        kResizeMinVersion = 0,
        kSetDisplayColorMatrixMinVersion = 0,
        kSetDisplayColorSpacesMinVersion = 0,
        kSetOutputIsSecureMinVersion = 0,
        kSetDisplayVSyncParametersMinVersion = 0,
        kForceImmediateDrawAndSwapIfPossibleMinVersion = 0,
        kAddVSyncParameterObserverMinVersion = 0,
        kSetDelegatedInkPointRendererMinVersion = 0,
        kSetStandaloneBeginFrameObserverMinVersion = 0,
        kSetMaxVSyncAndVrrMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct SetDisplayVisible_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DisableSwapUntilResize_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Resize_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetDisplayColorMatrix_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetDisplayColorSpaces_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetOutputIsSecure_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetDisplayVSyncParameters_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ForceImmediateDrawAndSwapIfPossible_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct AddVSyncParameterObserver_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetDelegatedInkPointRenderer_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetStandaloneBeginFrameObserver_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetMaxVSyncAndVrr_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~DisplayPrivate() = default;

    virtual void SetDisplayVisible(bool visible) = 0;

    // Sync method. This signature is used by the client side; the service side
    // should implement the signature with callback below.

    virtual bool DisableSwapUntilResize();

    using DisableSwapUntilResizeCallback = base::OnceCallback<void()>;

    virtual void DisableSwapUntilResize(DisableSwapUntilResizeCallback callback) = 0;

    virtual void Resize(const ::gfx::Size& size) = 0;

    virtual void SetDisplayColorMatrix(const ::gfx::Transform& color_matrix) = 0;

    virtual void SetDisplayColorSpaces(const ::gfx::DisplayColorSpaces& display_color_spaces) = 0;

    virtual void SetOutputIsSecure(bool secure) = 0;

    virtual void SetDisplayVSyncParameters(::base::TimeTicks timebase, ::base::TimeDelta interval) = 0;

    virtual void ForceImmediateDrawAndSwapIfPossible() = 0;

    virtual void AddVSyncParameterObserver(::mojo::PendingRemote<::viz::mojom::VSyncParameterObserver> observer) = 0;

    virtual void SetDelegatedInkPointRenderer(::mojo::PendingReceiver<::gfx::mojom::DelegatedInkPointRenderer> receiver) = 0;

    virtual void SetStandaloneBeginFrameObserver(::mojo::PendingRemote<::viz::mojom::BeginFrameObserver> observer) = 0;

    virtual void SetMaxVSyncAndVrr(std::optional<::base::TimeDelta> max_vsync_interval, ::display::VariableRefreshRateState vrr_state) = 0;
};

class DisplayClientProxy;

template <typename ImplRefTraits> class DisplayClientStub;

class DisplayClientRequestValidator;

class DisplayClient : public DisplayClientInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = DisplayClientInterfaceBase;
    using Proxy_ = DisplayClientProxy;

    template <typename ImplRefTraits> using Stub_ = DisplayClientStub<ImplRefTraits>;

    using RequestValidator_ = DisplayClientRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kCreateLayeredWindowUpdaterMinVersion = 0,
        kAddChildWindowToBrowserMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct CreateLayeredWindowUpdater_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct AddChildWindowToBrowser_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~DisplayClient() = default;

    virtual void CreateLayeredWindowUpdater(::mojo::PendingReceiver<::viz::mojom::LayeredWindowUpdater> receiver) = 0;

    virtual void AddChildWindowToBrowser(::gpu::SurfaceHandle child_window) = 0;
};

class DisplayPrivateProxy : public DisplayPrivate {
public:
    using InterfaceType = DisplayPrivate;

    explicit DisplayPrivateProxy(mojo::MessageReceiverWithResponder* receiver);

    void SetDisplayVisible(bool visible) final;

    bool DisableSwapUntilResize() final;

    void DisableSwapUntilResize(DisableSwapUntilResizeCallback callback) final;

    void Resize(const ::gfx::Size& size) final;

    void SetDisplayColorMatrix(const ::gfx::Transform& color_matrix) final;

    void SetDisplayColorSpaces(const ::gfx::DisplayColorSpaces& display_color_spaces) final;

    void SetOutputIsSecure(bool secure) final;

    void SetDisplayVSyncParameters(::base::TimeTicks timebase, ::base::TimeDelta interval) final;

    void ForceImmediateDrawAndSwapIfPossible() final;

    void AddVSyncParameterObserver(::mojo::PendingRemote<::viz::mojom::VSyncParameterObserver> observer) final;

    void SetDelegatedInkPointRenderer(::mojo::PendingReceiver<::gfx::mojom::DelegatedInkPointRenderer> receiver) final;

    void SetStandaloneBeginFrameObserver(::mojo::PendingRemote<::viz::mojom::BeginFrameObserver> observer) final;

    void SetMaxVSyncAndVrr(std::optional<::base::TimeDelta> max_vsync_interval, ::display::VariableRefreshRateState vrr_state) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class DisplayClientProxy : public DisplayClient {
public:
    using InterfaceType = DisplayClient;

    explicit DisplayClientProxy(mojo::MessageReceiverWithResponder* receiver);

    void CreateLayeredWindowUpdater(::mojo::PendingReceiver<::viz::mojom::LayeredWindowUpdater> receiver) final;

    void AddChildWindowToBrowser(::gpu::SurfaceHandle child_window) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};
class DisplayPrivateStubDispatch {
public:
    static bool Accept(DisplayPrivate* impl, mojo::Message* message);
    static bool AcceptWithResponder(DisplayPrivate* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<DisplayPrivate>> class DisplayPrivateStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    DisplayPrivateStub() = default;
//    ~DisplayPrivateStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return DisplayPrivateStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return DisplayPrivateStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class DisplayClientStubDispatch {
public:
    static bool Accept(DisplayClient* impl, mojo::Message* message);
    static bool AcceptWithResponder(DisplayClient* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<DisplayClient>> class DisplayClientStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    DisplayClientStub() = default;
//    ~DisplayClientStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return DisplayClientStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return DisplayClientStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class DisplayPrivateRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class DisplayClientRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class DisplayPrivateResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

} // viz::mojom

namespace mojo {

} // namespace mojo

#endif // SERVICES_VIZ_PRIVILEGED_MOJOM_COMPOSITING_DISPLAY_PRIVATE_MOJOM_H_
