// services/video_capture/public/mojom/video_source_provider.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIDEO_SOURCE_PROVIDER_MOJOM_TEST_UTILS_H_
#define SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIDEO_SOURCE_PROVIDER_MOJOM_TEST_UTILS_H_

#include "services/video_capture/public/mojom/video_source_provider.mojom.h"

namespace video_capture::mojom {

class VideoSourceProviderInterceptorForTesting : public VideoSourceProvider {
    virtual VideoSourceProvider* GetForwardingInterface() = 0;
    void GetSourceInfos(GetSourceInfosCallback callback) override;
    void GetVideoSource(const std::string& source_id, ::mojo::PendingReceiver<::video_capture::mojom::VideoSource> stream) override;
    void AddSharedMemoryVirtualDevice(const ::media::VideoCaptureDeviceInfo& device_info, ::mojo::PendingRemote<::video_capture::mojom::Producer> producer,
        ::mojo::PendingReceiver<::video_capture::mojom::SharedMemoryVirtualDevice> virtual_device_receiver) override;
    void AddTextureVirtualDevice(const ::media::VideoCaptureDeviceInfo& device_info,
        ::mojo::PendingReceiver<::video_capture::mojom::TextureVirtualDevice> virtual_device_receiver) override;
    void RegisterVirtualDevicesChangedObserver(
        ::mojo::PendingRemote<::video_capture::mojom::DevicesChangedObserver> observer, bool raise_event_if_virtual_devices_already_present) override;
    void RegisterDevicesChangedObserver(::mojo::PendingRemote<::video_capture::mojom::DevicesChangedObserver> observer) override;
    void Close(CloseCallback callback) override;
};
class VideoSourceProviderAsyncWaiter {
public:
    explicit VideoSourceProviderAsyncWaiter(VideoSourceProvider* proxy);

    VideoSourceProviderAsyncWaiter(const VideoSourceProviderAsyncWaiter&) = delete;
    VideoSourceProviderAsyncWaiter& operator=(const VideoSourceProviderAsyncWaiter&) = delete;

    ~VideoSourceProviderAsyncWaiter();
    void GetSourceInfos(VideoSourceProvider::GetSourceInfosResult* out_result, std::vector<::media::VideoCaptureDeviceInfo>* out_source_infos);

    void Close();

private:
    VideoSourceProvider* const proxy_;
};

} // video_capture::mojom

#endif // SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIDEO_SOURCE_PROVIDER_MOJOM_TEST_UTILS_H_
