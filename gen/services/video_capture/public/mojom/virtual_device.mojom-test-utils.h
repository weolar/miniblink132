// services/video_capture/public/mojom/virtual_device.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIRTUAL_DEVICE_MOJOM_TEST_UTILS_H_
#define SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIRTUAL_DEVICE_MOJOM_TEST_UTILS_H_

#include "services/video_capture/public/mojom/virtual_device.mojom.h"

namespace video_capture::mojom {

class SharedMemoryVirtualDeviceInterceptorForTesting : public SharedMemoryVirtualDevice {
    virtual SharedMemoryVirtualDevice* GetForwardingInterface() = 0;
    void RequestFrameBuffer(const ::gfx::Size& dimension, ::media::VideoPixelFormat pixel_format, ::media::mojom::PlaneStridesPtr strides,
        RequestFrameBufferCallback callback) override;
    void OnFrameReadyInBuffer(int32_t buffer_id, ::media::mojom::VideoFrameInfoPtr frame_info) override;
};
class SharedMemoryVirtualDeviceAsyncWaiter {
public:
    explicit SharedMemoryVirtualDeviceAsyncWaiter(SharedMemoryVirtualDevice* proxy);

    SharedMemoryVirtualDeviceAsyncWaiter(const SharedMemoryVirtualDeviceAsyncWaiter&) = delete;
    SharedMemoryVirtualDeviceAsyncWaiter& operator=(const SharedMemoryVirtualDeviceAsyncWaiter&) = delete;

    ~SharedMemoryVirtualDeviceAsyncWaiter();
    void RequestFrameBuffer(
        const ::gfx::Size& dimension, ::media::VideoPixelFormat pixel_format, ::media::mojom::PlaneStridesPtr strides, int32_t* out_buffer_id);
    int32_t RequestFrameBuffer(const ::gfx::Size& dimension, ::media::VideoPixelFormat pixel_format, ::media::mojom::PlaneStridesPtr strides);

private:
    SharedMemoryVirtualDevice* const proxy_;
};

class TextureVirtualDeviceInterceptorForTesting : public TextureVirtualDevice {
    virtual TextureVirtualDevice* GetForwardingInterface() = 0;
    void OnNewSharedImageBufferHandle(int32_t buffer_id, ::media::mojom::SharedImageBufferHandleSetPtr shared_image_handle) override;
    void OnFrameAccessHandlerReady(::mojo::PendingRemote<::video_capture::mojom::VideoFrameAccessHandler> frame_access_handler) override;
    void OnFrameReadyInBuffer(int32_t buffer_id, ::media::mojom::VideoFrameInfoPtr frame_info) override;
    void OnBufferRetired(int32_t buffer_id) override;
};
class TextureVirtualDeviceAsyncWaiter {
public:
    explicit TextureVirtualDeviceAsyncWaiter(TextureVirtualDevice* proxy);

    TextureVirtualDeviceAsyncWaiter(const TextureVirtualDeviceAsyncWaiter&) = delete;
    TextureVirtualDeviceAsyncWaiter& operator=(const TextureVirtualDeviceAsyncWaiter&) = delete;

    ~TextureVirtualDeviceAsyncWaiter();

private:
    TextureVirtualDevice* const proxy_;
};

class GpuMemoryBufferVirtualDeviceInterceptorForTesting : public GpuMemoryBufferVirtualDevice {
    virtual GpuMemoryBufferVirtualDevice* GetForwardingInterface() = 0;
    void OnNewGpuMemoryBufferHandle(int32_t buffer_id, ::gfx::GpuMemoryBufferHandle gmb_handle) override;
    void OnFrameAccessHandlerReady(::mojo::PendingRemote<::video_capture::mojom::VideoFrameAccessHandler> frame_access_handler) override;
    void OnFrameReadyInBuffer(int32_t buffer_id, ::media::mojom::VideoFrameInfoPtr frame_info) override;
    void OnBufferRetired(int32_t buffer_id) override;
};
class GpuMemoryBufferVirtualDeviceAsyncWaiter {
public:
    explicit GpuMemoryBufferVirtualDeviceAsyncWaiter(GpuMemoryBufferVirtualDevice* proxy);

    GpuMemoryBufferVirtualDeviceAsyncWaiter(const GpuMemoryBufferVirtualDeviceAsyncWaiter&) = delete;
    GpuMemoryBufferVirtualDeviceAsyncWaiter& operator=(const GpuMemoryBufferVirtualDeviceAsyncWaiter&) = delete;

    ~GpuMemoryBufferVirtualDeviceAsyncWaiter();

private:
    GpuMemoryBufferVirtualDevice* const proxy_;
};

} // video_capture::mojom

#endif // SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIRTUAL_DEVICE_MOJOM_TEST_UTILS_H_
