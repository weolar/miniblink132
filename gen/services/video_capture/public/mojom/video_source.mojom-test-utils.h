// services/video_capture/public/mojom/video_source.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIDEO_SOURCE_MOJOM_TEST_UTILS_H_
#define SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIDEO_SOURCE_MOJOM_TEST_UTILS_H_

#include "services/video_capture/public/mojom/video_source.mojom.h"

namespace video_capture::mojom {

class PushVideoStreamSubscriptionInterceptorForTesting : public PushVideoStreamSubscription {
    virtual PushVideoStreamSubscription* GetForwardingInterface() = 0;
    void Activate() override;
    void Suspend(SuspendCallback callback) override;
    void Resume() override;
    void GetPhotoState(GetPhotoStateCallback callback) override;
    void SetPhotoOptions(::media::mojom::PhotoSettingsPtr settings, SetPhotoOptionsCallback callback) override;
    void TakePhoto(TakePhotoCallback callback) override;
    void Close(CloseCallback callback) override;
    void ProcessFeedback(const ::media::VideoCaptureFeedback& feedback) override;
};
class PushVideoStreamSubscriptionAsyncWaiter {
public:
    explicit PushVideoStreamSubscriptionAsyncWaiter(PushVideoStreamSubscription* proxy);

    PushVideoStreamSubscriptionAsyncWaiter(const PushVideoStreamSubscriptionAsyncWaiter&) = delete;
    PushVideoStreamSubscriptionAsyncWaiter& operator=(const PushVideoStreamSubscriptionAsyncWaiter&) = delete;

    ~PushVideoStreamSubscriptionAsyncWaiter();
    void Suspend();

    void GetPhotoState(::media::mojom::PhotoStatePtr* out_capabilities);
    ::media::mojom::PhotoStatePtr GetPhotoState();
    void SetPhotoOptions(::media::mojom::PhotoSettingsPtr settings, bool* out_success);
    bool SetPhotoOptions(::media::mojom::PhotoSettingsPtr settings);
    void TakePhoto(::media::mojom::BlobPtr* out_blob);
    ::media::mojom::BlobPtr TakePhoto();
    void Close();

private:
    PushVideoStreamSubscription* const proxy_;
};

class VideoSourceInterceptorForTesting : public VideoSource {
    virtual VideoSource* GetForwardingInterface() = 0;
    void CreatePushSubscription(::mojo::PendingRemote<::video_capture::mojom::VideoFrameHandler> subscriber,
        const ::media::VideoCaptureParams& requested_settings, bool force_reopen_with_new_settings,
        ::mojo::PendingReceiver<PushVideoStreamSubscription> subscription, CreatePushSubscriptionCallback callback) override;
    void RegisterVideoEffectsProcessor(::mojo::PendingRemote<::video_effects::mojom::VideoEffectsProcessor> remote) override;
};
class VideoSourceAsyncWaiter {
public:
    explicit VideoSourceAsyncWaiter(VideoSource* proxy);

    VideoSourceAsyncWaiter(const VideoSourceAsyncWaiter&) = delete;
    VideoSourceAsyncWaiter& operator=(const VideoSourceAsyncWaiter&) = delete;

    ~VideoSourceAsyncWaiter();
    void CreatePushSubscription(::mojo::PendingRemote<::video_capture::mojom::VideoFrameHandler> subscriber,
        const ::media::VideoCaptureParams& requested_settings, bool force_reopen_with_new_settings,
        ::mojo::PendingReceiver<PushVideoStreamSubscription> subscription, CreatePushSubscriptionResultCodePtr* out_result_code,
        ::media::VideoCaptureParams* out_settings_source_was_opened_with);

private:
    VideoSource* const proxy_;
};

} // video_capture::mojom

#endif // SERVICES_VIDEO_CAPTURE_PUBLIC_MOJOM_VIDEO_SOURCE_MOJOM_TEST_UTILS_H_
