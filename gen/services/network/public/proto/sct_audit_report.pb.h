// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sct_audit_report.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sct_5faudit_5freport_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sct_5faudit_5freport_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sct_5faudit_5freport_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sct_5faudit_5freport_2eproto {
    static const uint32_t offsets[];
};
namespace sct_auditing {
class SCTClientReport;
struct SCTClientReportDefaultTypeInternal;
extern SCTClientReportDefaultTypeInternal _SCTClientReport_default_instance_;
class SCTWithVerifyStatus;
struct SCTWithVerifyStatusDefaultTypeInternal;
extern SCTWithVerifyStatusDefaultTypeInternal _SCTWithVerifyStatus_default_instance_;
class TLSConnectionContext;
struct TLSConnectionContextDefaultTypeInternal;
extern TLSConnectionContextDefaultTypeInternal _TLSConnectionContext_default_instance_;
class TLSConnectionContext_Origin;
struct TLSConnectionContext_OriginDefaultTypeInternal;
extern TLSConnectionContext_OriginDefaultTypeInternal _TLSConnectionContext_Origin_default_instance_;
class TLSConnectionReport;
struct TLSConnectionReportDefaultTypeInternal;
extern TLSConnectionReportDefaultTypeInternal _TLSConnectionReport_default_instance_;
} // namespace sct_auditing
PROTOBUF_NAMESPACE_OPEN
template <>::sct_auditing::SCTClientReport* Arena::CreateMaybeMessage<::sct_auditing::SCTClientReport>(Arena*);
template <>::sct_auditing::SCTWithVerifyStatus* Arena::CreateMaybeMessage<::sct_auditing::SCTWithVerifyStatus>(Arena*);
template <>::sct_auditing::TLSConnectionContext* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionContext>(Arena*);
template <>::sct_auditing::TLSConnectionContext_Origin* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionContext_Origin>(Arena*);
template <>::sct_auditing::TLSConnectionReport* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionReport>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sct_auditing {

enum SCTWithVerifyStatus_SctVerifyStatus : int {
    SCTWithVerifyStatus_SctVerifyStatus_NONE = 0,
    SCTWithVerifyStatus_SctVerifyStatus_LOG_UNKNOWN = 1,
    SCTWithVerifyStatus_SctVerifyStatus_OK = 3,
    SCTWithVerifyStatus_SctVerifyStatus_INVALID_SIGNATURE = 4,
    SCTWithVerifyStatus_SctVerifyStatus_INVALID_TIMESTAMP = 5,
    SCTWithVerifyStatus_SctVerifyStatus_SCTWithVerifyStatus_SctVerifyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
    SCTWithVerifyStatus_SctVerifyStatus_SCTWithVerifyStatus_SctVerifyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SCTWithVerifyStatus_SctVerifyStatus_IsValid(int value);
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MIN = SCTWithVerifyStatus_SctVerifyStatus_NONE;
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MAX = SCTWithVerifyStatus_SctVerifyStatus_INVALID_TIMESTAMP;
constexpr int SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_ARRAYSIZE = SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MAX + 1;

const std::string& SCTWithVerifyStatus_SctVerifyStatus_Name(SCTWithVerifyStatus_SctVerifyStatus value);
template <typename T> inline const std::string& SCTWithVerifyStatus_SctVerifyStatus_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, SCTWithVerifyStatus_SctVerifyStatus>::value || ::std::is_integral<T>::value,
        "Incorrect type passed to function SCTWithVerifyStatus_SctVerifyStatus_Name.");
    return SCTWithVerifyStatus_SctVerifyStatus_Name(static_cast<SCTWithVerifyStatus_SctVerifyStatus>(enum_t_value));
}
bool SCTWithVerifyStatus_SctVerifyStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SCTWithVerifyStatus_SctVerifyStatus* value);
// ===================================================================

class SCTClientReport final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.SCTClientReport) */ {
public:
    inline SCTClientReport()
        : SCTClientReport(nullptr)
    {
    }
    ~SCTClientReport() override;
    explicit PROTOBUF_CONSTEXPR SCTClientReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SCTClientReport(const SCTClientReport& from);
    SCTClientReport(SCTClientReport&& from) noexcept
        : SCTClientReport()
    {
        *this = ::std::move(from);
    }

    inline SCTClientReport& operator=(const SCTClientReport& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SCTClientReport& operator=(SCTClientReport&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SCTClientReport& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SCTClientReport* internal_default_instance()
    {
        return reinterpret_cast<const SCTClientReport*>(&_SCTClientReport_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(SCTClientReport& a, SCTClientReport& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SCTClientReport* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SCTClientReport* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SCTClientReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SCTClientReport>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SCTClientReport& from);
    void MergeFrom(const SCTClientReport& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SCTClientReport* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sct_auditing.SCTClientReport";
    }

protected:
    explicit SCTClientReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCertificateReportFieldNumber = 2,
        kUserAgentFieldNumber = 1,
    };
    // repeated .sct_auditing.TLSConnectionReport certificate_report = 2;
    int certificate_report_size() const;

private:
    int _internal_certificate_report_size() const;

public:
    void clear_certificate_report();
    ::sct_auditing::TLSConnectionReport* mutable_certificate_report(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::TLSConnectionReport>* mutable_certificate_report();

private:
    const ::sct_auditing::TLSConnectionReport& _internal_certificate_report(int index) const;
    ::sct_auditing::TLSConnectionReport* _internal_add_certificate_report();

public:
    const ::sct_auditing::TLSConnectionReport& certificate_report(int index) const;
    ::sct_auditing::TLSConnectionReport* add_certificate_report();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::TLSConnectionReport>& certificate_report() const;

    // string user_agent = 1;
    void clear_user_agent();
    const std::string& user_agent() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_user_agent(ArgT0&& arg0, ArgT... args);
    std::string* mutable_user_agent();
    PROTOBUF_NODISCARD std::string* release_user_agent();
    void set_allocated_user_agent(std::string* user_agent);

private:
    const std::string& _internal_user_agent() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
    std::string* _internal_mutable_user_agent();

public:
    // @@protoc_insertion_point(class_scope:sct_auditing.SCTClientReport)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::TLSConnectionReport> certificate_report_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// -------------------------------------------------------------------

class TLSConnectionReport final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.TLSConnectionReport) */ {
public:
    inline TLSConnectionReport()
        : TLSConnectionReport(nullptr)
    {
    }
    ~TLSConnectionReport() override;
    explicit PROTOBUF_CONSTEXPR TLSConnectionReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TLSConnectionReport(const TLSConnectionReport& from);
    TLSConnectionReport(TLSConnectionReport&& from) noexcept
        : TLSConnectionReport()
    {
        *this = ::std::move(from);
    }

    inline TLSConnectionReport& operator=(const TLSConnectionReport& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TLSConnectionReport& operator=(TLSConnectionReport&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const TLSConnectionReport& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TLSConnectionReport* internal_default_instance()
    {
        return reinterpret_cast<const TLSConnectionReport*>(&_TLSConnectionReport_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(TLSConnectionReport& a, TLSConnectionReport& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TLSConnectionReport* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TLSConnectionReport* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TLSConnectionReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TLSConnectionReport>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TLSConnectionReport& from);
    void MergeFrom(const TLSConnectionReport& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TLSConnectionReport* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sct_auditing.TLSConnectionReport";
    }

protected:
    explicit TLSConnectionReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kIncludedSctFieldNumber = 2,
        kContextFieldNumber = 1,
    };
    // repeated .sct_auditing.SCTWithVerifyStatus included_sct = 2;
    int included_sct_size() const;

private:
    int _internal_included_sct_size() const;

public:
    void clear_included_sct();
    ::sct_auditing::SCTWithVerifyStatus* mutable_included_sct(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::SCTWithVerifyStatus>* mutable_included_sct();

private:
    const ::sct_auditing::SCTWithVerifyStatus& _internal_included_sct(int index) const;
    ::sct_auditing::SCTWithVerifyStatus* _internal_add_included_sct();

public:
    const ::sct_auditing::SCTWithVerifyStatus& included_sct(int index) const;
    ::sct_auditing::SCTWithVerifyStatus* add_included_sct();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::SCTWithVerifyStatus>& included_sct() const;

    // .sct_auditing.TLSConnectionContext context = 1;
    bool has_context() const;

private:
    bool _internal_has_context() const;

public:
    void clear_context();
    const ::sct_auditing::TLSConnectionContext& context() const;
    PROTOBUF_NODISCARD ::sct_auditing::TLSConnectionContext* release_context();
    ::sct_auditing::TLSConnectionContext* mutable_context();
    void set_allocated_context(::sct_auditing::TLSConnectionContext* context);

private:
    const ::sct_auditing::TLSConnectionContext& _internal_context() const;
    ::sct_auditing::TLSConnectionContext* _internal_mutable_context();

public:
    void unsafe_arena_set_allocated_context(::sct_auditing::TLSConnectionContext* context);
    ::sct_auditing::TLSConnectionContext* unsafe_arena_release_context();

    // @@protoc_insertion_point(class_scope:sct_auditing.TLSConnectionReport)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::SCTWithVerifyStatus> included_sct_;
        ::sct_auditing::TLSConnectionContext* context_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// -------------------------------------------------------------------

class TLSConnectionContext_Origin final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.TLSConnectionContext.Origin) */ {
public:
    inline TLSConnectionContext_Origin()
        : TLSConnectionContext_Origin(nullptr)
    {
    }
    ~TLSConnectionContext_Origin() override;
    explicit PROTOBUF_CONSTEXPR TLSConnectionContext_Origin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TLSConnectionContext_Origin(const TLSConnectionContext_Origin& from);
    TLSConnectionContext_Origin(TLSConnectionContext_Origin&& from) noexcept
        : TLSConnectionContext_Origin()
    {
        *this = ::std::move(from);
    }

    inline TLSConnectionContext_Origin& operator=(const TLSConnectionContext_Origin& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TLSConnectionContext_Origin& operator=(TLSConnectionContext_Origin&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const TLSConnectionContext_Origin& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TLSConnectionContext_Origin* internal_default_instance()
    {
        return reinterpret_cast<const TLSConnectionContext_Origin*>(&_TLSConnectionContext_Origin_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(TLSConnectionContext_Origin& a, TLSConnectionContext_Origin& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TLSConnectionContext_Origin* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TLSConnectionContext_Origin* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TLSConnectionContext_Origin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TLSConnectionContext_Origin>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TLSConnectionContext_Origin& from);
    void MergeFrom(const TLSConnectionContext_Origin& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TLSConnectionContext_Origin* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sct_auditing.TLSConnectionContext.Origin";
    }

protected:
    explicit TLSConnectionContext_Origin(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kHostnameFieldNumber = 1,
        kPortFieldNumber = 2,
    };
    // string hostname = 1;
    void clear_hostname();
    const std::string& hostname() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_hostname(ArgT0&& arg0, ArgT... args);
    std::string* mutable_hostname();
    PROTOBUF_NODISCARD std::string* release_hostname();
    void set_allocated_hostname(std::string* hostname);

private:
    const std::string& _internal_hostname() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
    std::string* _internal_mutable_hostname();

public:
    // int32 port = 2;
    void clear_port();
    int32_t port() const;
    void set_port(int32_t value);

private:
    int32_t _internal_port() const;
    void _internal_set_port(int32_t value);

public:
    // @@protoc_insertion_point(class_scope:sct_auditing.TLSConnectionContext.Origin)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
        int32_t port_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// -------------------------------------------------------------------

class TLSConnectionContext final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.TLSConnectionContext) */ {
public:
    inline TLSConnectionContext()
        : TLSConnectionContext(nullptr)
    {
    }
    ~TLSConnectionContext() override;
    explicit PROTOBUF_CONSTEXPR TLSConnectionContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    TLSConnectionContext(const TLSConnectionContext& from);
    TLSConnectionContext(TLSConnectionContext&& from) noexcept
        : TLSConnectionContext()
    {
        *this = ::std::move(from);
    }

    inline TLSConnectionContext& operator=(const TLSConnectionContext& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline TLSConnectionContext& operator=(TLSConnectionContext&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const TLSConnectionContext& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const TLSConnectionContext* internal_default_instance()
    {
        return reinterpret_cast<const TLSConnectionContext*>(&_TLSConnectionContext_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(TLSConnectionContext& a, TLSConnectionContext& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(TLSConnectionContext* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(TLSConnectionContext* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    TLSConnectionContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<TLSConnectionContext>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const TLSConnectionContext& from);
    void MergeFrom(const TLSConnectionContext& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(TLSConnectionContext* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sct_auditing.TLSConnectionContext";
    }

protected:
    explicit TLSConnectionContext(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef TLSConnectionContext_Origin Origin;

    // accessors -------------------------------------------------------

    enum : int {
        kCertificateChainFieldNumber = 3,
        kOriginFieldNumber = 2,
        kTimeSeenFieldNumber = 1,
    };
    // repeated bytes certificate_chain = 3;
    int certificate_chain_size() const;

private:
    int _internal_certificate_chain_size() const;

public:
    void clear_certificate_chain();
    const std::string& certificate_chain(int index) const;
    std::string* mutable_certificate_chain(int index);
    void set_certificate_chain(int index, const std::string& value);
    void set_certificate_chain(int index, std::string&& value);
    void set_certificate_chain(int index, const char* value);
    void set_certificate_chain(int index, const void* value, size_t size);
    std::string* add_certificate_chain();
    void add_certificate_chain(const std::string& value);
    void add_certificate_chain(std::string&& value);
    void add_certificate_chain(const char* value);
    void add_certificate_chain(const void* value, size_t size);
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& certificate_chain() const;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_certificate_chain();

private:
    const std::string& _internal_certificate_chain(int index) const;
    std::string* _internal_add_certificate_chain();

public:
    // .sct_auditing.TLSConnectionContext.Origin origin = 2;
    bool has_origin() const;

private:
    bool _internal_has_origin() const;

public:
    void clear_origin();
    const ::sct_auditing::TLSConnectionContext_Origin& origin() const;
    PROTOBUF_NODISCARD ::sct_auditing::TLSConnectionContext_Origin* release_origin();
    ::sct_auditing::TLSConnectionContext_Origin* mutable_origin();
    void set_allocated_origin(::sct_auditing::TLSConnectionContext_Origin* origin);

private:
    const ::sct_auditing::TLSConnectionContext_Origin& _internal_origin() const;
    ::sct_auditing::TLSConnectionContext_Origin* _internal_mutable_origin();

public:
    void unsafe_arena_set_allocated_origin(::sct_auditing::TLSConnectionContext_Origin* origin);
    ::sct_auditing::TLSConnectionContext_Origin* unsafe_arena_release_origin();

    // int64 time_seen = 1;
    void clear_time_seen();
    int64_t time_seen() const;
    void set_time_seen(int64_t value);

private:
    int64_t _internal_time_seen() const;
    void _internal_set_time_seen(int64_t value);

public:
    // @@protoc_insertion_point(class_scope:sct_auditing.TLSConnectionContext)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> certificate_chain_;
        ::sct_auditing::TLSConnectionContext_Origin* origin_;
        int64_t time_seen_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// -------------------------------------------------------------------

class SCTWithVerifyStatus final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.SCTWithVerifyStatus) */ {
public:
    inline SCTWithVerifyStatus()
        : SCTWithVerifyStatus(nullptr)
    {
    }
    ~SCTWithVerifyStatus() override;
    explicit PROTOBUF_CONSTEXPR SCTWithVerifyStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SCTWithVerifyStatus(const SCTWithVerifyStatus& from);
    SCTWithVerifyStatus(SCTWithVerifyStatus&& from) noexcept
        : SCTWithVerifyStatus()
    {
        *this = ::std::move(from);
    }

    inline SCTWithVerifyStatus& operator=(const SCTWithVerifyStatus& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SCTWithVerifyStatus& operator=(SCTWithVerifyStatus&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    static const SCTWithVerifyStatus& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SCTWithVerifyStatus* internal_default_instance()
    {
        return reinterpret_cast<const SCTWithVerifyStatus*>(&_SCTWithVerifyStatus_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(SCTWithVerifyStatus& a, SCTWithVerifyStatus& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SCTWithVerifyStatus* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SCTWithVerifyStatus* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SCTWithVerifyStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SCTWithVerifyStatus>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SCTWithVerifyStatus& from);
    void MergeFrom(const SCTWithVerifyStatus& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SCTWithVerifyStatus* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "sct_auditing.SCTWithVerifyStatus";
    }

protected:
    explicit SCTWithVerifyStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef SCTWithVerifyStatus_SctVerifyStatus SctVerifyStatus;
    static constexpr SctVerifyStatus NONE = SCTWithVerifyStatus_SctVerifyStatus_NONE;
    static constexpr SctVerifyStatus LOG_UNKNOWN = SCTWithVerifyStatus_SctVerifyStatus_LOG_UNKNOWN;
    static constexpr SctVerifyStatus OK = SCTWithVerifyStatus_SctVerifyStatus_OK;
    static constexpr SctVerifyStatus INVALID_SIGNATURE = SCTWithVerifyStatus_SctVerifyStatus_INVALID_SIGNATURE;
    static constexpr SctVerifyStatus INVALID_TIMESTAMP = SCTWithVerifyStatus_SctVerifyStatus_INVALID_TIMESTAMP;
    static inline bool SctVerifyStatus_IsValid(int value)
    {
        return SCTWithVerifyStatus_SctVerifyStatus_IsValid(value);
    }
    static constexpr SctVerifyStatus SctVerifyStatus_MIN = SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MIN;
    static constexpr SctVerifyStatus SctVerifyStatus_MAX = SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MAX;
    static constexpr int SctVerifyStatus_ARRAYSIZE = SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_ARRAYSIZE;
    template <typename T> static inline const std::string& SctVerifyStatus_Name(T enum_t_value)
    {
        static_assert(::std::is_same<T, SctVerifyStatus>::value || ::std::is_integral<T>::value, "Incorrect type passed to function SctVerifyStatus_Name.");
        return SCTWithVerifyStatus_SctVerifyStatus_Name(enum_t_value);
    }
    static inline bool SctVerifyStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SctVerifyStatus* value)
    {
        return SCTWithVerifyStatus_SctVerifyStatus_Parse(name, value);
    }

    // accessors -------------------------------------------------------

    enum : int {
        kSerializedSctFieldNumber = 2,
        kStatusFieldNumber = 1,
    };
    // bytes serialized_sct = 2;
    void clear_serialized_sct();
    const std::string& serialized_sct() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_serialized_sct(ArgT0&& arg0, ArgT... args);
    std::string* mutable_serialized_sct();
    PROTOBUF_NODISCARD std::string* release_serialized_sct();
    void set_allocated_serialized_sct(std::string* serialized_sct);

private:
    const std::string& _internal_serialized_sct() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_sct(const std::string& value);
    std::string* _internal_mutable_serialized_sct();

public:
    // .sct_auditing.SCTWithVerifyStatus.SctVerifyStatus status = 1;
    void clear_status();
    ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus status() const;
    void set_status(::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus value);

private:
    ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus _internal_status() const;
    void _internal_set_status(::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus value);

public:
    // @@protoc_insertion_point(class_scope:sct_auditing.SCTWithVerifyStatus)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_sct_;
        int status_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// SCTClientReport

// string user_agent = 1;
inline void SCTClientReport::clear_user_agent()
{
    _impl_.user_agent_.ClearToEmpty();
}
inline const std::string& SCTClientReport::user_agent() const
{
    // @@protoc_insertion_point(field_get:sct_auditing.SCTClientReport.user_agent)
    return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SCTClientReport::set_user_agent(ArgT0&& arg0, ArgT... args)
{

    _impl_.user_agent_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sct_auditing.SCTClientReport.user_agent)
}
inline std::string* SCTClientReport::mutable_user_agent()
{
    std::string* _s = _internal_mutable_user_agent();
    // @@protoc_insertion_point(field_mutable:sct_auditing.SCTClientReport.user_agent)
    return _s;
}
inline const std::string& SCTClientReport::_internal_user_agent() const
{
    return _impl_.user_agent_.Get();
}
inline void SCTClientReport::_internal_set_user_agent(const std::string& value)
{

    _impl_.user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* SCTClientReport::_internal_mutable_user_agent()
{

    return _impl_.user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* SCTClientReport::release_user_agent()
{
    // @@protoc_insertion_point(field_release:sct_auditing.SCTClientReport.user_agent)
    return _impl_.user_agent_.Release();
}
inline void SCTClientReport::set_allocated_user_agent(std::string* user_agent)
{
    if (user_agent != nullptr) {

    } else {
    }
    _impl_.user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.user_agent_.IsDefault()) {
        _impl_.user_agent_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sct_auditing.SCTClientReport.user_agent)
}

// repeated .sct_auditing.TLSConnectionReport certificate_report = 2;
inline int SCTClientReport::_internal_certificate_report_size() const
{
    return _impl_.certificate_report_.size();
}
inline int SCTClientReport::certificate_report_size() const
{
    return _internal_certificate_report_size();
}
inline void SCTClientReport::clear_certificate_report()
{
    _impl_.certificate_report_.Clear();
}
inline ::sct_auditing::TLSConnectionReport* SCTClientReport::mutable_certificate_report(int index)
{
    // @@protoc_insertion_point(field_mutable:sct_auditing.SCTClientReport.certificate_report)
    return _impl_.certificate_report_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::TLSConnectionReport>* SCTClientReport::mutable_certificate_report()
{
    // @@protoc_insertion_point(field_mutable_list:sct_auditing.SCTClientReport.certificate_report)
    return &_impl_.certificate_report_;
}
inline const ::sct_auditing::TLSConnectionReport& SCTClientReport::_internal_certificate_report(int index) const
{
    return _impl_.certificate_report_.Get(index);
}
inline const ::sct_auditing::TLSConnectionReport& SCTClientReport::certificate_report(int index) const
{
    // @@protoc_insertion_point(field_get:sct_auditing.SCTClientReport.certificate_report)
    return _internal_certificate_report(index);
}
inline ::sct_auditing::TLSConnectionReport* SCTClientReport::_internal_add_certificate_report()
{
    return _impl_.certificate_report_.Add();
}
inline ::sct_auditing::TLSConnectionReport* SCTClientReport::add_certificate_report()
{
    ::sct_auditing::TLSConnectionReport* _add = _internal_add_certificate_report();
    // @@protoc_insertion_point(field_add:sct_auditing.SCTClientReport.certificate_report)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::TLSConnectionReport>& SCTClientReport::certificate_report() const
{
    // @@protoc_insertion_point(field_list:sct_auditing.SCTClientReport.certificate_report)
    return _impl_.certificate_report_;
}

// -------------------------------------------------------------------

// TLSConnectionReport

// .sct_auditing.TLSConnectionContext context = 1;
inline bool TLSConnectionReport::_internal_has_context() const
{
    return this != internal_default_instance() && _impl_.context_ != nullptr;
}
inline bool TLSConnectionReport::has_context() const
{
    return _internal_has_context();
}
inline void TLSConnectionReport::clear_context()
{
    if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
        delete _impl_.context_;
    }
    _impl_.context_ = nullptr;
}
inline const ::sct_auditing::TLSConnectionContext& TLSConnectionReport::_internal_context() const
{
    const ::sct_auditing::TLSConnectionContext* p = _impl_.context_;
    return p != nullptr ? *p : reinterpret_cast<const ::sct_auditing::TLSConnectionContext&>(::sct_auditing::_TLSConnectionContext_default_instance_);
}
inline const ::sct_auditing::TLSConnectionContext& TLSConnectionReport::context() const
{
    // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionReport.context)
    return _internal_context();
}
inline void TLSConnectionReport::unsafe_arena_set_allocated_context(::sct_auditing::TLSConnectionContext* context)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.context_);
    }
    _impl_.context_ = context;
    if (context) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sct_auditing.TLSConnectionReport.context)
}
inline ::sct_auditing::TLSConnectionContext* TLSConnectionReport::release_context()
{

    ::sct_auditing::TLSConnectionContext* temp = _impl_.context_;
    _impl_.context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sct_auditing::TLSConnectionContext* TLSConnectionReport::unsafe_arena_release_context()
{
    // @@protoc_insertion_point(field_release:sct_auditing.TLSConnectionReport.context)

    ::sct_auditing::TLSConnectionContext* temp = _impl_.context_;
    _impl_.context_ = nullptr;
    return temp;
}
inline ::sct_auditing::TLSConnectionContext* TLSConnectionReport::_internal_mutable_context()
{

    if (_impl_.context_ == nullptr) {
        auto* p = CreateMaybeMessage<::sct_auditing::TLSConnectionContext>(GetArenaForAllocation());
        _impl_.context_ = p;
    }
    return _impl_.context_;
}
inline ::sct_auditing::TLSConnectionContext* TLSConnectionReport::mutable_context()
{
    ::sct_auditing::TLSConnectionContext* _msg = _internal_mutable_context();
    // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionReport.context)
    return _msg;
}
inline void TLSConnectionReport::set_allocated_context(::sct_auditing::TLSConnectionContext* context)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.context_;
    }
    if (context) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
        if (message_arena != submessage_arena) {
            context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, context, submessage_arena);
        }

    } else {
    }
    _impl_.context_ = context;
    // @@protoc_insertion_point(field_set_allocated:sct_auditing.TLSConnectionReport.context)
}

// repeated .sct_auditing.SCTWithVerifyStatus included_sct = 2;
inline int TLSConnectionReport::_internal_included_sct_size() const
{
    return _impl_.included_sct_.size();
}
inline int TLSConnectionReport::included_sct_size() const
{
    return _internal_included_sct_size();
}
inline void TLSConnectionReport::clear_included_sct()
{
    _impl_.included_sct_.Clear();
}
inline ::sct_auditing::SCTWithVerifyStatus* TLSConnectionReport::mutable_included_sct(int index)
{
    // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionReport.included_sct)
    return _impl_.included_sct_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::SCTWithVerifyStatus>* TLSConnectionReport::mutable_included_sct()
{
    // @@protoc_insertion_point(field_mutable_list:sct_auditing.TLSConnectionReport.included_sct)
    return &_impl_.included_sct_;
}
inline const ::sct_auditing::SCTWithVerifyStatus& TLSConnectionReport::_internal_included_sct(int index) const
{
    return _impl_.included_sct_.Get(index);
}
inline const ::sct_auditing::SCTWithVerifyStatus& TLSConnectionReport::included_sct(int index) const
{
    // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionReport.included_sct)
    return _internal_included_sct(index);
}
inline ::sct_auditing::SCTWithVerifyStatus* TLSConnectionReport::_internal_add_included_sct()
{
    return _impl_.included_sct_.Add();
}
inline ::sct_auditing::SCTWithVerifyStatus* TLSConnectionReport::add_included_sct()
{
    ::sct_auditing::SCTWithVerifyStatus* _add = _internal_add_included_sct();
    // @@protoc_insertion_point(field_add:sct_auditing.TLSConnectionReport.included_sct)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::sct_auditing::SCTWithVerifyStatus>& TLSConnectionReport::included_sct() const
{
    // @@protoc_insertion_point(field_list:sct_auditing.TLSConnectionReport.included_sct)
    return _impl_.included_sct_;
}

// -------------------------------------------------------------------

// TLSConnectionContext_Origin

// string hostname = 1;
inline void TLSConnectionContext_Origin::clear_hostname()
{
    _impl_.hostname_.ClearToEmpty();
}
inline const std::string& TLSConnectionContext_Origin::hostname() const
{
    // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.Origin.hostname)
    return _internal_hostname();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void TLSConnectionContext_Origin::set_hostname(ArgT0&& arg0, ArgT... args)
{

    _impl_.hostname_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.Origin.hostname)
}
inline std::string* TLSConnectionContext_Origin::mutable_hostname()
{
    std::string* _s = _internal_mutable_hostname();
    // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionContext.Origin.hostname)
    return _s;
}
inline const std::string& TLSConnectionContext_Origin::_internal_hostname() const
{
    return _impl_.hostname_.Get();
}
inline void TLSConnectionContext_Origin::_internal_set_hostname(const std::string& value)
{

    _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* TLSConnectionContext_Origin::_internal_mutable_hostname()
{

    return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* TLSConnectionContext_Origin::release_hostname()
{
    // @@protoc_insertion_point(field_release:sct_auditing.TLSConnectionContext.Origin.hostname)
    return _impl_.hostname_.Release();
}
inline void TLSConnectionContext_Origin::set_allocated_hostname(std::string* hostname)
{
    if (hostname != nullptr) {

    } else {
    }
    _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.hostname_.IsDefault()) {
        _impl_.hostname_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sct_auditing.TLSConnectionContext.Origin.hostname)
}

// int32 port = 2;
inline void TLSConnectionContext_Origin::clear_port()
{
    _impl_.port_ = 0;
}
inline int32_t TLSConnectionContext_Origin::_internal_port() const
{
    return _impl_.port_;
}
inline int32_t TLSConnectionContext_Origin::port() const
{
    // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.Origin.port)
    return _internal_port();
}
inline void TLSConnectionContext_Origin::_internal_set_port(int32_t value)
{

    _impl_.port_ = value;
}
inline void TLSConnectionContext_Origin::set_port(int32_t value)
{
    _internal_set_port(value);
    // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.Origin.port)
}

// -------------------------------------------------------------------

// TLSConnectionContext

// int64 time_seen = 1;
inline void TLSConnectionContext::clear_time_seen()
{
    _impl_.time_seen_ = int64_t { 0 };
}
inline int64_t TLSConnectionContext::_internal_time_seen() const
{
    return _impl_.time_seen_;
}
inline int64_t TLSConnectionContext::time_seen() const
{
    // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.time_seen)
    return _internal_time_seen();
}
inline void TLSConnectionContext::_internal_set_time_seen(int64_t value)
{

    _impl_.time_seen_ = value;
}
inline void TLSConnectionContext::set_time_seen(int64_t value)
{
    _internal_set_time_seen(value);
    // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.time_seen)
}

// .sct_auditing.TLSConnectionContext.Origin origin = 2;
inline bool TLSConnectionContext::_internal_has_origin() const
{
    return this != internal_default_instance() && _impl_.origin_ != nullptr;
}
inline bool TLSConnectionContext::has_origin() const
{
    return _internal_has_origin();
}
inline void TLSConnectionContext::clear_origin()
{
    if (GetArenaForAllocation() == nullptr && _impl_.origin_ != nullptr) {
        delete _impl_.origin_;
    }
    _impl_.origin_ = nullptr;
}
inline const ::sct_auditing::TLSConnectionContext_Origin& TLSConnectionContext::_internal_origin() const
{
    const ::sct_auditing::TLSConnectionContext_Origin* p = _impl_.origin_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::sct_auditing::TLSConnectionContext_Origin&>(::sct_auditing::_TLSConnectionContext_Origin_default_instance_);
}
inline const ::sct_auditing::TLSConnectionContext_Origin& TLSConnectionContext::origin() const
{
    // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.origin)
    return _internal_origin();
}
inline void TLSConnectionContext::unsafe_arena_set_allocated_origin(::sct_auditing::TLSConnectionContext_Origin* origin)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.origin_);
    }
    _impl_.origin_ = origin;
    if (origin) {

    } else {
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sct_auditing.TLSConnectionContext.origin)
}
inline ::sct_auditing::TLSConnectionContext_Origin* TLSConnectionContext::release_origin()
{

    ::sct_auditing::TLSConnectionContext_Origin* temp = _impl_.origin_;
    _impl_.origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::sct_auditing::TLSConnectionContext_Origin* TLSConnectionContext::unsafe_arena_release_origin()
{
    // @@protoc_insertion_point(field_release:sct_auditing.TLSConnectionContext.origin)

    ::sct_auditing::TLSConnectionContext_Origin* temp = _impl_.origin_;
    _impl_.origin_ = nullptr;
    return temp;
}
inline ::sct_auditing::TLSConnectionContext_Origin* TLSConnectionContext::_internal_mutable_origin()
{

    if (_impl_.origin_ == nullptr) {
        auto* p = CreateMaybeMessage<::sct_auditing::TLSConnectionContext_Origin>(GetArenaForAllocation());
        _impl_.origin_ = p;
    }
    return _impl_.origin_;
}
inline ::sct_auditing::TLSConnectionContext_Origin* TLSConnectionContext::mutable_origin()
{
    ::sct_auditing::TLSConnectionContext_Origin* _msg = _internal_mutable_origin();
    // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionContext.origin)
    return _msg;
}
inline void TLSConnectionContext::set_allocated_origin(::sct_auditing::TLSConnectionContext_Origin* origin)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.origin_;
    }
    if (origin) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin);
        if (message_arena != submessage_arena) {
            origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, origin, submessage_arena);
        }

    } else {
    }
    _impl_.origin_ = origin;
    // @@protoc_insertion_point(field_set_allocated:sct_auditing.TLSConnectionContext.origin)
}

// repeated bytes certificate_chain = 3;
inline int TLSConnectionContext::_internal_certificate_chain_size() const
{
    return _impl_.certificate_chain_.size();
}
inline int TLSConnectionContext::certificate_chain_size() const
{
    return _internal_certificate_chain_size();
}
inline void TLSConnectionContext::clear_certificate_chain()
{
    _impl_.certificate_chain_.Clear();
}
inline std::string* TLSConnectionContext::add_certificate_chain()
{
    std::string* _s = _internal_add_certificate_chain();
    // @@protoc_insertion_point(field_add_mutable:sct_auditing.TLSConnectionContext.certificate_chain)
    return _s;
}
inline const std::string& TLSConnectionContext::_internal_certificate_chain(int index) const
{
    return _impl_.certificate_chain_.Get(index);
}
inline const std::string& TLSConnectionContext::certificate_chain(int index) const
{
    // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.certificate_chain)
    return _internal_certificate_chain(index);
}
inline std::string* TLSConnectionContext::mutable_certificate_chain(int index)
{
    // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionContext.certificate_chain)
    return _impl_.certificate_chain_.Mutable(index);
}
inline void TLSConnectionContext::set_certificate_chain(int index, const std::string& value)
{
    _impl_.certificate_chain_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::set_certificate_chain(int index, std::string&& value)
{
    _impl_.certificate_chain_.Mutable(index)->assign(std::move(value));
    // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::set_certificate_chain(int index, const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.certificate_chain_.Mutable(index)->assign(value);
    // @@protoc_insertion_point(field_set_char:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::set_certificate_chain(int index, const void* value, size_t size)
{
    _impl_.certificate_chain_.Mutable(index)->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_set_pointer:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline std::string* TLSConnectionContext::_internal_add_certificate_chain()
{
    return _impl_.certificate_chain_.Add();
}
inline void TLSConnectionContext::add_certificate_chain(const std::string& value)
{
    _impl_.certificate_chain_.Add()->assign(value);
    // @@protoc_insertion_point(field_add:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::add_certificate_chain(std::string&& value)
{
    _impl_.certificate_chain_.Add(std::move(value));
    // @@protoc_insertion_point(field_add:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::add_certificate_chain(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _impl_.certificate_chain_.Add()->assign(value);
    // @@protoc_insertion_point(field_add_char:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::add_certificate_chain(const void* value, size_t size)
{
    _impl_.certificate_chain_.Add()->assign(reinterpret_cast<const char*>(value), size);
    // @@protoc_insertion_point(field_add_pointer:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& TLSConnectionContext::certificate_chain() const
{
    // @@protoc_insertion_point(field_list:sct_auditing.TLSConnectionContext.certificate_chain)
    return _impl_.certificate_chain_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* TLSConnectionContext::mutable_certificate_chain()
{
    // @@protoc_insertion_point(field_mutable_list:sct_auditing.TLSConnectionContext.certificate_chain)
    return &_impl_.certificate_chain_;
}

// -------------------------------------------------------------------

// SCTWithVerifyStatus

// .sct_auditing.SCTWithVerifyStatus.SctVerifyStatus status = 1;
inline void SCTWithVerifyStatus::clear_status()
{
    _impl_.status_ = 0;
}
inline ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::_internal_status() const
{
    return static_cast<::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus>(_impl_.status_);
}
inline ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::status() const
{
    // @@protoc_insertion_point(field_get:sct_auditing.SCTWithVerifyStatus.status)
    return _internal_status();
}
inline void SCTWithVerifyStatus::_internal_set_status(::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus value)
{

    _impl_.status_ = value;
}
inline void SCTWithVerifyStatus::set_status(::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus value)
{
    _internal_set_status(value);
    // @@protoc_insertion_point(field_set:sct_auditing.SCTWithVerifyStatus.status)
}

// bytes serialized_sct = 2;
inline void SCTWithVerifyStatus::clear_serialized_sct()
{
    _impl_.serialized_sct_.ClearToEmpty();
}
inline const std::string& SCTWithVerifyStatus::serialized_sct() const
{
    // @@protoc_insertion_point(field_get:sct_auditing.SCTWithVerifyStatus.serialized_sct)
    return _internal_serialized_sct();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SCTWithVerifyStatus::set_serialized_sct(ArgT0&& arg0, ArgT... args)
{

    _impl_.serialized_sct_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:sct_auditing.SCTWithVerifyStatus.serialized_sct)
}
inline std::string* SCTWithVerifyStatus::mutable_serialized_sct()
{
    std::string* _s = _internal_mutable_serialized_sct();
    // @@protoc_insertion_point(field_mutable:sct_auditing.SCTWithVerifyStatus.serialized_sct)
    return _s;
}
inline const std::string& SCTWithVerifyStatus::_internal_serialized_sct() const
{
    return _impl_.serialized_sct_.Get();
}
inline void SCTWithVerifyStatus::_internal_set_serialized_sct(const std::string& value)
{

    _impl_.serialized_sct_.Set(value, GetArenaForAllocation());
}
inline std::string* SCTWithVerifyStatus::_internal_mutable_serialized_sct()
{

    return _impl_.serialized_sct_.Mutable(GetArenaForAllocation());
}
inline std::string* SCTWithVerifyStatus::release_serialized_sct()
{
    // @@protoc_insertion_point(field_release:sct_auditing.SCTWithVerifyStatus.serialized_sct)
    return _impl_.serialized_sct_.Release();
}
inline void SCTWithVerifyStatus::set_allocated_serialized_sct(std::string* serialized_sct)
{
    if (serialized_sct != nullptr) {

    } else {
    }
    _impl_.serialized_sct_.SetAllocated(serialized_sct, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.serialized_sct_.IsDefault()) {
        _impl_.serialized_sct_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:sct_auditing.SCTWithVerifyStatus.serialized_sct)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace sct_auditing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sct_5faudit_5freport_2eproto
