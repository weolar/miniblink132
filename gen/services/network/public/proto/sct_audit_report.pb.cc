// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sct_audit_report.proto

#include "sct_audit_report.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sct_auditing {
PROTOBUF_CONSTEXPR SCTClientReport::SCTClientReport(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.certificate_report_)*/ {},
        /*decltype(_impl_.user_agent_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SCTClientReportDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SCTClientReportDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SCTClientReportDefaultTypeInternal()
    {
    }
    union {
        SCTClientReport _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SCTClientReportDefaultTypeInternal _SCTClientReport_default_instance_;
PROTOBUF_CONSTEXPR TLSConnectionReport::TLSConnectionReport(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.included_sct_)*/ {}, /*decltype(_impl_.context_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct TLSConnectionReportDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TLSConnectionReportDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TLSConnectionReportDefaultTypeInternal()
    {
    }
    union {
        TLSConnectionReport _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TLSConnectionReportDefaultTypeInternal
    _TLSConnectionReport_default_instance_;
PROTOBUF_CONSTEXPR TLSConnectionContext_Origin::TLSConnectionContext_Origin(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.hostname_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.port_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct TLSConnectionContext_OriginDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TLSConnectionContext_OriginDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TLSConnectionContext_OriginDefaultTypeInternal()
    {
    }
    union {
        TLSConnectionContext_Origin _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TLSConnectionContext_OriginDefaultTypeInternal
    _TLSConnectionContext_Origin_default_instance_;
PROTOBUF_CONSTEXPR TLSConnectionContext::TLSConnectionContext(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.certificate_chain_)*/ {}, /*decltype(_impl_.origin_)*/ nullptr, /*decltype(_impl_.time_seen_)*/ int64_t { 0 },
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct TLSConnectionContextDefaultTypeInternal {
    PROTOBUF_CONSTEXPR TLSConnectionContextDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~TLSConnectionContextDefaultTypeInternal()
    {
    }
    union {
        TLSConnectionContext _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TLSConnectionContextDefaultTypeInternal
    _TLSConnectionContext_default_instance_;
PROTOBUF_CONSTEXPR SCTWithVerifyStatus::SCTWithVerifyStatus(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.serialized_sct_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_.status_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct SCTWithVerifyStatusDefaultTypeInternal {
    PROTOBUF_CONSTEXPR SCTWithVerifyStatusDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~SCTWithVerifyStatusDefaultTypeInternal()
    {
    }
    union {
        SCTWithVerifyStatus _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SCTWithVerifyStatusDefaultTypeInternal
    _SCTWithVerifyStatus_default_instance_;
} // namespace sct_auditing
namespace sct_auditing {
bool SCTWithVerifyStatus_SctVerifyStatus_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 3:
    case 4:
    case 5:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> SCTWithVerifyStatus_SctVerifyStatus_strings[5] = {};

static const char SCTWithVerifyStatus_SctVerifyStatus_names[] = "INVALID_SIGNATURE"
                                                                "INVALID_TIMESTAMP"
                                                                "LOG_UNKNOWN"
                                                                "NONE"
                                                                "OK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry SCTWithVerifyStatus_SctVerifyStatus_entries[] = {
    { { SCTWithVerifyStatus_SctVerifyStatus_names + 0, 17 }, 4 },
    { { SCTWithVerifyStatus_SctVerifyStatus_names + 17, 17 }, 5 },
    { { SCTWithVerifyStatus_SctVerifyStatus_names + 34, 11 }, 1 },
    { { SCTWithVerifyStatus_SctVerifyStatus_names + 45, 4 }, 0 },
    { { SCTWithVerifyStatus_SctVerifyStatus_names + 49, 2 }, 3 },
};

static const int SCTWithVerifyStatus_SctVerifyStatus_entries_by_number[] = {
    3, // 0 -> NONE
    2, // 1 -> LOG_UNKNOWN
    4, // 3 -> OK
    0, // 4 -> INVALID_SIGNATURE
    1, // 5 -> INVALID_TIMESTAMP
};

const std::string& SCTWithVerifyStatus_SctVerifyStatus_Name(SCTWithVerifyStatus_SctVerifyStatus value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        SCTWithVerifyStatus_SctVerifyStatus_entries, SCTWithVerifyStatus_SctVerifyStatus_entries_by_number, 5, SCTWithVerifyStatus_SctVerifyStatus_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        SCTWithVerifyStatus_SctVerifyStatus_entries, SCTWithVerifyStatus_SctVerifyStatus_entries_by_number, 5, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : SCTWithVerifyStatus_SctVerifyStatus_strings[idx].get();
}
bool SCTWithVerifyStatus_SctVerifyStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SCTWithVerifyStatus_SctVerifyStatus* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(SCTWithVerifyStatus_SctVerifyStatus_entries, 5, name, &int_value);
    if (success) {
        *value = static_cast<SCTWithVerifyStatus_SctVerifyStatus>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::NONE;
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::LOG_UNKNOWN;
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::OK;
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::INVALID_SIGNATURE;
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::INVALID_TIMESTAMP;
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::SctVerifyStatus_MIN;
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::SctVerifyStatus_MAX;
constexpr int SCTWithVerifyStatus::SctVerifyStatus_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SCTClientReport::_Internal {
public:
};

SCTClientReport::SCTClientReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sct_auditing.SCTClientReport)
}
SCTClientReport::SCTClientReport(const SCTClientReport& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SCTClientReport* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.certificate_report_) { from._impl_.certificate_report_ }, decltype(_impl_.user_agent_) {},
        /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_user_agent().empty()) {
        _this->_impl_.user_agent_.Set(from._internal_user_agent(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:sct_auditing.SCTClientReport)
}

inline void SCTClientReport::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.certificate_report_) { arena }, decltype(_impl_.user_agent_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.user_agent_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_agent_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SCTClientReport::~SCTClientReport()
{
    // @@protoc_insertion_point(destructor:sct_auditing.SCTClientReport)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SCTClientReport::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.certificate_report_.~RepeatedPtrField();
    _impl_.user_agent_.Destroy();
}

void SCTClientReport::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SCTClientReport::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sct_auditing.SCTClientReport)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.certificate_report_.Clear();
    _impl_.user_agent_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* SCTClientReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string user_agent = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_user_agent();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated .sct_auditing.TLSConnectionReport certificate_report = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_certificate_report(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SCTClientReport::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sct_auditing.SCTClientReport)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string user_agent = 1;
    if (!this->_internal_user_agent().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_user_agent().data(),
            static_cast<int>(this->_internal_user_agent().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "sct_auditing.SCTClientReport.user_agent");
        target = stream->WriteStringMaybeAliased(1, this->_internal_user_agent(), target);
    }

    // repeated .sct_auditing.TLSConnectionReport certificate_report = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_certificate_report_size()); i < n; i++) {
        const auto& repfield = this->_internal_certificate_report(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sct_auditing.SCTClientReport)
    return target;
}

size_t SCTClientReport::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sct_auditing.SCTClientReport)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sct_auditing.TLSConnectionReport certificate_report = 2;
    total_size += 1UL * this->_internal_certificate_report_size();
    for (const auto& msg : this->_impl_.certificate_report_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // string user_agent = 1;
    if (!this->_internal_user_agent().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_user_agent());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SCTClientReport::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SCTClientReport*>(&from));
}

void SCTClientReport::MergeFrom(const SCTClientReport& from)
{
    SCTClientReport* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sct_auditing.SCTClientReport)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.certificate_report_.MergeFrom(from._impl_.certificate_report_);
    if (!from._internal_user_agent().empty()) {
        _this->_internal_set_user_agent(from._internal_user_agent());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SCTClientReport::CopyFrom(const SCTClientReport& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sct_auditing.SCTClientReport)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SCTClientReport::IsInitialized() const
{
    return true;
}

void SCTClientReport::InternalSwap(SCTClientReport* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.certificate_report_.InternalSwap(&other->_impl_.certificate_report_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.user_agent_, lhs_arena, &other->_impl_.user_agent_, rhs_arena);
}

std::string SCTClientReport::GetTypeName() const
{
    return "sct_auditing.SCTClientReport";
}

// ===================================================================

class TLSConnectionReport::_Internal {
public:
    static const ::sct_auditing::TLSConnectionContext& context(const TLSConnectionReport* msg);
};

const ::sct_auditing::TLSConnectionContext& TLSConnectionReport::_Internal::context(const TLSConnectionReport* msg)
{
    return *msg->_impl_.context_;
}
TLSConnectionReport::TLSConnectionReport(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sct_auditing.TLSConnectionReport)
}
TLSConnectionReport::TLSConnectionReport(const TLSConnectionReport& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TLSConnectionReport* const _this = this;
    (void)_this;
    new (&_impl_)
        Impl_ { decltype(_impl_.included_sct_) { from._impl_.included_sct_ }, decltype(_impl_.context_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_context()) {
        _this->_impl_.context_ = new ::sct_auditing::TLSConnectionContext(*from._impl_.context_);
    }
    // @@protoc_insertion_point(copy_constructor:sct_auditing.TLSConnectionReport)
}

inline void TLSConnectionReport::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.included_sct_) { arena }, decltype(_impl_.context_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

TLSConnectionReport::~TLSConnectionReport()
{
    // @@protoc_insertion_point(destructor:sct_auditing.TLSConnectionReport)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TLSConnectionReport::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.included_sct_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.context_;
}

void TLSConnectionReport::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TLSConnectionReport::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sct_auditing.TLSConnectionReport)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.included_sct_.Clear();
    if (GetArenaForAllocation() == nullptr && _impl_.context_ != nullptr) {
        delete _impl_.context_;
    }
    _impl_.context_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* TLSConnectionReport::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .sct_auditing.TLSConnectionContext context = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_context(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated .sct_auditing.SCTWithVerifyStatus included_sct = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    ptr = ctx->ParseMessage(_internal_add_included_sct(), ptr);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TLSConnectionReport::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sct_auditing.TLSConnectionReport)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .sct_auditing.TLSConnectionContext context = 1;
    if (this->_internal_has_context()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::context(this), _Internal::context(this).GetCachedSize(), target, stream);
    }

    // repeated .sct_auditing.SCTWithVerifyStatus included_sct = 2;
    for (unsigned i = 0, n = static_cast<unsigned>(this->_internal_included_sct_size()); i < n; i++) {
        const auto& repfield = this->_internal_included_sct(i);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sct_auditing.TLSConnectionReport)
    return target;
}

size_t TLSConnectionReport::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sct_auditing.TLSConnectionReport)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated .sct_auditing.SCTWithVerifyStatus included_sct = 2;
    total_size += 1UL * this->_internal_included_sct_size();
    for (const auto& msg : this->_impl_.included_sct_) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
    }

    // .sct_auditing.TLSConnectionContext context = 1;
    if (this->_internal_has_context()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.context_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TLSConnectionReport::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TLSConnectionReport*>(&from));
}

void TLSConnectionReport::MergeFrom(const TLSConnectionReport& from)
{
    TLSConnectionReport* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sct_auditing.TLSConnectionReport)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.included_sct_.MergeFrom(from._impl_.included_sct_);
    if (from._internal_has_context()) {
        _this->_internal_mutable_context()->::sct_auditing::TLSConnectionContext::MergeFrom(from._internal_context());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TLSConnectionReport::CopyFrom(const TLSConnectionReport& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sct_auditing.TLSConnectionReport)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TLSConnectionReport::IsInitialized() const
{
    return true;
}

void TLSConnectionReport::InternalSwap(TLSConnectionReport* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.included_sct_.InternalSwap(&other->_impl_.included_sct_);
    swap(_impl_.context_, other->_impl_.context_);
}

std::string TLSConnectionReport::GetTypeName() const
{
    return "sct_auditing.TLSConnectionReport";
}

// ===================================================================

class TLSConnectionContext_Origin::_Internal {
public:
};

TLSConnectionContext_Origin::TLSConnectionContext_Origin(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sct_auditing.TLSConnectionContext.Origin)
}
TLSConnectionContext_Origin::TLSConnectionContext_Origin(const TLSConnectionContext_Origin& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TLSConnectionContext_Origin* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.hostname_) {}, decltype(_impl_.port_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.hostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_hostname().empty()) {
        _this->_impl_.hostname_.Set(from._internal_hostname(), _this->GetArenaForAllocation());
    }
    _this->_impl_.port_ = from._impl_.port_;
    // @@protoc_insertion_point(copy_constructor:sct_auditing.TLSConnectionContext.Origin)
}

inline void TLSConnectionContext_Origin::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.hostname_) {}, decltype(_impl_.port_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.hostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TLSConnectionContext_Origin::~TLSConnectionContext_Origin()
{
    // @@protoc_insertion_point(destructor:sct_auditing.TLSConnectionContext.Origin)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TLSConnectionContext_Origin::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.hostname_.Destroy();
}

void TLSConnectionContext_Origin::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TLSConnectionContext_Origin::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sct_auditing.TLSConnectionContext.Origin)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.hostname_.ClearToEmpty();
    _impl_.port_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* TLSConnectionContext_Origin::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string hostname = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_hostname();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // int32 port = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TLSConnectionContext_Origin::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sct_auditing.TLSConnectionContext.Origin)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string hostname = 1;
    if (!this->_internal_hostname().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_hostname().data(),
            static_cast<int>(this->_internal_hostname().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "sct_auditing.TLSConnectionContext.Origin.hostname");
        target = stream->WriteStringMaybeAliased(1, this->_internal_hostname(), target);
    }

    // int32 port = 2;
    if (this->_internal_port() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_port(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sct_auditing.TLSConnectionContext.Origin)
    return target;
}

size_t TLSConnectionContext_Origin::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sct_auditing.TLSConnectionContext.Origin)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string hostname = 1;
    if (!this->_internal_hostname().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_hostname());
    }

    // int32 port = 2;
    if (this->_internal_port() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TLSConnectionContext_Origin::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TLSConnectionContext_Origin*>(&from));
}

void TLSConnectionContext_Origin::MergeFrom(const TLSConnectionContext_Origin& from)
{
    TLSConnectionContext_Origin* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sct_auditing.TLSConnectionContext.Origin)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_hostname().empty()) {
        _this->_internal_set_hostname(from._internal_hostname());
    }
    if (from._internal_port() != 0) {
        _this->_internal_set_port(from._internal_port());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TLSConnectionContext_Origin::CopyFrom(const TLSConnectionContext_Origin& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sct_auditing.TLSConnectionContext.Origin)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TLSConnectionContext_Origin::IsInitialized() const
{
    return true;
}

void TLSConnectionContext_Origin::InternalSwap(TLSConnectionContext_Origin* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.hostname_, lhs_arena, &other->_impl_.hostname_, rhs_arena);
    swap(_impl_.port_, other->_impl_.port_);
}

std::string TLSConnectionContext_Origin::GetTypeName() const
{
    return "sct_auditing.TLSConnectionContext.Origin";
}

// ===================================================================

class TLSConnectionContext::_Internal {
public:
    static const ::sct_auditing::TLSConnectionContext_Origin& origin(const TLSConnectionContext* msg);
};

const ::sct_auditing::TLSConnectionContext_Origin& TLSConnectionContext::_Internal::origin(const TLSConnectionContext* msg)
{
    return *msg->_impl_.origin_;
}
TLSConnectionContext::TLSConnectionContext(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sct_auditing.TLSConnectionContext)
}
TLSConnectionContext::TLSConnectionContext(const TLSConnectionContext& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    TLSConnectionContext* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.certificate_chain_) { from._impl_.certificate_chain_ }, decltype(_impl_.origin_) { nullptr },
        decltype(_impl_.time_seen_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_origin()) {
        _this->_impl_.origin_ = new ::sct_auditing::TLSConnectionContext_Origin(*from._impl_.origin_);
    }
    _this->_impl_.time_seen_ = from._impl_.time_seen_;
    // @@protoc_insertion_point(copy_constructor:sct_auditing.TLSConnectionContext)
}

inline void TLSConnectionContext::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.certificate_chain_) { arena }, decltype(_impl_.origin_) { nullptr }, decltype(_impl_.time_seen_) { int64_t { 0 } },
        /*decltype(_impl_._cached_size_)*/ {} };
}

TLSConnectionContext::~TLSConnectionContext()
{
    // @@protoc_insertion_point(destructor:sct_auditing.TLSConnectionContext)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void TLSConnectionContext::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.certificate_chain_.~RepeatedPtrField();
    if (this != internal_default_instance())
        delete _impl_.origin_;
}

void TLSConnectionContext::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void TLSConnectionContext::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sct_auditing.TLSConnectionContext)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.certificate_chain_.Clear();
    if (GetArenaForAllocation() == nullptr && _impl_.origin_ != nullptr) {
        delete _impl_.origin_;
    }
    _impl_.origin_ = nullptr;
    _impl_.time_seen_ = int64_t { 0 };
    _internal_metadata_.Clear<std::string>();
}

const char* TLSConnectionContext::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // int64 time_seen = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.time_seen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .sct_auditing.TLSConnectionContext.Origin origin = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // repeated bytes certificate_chain = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_certificate_chain();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* TLSConnectionContext::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sct_auditing.TLSConnectionContext)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // int64 time_seen = 1;
    if (this->_internal_time_seen() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_time_seen(), target);
    }

    // .sct_auditing.TLSConnectionContext.Origin origin = 2;
    if (this->_internal_has_origin()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::origin(this), _Internal::origin(this).GetCachedSize(), target, stream);
    }

    // repeated bytes certificate_chain = 3;
    for (int i = 0, n = this->_internal_certificate_chain_size(); i < n; i++) {
        const auto& s = this->_internal_certificate_chain(i);
        target = stream->WriteBytes(3, s, target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sct_auditing.TLSConnectionContext)
    return target;
}

size_t TLSConnectionContext::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sct_auditing.TLSConnectionContext)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated bytes certificate_chain = 3;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.certificate_chain_.size());
    for (int i = 0, n = _impl_.certificate_chain_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(_impl_.certificate_chain_.Get(i));
    }

    // .sct_auditing.TLSConnectionContext.Origin origin = 2;
    if (this->_internal_has_origin()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.origin_);
    }

    // int64 time_seen = 1;
    if (this->_internal_time_seen() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_seen());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void TLSConnectionContext::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const TLSConnectionContext*>(&from));
}

void TLSConnectionContext::MergeFrom(const TLSConnectionContext& from)
{
    TLSConnectionContext* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sct_auditing.TLSConnectionContext)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.certificate_chain_.MergeFrom(from._impl_.certificate_chain_);
    if (from._internal_has_origin()) {
        _this->_internal_mutable_origin()->::sct_auditing::TLSConnectionContext_Origin::MergeFrom(from._internal_origin());
    }
    if (from._internal_time_seen() != 0) {
        _this->_internal_set_time_seen(from._internal_time_seen());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TLSConnectionContext::CopyFrom(const TLSConnectionContext& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sct_auditing.TLSConnectionContext)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool TLSConnectionContext::IsInitialized() const
{
    return true;
}

void TLSConnectionContext::InternalSwap(TLSConnectionContext* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.certificate_chain_.InternalSwap(&other->_impl_.certificate_chain_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(TLSConnectionContext, _impl_.time_seen_) + sizeof(TLSConnectionContext::_impl_.time_seen_)
        - PROTOBUF_FIELD_OFFSET(TLSConnectionContext, _impl_.origin_)>(
        reinterpret_cast<char*>(&_impl_.origin_), reinterpret_cast<char*>(&other->_impl_.origin_));
}

std::string TLSConnectionContext::GetTypeName() const
{
    return "sct_auditing.TLSConnectionContext";
}

// ===================================================================

class SCTWithVerifyStatus::_Internal {
public:
};

SCTWithVerifyStatus::SCTWithVerifyStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:sct_auditing.SCTWithVerifyStatus)
}
SCTWithVerifyStatus::SCTWithVerifyStatus(const SCTWithVerifyStatus& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    SCTWithVerifyStatus* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.serialized_sct_) {}, decltype(_impl_.status_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.serialized_sct_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_sct_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_serialized_sct().empty()) {
        _this->_impl_.serialized_sct_.Set(from._internal_serialized_sct(), _this->GetArenaForAllocation());
    }
    _this->_impl_.status_ = from._impl_.status_;
    // @@protoc_insertion_point(copy_constructor:sct_auditing.SCTWithVerifyStatus)
}

inline void SCTWithVerifyStatus::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.serialized_sct_) {}, decltype(_impl_.status_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.serialized_sct_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_sct_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SCTWithVerifyStatus::~SCTWithVerifyStatus()
{
    // @@protoc_insertion_point(destructor:sct_auditing.SCTWithVerifyStatus)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void SCTWithVerifyStatus::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.serialized_sct_.Destroy();
}

void SCTWithVerifyStatus::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void SCTWithVerifyStatus::Clear()
{
    // @@protoc_insertion_point(message_clear_start:sct_auditing.SCTWithVerifyStatus)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.serialized_sct_.ClearToEmpty();
    _impl_.status_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* SCTWithVerifyStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .sct_auditing.SCTWithVerifyStatus.SctVerifyStatus status = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_status(static_cast<::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus>(val));
            } else
                goto handle_unusual;
            continue;
        // bytes serialized_sct = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_serialized_sct();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* SCTWithVerifyStatus::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:sct_auditing.SCTWithVerifyStatus)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .sct_auditing.SCTWithVerifyStatus.SctVerifyStatus status = 1;
    if (this->_internal_status() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(1, this->_internal_status(), target);
    }

    // bytes serialized_sct = 2;
    if (!this->_internal_serialized_sct().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_serialized_sct(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:sct_auditing.SCTWithVerifyStatus)
    return target;
}

size_t SCTWithVerifyStatus::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:sct_auditing.SCTWithVerifyStatus)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bytes serialized_sct = 2;
    if (!this->_internal_serialized_sct().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_serialized_sct());
    }

    // .sct_auditing.SCTWithVerifyStatus.SctVerifyStatus status = 1;
    if (this->_internal_status() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void SCTWithVerifyStatus::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const SCTWithVerifyStatus*>(&from));
}

void SCTWithVerifyStatus::MergeFrom(const SCTWithVerifyStatus& from)
{
    SCTWithVerifyStatus* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:sct_auditing.SCTWithVerifyStatus)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_serialized_sct().empty()) {
        _this->_internal_set_serialized_sct(from._internal_serialized_sct());
    }
    if (from._internal_status() != 0) {
        _this->_internal_set_status(from._internal_status());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SCTWithVerifyStatus::CopyFrom(const SCTWithVerifyStatus& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:sct_auditing.SCTWithVerifyStatus)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool SCTWithVerifyStatus::IsInitialized() const
{
    return true;
}

void SCTWithVerifyStatus::InternalSwap(SCTWithVerifyStatus* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.serialized_sct_, lhs_arena, &other->_impl_.serialized_sct_, rhs_arena);
    swap(_impl_.status_, other->_impl_.status_);
}

std::string SCTWithVerifyStatus::GetTypeName() const
{
    return "sct_auditing.SCTWithVerifyStatus";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace sct_auditing
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::sct_auditing::SCTClientReport* Arena::CreateMaybeMessage<::sct_auditing::SCTClientReport>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sct_auditing::SCTClientReport>(arena);
}
template <> PROTOBUF_NOINLINE ::sct_auditing::TLSConnectionReport* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionReport>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sct_auditing::TLSConnectionReport>(arena);
}
template <> PROTOBUF_NOINLINE ::sct_auditing::TLSConnectionContext_Origin* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionContext_Origin>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sct_auditing::TLSConnectionContext_Origin>(arena);
}
template <> PROTOBUF_NOINLINE ::sct_auditing::TLSConnectionContext* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionContext>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sct_auditing::TLSConnectionContext>(arena);
}
template <> PROTOBUF_NOINLINE ::sct_auditing::SCTWithVerifyStatus* Arena::CreateMaybeMessage<::sct_auditing::SCTWithVerifyStatus>(Arena* arena)
{
    return Arena::CreateMessageInternal<::sct_auditing::SCTWithVerifyStatus>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
