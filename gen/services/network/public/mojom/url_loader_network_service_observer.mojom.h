// services/network/public/mojom/url_loader_network_service_observer.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_URL_LOADER_NETWORK_SERVICE_OBSERVER_MOJOM_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_URL_LOADER_NETWORK_SERVICE_OBSERVER_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/url_loader_network_service_observer.mojom-features.h" // IWYU pragma: export
#include "services/network/public/mojom/url_loader_network_service_observer.mojom-shared.h" // IWYU pragma: export
#include "services/network/public/mojom/url_loader_network_service_observer.mojom-forward.h" // IWYU pragma: export
#include "mojo/public/mojom/base/string16.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "mojo/public/mojom/base/unguessable_token.mojom.h"
#include "services/network/public/mojom/cookie_partition_key.mojom.h"
#include "services/network/public/mojom/ip_address.mojom.h"
#include "services/network/public/mojom/ip_address_space.mojom-forward.h"
#include "services/network/public/mojom/network_param.mojom.h"
#include "services/network/public/mojom/optional_bool.mojom-forward.h"
#include "url/mojom/origin.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

//#include "net/cert/x509_certificate.h"
#include "net/ssl/ssl_info.h"
#include "net/http/http_response_headers.h"

namespace network::mojom {

class ClientCertificateResponderProxy;

template <typename ImplRefTraits> class ClientCertificateResponderStub;

class ClientCertificateResponderRequestValidator;

class ClientCertificateResponder : public ClientCertificateResponderInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = ClientCertificateResponderInterfaceBase;
    using Proxy_ = ClientCertificateResponderProxy;

    template <typename ImplRefTraits> using Stub_ = ClientCertificateResponderStub<ImplRefTraits>;

    using RequestValidator_ = ClientCertificateResponderRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kContinueWithCertificateMinVersion = 0,
        kContinueWithoutCertificateMinVersion = 0,
        kCancelRequestMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct ContinueWithCertificate_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ContinueWithoutCertificate_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CancelRequest_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~ClientCertificateResponder() = default;

    virtual void ContinueWithCertificate(const ::scoped_refptr<::net::X509Certificate>& x509_certificate, const std::string& provider_name,
        const std::vector<uint16_t>& algorithm_preferences, ::mojo::PendingRemote<SSLPrivateKey> ssl_private_key)
        = 0;

    virtual void ContinueWithoutCertificate() = 0;

    virtual void CancelRequest() = 0;
};

class SSLPrivateKeyProxy;

template <typename ImplRefTraits> class SSLPrivateKeyStub;

class SSLPrivateKeyRequestValidator;
class SSLPrivateKeyResponseValidator;

class SSLPrivateKey : public SSLPrivateKeyInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = SSLPrivateKeyInterfaceBase;
    using Proxy_ = SSLPrivateKeyProxy;

    template <typename ImplRefTraits> using Stub_ = SSLPrivateKeyStub<ImplRefTraits>;

    using RequestValidator_ = SSLPrivateKeyRequestValidator;
    using ResponseValidator_ = SSLPrivateKeyResponseValidator;
    enum MethodMinVersions : uint32_t {
        kSignMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct Sign_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~SSLPrivateKey() = default;

    using SignCallback = base::OnceCallback<void(int32_t, const std::vector<uint8_t>&)>;

    virtual void Sign(uint16_t algorithm, const std::vector<uint8_t>& input, SignCallback callback) = 0;
};

class AuthChallengeResponderProxy;

template <typename ImplRefTraits> class AuthChallengeResponderStub;

class AuthChallengeResponderRequestValidator;

class AuthChallengeResponder : public AuthChallengeResponderInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = AuthChallengeResponderInterfaceBase;
    using Proxy_ = AuthChallengeResponderProxy;

    template <typename ImplRefTraits> using Stub_ = AuthChallengeResponderStub<ImplRefTraits>;

    using RequestValidator_ = AuthChallengeResponderRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kOnAuthCredentialsMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct OnAuthCredentials_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~AuthChallengeResponder() = default;

    virtual void OnAuthCredentials(const std::optional<::net::AuthCredentials>& credentials) = 0;
};

class URLLoaderNetworkServiceObserverProxy;

template <typename ImplRefTraits> class URLLoaderNetworkServiceObserverStub;

class URLLoaderNetworkServiceObserverRequestValidator;
class URLLoaderNetworkServiceObserverResponseValidator;

class URLLoaderNetworkServiceObserver : public URLLoaderNetworkServiceObserverInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = URLLoaderNetworkServiceObserverInterfaceBase;
    using Proxy_ = URLLoaderNetworkServiceObserverProxy;

    template <typename ImplRefTraits> using Stub_ = URLLoaderNetworkServiceObserverStub<ImplRefTraits>;

    using RequestValidator_ = URLLoaderNetworkServiceObserverRequestValidator;
    using ResponseValidator_ = URLLoaderNetworkServiceObserverResponseValidator;
    enum MethodMinVersions : uint32_t {
        kOnSSLCertificateErrorMinVersion = 0,
        kOnCertificateRequestedMinVersion = 0,
        kOnAuthRequiredMinVersion = 0,
        kOnPrivateNetworkAccessPermissionRequiredMinVersion = 0,
        kOnClearSiteDataMinVersion = 0,
        kOnLoadingStateUpdateMinVersion = 0,
        kOnDataUseUpdateMinVersion = 0,
        kOnSharedStorageHeaderReceivedMinVersion = 0,
        kCloneMinVersion = 0,
        kOnWebSocketConnectedToPrivateNetworkMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct OnSSLCertificateError_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnCertificateRequested_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnAuthRequired_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnPrivateNetworkAccessPermissionRequired_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnClearSiteData_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnLoadingStateUpdate_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnDataUseUpdate_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnSharedStorageHeaderReceived_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct Clone_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnWebSocketConnectedToPrivateNetwork_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~URLLoaderNetworkServiceObserver() = default;

    using OnSSLCertificateErrorCallback = base::OnceCallback<void(int32_t)>;

    virtual void OnSSLCertificateError(const ::GURL& url, int32_t net_error, const ::net::SSLInfo& ssl_info, bool fatal, OnSSLCertificateErrorCallback callback)
        = 0;

    virtual void OnCertificateRequested(const std::optional<::base::UnguessableToken>& window_id, const ::scoped_refptr<::net::SSLCertRequestInfo>& cert_info,
        ::mojo::PendingRemote<ClientCertificateResponder> cert_responder)
        = 0;

    virtual void OnAuthRequired(const std::optional<::base::UnguessableToken>& window_id, int32_t request_id, const ::GURL& url, bool first_auth_attempt,
        const ::net::AuthChallengeInfo& auth_info, const ::scoped_refptr<::net::HttpResponseHeaders>& head_headers,
        ::mojo::PendingRemote<AuthChallengeResponder> auth_challenge_responder)
        = 0;

    using OnPrivateNetworkAccessPermissionRequiredCallback = base::OnceCallback<void(bool)>;

    virtual void OnPrivateNetworkAccessPermissionRequired(const ::GURL& url, const ::net::IPAddress& ip_address,
        const std::optional<std::string>& private_network_device_id, const std::optional<std::string>& private_network_device_name,
        OnPrivateNetworkAccessPermissionRequiredCallback callback)
        = 0;

    using OnClearSiteDataCallback = base::OnceCallback<void()>;

    virtual void OnClearSiteData(const ::GURL& url, const std::string& header_value, int32_t load_flags,
        const std::optional<::net::CookiePartitionKey>& cookie_partition_key, bool partitioned_state_allowed_only, OnClearSiteDataCallback callback)
        = 0;

    using OnLoadingStateUpdateCallback = base::OnceCallback<void()>;

    virtual void OnLoadingStateUpdate(LoadInfoPtr info, OnLoadingStateUpdateCallback callback) = 0;

    virtual void OnDataUseUpdate(int32_t network_traffic_annotation_id_hash, int64_t recv_bytes, int64_t sent_bytes) = 0;

    using OnSharedStorageHeaderReceivedCallback = base::OnceCallback<void()>;

    virtual void OnSharedStorageHeaderReceived(
        const ::url::Origin& request_origin, std::vector<SharedStorageOperationPtr> operations, OnSharedStorageHeaderReceivedCallback callback)
        = 0;

    virtual void Clone(::mojo::PendingReceiver<URLLoaderNetworkServiceObserver> listener) = 0;

    virtual void OnWebSocketConnectedToPrivateNetwork(::network::mojom::IPAddressSpace ip_address_space) = 0;
};

class ClientCertificateResponderProxy : public ClientCertificateResponder {
public:
    using InterfaceType = ClientCertificateResponder;

    explicit ClientCertificateResponderProxy(mojo::MessageReceiverWithResponder* receiver);

    //   void ContinueWithCertificate(const ::scoped_refptr<::net::X509Certificate>& x509_certificate,
    //     const std::string& provider_name,
    //     const std::vector<uint16_t>& algorithm_preferences,
    //     ::mojo::PendingRemote<SSLPrivateKey> ssl_private_key) final;

    void ContinueWithoutCertificate() final;

    void CancelRequest() final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class SSLPrivateKeyProxy : public SSLPrivateKey {
public:
    using InterfaceType = SSLPrivateKey;

    explicit SSLPrivateKeyProxy(mojo::MessageReceiverWithResponder* receiver);

    void Sign(uint16_t algorithm, const std::vector<uint8_t>& input, SignCallback callback) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class AuthChallengeResponderProxy : public AuthChallengeResponder {
public:
    using InterfaceType = AuthChallengeResponder;

    explicit AuthChallengeResponderProxy(mojo::MessageReceiverWithResponder* receiver);

    void OnAuthCredentials(const std::optional<::net::AuthCredentials>& credentials) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class URLLoaderNetworkServiceObserverProxy : public URLLoaderNetworkServiceObserver {
public:
    using InterfaceType = URLLoaderNetworkServiceObserver;

    explicit URLLoaderNetworkServiceObserverProxy(mojo::MessageReceiverWithResponder* receiver);

    void OnSSLCertificateError(const ::GURL& url, int32_t net_error, const ::net::SSLInfo& ssl_info, bool fatal, OnSSLCertificateErrorCallback callback) final;

    void OnCertificateRequested(const std::optional<::base::UnguessableToken>& window_id, const ::scoped_refptr<::net::SSLCertRequestInfo>& cert_info,
        ::mojo::PendingRemote<ClientCertificateResponder> cert_responder) final;

    void OnAuthRequired(const std::optional<::base::UnguessableToken>& window_id, int32_t request_id, const ::GURL& url, bool first_auth_attempt,
        const ::net::AuthChallengeInfo& auth_info, const ::scoped_refptr<::net::HttpResponseHeaders>& head_headers,
        ::mojo::PendingRemote<AuthChallengeResponder> auth_challenge_responder) final;

    void OnPrivateNetworkAccessPermissionRequired(const ::GURL& url, const ::net::IPAddress& ip_address,
        const std::optional<std::string>& private_network_device_id, const std::optional<std::string>& private_network_device_name,
        OnPrivateNetworkAccessPermissionRequiredCallback callback) final;

    void OnClearSiteData(const ::GURL& url, const std::string& header_value, int32_t load_flags,
        const std::optional<::net::CookiePartitionKey>& cookie_partition_key, bool partitioned_state_allowed_only, OnClearSiteDataCallback callback) final;

    void OnLoadingStateUpdate(LoadInfoPtr info, OnLoadingStateUpdateCallback callback) final;

    void OnDataUseUpdate(int32_t network_traffic_annotation_id_hash, int64_t recv_bytes, int64_t sent_bytes) final;

    void OnSharedStorageHeaderReceived(
        const ::url::Origin& request_origin, std::vector<SharedStorageOperationPtr> operations, OnSharedStorageHeaderReceivedCallback callback) final;

    void Clone(::mojo::PendingReceiver<URLLoaderNetworkServiceObserver> listener) final;

    void OnWebSocketConnectedToPrivateNetwork(::network::mojom::IPAddressSpace ip_address_space) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};
class ClientCertificateResponderStubDispatch {
public:
    static bool Accept(ClientCertificateResponder* impl, mojo::Message* message);
    static bool AcceptWithResponder(ClientCertificateResponder* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<ClientCertificateResponder>>
//class ClientCertificateResponderStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    ClientCertificateResponderStub() = default;
//    ~ClientCertificateResponderStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return ClientCertificateResponderStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return ClientCertificateResponderStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class SSLPrivateKeyStubDispatch {
public:
    static bool Accept(SSLPrivateKey* impl, mojo::Message* message);
    static bool AcceptWithResponder(SSLPrivateKey* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<SSLPrivateKey>> class SSLPrivateKeyStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    SSLPrivateKeyStub() = default;
//    ~SSLPrivateKeyStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return SSLPrivateKeyStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return SSLPrivateKeyStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class AuthChallengeResponderStubDispatch {
public:
    static bool Accept(AuthChallengeResponder* impl, mojo::Message* message);
    static bool AcceptWithResponder(AuthChallengeResponder* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<AuthChallengeResponder>>
//class AuthChallengeResponderStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    AuthChallengeResponderStub() = default;
//    ~AuthChallengeResponderStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return AuthChallengeResponderStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return AuthChallengeResponderStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class URLLoaderNetworkServiceObserverStubDispatch {
public:
    static bool Accept(URLLoaderNetworkServiceObserver* impl, mojo::Message* message);
    static bool AcceptWithResponder(URLLoaderNetworkServiceObserver* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<URLLoaderNetworkServiceObserver>>
//class URLLoaderNetworkServiceObserverStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    URLLoaderNetworkServiceObserverStub() = default;
//    ~URLLoaderNetworkServiceObserverStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return URLLoaderNetworkServiceObserverStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return URLLoaderNetworkServiceObserverStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class ClientCertificateResponderRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class SSLPrivateKeyRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class AuthChallengeResponderRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class URLLoaderNetworkServiceObserverRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class SSLPrivateKeyResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class URLLoaderNetworkServiceObserverResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class SharedStorageOperation {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SharedStorageOperation, T>::value>;
    using DataView = SharedStorageOperationDataView;
    using Data_ = internal::SharedStorageOperation_Data;

    template <typename... Args> static SharedStorageOperationPtr New(Args&&... args)
    {
        return SharedStorageOperationPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SharedStorageOperationPtr From(const U& u)
    {
        return mojo::TypeConverter<SharedStorageOperationPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SharedStorageOperation>::Convert(*this);
    }

    SharedStorageOperation();

    SharedStorageOperation(SharedStorageOperationType type, const std::optional<std::string>& key, const std::optional<std::string>& value,
        ::network::mojom::OptionalBool ignore_if_present);

    ~SharedStorageOperation();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SharedStorageOperationPtr> SharedStorageOperationPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SharedStorageOperation::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SharedStorageOperation::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SharedStorageOperation::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SharedStorageOperation::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SharedStorageOperation::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::SharedStorageOperation_UnserializedMessageContext<UserType, SharedStorageOperation::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SharedStorageOperation::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SharedStorageOperation::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::SharedStorageOperation_UnserializedMessageContext<UserType, SharedStorageOperation::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SharedStorageOperation::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    SharedStorageOperationType type;

    std::optional<std::string> key;

    std::optional<std::string> value;

    ::network::mojom::OptionalBool ignore_if_present;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SharedStorageOperation::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SharedStorageOperation::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SharedStorageOperation::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SharedStorageOperation::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class LoadInfo {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<LoadInfo, T>::value>;
    using DataView = LoadInfoDataView;
    using Data_ = internal::LoadInfo_Data;

    template <typename... Args> static LoadInfoPtr New(Args&&... args)
    {
        return LoadInfoPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static LoadInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<LoadInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, LoadInfo>::Convert(*this);
    }

    LoadInfo();

    LoadInfo(::base::TimeTicks timestamp, const std::string& host, uint32_t load_state, const ::std::u16string& state_param, uint64_t upload_position,
        uint64_t upload_size);

    ~LoadInfo();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = LoadInfoPtr> LoadInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, LoadInfo::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, LoadInfo::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, LoadInfo::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<LoadInfo::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<LoadInfo::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::LoadInfo_UnserializedMessageContext<UserType, LoadInfo::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<LoadInfo::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return LoadInfo::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::LoadInfo_UnserializedMessageContext<UserType, LoadInfo::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<LoadInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::base::TimeTicks timestamp;

    std::string host;

    uint32_t load_state;

    ::std::u16string state_param;

    uint64_t upload_position;

    uint64_t upload_size;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LoadInfo::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, LoadInfo::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, LoadInfo::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, LoadInfo::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename StructPtrType> LoadInfoPtr LoadInfo::Clone() const
{
    return New(
        mojo::Clone(timestamp), mojo::Clone(host), mojo::Clone(load_state), mojo::Clone(state_param), mojo::Clone(upload_position), mojo::Clone(upload_size));
}

template <typename T, LoadInfo::EnableIfSame<T>*> bool LoadInfo::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->timestamp, other_struct.timestamp))
        return false;
    if (!mojo::Equals(this->host, other_struct.host))
        return false;
    if (!mojo::Equals(this->load_state, other_struct.load_state))
        return false;
    if (!mojo::Equals(this->state_param, other_struct.state_param))
        return false;
    if (!mojo::Equals(this->upload_position, other_struct.upload_position))
        return false;
    if (!mojo::Equals(this->upload_size, other_struct.upload_size))
        return false;
    return true;
}

template <typename T, LoadInfo::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.timestamp < rhs.timestamp)
        return true;
    if (rhs.timestamp < lhs.timestamp)
        return false;
    if (lhs.host < rhs.host)
        return true;
    if (rhs.host < lhs.host)
        return false;
    if (lhs.load_state < rhs.load_state)
        return true;
    if (rhs.load_state < lhs.load_state)
        return false;
    if (lhs.state_param < rhs.state_param)
        return true;
    if (rhs.state_param < lhs.state_param)
        return false;
    if (lhs.upload_position < rhs.upload_position)
        return true;
    if (rhs.upload_position < lhs.upload_position)
        return false;
    if (lhs.upload_size < rhs.upload_size)
        return true;
    if (rhs.upload_size < lhs.upload_size)
        return false;
    return false;
}
template <typename StructPtrType> SharedStorageOperationPtr SharedStorageOperation::Clone() const
{
    return New(mojo::Clone(type), mojo::Clone(key), mojo::Clone(value), mojo::Clone(ignore_if_present));
}

template <typename T, SharedStorageOperation::EnableIfSame<T>*> bool SharedStorageOperation::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->type, other_struct.type))
        return false;
    if (!mojo::Equals(this->key, other_struct.key))
        return false;
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    if (!mojo::Equals(this->ignore_if_present, other_struct.ignore_if_present))
        return false;
    return true;
}

template <typename T, SharedStorageOperation::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.type < rhs.type)
        return true;
    if (rhs.type < lhs.type)
        return false;
    if (lhs.key < rhs.key)
        return true;
    if (rhs.key < lhs.key)
        return false;
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    if (lhs.ignore_if_present < rhs.ignore_if_present)
        return true;
    if (rhs.ignore_if_present < lhs.ignore_if_present)
        return false;
    return false;
}

} // network::mojom

namespace mojo {

template <> struct StructTraits<::network::mojom::LoadInfo::DataView, ::network::mojom::LoadInfoPtr> {
    static bool IsNull(const ::network::mojom::LoadInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::LoadInfoPtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::LoadInfo::timestamp)& timestamp(const ::network::mojom::LoadInfoPtr& input)
    {
        return input->timestamp;
    }

    static const decltype(::network::mojom::LoadInfo::host)& host(const ::network::mojom::LoadInfoPtr& input)
    {
        return input->host;
    }

    static decltype(::network::mojom::LoadInfo::load_state) load_state(const ::network::mojom::LoadInfoPtr& input)
    {
        return input->load_state;
    }

    static const decltype(::network::mojom::LoadInfo::state_param)& state_param(const ::network::mojom::LoadInfoPtr& input)
    {
        return input->state_param;
    }

    static decltype(::network::mojom::LoadInfo::upload_position) upload_position(const ::network::mojom::LoadInfoPtr& input)
    {
        return input->upload_position;
    }

    static decltype(::network::mojom::LoadInfo::upload_size) upload_size(const ::network::mojom::LoadInfoPtr& input)
    {
        return input->upload_size;
    }

    static bool Read(::network::mojom::LoadInfo::DataView input, ::network::mojom::LoadInfoPtr* output);
};

template <> struct StructTraits<::network::mojom::SharedStorageOperation::DataView, ::network::mojom::SharedStorageOperationPtr> {
    static bool IsNull(const ::network::mojom::SharedStorageOperationPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::SharedStorageOperationPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::SharedStorageOperation::type) type(const ::network::mojom::SharedStorageOperationPtr& input)
    {
        return input->type;
    }

    static const decltype(::network::mojom::SharedStorageOperation::key)& key(const ::network::mojom::SharedStorageOperationPtr& input)
    {
        return input->key;
    }

    static const decltype(::network::mojom::SharedStorageOperation::value)& value(const ::network::mojom::SharedStorageOperationPtr& input)
    {
        return input->value;
    }

    static decltype(::network::mojom::SharedStorageOperation::ignore_if_present) ignore_if_present(const ::network::mojom::SharedStorageOperationPtr& input)
    {
        return input->ignore_if_present;
    }

    static bool Read(::network::mojom::SharedStorageOperation::DataView input, ::network::mojom::SharedStorageOperationPtr* output);
};

} // namespace mojo

#endif // SERVICES_NETWORK_PUBLIC_MOJOM_URL_LOADER_NETWORK_SERVICE_OBSERVER_MOJOM_H_
