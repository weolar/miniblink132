// services/network/public/mojom/net_log.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NET_LOG_MOJOM_TEST_UTILS_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NET_LOG_MOJOM_TEST_UTILS_H_

#include "services/network/public/mojom/net_log.mojom.h"

namespace network::mojom {

class NetLogExporterInterceptorForTesting : public NetLogExporter {
    virtual NetLogExporter* GetForwardingInterface() = 0;
    void Start(::base::File destination, ::base::Value::Dict extra_constants, ::net::NetLogCaptureMode capture_mode, uint64_t max_file_size,
        StartCallback callback) override;
    void Stop(::base::Value::Dict polled_values, StopCallback callback) override;
};
class NetLogExporterAsyncWaiter {
public:
    explicit NetLogExporterAsyncWaiter(NetLogExporter* proxy);

    NetLogExporterAsyncWaiter(const NetLogExporterAsyncWaiter&) = delete;
    NetLogExporterAsyncWaiter& operator=(const NetLogExporterAsyncWaiter&) = delete;

    ~NetLogExporterAsyncWaiter();
    void Start(
        ::base::File destination, ::base::Value::Dict extra_constants, ::net::NetLogCaptureMode capture_mode, uint64_t max_file_size, int32_t* out_net_error);
    int32_t Start(::base::File destination, ::base::Value::Dict extra_constants, ::net::NetLogCaptureMode capture_mode, uint64_t max_file_size);
    void Stop(::base::Value::Dict polled_values, int32_t* out_net_error);
    int32_t Stop(::base::Value::Dict polled_values);

private:
    NetLogExporter* const proxy_;
};

class NetLogProxySourceInterceptorForTesting : public NetLogProxySource {
    virtual NetLogProxySource* GetForwardingInterface() = 0;
    void UpdateCaptureModes(uint32_t modes) override;
};
class NetLogProxySourceAsyncWaiter {
public:
    explicit NetLogProxySourceAsyncWaiter(NetLogProxySource* proxy);

    NetLogProxySourceAsyncWaiter(const NetLogProxySourceAsyncWaiter&) = delete;
    NetLogProxySourceAsyncWaiter& operator=(const NetLogProxySourceAsyncWaiter&) = delete;

    ~NetLogProxySourceAsyncWaiter();

private:
    NetLogProxySource* const proxy_;
};

class NetLogProxySinkInterceptorForTesting : public NetLogProxySink {
    virtual NetLogProxySink* GetForwardingInterface() = 0;
    void AddEntry(
        uint32_t type, const ::net::NetLogSource& net_log_source, ::net::NetLogEventPhase phase, ::base::TimeTicks time, ::base::Value::Dict params) override;
};
class NetLogProxySinkAsyncWaiter {
public:
    explicit NetLogProxySinkAsyncWaiter(NetLogProxySink* proxy);

    NetLogProxySinkAsyncWaiter(const NetLogProxySinkAsyncWaiter&) = delete;
    NetLogProxySinkAsyncWaiter& operator=(const NetLogProxySinkAsyncWaiter&) = delete;

    ~NetLogProxySinkAsyncWaiter();

private:
    NetLogProxySink* const proxy_;
};

} // network::mojom

#endif // SERVICES_NETWORK_PUBLIC_MOJOM_NET_LOG_MOJOM_TEST_UTILS_H_
