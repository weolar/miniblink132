// services/network/public/mojom/cookie_manager.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_COOKIE_MANAGER_MOJOM_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_COOKIE_MANAGER_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/cookie_manager.mojom-features.h" // IWYU pragma: export
#include "services/network/public/mojom/cookie_manager.mojom-shared.h" // IWYU pragma: export
#include "services/network/public/mojom/cookie_manager.mojom-forward.h" // IWYU pragma: export
#include "components/content_settings/core/common/content_settings.mojom.h"
#include "components/content_settings/core/common/content_settings_types.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "sandbox/policy/mojom/context.mojom-forward.h"
#include "services/network/public/mojom/cookie_partition_key.mojom.h"
#include "services/network/public/mojom/first_party_sets.mojom-forward.h"
#include "services/network/public/mojom/schemeful_site.mojom-forward.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "services/network/public/cpp/cookie_manager_mojom_traits.h"
#include "services/network/public/cpp/cookie_manager_shared_mojom_traits.h"

namespace network::mojom {

class CookieChangeListenerProxy;

template <typename ImplRefTraits> class CookieChangeListenerStub;

class CookieChangeListenerRequestValidator;

class CookieChangeListener : public CookieChangeListenerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = CookieChangeListenerInterfaceBase;
    using Proxy_ = CookieChangeListenerProxy;

    template <typename ImplRefTraits> using Stub_ = CookieChangeListenerStub<ImplRefTraits>;

    using RequestValidator_ = CookieChangeListenerRequestValidator;
    using ResponseValidator_ = mojo::PassThroughFilter;
    enum MethodMinVersions : uint32_t {
        kOnCookieChangeMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct OnCookieChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~CookieChangeListener() = default;

    virtual void OnCookieChange(const ::net::CookieChangeInfo& change) = 0;
};

class CookieManagerProxy;

template <typename ImplRefTraits> class CookieManagerStub;

class CookieManagerRequestValidator;
class CookieManagerResponseValidator;

class CookieManager : public CookieManagerInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = CookieManagerInterfaceBase;
    using Proxy_ = CookieManagerProxy;

    template <typename ImplRefTraits> using Stub_ = CookieManagerStub<ImplRefTraits>;

    using RequestValidator_ = CookieManagerRequestValidator;
    using ResponseValidator_ = CookieManagerResponseValidator;
    enum MethodMinVersions : uint32_t {
        kGetAllCookiesMinVersion = 0,
        kGetAllCookiesWithAccessSemanticsMinVersion = 0,
        kGetCookieListMinVersion = 0,
        kSetCanonicalCookieMinVersion = 0,
        kDeleteCanonicalCookieMinVersion = 0,
        kDeleteCookiesMinVersion = 0,
        kDeleteSessionOnlyCookiesMinVersion = 0,
        kDeleteStaleSessionOnlyCookiesMinVersion = 0,
        kAddCookieChangeListenerMinVersion = 0,
        kAddGlobalChangeListenerMinVersion = 0,
        kCloneInterfaceMinVersion = 0,
        kFlushCookieStoreMinVersion = 0,
        kAllowFileSchemeCookiesMinVersion = 0,
        kSetContentSettingsMinVersion = 0,
        kSetForceKeepSessionStateMinVersion = 0,
        kBlockThirdPartyCookiesMinVersion = 0,
        kSetMitigationsEnabledFor3pcdMinVersion = 0,
        kSetTrackingProtectionEnabledFor3pcdMinVersion = 0,
        kSetPreCommitCallbackDelayForTestingMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct GetAllCookies_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetAllCookiesWithAccessSemantics_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetCookieList_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetCanonicalCookie_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DeleteCanonicalCookie_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DeleteCookies_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DeleteSessionOnlyCookies_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DeleteStaleSessionOnlyCookies_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct AddCookieChangeListener_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct AddGlobalChangeListener_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CloneInterface_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct FlushCookieStore_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct AllowFileSchemeCookies_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetContentSettings_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetForceKeepSessionState_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct BlockThirdPartyCookies_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetMitigationsEnabledFor3pcd_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetTrackingProtectionEnabledFor3pcd_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetPreCommitCallbackDelayForTesting_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~CookieManager() = default;

    using GetAllCookiesCallback = base::OnceCallback<void(const std::vector<::net::CanonicalCookie>&)>;

    virtual void GetAllCookies(GetAllCookiesCallback callback) = 0;

    using GetAllCookiesWithAccessSemanticsCallback
        = base::OnceCallback<void(const std::vector<::net::CanonicalCookie>&, const std::vector<::net::CookieAccessSemantics>&)>;

    virtual void GetAllCookiesWithAccessSemantics(GetAllCookiesWithAccessSemanticsCallback callback) = 0;

    using GetCookieListCallback
        = base::OnceCallback<void(const std::vector<::net::CookieWithAccessResult>&, const std::vector<::net::CookieWithAccessResult>&)>;

    virtual void GetCookieList(const ::GURL& url, const ::net::CookieOptions& cookie_options,
        const ::net::CookiePartitionKeyCollection& cookie_partition_key_collection, GetCookieListCallback callback)
        = 0;

    using SetCanonicalCookieCallback = base::OnceCallback<void(::net::CookieAccessResult)>;

    virtual void SetCanonicalCookie(
        const ::net::CanonicalCookie& cookie, const ::GURL& source_url, const ::net::CookieOptions& cookie_options, SetCanonicalCookieCallback callback)
        = 0;

    using DeleteCanonicalCookieCallback = base::OnceCallback<void(bool)>;

    virtual void DeleteCanonicalCookie(const ::net::CanonicalCookie& cookie, DeleteCanonicalCookieCallback callback) = 0;

    using DeleteCookiesCallback = base::OnceCallback<void(uint32_t)>;

    virtual void DeleteCookies(CookieDeletionFilterPtr filter, DeleteCookiesCallback callback) = 0;

    using DeleteSessionOnlyCookiesCallback = base::OnceCallback<void(uint32_t)>;

    virtual void DeleteSessionOnlyCookies(DeleteSessionOnlyCookiesCallback callback) = 0;

    using DeleteStaleSessionOnlyCookiesCallback = base::OnceCallback<void(uint32_t)>;

    virtual void DeleteStaleSessionOnlyCookies(DeleteStaleSessionOnlyCookiesCallback callback) = 0;

    virtual void AddCookieChangeListener(const ::GURL& url, const std::optional<std::string>& name, ::mojo::PendingRemote<CookieChangeListener> listener) = 0;

    virtual void AddGlobalChangeListener(::mojo::PendingRemote<CookieChangeListener> notification_pointer) = 0;

    virtual void CloneInterface(::mojo::PendingReceiver<CookieManager> new_interface) = 0;

    using FlushCookieStoreCallback = base::OnceCallback<void()>;

    virtual void FlushCookieStore(FlushCookieStoreCallback callback) = 0;

    using AllowFileSchemeCookiesCallback = base::OnceCallback<void(bool)>;

    virtual void AllowFileSchemeCookies(bool allow, AllowFileSchemeCookiesCallback callback) = 0;

    using SetContentSettingsCallback = base::OnceCallback<void()>;

    virtual void SetContentSettings(::content_settings::mojom::ContentSettingsType content_settings_type,
        const std::vector<::ContentSettingPatternSource>& settings, SetContentSettingsCallback callback)
        = 0;

    virtual void SetForceKeepSessionState() = 0;

    virtual void BlockThirdPartyCookies(bool block) = 0;

    virtual void SetMitigationsEnabledFor3pcd(bool enable) = 0;

    virtual void SetTrackingProtectionEnabledFor3pcd(bool enable) = 0;

    virtual void SetPreCommitCallbackDelayForTesting(::base::TimeDelta delay) = 0;
};

class CookieChangeListenerProxy : public CookieChangeListener {
public:
    using InterfaceType = CookieChangeListener;

    explicit CookieChangeListenerProxy(mojo::MessageReceiverWithResponder* receiver);

    void OnCookieChange(const ::net::CookieChangeInfo& change) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};

class CookieManagerProxy : public CookieManager {
public:
    using InterfaceType = CookieManager;

    explicit CookieManagerProxy(mojo::MessageReceiverWithResponder* receiver);

    void GetAllCookies(GetAllCookiesCallback callback) final;

    void GetAllCookiesWithAccessSemantics(GetAllCookiesWithAccessSemanticsCallback callback) final;

    void GetCookieList(const ::GURL& url, const ::net::CookieOptions& cookie_options,
        const ::net::CookiePartitionKeyCollection& cookie_partition_key_collection, GetCookieListCallback callback) final;

    void SetCanonicalCookie(
        const ::net::CanonicalCookie& cookie, const ::GURL& source_url, const ::net::CookieOptions& cookie_options, SetCanonicalCookieCallback callback) final;

    void DeleteCanonicalCookie(const ::net::CanonicalCookie& cookie, DeleteCanonicalCookieCallback callback) final;

    void DeleteCookies(CookieDeletionFilterPtr filter, DeleteCookiesCallback callback) final;

    void DeleteSessionOnlyCookies(DeleteSessionOnlyCookiesCallback callback) final;

    void DeleteStaleSessionOnlyCookies(DeleteStaleSessionOnlyCookiesCallback callback) final;

    void AddCookieChangeListener(const ::GURL& url, const std::optional<std::string>& name, ::mojo::PendingRemote<CookieChangeListener> listener) final;

    void AddGlobalChangeListener(::mojo::PendingRemote<CookieChangeListener> notification_pointer) final;

    void CloneInterface(::mojo::PendingReceiver<CookieManager> new_interface) final;

    void FlushCookieStore(FlushCookieStoreCallback callback) final;

    void AllowFileSchemeCookies(bool allow, AllowFileSchemeCookiesCallback callback) final;

    void SetContentSettings(::content_settings::mojom::ContentSettingsType content_settings_type, const std::vector<::ContentSettingPatternSource>& settings,
        SetContentSettingsCallback callback) final;

    void SetForceKeepSessionState() final;

    void BlockThirdPartyCookies(bool block) final;

    void SetMitigationsEnabledFor3pcd(bool enable) final;

    void SetTrackingProtectionEnabledFor3pcd(bool enable) final;

    void SetPreCommitCallbackDelayForTesting(::base::TimeDelta delay) final;

private:
    mojo::MessageReceiverWithResponder* receiver_;
};
class CookieChangeListenerStubDispatch {
public:
    static bool Accept(CookieChangeListener* impl, mojo::Message* message);
    static bool AcceptWithResponder(CookieChangeListener* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<CookieChangeListener>>
//class CookieChangeListenerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    CookieChangeListenerStub() = default;
//    ~CookieChangeListenerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return CookieChangeListenerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return CookieChangeListenerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
class CookieManagerStubDispatch {
public:
    static bool Accept(CookieManager* impl, mojo::Message* message);
    static bool AcceptWithResponder(CookieManager* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<CookieManager>> class CookieManagerStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    CookieManagerStub() = default;
//    ~CookieManagerStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return CookieManagerStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return CookieManagerStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class CookieChangeListenerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class CookieManagerRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class CookieManagerResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class CookieSameSiteContextMetadata {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieSameSiteContextMetadata, T>::value>;
    using DataView = CookieSameSiteContextMetadataDataView;
    using Data_ = internal::CookieSameSiteContextMetadata_Data;

    template <typename... Args> static CookieSameSiteContextMetadataPtr New(Args&&... args)
    {
        return CookieSameSiteContextMetadataPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieSameSiteContextMetadataPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieSameSiteContextMetadataPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieSameSiteContextMetadata>::Convert(*this);
    }

    CookieSameSiteContextMetadata();

    CookieSameSiteContextMetadata(::net::CookieOptions::SameSiteCookieContext::ContextMetadata::ContextDowngradeType cross_site_redirect_downgrade,
        ::net::CookieOptions::SameSiteCookieContext::ContextMetadata::ContextRedirectTypeBug1221316 redirect_type_bug_1221316,
        ::net::CookieOptions::SameSiteCookieContext::ContextMetadata::HttpMethod http_method_bug_1221316);

    ~CookieSameSiteContextMetadata();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieSameSiteContextMetadataPtr> CookieSameSiteContextMetadataPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieSameSiteContextMetadata::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieSameSiteContextMetadata::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieSameSiteContextMetadata_UnserializedMessageContext<UserType, CookieSameSiteContextMetadata::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieSameSiteContextMetadata::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieSameSiteContextMetadata::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::CookieSameSiteContextMetadata_UnserializedMessageContext<UserType, CookieSameSiteContextMetadata::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieSameSiteContextMetadata::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::net::CookieOptions::SameSiteCookieContext::ContextMetadata::ContextDowngradeType cross_site_redirect_downgrade;

    ::net::CookieOptions::SameSiteCookieContext::ContextMetadata::ContextRedirectTypeBug1221316 redirect_type_bug_1221316;

    ::net::CookieOptions::SameSiteCookieContext::ContextMetadata::HttpMethod http_method_bug_1221316;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieInclusionStatus {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieInclusionStatus, T>::value>;
    using DataView = CookieInclusionStatusDataView;
    using Data_ = internal::CookieInclusionStatus_Data;

    template <typename... Args> static CookieInclusionStatusPtr New(Args&&... args)
    {
        return CookieInclusionStatusPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieInclusionStatusPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieInclusionStatusPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieInclusionStatus>::Convert(*this);
    }

    CookieInclusionStatus();

    CookieInclusionStatus(uint32_t exclusion_reasons, uint32_t warning_reasons, CookieExemptionReason exemption_reason);

    ~CookieInclusionStatus();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieInclusionStatusPtr> CookieInclusionStatusPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieInclusionStatus::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieInclusionStatus::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieInclusionStatus::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieInclusionStatus::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieInclusionStatus::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieInclusionStatus_UnserializedMessageContext<UserType, CookieInclusionStatus::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieInclusionStatus::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieInclusionStatus::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CookieInclusionStatus_UnserializedMessageContext<UserType, CookieInclusionStatus::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieInclusionStatus::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    uint32_t exclusion_reasons;

    uint32_t warning_reasons;

    CookieExemptionReason exemption_reason;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieInclusionStatus::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieInclusionStatus::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieInclusionStatus::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieInclusionStatus::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieOrLine {
public:
    using DataView = CookieOrLineDataView;
    using Data_ = internal::CookieOrLine_Data;
    using Tag = Data_::CookieOrLine_Tag;

    template <typename... Args> static CookieOrLinePtr New(Args&&... args)
    {
        static_assert(sizeof...(args) < 0,
            "Do not use Union::New(); to create a union of a given subtype, use "
            "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
            "an empty union, mark the field or parameter as nullable in the mojom "
            "definition.");
        return nullptr;
    }
    // Construct an instance holding |cookie|.
    static CookieOrLinePtr NewCookie(const ::net::CanonicalCookie& value)
    {
        auto result = CookieOrLinePtr(std::in_place);
        result->set_cookie(std::move(value));
        return result;
    }
    // Construct an instance holding |cookie_string|.
    static CookieOrLinePtr NewCookieString(const std::string& value)
    {
        auto result = CookieOrLinePtr(std::in_place);
        result->set_cookie_string(std::move(value));
        return result;
    }

    template <typename U> static CookieOrLinePtr From(const U& u)
    {
        return mojo::TypeConverter<CookieOrLinePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieOrLine>::Convert(*this);
    }

    CookieOrLine();
    ~CookieOrLine();
    // Delete the copy constructor and copy assignment operators because `data_`
    // contains raw pointers that must not be copied.
    CookieOrLine(const CookieOrLine& other) = delete;
    CookieOrLine& operator=(const CookieOrLine& other) = delete;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename UnionPtrType = CookieOrLinePtr> CookieOrLinePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, typename std::enable_if<std::is_same<T, CookieOrLine>::value>::type* = nullptr> bool Equals(const T& other) const;

    template <typename T, typename std::enable_if<std::is_same<T, CookieOrLine>::value>::type* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    Tag which() const
    {
        return tag_;
    }

    bool is_cookie() const
    {
        return tag_ == Tag::kCookie;
    }

    ::net::CanonicalCookie& get_cookie() const
    {
        CHECK(tag_ == Tag::kCookie);
        return *(data_.cookie);
    }

    void set_cookie(const ::net::CanonicalCookie& cookie);

    bool is_cookie_string() const
    {
        return tag_ == Tag::kCookieString;
    }

    std::string& get_cookie_string() const
    {
        CHECK(tag_ == Tag::kCookieString);
        return *(data_.cookie_string);
    }

    void set_cookie_string(const std::string& cookie_string);

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieOrLine::DataView>(input);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        return mojo::internal::DeserializeImpl<CookieOrLine::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

private:
    union Union_ {
        Union_() = default;
        ~Union_() = default;
        ::net::CanonicalCookie* cookie;
        std::string* cookie_string;
    };

    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);

    void DestroyActive();
    Tag tag_;
    Union_ data_;
};

class CookieManagerParams {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieManagerParams, T>::value>;
    using DataView = CookieManagerParamsDataView;
    using Data_ = internal::CookieManagerParams_Data;

    template <typename... Args> static CookieManagerParamsPtr New(Args&&... args)
    {
        return CookieManagerParamsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieManagerParamsPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieManagerParamsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieManagerParams>::Convert(*this);
    }

    CookieManagerParams();

    CookieManagerParams(bool block_third_party_cookies, bool tracking_protection_enabled_for_3pcd, bool mitigations_enabled_for_3pcd,
        const base::flat_map<::content_settings::mojom::ContentSettingsType, std::vector<::ContentSettingPatternSource>>& content_settings,
        std::vector<std::string> secure_origin_cookies_allowed_schemes, std::vector<std::string> matching_scheme_cookies_allowed_schemes,
        std::vector<std::string> third_party_cookies_allowed_schemes, bool allow_file_scheme_cookies, CookieAccessDelegateType cookie_access_delegate_type);

    ~CookieManagerParams();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieManagerParamsPtr> CookieManagerParamsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieManagerParams::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieManagerParams::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieManagerParams::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieManagerParams::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieManagerParams::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieManagerParams_UnserializedMessageContext<UserType, CookieManagerParams::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieManagerParams::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieManagerParams::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CookieManagerParams_UnserializedMessageContext<UserType, CookieManagerParams::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieManagerParams::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool block_third_party_cookies;

    bool tracking_protection_enabled_for_3pcd;

    bool mitigations_enabled_for_3pcd;

    base::flat_map<::content_settings::mojom::ContentSettingsType, std::vector<::ContentSettingPatternSource>> content_settings;

    std::vector<std::string> secure_origin_cookies_allowed_schemes;

    std::vector<std::string> matching_scheme_cookies_allowed_schemes;

    std::vector<std::string> third_party_cookies_allowed_schemes;

    bool allow_file_scheme_cookies;

    CookieAccessDelegateType cookie_access_delegate_type;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieManagerParams::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieManagerParams::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieManagerParams::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieManagerParams::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieSameSiteContext {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieSameSiteContext, T>::value>;
    using DataView = CookieSameSiteContextDataView;
    using Data_ = internal::CookieSameSiteContext_Data;

    template <typename... Args> static CookieSameSiteContextPtr New(Args&&... args)
    {
        return CookieSameSiteContextPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieSameSiteContextPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieSameSiteContextPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieSameSiteContext>::Convert(*this);
    }

    CookieSameSiteContext();

    CookieSameSiteContext(ContextType context, ContextType schemeful_context, const ::net::CookieOptions::SameSiteCookieContext::ContextMetadata& metadata,
        const ::net::CookieOptions::SameSiteCookieContext::ContextMetadata& schemeful_metadata);

    ~CookieSameSiteContext();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieSameSiteContextPtr> CookieSameSiteContextPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieSameSiteContext::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieSameSiteContext::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieSameSiteContext::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieSameSiteContext::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieSameSiteContext::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieSameSiteContext_UnserializedMessageContext<UserType, CookieSameSiteContext::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieSameSiteContext::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieSameSiteContext::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CookieSameSiteContext_UnserializedMessageContext<UserType, CookieSameSiteContext::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieSameSiteContext::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ContextType context;

    ContextType schemeful_context;

    ::net::CookieOptions::SameSiteCookieContext::ContextMetadata metadata;

    ::net::CookieOptions::SameSiteCookieContext::ContextMetadata schemeful_metadata;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieSameSiteContext::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieSameSiteContext::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieSameSiteContext::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieSameSiteContext::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieOptions {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieOptions, T>::value>;
    using DataView = CookieOptionsDataView;
    using Data_ = internal::CookieOptions_Data;

    template <typename... Args> static CookieOptionsPtr New(Args&&... args)
    {
        return CookieOptionsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieOptionsPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieOptionsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieOptions>::Convert(*this);
    }

    CookieOptions();

    CookieOptions(bool exclude_httponly, const ::net::CookieOptions::SameSiteCookieContext& same_site_cookie_context, bool update_access_time,
        bool return_excluded_cookies);

    ~CookieOptions();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieOptionsPtr> CookieOptionsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieOptions::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieOptions::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieOptions::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieOptions::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieOptions::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::CookieOptions_UnserializedMessageContext<UserType, CookieOptions::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieOptions::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieOptions::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CookieOptions_UnserializedMessageContext<UserType, CookieOptions::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieOptions::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    bool exclude_httponly;

    ::net::CookieOptions::SameSiteCookieContext same_site_cookie_context;

    bool update_access_time;

    bool return_excluded_cookies;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieOptions::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieOptions::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieOptions::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieOptions::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CanonicalCookie {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CanonicalCookie, T>::value>;
    using DataView = CanonicalCookieDataView;
    using Data_ = internal::CanonicalCookie_Data;

    template <typename... Args> static CanonicalCookiePtr New(Args&&... args)
    {
        return CanonicalCookiePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CanonicalCookiePtr From(const U& u)
    {
        return mojo::TypeConverter<CanonicalCookiePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CanonicalCookie>::Convert(*this);
    }

    CanonicalCookie();

    CanonicalCookie(const std::string& name, const std::string& value, const std::string& domain, const std::string& path, ::base::Time creation,
        ::base::Time expiry, ::base::Time last_access, ::base::Time last_update, bool secure, bool httponly, ::net::CookieSameSite site_restrictions,
        ::net::CookiePriority priority, ::net::CookieSourceScheme source_scheme, const std::optional<::net::CookiePartitionKey>& partition_key,
        int32_t source_port, CookieSourceType source_type);

    ~CanonicalCookie();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CanonicalCookiePtr> CanonicalCookiePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CanonicalCookie::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CanonicalCookie::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CanonicalCookie::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CanonicalCookie::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CanonicalCookie::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CanonicalCookie_UnserializedMessageContext<UserType, CanonicalCookie::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CanonicalCookie::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CanonicalCookie::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CanonicalCookie_UnserializedMessageContext<UserType, CanonicalCookie::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CanonicalCookie::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::string name;

    std::string value;

    std::string domain;

    std::string path;

    ::base::Time creation;

    ::base::Time expiry;

    ::base::Time last_access;

    ::base::Time last_update;

    bool secure;

    bool httponly;

    ::net::CookieSameSite site_restrictions;

    ::net::CookiePriority priority;

    ::net::CookieSourceScheme source_scheme;

    std::optional<::net::CookiePartitionKey> partition_key;

    int32_t source_port;

    CookieSourceType source_type;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CanonicalCookie::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CanonicalCookie::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CanonicalCookie::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CanonicalCookie::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieAndLineWithAccessResult {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieAndLineWithAccessResult, T>::value>;
    using DataView = CookieAndLineWithAccessResultDataView;
    using Data_ = internal::CookieAndLineWithAccessResult_Data;

    template <typename... Args> static CookieAndLineWithAccessResultPtr New(Args&&... args)
    {
        return CookieAndLineWithAccessResultPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieAndLineWithAccessResultPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieAndLineWithAccessResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieAndLineWithAccessResult>::Convert(*this);
    }

    CookieAndLineWithAccessResult();

    CookieAndLineWithAccessResult(
        const std::optional<::net::CanonicalCookie>& cookie, const std::string& cookie_string, ::net::CookieAccessResult access_result);

    CookieAndLineWithAccessResult(const CookieAndLineWithAccessResult&) = delete;
    CookieAndLineWithAccessResult& operator=(const CookieAndLineWithAccessResult&) = delete;

    ~CookieAndLineWithAccessResult();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieAndLineWithAccessResultPtr> CookieAndLineWithAccessResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieAndLineWithAccessResult::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieAndLineWithAccessResult::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieAndLineWithAccessResult_UnserializedMessageContext<UserType, CookieAndLineWithAccessResult::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieAndLineWithAccessResult::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieAndLineWithAccessResult::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::CookieAndLineWithAccessResult_UnserializedMessageContext<UserType, CookieAndLineWithAccessResult::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieAndLineWithAccessResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::optional<::net::CanonicalCookie> cookie;

    std::string cookie_string;

    ::net::CookieAccessResult access_result;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieOrLineWithAccessResult {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieOrLineWithAccessResult, T>::value>;
    using DataView = CookieOrLineWithAccessResultDataView;
    using Data_ = internal::CookieOrLineWithAccessResult_Data;

    template <typename... Args> static CookieOrLineWithAccessResultPtr New(Args&&... args)
    {
        return CookieOrLineWithAccessResultPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieOrLineWithAccessResultPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieOrLineWithAccessResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieOrLineWithAccessResult>::Convert(*this);
    }

    CookieOrLineWithAccessResult();

    CookieOrLineWithAccessResult(CookieOrLinePtr cookie_or_line, ::net::CookieAccessResult access_result);

    CookieOrLineWithAccessResult(const CookieOrLineWithAccessResult&) = delete;
    CookieOrLineWithAccessResult& operator=(const CookieOrLineWithAccessResult&) = delete;

    ~CookieOrLineWithAccessResult();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieOrLineWithAccessResultPtr> CookieOrLineWithAccessResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieOrLineWithAccessResult::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieOrLineWithAccessResult::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieOrLineWithAccessResult_UnserializedMessageContext<UserType, CookieOrLineWithAccessResult::DataView>>(
                0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieOrLineWithAccessResult::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieOrLineWithAccessResult::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<
            internal::CookieOrLineWithAccessResult_UnserializedMessageContext<UserType, CookieOrLineWithAccessResult::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieOrLineWithAccessResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    CookieOrLinePtr cookie_or_line;

    ::net::CookieAccessResult access_result;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieAccessResult {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieAccessResult, T>::value>;
    using DataView = CookieAccessResultDataView;
    using Data_ = internal::CookieAccessResult_Data;

    template <typename... Args> static CookieAccessResultPtr New(Args&&... args)
    {
        return CookieAccessResultPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieAccessResultPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieAccessResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieAccessResult>::Convert(*this);
    }

    CookieAccessResult();

    CookieAccessResult(::net::CookieEffectiveSameSite effective_same_site, ::net::CookieAccessSemantics access_semantics, ::net::CookieInclusionStatus status,
        bool is_allowed_to_access_secure_cookies);

    CookieAccessResult(const CookieAccessResult&) = delete;
    CookieAccessResult& operator=(const CookieAccessResult&) = delete;

    ~CookieAccessResult();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieAccessResultPtr> CookieAccessResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieAccessResult::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieAccessResult::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieAccessResult::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieAccessResult::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieAccessResult::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieAccessResult_UnserializedMessageContext<UserType, CookieAccessResult::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieAccessResult::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieAccessResult::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CookieAccessResult_UnserializedMessageContext<UserType, CookieAccessResult::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieAccessResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::net::CookieEffectiveSameSite effective_same_site;

    ::net::CookieAccessSemantics access_semantics;

    ::net::CookieInclusionStatus status;

    bool is_allowed_to_access_secure_cookies;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieAccessResult::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieAccessResult::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieAccessResult::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieAccessResult::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieWithAccessResult {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieWithAccessResult, T>::value>;
    using DataView = CookieWithAccessResultDataView;
    using Data_ = internal::CookieWithAccessResult_Data;

    template <typename... Args> static CookieWithAccessResultPtr New(Args&&... args)
    {
        return CookieWithAccessResultPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieWithAccessResultPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieWithAccessResultPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieWithAccessResult>::Convert(*this);
    }

    CookieWithAccessResult();

    CookieWithAccessResult(const ::net::CanonicalCookie& cookie, ::net::CookieAccessResult access_result);

    CookieWithAccessResult(const CookieWithAccessResult&) = delete;
    CookieWithAccessResult& operator=(const CookieWithAccessResult&) = delete;

    ~CookieWithAccessResult();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieWithAccessResultPtr> CookieWithAccessResultPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieWithAccessResult::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieWithAccessResult::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieWithAccessResult::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieWithAccessResult::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieWithAccessResult::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieWithAccessResult_UnserializedMessageContext<UserType, CookieWithAccessResult::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieWithAccessResult::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieWithAccessResult::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CookieWithAccessResult_UnserializedMessageContext<UserType, CookieWithAccessResult::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieWithAccessResult::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::net::CanonicalCookie cookie;

    ::net::CookieAccessResult access_result;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieWithAccessResult::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieWithAccessResult::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieWithAccessResult::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieWithAccessResult::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieChangeInfo {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieChangeInfo, T>::value>;
    using DataView = CookieChangeInfoDataView;
    using Data_ = internal::CookieChangeInfo_Data;

    template <typename... Args> static CookieChangeInfoPtr New(Args&&... args)
    {
        return CookieChangeInfoPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieChangeInfoPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieChangeInfoPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieChangeInfo>::Convert(*this);
    }

    CookieChangeInfo();

    CookieChangeInfo(const ::net::CanonicalCookie& cookie, ::net::CookieAccessResult access_result, ::net::CookieChangeCause cause);

    CookieChangeInfo(const CookieChangeInfo&) = delete;
    CookieChangeInfo& operator=(const CookieChangeInfo&) = delete;

    ~CookieChangeInfo();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieChangeInfoPtr> CookieChangeInfoPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieChangeInfo::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieChangeInfo::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieChangeInfo::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieChangeInfo::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieChangeInfo::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieChangeInfo_UnserializedMessageContext<UserType, CookieChangeInfo::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieChangeInfo::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieChangeInfo::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CookieChangeInfo_UnserializedMessageContext<UserType, CookieChangeInfo::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieChangeInfo::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::net::CanonicalCookie cookie;

    ::net::CookieAccessResult access_result;

    ::net::CookieChangeCause cause;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieChangeInfo::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieChangeInfo::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieChangeInfo::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieChangeInfo::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class CookieDeletionFilter {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<CookieDeletionFilter, T>::value>;
    using DataView = CookieDeletionFilterDataView;
    using Data_ = internal::CookieDeletionFilter_Data;

    template <typename... Args> static CookieDeletionFilterPtr New(Args&&... args)
    {
        return CookieDeletionFilterPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static CookieDeletionFilterPtr From(const U& u)
    {
        return mojo::TypeConverter<CookieDeletionFilterPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, CookieDeletionFilter>::Convert(*this);
    }

    CookieDeletionFilter();

    CookieDeletionFilter(std::optional<::base::Time> created_after_time, std::optional<::base::Time> created_before_time,
        std::optional<std::vector<std::string>> excluding_domains, std::optional<std::vector<std::string>> including_domains,
        const std::optional<std::string>& cookie_name, const std::optional<std::string>& host_name, const std::optional<::GURL>& url,
        CookieDeletionSessionControl session_control, const std::optional<::net::CookiePartitionKeyCollection>& cookie_partition_key_collection,
        bool partitioned_state_only);

    ~CookieDeletionFilter();

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = CookieDeletionFilterPtr> CookieDeletionFilterPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, CookieDeletionFilter::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, CookieDeletionFilter::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, CookieDeletionFilter::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static std::vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<CookieDeletionFilter::DataView, std::vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<CookieDeletionFilter::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::CookieDeletionFilter_UnserializedMessageContext<UserType, CookieDeletionFilter::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<CookieDeletionFilter::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return CookieDeletionFilter::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::CookieDeletionFilter_UnserializedMessageContext<UserType, CookieDeletionFilter::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<CookieDeletionFilter::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::optional<::base::Time> created_after_time;

    std::optional<::base::Time> created_before_time;

    std::optional<std::vector<std::string>> excluding_domains;

    std::optional<std::vector<std::string>> including_domains;

    std::optional<std::string> cookie_name;

    std::optional<std::string> host_name;

    std::optional<::GURL> url;

    CookieDeletionSessionControl session_control;

    std::optional<::net::CookiePartitionKeyCollection> cookie_partition_key_collection;

    bool partitioned_state_only;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CookieDeletionFilter::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, CookieDeletionFilter::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, CookieDeletionFilter::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, CookieDeletionFilter::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename UnionPtrType> CookieOrLinePtr CookieOrLine::Clone() const
{
    switch (tag_) {
    case Tag::kCookie:
        return NewCookie(mojo::Clone(*data_.cookie));
    case Tag::kCookieString:
        return NewCookieString(mojo::Clone(*data_.cookie_string));
    }
    return nullptr;
}

template <typename T, typename std::enable_if<std::is_same<T, CookieOrLine>::value>::type*> bool CookieOrLine::Equals(const T& other) const
{
    if (tag_ != other.which())
        return false;

    switch (tag_) {
    case Tag::kCookie:
        return mojo::Equals(*(data_.cookie), *(other.data_.cookie));
    case Tag::kCookieString:
        return mojo::Equals(*(data_.cookie_string), *(other.data_.cookie_string));
    }

    return false;
}
template <typename StructPtrType> CookieManagerParamsPtr CookieManagerParams::Clone() const
{
    return New(mojo::Clone(block_third_party_cookies), mojo::Clone(tracking_protection_enabled_for_3pcd), mojo::Clone(mitigations_enabled_for_3pcd),
        mojo::Clone(content_settings), mojo::Clone(secure_origin_cookies_allowed_schemes), mojo::Clone(matching_scheme_cookies_allowed_schemes),
        mojo::Clone(third_party_cookies_allowed_schemes), mojo::Clone(allow_file_scheme_cookies), mojo::Clone(cookie_access_delegate_type));
}

template <typename T, CookieManagerParams::EnableIfSame<T>*> bool CookieManagerParams::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->block_third_party_cookies, other_struct.block_third_party_cookies))
        return false;
    if (!mojo::Equals(this->tracking_protection_enabled_for_3pcd, other_struct.tracking_protection_enabled_for_3pcd))
        return false;
    if (!mojo::Equals(this->mitigations_enabled_for_3pcd, other_struct.mitigations_enabled_for_3pcd))
        return false;
    if (!mojo::Equals(this->content_settings, other_struct.content_settings))
        return false;
    if (!mojo::Equals(this->secure_origin_cookies_allowed_schemes, other_struct.secure_origin_cookies_allowed_schemes))
        return false;
    if (!mojo::Equals(this->matching_scheme_cookies_allowed_schemes, other_struct.matching_scheme_cookies_allowed_schemes))
        return false;
    if (!mojo::Equals(this->third_party_cookies_allowed_schemes, other_struct.third_party_cookies_allowed_schemes))
        return false;
    if (!mojo::Equals(this->allow_file_scheme_cookies, other_struct.allow_file_scheme_cookies))
        return false;
    if (!mojo::Equals(this->cookie_access_delegate_type, other_struct.cookie_access_delegate_type))
        return false;
    return true;
}

template <typename T, CookieManagerParams::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.block_third_party_cookies < rhs.block_third_party_cookies)
        return true;
    if (rhs.block_third_party_cookies < lhs.block_third_party_cookies)
        return false;
    if (lhs.tracking_protection_enabled_for_3pcd < rhs.tracking_protection_enabled_for_3pcd)
        return true;
    if (rhs.tracking_protection_enabled_for_3pcd < lhs.tracking_protection_enabled_for_3pcd)
        return false;
    if (lhs.mitigations_enabled_for_3pcd < rhs.mitigations_enabled_for_3pcd)
        return true;
    if (rhs.mitigations_enabled_for_3pcd < lhs.mitigations_enabled_for_3pcd)
        return false;
    if (lhs.content_settings < rhs.content_settings)
        return true;
    if (rhs.content_settings < lhs.content_settings)
        return false;
    if (lhs.secure_origin_cookies_allowed_schemes < rhs.secure_origin_cookies_allowed_schemes)
        return true;
    if (rhs.secure_origin_cookies_allowed_schemes < lhs.secure_origin_cookies_allowed_schemes)
        return false;
    if (lhs.matching_scheme_cookies_allowed_schemes < rhs.matching_scheme_cookies_allowed_schemes)
        return true;
    if (rhs.matching_scheme_cookies_allowed_schemes < lhs.matching_scheme_cookies_allowed_schemes)
        return false;
    if (lhs.third_party_cookies_allowed_schemes < rhs.third_party_cookies_allowed_schemes)
        return true;
    if (rhs.third_party_cookies_allowed_schemes < lhs.third_party_cookies_allowed_schemes)
        return false;
    if (lhs.allow_file_scheme_cookies < rhs.allow_file_scheme_cookies)
        return true;
    if (rhs.allow_file_scheme_cookies < lhs.allow_file_scheme_cookies)
        return false;
    if (lhs.cookie_access_delegate_type < rhs.cookie_access_delegate_type)
        return true;
    if (rhs.cookie_access_delegate_type < lhs.cookie_access_delegate_type)
        return false;
    return false;
}
template <typename StructPtrType> CookieSameSiteContextMetadataPtr CookieSameSiteContextMetadata::Clone() const
{
    return New(mojo::Clone(cross_site_redirect_downgrade), mojo::Clone(redirect_type_bug_1221316), mojo::Clone(http_method_bug_1221316));
}

template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>*> bool CookieSameSiteContextMetadata::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->cross_site_redirect_downgrade, other_struct.cross_site_redirect_downgrade))
        return false;
    if (!mojo::Equals(this->redirect_type_bug_1221316, other_struct.redirect_type_bug_1221316))
        return false;
    if (!mojo::Equals(this->http_method_bug_1221316, other_struct.http_method_bug_1221316))
        return false;
    return true;
}

template <typename T, CookieSameSiteContextMetadata::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.cross_site_redirect_downgrade < rhs.cross_site_redirect_downgrade)
        return true;
    if (rhs.cross_site_redirect_downgrade < lhs.cross_site_redirect_downgrade)
        return false;
    if (lhs.redirect_type_bug_1221316 < rhs.redirect_type_bug_1221316)
        return true;
    if (rhs.redirect_type_bug_1221316 < lhs.redirect_type_bug_1221316)
        return false;
    if (lhs.http_method_bug_1221316 < rhs.http_method_bug_1221316)
        return true;
    if (rhs.http_method_bug_1221316 < lhs.http_method_bug_1221316)
        return false;
    return false;
}
template <typename StructPtrType> CookieSameSiteContextPtr CookieSameSiteContext::Clone() const
{
    return New(mojo::Clone(context), mojo::Clone(schemeful_context), mojo::Clone(metadata), mojo::Clone(schemeful_metadata));
}

template <typename T, CookieSameSiteContext::EnableIfSame<T>*> bool CookieSameSiteContext::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->context, other_struct.context))
        return false;
    if (!mojo::Equals(this->schemeful_context, other_struct.schemeful_context))
        return false;
    if (!mojo::Equals(this->metadata, other_struct.metadata))
        return false;
    if (!mojo::Equals(this->schemeful_metadata, other_struct.schemeful_metadata))
        return false;
    return true;
}

template <typename T, CookieSameSiteContext::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.context < rhs.context)
        return true;
    if (rhs.context < lhs.context)
        return false;
    if (lhs.schemeful_context < rhs.schemeful_context)
        return true;
    if (rhs.schemeful_context < lhs.schemeful_context)
        return false;
    if (lhs.metadata < rhs.metadata)
        return true;
    if (rhs.metadata < lhs.metadata)
        return false;
    if (lhs.schemeful_metadata < rhs.schemeful_metadata)
        return true;
    if (rhs.schemeful_metadata < lhs.schemeful_metadata)
        return false;
    return false;
}
template <typename StructPtrType> CookieOptionsPtr CookieOptions::Clone() const
{
    return New(mojo::Clone(exclude_httponly), mojo::Clone(same_site_cookie_context), mojo::Clone(update_access_time), mojo::Clone(return_excluded_cookies));
}

template <typename T, CookieOptions::EnableIfSame<T>*> bool CookieOptions::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->exclude_httponly, other_struct.exclude_httponly))
        return false;
    if (!mojo::Equals(this->same_site_cookie_context, other_struct.same_site_cookie_context))
        return false;
    if (!mojo::Equals(this->update_access_time, other_struct.update_access_time))
        return false;
    if (!mojo::Equals(this->return_excluded_cookies, other_struct.return_excluded_cookies))
        return false;
    return true;
}

template <typename T, CookieOptions::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.exclude_httponly < rhs.exclude_httponly)
        return true;
    if (rhs.exclude_httponly < lhs.exclude_httponly)
        return false;
    if (lhs.same_site_cookie_context < rhs.same_site_cookie_context)
        return true;
    if (rhs.same_site_cookie_context < lhs.same_site_cookie_context)
        return false;
    if (lhs.update_access_time < rhs.update_access_time)
        return true;
    if (rhs.update_access_time < lhs.update_access_time)
        return false;
    if (lhs.return_excluded_cookies < rhs.return_excluded_cookies)
        return true;
    if (rhs.return_excluded_cookies < lhs.return_excluded_cookies)
        return false;
    return false;
}
template <typename StructPtrType> CanonicalCookiePtr CanonicalCookie::Clone() const
{
    return New(mojo::Clone(name), mojo::Clone(value), mojo::Clone(domain), mojo::Clone(path), mojo::Clone(creation), mojo::Clone(expiry),
        mojo::Clone(last_access), mojo::Clone(last_update), mojo::Clone(secure), mojo::Clone(httponly), mojo::Clone(site_restrictions), mojo::Clone(priority),
        mojo::Clone(source_scheme), mojo::Clone(partition_key), mojo::Clone(source_port), mojo::Clone(source_type));
}

template <typename T, CanonicalCookie::EnableIfSame<T>*> bool CanonicalCookie::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    if (!mojo::Equals(this->domain, other_struct.domain))
        return false;
    if (!mojo::Equals(this->path, other_struct.path))
        return false;
    if (!mojo::Equals(this->creation, other_struct.creation))
        return false;
    if (!mojo::Equals(this->expiry, other_struct.expiry))
        return false;
    if (!mojo::Equals(this->last_access, other_struct.last_access))
        return false;
    if (!mojo::Equals(this->last_update, other_struct.last_update))
        return false;
    if (!mojo::Equals(this->secure, other_struct.secure))
        return false;
    if (!mojo::Equals(this->httponly, other_struct.httponly))
        return false;
    if (!mojo::Equals(this->site_restrictions, other_struct.site_restrictions))
        return false;
    if (!mojo::Equals(this->priority, other_struct.priority))
        return false;
    if (!mojo::Equals(this->source_scheme, other_struct.source_scheme))
        return false;
    if (!mojo::Equals(this->partition_key, other_struct.partition_key))
        return false;
    if (!mojo::Equals(this->source_port, other_struct.source_port))
        return false;
    if (!mojo::Equals(this->source_type, other_struct.source_type))
        return false;
    return true;
}

template <typename T, CanonicalCookie::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    if (lhs.domain < rhs.domain)
        return true;
    if (rhs.domain < lhs.domain)
        return false;
    if (lhs.path < rhs.path)
        return true;
    if (rhs.path < lhs.path)
        return false;
    if (lhs.creation < rhs.creation)
        return true;
    if (rhs.creation < lhs.creation)
        return false;
    if (lhs.expiry < rhs.expiry)
        return true;
    if (rhs.expiry < lhs.expiry)
        return false;
    if (lhs.last_access < rhs.last_access)
        return true;
    if (rhs.last_access < lhs.last_access)
        return false;
    if (lhs.last_update < rhs.last_update)
        return true;
    if (rhs.last_update < lhs.last_update)
        return false;
    if (lhs.secure < rhs.secure)
        return true;
    if (rhs.secure < lhs.secure)
        return false;
    if (lhs.httponly < rhs.httponly)
        return true;
    if (rhs.httponly < lhs.httponly)
        return false;
    if (lhs.site_restrictions < rhs.site_restrictions)
        return true;
    if (rhs.site_restrictions < lhs.site_restrictions)
        return false;
    if (lhs.priority < rhs.priority)
        return true;
    if (rhs.priority < lhs.priority)
        return false;
    if (lhs.source_scheme < rhs.source_scheme)
        return true;
    if (rhs.source_scheme < lhs.source_scheme)
        return false;
    if (lhs.partition_key < rhs.partition_key)
        return true;
    if (rhs.partition_key < lhs.partition_key)
        return false;
    if (lhs.source_port < rhs.source_port)
        return true;
    if (rhs.source_port < lhs.source_port)
        return false;
    if (lhs.source_type < rhs.source_type)
        return true;
    if (rhs.source_type < lhs.source_type)
        return false;
    return false;
}
template <typename StructPtrType> CookieInclusionStatusPtr CookieInclusionStatus::Clone() const
{
    return New(mojo::Clone(exclusion_reasons), mojo::Clone(warning_reasons), mojo::Clone(exemption_reason));
}

template <typename T, CookieInclusionStatus::EnableIfSame<T>*> bool CookieInclusionStatus::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->exclusion_reasons, other_struct.exclusion_reasons))
        return false;
    if (!mojo::Equals(this->warning_reasons, other_struct.warning_reasons))
        return false;
    if (!mojo::Equals(this->exemption_reason, other_struct.exemption_reason))
        return false;
    return true;
}

template <typename T, CookieInclusionStatus::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.exclusion_reasons < rhs.exclusion_reasons)
        return true;
    if (rhs.exclusion_reasons < lhs.exclusion_reasons)
        return false;
    if (lhs.warning_reasons < rhs.warning_reasons)
        return true;
    if (rhs.warning_reasons < lhs.warning_reasons)
        return false;
    if (lhs.exemption_reason < rhs.exemption_reason)
        return true;
    if (rhs.exemption_reason < lhs.exemption_reason)
        return false;
    return false;
}
template <typename StructPtrType> CookieAndLineWithAccessResultPtr CookieAndLineWithAccessResult::Clone() const
{
    return New(mojo::Clone(cookie), mojo::Clone(cookie_string), mojo::Clone(access_result));
}

template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>*> bool CookieAndLineWithAccessResult::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->cookie, other_struct.cookie))
        return false;
    if (!mojo::Equals(this->cookie_string, other_struct.cookie_string))
        return false;
    if (!mojo::Equals(this->access_result, other_struct.access_result))
        return false;
    return true;
}

template <typename T, CookieAndLineWithAccessResult::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.cookie < rhs.cookie)
        return true;
    if (rhs.cookie < lhs.cookie)
        return false;
    if (lhs.cookie_string < rhs.cookie_string)
        return true;
    if (rhs.cookie_string < lhs.cookie_string)
        return false;
    if (lhs.access_result < rhs.access_result)
        return true;
    if (rhs.access_result < lhs.access_result)
        return false;
    return false;
}
template <typename StructPtrType> CookieOrLineWithAccessResultPtr CookieOrLineWithAccessResult::Clone() const
{
    return New(mojo::Clone(cookie_or_line), mojo::Clone(access_result));
}

template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>*> bool CookieOrLineWithAccessResult::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->cookie_or_line, other_struct.cookie_or_line))
        return false;
    if (!mojo::Equals(this->access_result, other_struct.access_result))
        return false;
    return true;
}

template <typename T, CookieOrLineWithAccessResult::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.cookie_or_line < rhs.cookie_or_line)
        return true;
    if (rhs.cookie_or_line < lhs.cookie_or_line)
        return false;
    if (lhs.access_result < rhs.access_result)
        return true;
    if (rhs.access_result < lhs.access_result)
        return false;
    return false;
}
template <typename StructPtrType> CookieAccessResultPtr CookieAccessResult::Clone() const
{
    return New(mojo::Clone(effective_same_site), mojo::Clone(access_semantics), mojo::Clone(status), mojo::Clone(is_allowed_to_access_secure_cookies));
}

template <typename T, CookieAccessResult::EnableIfSame<T>*> bool CookieAccessResult::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->effective_same_site, other_struct.effective_same_site))
        return false;
    if (!mojo::Equals(this->access_semantics, other_struct.access_semantics))
        return false;
    if (!mojo::Equals(this->status, other_struct.status))
        return false;
    if (!mojo::Equals(this->is_allowed_to_access_secure_cookies, other_struct.is_allowed_to_access_secure_cookies))
        return false;
    return true;
}

template <typename T, CookieAccessResult::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.effective_same_site < rhs.effective_same_site)
        return true;
    if (rhs.effective_same_site < lhs.effective_same_site)
        return false;
    if (lhs.access_semantics < rhs.access_semantics)
        return true;
    if (rhs.access_semantics < lhs.access_semantics)
        return false;
    if (lhs.status < rhs.status)
        return true;
    if (rhs.status < lhs.status)
        return false;
    if (lhs.is_allowed_to_access_secure_cookies < rhs.is_allowed_to_access_secure_cookies)
        return true;
    if (rhs.is_allowed_to_access_secure_cookies < lhs.is_allowed_to_access_secure_cookies)
        return false;
    return false;
}
template <typename StructPtrType> CookieWithAccessResultPtr CookieWithAccessResult::Clone() const
{
    return New(mojo::Clone(cookie), mojo::Clone(access_result));
}

template <typename T, CookieWithAccessResult::EnableIfSame<T>*> bool CookieWithAccessResult::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->cookie, other_struct.cookie))
        return false;
    if (!mojo::Equals(this->access_result, other_struct.access_result))
        return false;
    return true;
}

template <typename T, CookieWithAccessResult::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.cookie < rhs.cookie)
        return true;
    if (rhs.cookie < lhs.cookie)
        return false;
    if (lhs.access_result < rhs.access_result)
        return true;
    if (rhs.access_result < lhs.access_result)
        return false;
    return false;
}
template <typename StructPtrType> CookieChangeInfoPtr CookieChangeInfo::Clone() const
{
    return New(mojo::Clone(cookie), mojo::Clone(access_result), mojo::Clone(cause));
}

template <typename T, CookieChangeInfo::EnableIfSame<T>*> bool CookieChangeInfo::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->cookie, other_struct.cookie))
        return false;
    if (!mojo::Equals(this->access_result, other_struct.access_result))
        return false;
    if (!mojo::Equals(this->cause, other_struct.cause))
        return false;
    return true;
}

template <typename T, CookieChangeInfo::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.cookie < rhs.cookie)
        return true;
    if (rhs.cookie < lhs.cookie)
        return false;
    if (lhs.access_result < rhs.access_result)
        return true;
    if (rhs.access_result < lhs.access_result)
        return false;
    if (lhs.cause < rhs.cause)
        return true;
    if (rhs.cause < lhs.cause)
        return false;
    return false;
}
template <typename StructPtrType> CookieDeletionFilterPtr CookieDeletionFilter::Clone() const
{
    return New(mojo::Clone(created_after_time), mojo::Clone(created_before_time), mojo::Clone(excluding_domains), mojo::Clone(including_domains),
        mojo::Clone(cookie_name), mojo::Clone(host_name), mojo::Clone(url), mojo::Clone(session_control), mojo::Clone(cookie_partition_key_collection),
        mojo::Clone(partitioned_state_only));
}

template <typename T, CookieDeletionFilter::EnableIfSame<T>*> bool CookieDeletionFilter::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->created_after_time, other_struct.created_after_time))
        return false;
    if (!mojo::Equals(this->created_before_time, other_struct.created_before_time))
        return false;
    if (!mojo::Equals(this->excluding_domains, other_struct.excluding_domains))
        return false;
    if (!mojo::Equals(this->including_domains, other_struct.including_domains))
        return false;
    if (!mojo::Equals(this->cookie_name, other_struct.cookie_name))
        return false;
    if (!mojo::Equals(this->host_name, other_struct.host_name))
        return false;
    if (!mojo::Equals(this->url, other_struct.url))
        return false;
    if (!mojo::Equals(this->session_control, other_struct.session_control))
        return false;
    if (!mojo::Equals(this->cookie_partition_key_collection, other_struct.cookie_partition_key_collection))
        return false;
    if (!mojo::Equals(this->partitioned_state_only, other_struct.partitioned_state_only))
        return false;
    return true;
}

template <typename T, CookieDeletionFilter::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.created_after_time < rhs.created_after_time)
        return true;
    if (rhs.created_after_time < lhs.created_after_time)
        return false;
    if (lhs.created_before_time < rhs.created_before_time)
        return true;
    if (rhs.created_before_time < lhs.created_before_time)
        return false;
    if (lhs.excluding_domains < rhs.excluding_domains)
        return true;
    if (rhs.excluding_domains < lhs.excluding_domains)
        return false;
    if (lhs.including_domains < rhs.including_domains)
        return true;
    if (rhs.including_domains < lhs.including_domains)
        return false;
    if (lhs.cookie_name < rhs.cookie_name)
        return true;
    if (rhs.cookie_name < lhs.cookie_name)
        return false;
    if (lhs.host_name < rhs.host_name)
        return true;
    if (rhs.host_name < lhs.host_name)
        return false;
    if (lhs.url < rhs.url)
        return true;
    if (rhs.url < lhs.url)
        return false;
    if (lhs.session_control < rhs.session_control)
        return true;
    if (rhs.session_control < lhs.session_control)
        return false;
    if (lhs.cookie_partition_key_collection < rhs.cookie_partition_key_collection)
        return true;
    if (rhs.cookie_partition_key_collection < lhs.cookie_partition_key_collection)
        return false;
    if (lhs.partitioned_state_only < rhs.partitioned_state_only)
        return true;
    if (rhs.partitioned_state_only < lhs.partitioned_state_only)
        return false;
    return false;
}

} // network::mojom

namespace mojo {

template <> struct StructTraits<::network::mojom::CookieManagerParams::DataView, ::network::mojom::CookieManagerParamsPtr> {
    static bool IsNull(const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieManagerParamsPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::CookieManagerParams::block_third_party_cookies) block_third_party_cookies(
        const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->block_third_party_cookies;
    }

    static decltype(::network::mojom::CookieManagerParams::tracking_protection_enabled_for_3pcd) tracking_protection_enabled_for_3pcd(
        const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->tracking_protection_enabled_for_3pcd;
    }

    static decltype(::network::mojom::CookieManagerParams::mitigations_enabled_for_3pcd) mitigations_enabled_for_3pcd(
        const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->mitigations_enabled_for_3pcd;
    }

    static const decltype(::network::mojom::CookieManagerParams::content_settings)& content_settings(const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->content_settings;
    }

    static const decltype(::network::mojom::CookieManagerParams::secure_origin_cookies_allowed_schemes)& secure_origin_cookies_allowed_schemes(
        const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->secure_origin_cookies_allowed_schemes;
    }

    static const decltype(::network::mojom::CookieManagerParams::matching_scheme_cookies_allowed_schemes)& matching_scheme_cookies_allowed_schemes(
        const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->matching_scheme_cookies_allowed_schemes;
    }

    static const decltype(::network::mojom::CookieManagerParams::third_party_cookies_allowed_schemes)& third_party_cookies_allowed_schemes(
        const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->third_party_cookies_allowed_schemes;
    }

    static decltype(::network::mojom::CookieManagerParams::allow_file_scheme_cookies) allow_file_scheme_cookies(
        const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->allow_file_scheme_cookies;
    }

    static decltype(::network::mojom::CookieManagerParams::cookie_access_delegate_type) cookie_access_delegate_type(
        const ::network::mojom::CookieManagerParamsPtr& input)
    {
        return input->cookie_access_delegate_type;
    }

    static bool Read(::network::mojom::CookieManagerParams::DataView input, ::network::mojom::CookieManagerParamsPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieSameSiteContextMetadata::DataView, ::network::mojom::CookieSameSiteContextMetadataPtr> {
    static bool IsNull(const ::network::mojom::CookieSameSiteContextMetadataPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieSameSiteContextMetadataPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::CookieSameSiteContextMetadata::cross_site_redirect_downgrade) cross_site_redirect_downgrade(
        const ::network::mojom::CookieSameSiteContextMetadataPtr& input)
    {
        return input->cross_site_redirect_downgrade;
    }

    static decltype(::network::mojom::CookieSameSiteContextMetadata::redirect_type_bug_1221316) redirect_type_bug_1221316(
        const ::network::mojom::CookieSameSiteContextMetadataPtr& input)
    {
        return input->redirect_type_bug_1221316;
    }

    static decltype(::network::mojom::CookieSameSiteContextMetadata::http_method_bug_1221316) http_method_bug_1221316(
        const ::network::mojom::CookieSameSiteContextMetadataPtr& input)
    {
        return input->http_method_bug_1221316;
    }

    static bool Read(::network::mojom::CookieSameSiteContextMetadata::DataView input, ::network::mojom::CookieSameSiteContextMetadataPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieSameSiteContext::DataView, ::network::mojom::CookieSameSiteContextPtr> {
    static bool IsNull(const ::network::mojom::CookieSameSiteContextPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieSameSiteContextPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::CookieSameSiteContext::context) context(const ::network::mojom::CookieSameSiteContextPtr& input)
    {
        return input->context;
    }

    static decltype(::network::mojom::CookieSameSiteContext::schemeful_context) schemeful_context(const ::network::mojom::CookieSameSiteContextPtr& input)
    {
        return input->schemeful_context;
    }

    static const decltype(::network::mojom::CookieSameSiteContext::metadata)& metadata(const ::network::mojom::CookieSameSiteContextPtr& input)
    {
        return input->metadata;
    }

    static const decltype(::network::mojom::CookieSameSiteContext::schemeful_metadata)& schemeful_metadata(
        const ::network::mojom::CookieSameSiteContextPtr& input)
    {
        return input->schemeful_metadata;
    }

    static bool Read(::network::mojom::CookieSameSiteContext::DataView input, ::network::mojom::CookieSameSiteContextPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieOptions::DataView, ::network::mojom::CookieOptionsPtr> {
    static bool IsNull(const ::network::mojom::CookieOptionsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieOptionsPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::CookieOptions::exclude_httponly) exclude_httponly(const ::network::mojom::CookieOptionsPtr& input)
    {
        return input->exclude_httponly;
    }

    static const decltype(::network::mojom::CookieOptions::same_site_cookie_context)& same_site_cookie_context(const ::network::mojom::CookieOptionsPtr& input)
    {
        return input->same_site_cookie_context;
    }

    static decltype(::network::mojom::CookieOptions::update_access_time) update_access_time(const ::network::mojom::CookieOptionsPtr& input)
    {
        return input->update_access_time;
    }

    static decltype(::network::mojom::CookieOptions::return_excluded_cookies) return_excluded_cookies(const ::network::mojom::CookieOptionsPtr& input)
    {
        return input->return_excluded_cookies;
    }

    static bool Read(::network::mojom::CookieOptions::DataView input, ::network::mojom::CookieOptionsPtr* output);
};

template <> struct StructTraits<::network::mojom::CanonicalCookie::DataView, ::network::mojom::CanonicalCookiePtr> {
    static bool IsNull(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CanonicalCookiePtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::CanonicalCookie::name)& name(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->name;
    }

    static const decltype(::network::mojom::CanonicalCookie::value)& value(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->value;
    }

    static const decltype(::network::mojom::CanonicalCookie::domain)& domain(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->domain;
    }

    static const decltype(::network::mojom::CanonicalCookie::path)& path(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->path;
    }

    static const decltype(::network::mojom::CanonicalCookie::creation)& creation(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->creation;
    }

    static const decltype(::network::mojom::CanonicalCookie::expiry)& expiry(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->expiry;
    }

    static const decltype(::network::mojom::CanonicalCookie::last_access)& last_access(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->last_access;
    }

    static const decltype(::network::mojom::CanonicalCookie::last_update)& last_update(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->last_update;
    }

    static decltype(::network::mojom::CanonicalCookie::secure) secure(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->secure;
    }

    static decltype(::network::mojom::CanonicalCookie::httponly) httponly(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->httponly;
    }

    static decltype(::network::mojom::CanonicalCookie::site_restrictions) site_restrictions(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->site_restrictions;
    }

    static decltype(::network::mojom::CanonicalCookie::priority) priority(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->priority;
    }

    static decltype(::network::mojom::CanonicalCookie::source_scheme) source_scheme(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->source_scheme;
    }

    static const decltype(::network::mojom::CanonicalCookie::partition_key)& partition_key(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->partition_key;
    }

    static decltype(::network::mojom::CanonicalCookie::source_port) source_port(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->source_port;
    }

    static decltype(::network::mojom::CanonicalCookie::source_type) source_type(const ::network::mojom::CanonicalCookiePtr& input)
    {
        return input->source_type;
    }

    static bool Read(::network::mojom::CanonicalCookie::DataView input, ::network::mojom::CanonicalCookiePtr* output);
};

template <> struct StructTraits<::network::mojom::CookieInclusionStatus::DataView, ::network::mojom::CookieInclusionStatusPtr> {
    static bool IsNull(const ::network::mojom::CookieInclusionStatusPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieInclusionStatusPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::CookieInclusionStatus::exclusion_reasons) exclusion_reasons(const ::network::mojom::CookieInclusionStatusPtr& input)
    {
        return input->exclusion_reasons;
    }

    static decltype(::network::mojom::CookieInclusionStatus::warning_reasons) warning_reasons(const ::network::mojom::CookieInclusionStatusPtr& input)
    {
        return input->warning_reasons;
    }

    static decltype(::network::mojom::CookieInclusionStatus::exemption_reason) exemption_reason(const ::network::mojom::CookieInclusionStatusPtr& input)
    {
        return input->exemption_reason;
    }

    static bool Read(::network::mojom::CookieInclusionStatus::DataView input, ::network::mojom::CookieInclusionStatusPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieAndLineWithAccessResult::DataView, ::network::mojom::CookieAndLineWithAccessResultPtr> {
    static bool IsNull(const ::network::mojom::CookieAndLineWithAccessResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieAndLineWithAccessResultPtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::CookieAndLineWithAccessResult::cookie)& cookie(const ::network::mojom::CookieAndLineWithAccessResultPtr& input)
    {
        return input->cookie;
    }

    static const decltype(::network::mojom::CookieAndLineWithAccessResult::cookie_string)& cookie_string(
        const ::network::mojom::CookieAndLineWithAccessResultPtr& input)
    {
        return input->cookie_string;
    }

    static const decltype(::network::mojom::CookieAndLineWithAccessResult::access_result)& access_result(
        const ::network::mojom::CookieAndLineWithAccessResultPtr& input)
    {
        return input->access_result;
    }

    static bool Read(::network::mojom::CookieAndLineWithAccessResult::DataView input, ::network::mojom::CookieAndLineWithAccessResultPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieOrLineWithAccessResult::DataView, ::network::mojom::CookieOrLineWithAccessResultPtr> {
    static bool IsNull(const ::network::mojom::CookieOrLineWithAccessResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieOrLineWithAccessResultPtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::CookieOrLineWithAccessResult::cookie_or_line)& cookie_or_line(
        const ::network::mojom::CookieOrLineWithAccessResultPtr& input)
    {
        return input->cookie_or_line;
    }

    static const decltype(::network::mojom::CookieOrLineWithAccessResult::access_result)& access_result(
        const ::network::mojom::CookieOrLineWithAccessResultPtr& input)
    {
        return input->access_result;
    }

    static bool Read(::network::mojom::CookieOrLineWithAccessResult::DataView input, ::network::mojom::CookieOrLineWithAccessResultPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieAccessResult::DataView, ::network::mojom::CookieAccessResultPtr> {
    static bool IsNull(const ::network::mojom::CookieAccessResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieAccessResultPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::CookieAccessResult::effective_same_site) effective_same_site(const ::network::mojom::CookieAccessResultPtr& input)
    {
        return input->effective_same_site;
    }

    static decltype(::network::mojom::CookieAccessResult::access_semantics) access_semantics(const ::network::mojom::CookieAccessResultPtr& input)
    {
        return input->access_semantics;
    }

    static const decltype(::network::mojom::CookieAccessResult::status)& status(const ::network::mojom::CookieAccessResultPtr& input)
    {
        return input->status;
    }

    static decltype(::network::mojom::CookieAccessResult::is_allowed_to_access_secure_cookies) is_allowed_to_access_secure_cookies(
        const ::network::mojom::CookieAccessResultPtr& input)
    {
        return input->is_allowed_to_access_secure_cookies;
    }

    static bool Read(::network::mojom::CookieAccessResult::DataView input, ::network::mojom::CookieAccessResultPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieWithAccessResult::DataView, ::network::mojom::CookieWithAccessResultPtr> {
    static bool IsNull(const ::network::mojom::CookieWithAccessResultPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieWithAccessResultPtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::CookieWithAccessResult::cookie)& cookie(const ::network::mojom::CookieWithAccessResultPtr& input)
    {
        return input->cookie;
    }

    static const decltype(::network::mojom::CookieWithAccessResult::access_result)& access_result(const ::network::mojom::CookieWithAccessResultPtr& input)
    {
        return input->access_result;
    }

    static bool Read(::network::mojom::CookieWithAccessResult::DataView input, ::network::mojom::CookieWithAccessResultPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieChangeInfo::DataView, ::network::mojom::CookieChangeInfoPtr> {
    static bool IsNull(const ::network::mojom::CookieChangeInfoPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieChangeInfoPtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::CookieChangeInfo::cookie)& cookie(const ::network::mojom::CookieChangeInfoPtr& input)
    {
        return input->cookie;
    }

    static const decltype(::network::mojom::CookieChangeInfo::access_result)& access_result(const ::network::mojom::CookieChangeInfoPtr& input)
    {
        return input->access_result;
    }

    static decltype(::network::mojom::CookieChangeInfo::cause) cause(const ::network::mojom::CookieChangeInfoPtr& input)
    {
        return input->cause;
    }

    static bool Read(::network::mojom::CookieChangeInfo::DataView input, ::network::mojom::CookieChangeInfoPtr* output);
};

template <> struct StructTraits<::network::mojom::CookieDeletionFilter::DataView, ::network::mojom::CookieDeletionFilterPtr> {
    static bool IsNull(const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieDeletionFilterPtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::CookieDeletionFilter::created_after_time)& created_after_time(
        const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->created_after_time;
    }

    static const decltype(::network::mojom::CookieDeletionFilter::created_before_time)& created_before_time(
        const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->created_before_time;
    }

    static const decltype(::network::mojom::CookieDeletionFilter::excluding_domains)& excluding_domains(const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->excluding_domains;
    }

    static const decltype(::network::mojom::CookieDeletionFilter::including_domains)& including_domains(const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->including_domains;
    }

    static const decltype(::network::mojom::CookieDeletionFilter::cookie_name)& cookie_name(const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->cookie_name;
    }

    static const decltype(::network::mojom::CookieDeletionFilter::host_name)& host_name(const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->host_name;
    }

    static const decltype(::network::mojom::CookieDeletionFilter::url)& url(const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->url;
    }

    static decltype(::network::mojom::CookieDeletionFilter::session_control) session_control(const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->session_control;
    }

    static const decltype(::network::mojom::CookieDeletionFilter::cookie_partition_key_collection)& cookie_partition_key_collection(
        const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->cookie_partition_key_collection;
    }

    static decltype(::network::mojom::CookieDeletionFilter::partitioned_state_only) partitioned_state_only(
        const ::network::mojom::CookieDeletionFilterPtr& input)
    {
        return input->partitioned_state_only;
    }

    static bool Read(::network::mojom::CookieDeletionFilter::DataView input, ::network::mojom::CookieDeletionFilterPtr* output);
};

template <> struct UnionTraits<::network::mojom::CookieOrLine::DataView, ::network::mojom::CookieOrLinePtr> {
    static bool IsNull(const ::network::mojom::CookieOrLinePtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::CookieOrLinePtr* output)
    {
        output->reset();
    }

    static ::network::mojom::CookieOrLine::Tag GetTag(const ::network::mojom::CookieOrLinePtr& input)
    {
        return input->which();
    }

    static const ::net::CanonicalCookie& cookie(const ::network::mojom::CookieOrLinePtr& input)
    {
        return input->get_cookie();
    }

    static const std::string& cookie_string(const ::network::mojom::CookieOrLinePtr& input)
    {
        return input->get_cookie_string();
    }

    static bool Read(::network::mojom::CookieOrLine::DataView input, ::network::mojom::CookieOrLinePtr* output);
};

} // namespace mojo

#endif // SERVICES_NETWORK_PUBLIC_MOJOM_COOKIE_MANAGER_MOJOM_H_
