// services/network/public/mojom/cookie_manager.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_COOKIE_MANAGER_MOJOM_SHARED_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_COOKIE_MANAGER_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/cookie_manager.mojom-shared-internal.h"
#include "components/content_settings/core/common/content_settings.mojom-shared.h"
#include "components/content_settings/core/common/content_settings_types.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "sandbox/policy/mojom/context.mojom-shared.h"
#include "services/network/public/mojom/cookie_partition_key.mojom-shared.h"
#include "services/network/public/mojom/first_party_sets.mojom-shared.h"
#include "services/network/public/mojom/schemeful_site.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"
#include "mojo/public/cpp/system/data_pipe.h"

namespace network::mojom {
class CookieManagerParamsDataView;

class CookieSameSiteContextMetadataDataView;

class CookieSameSiteContextDataView;

class CookieOptionsDataView;

class CanonicalCookieDataView;

class CookieInclusionStatusDataView;

class CookieAndLineWithAccessResultDataView;

class CookieOrLineWithAccessResultDataView;

class CookieAccessResultDataView;

class CookieWithAccessResultDataView;

class CookieChangeInfoDataView;

class CookieDeletionFilterDataView;

class CookieOrLineDataView;

} // network::mojom

namespace mojo {
namespace internal {

template <> struct MojomTypeTraits<::network::mojom::CookieManagerParamsDataView> {
    using Data = ::network::mojom::internal::CookieManagerParams_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieSameSiteContextMetadataDataView> {
    using Data = ::network::mojom::internal::CookieSameSiteContextMetadata_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieSameSiteContextDataView> {
    using Data = ::network::mojom::internal::CookieSameSiteContext_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieOptionsDataView> {
    using Data = ::network::mojom::internal::CookieOptions_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CanonicalCookieDataView> {
    using Data = ::network::mojom::internal::CanonicalCookie_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieInclusionStatusDataView> {
    using Data = ::network::mojom::internal::CookieInclusionStatus_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieAndLineWithAccessResultDataView> {
    using Data = ::network::mojom::internal::CookieAndLineWithAccessResult_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieOrLineWithAccessResultDataView> {
    using Data = ::network::mojom::internal::CookieOrLineWithAccessResult_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieAccessResultDataView> {
    using Data = ::network::mojom::internal::CookieAccessResult_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieWithAccessResultDataView> {
    using Data = ::network::mojom::internal::CookieWithAccessResult_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieChangeInfoDataView> {
    using Data = ::network::mojom::internal::CookieChangeInfo_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieDeletionFilterDataView> {
    using Data = ::network::mojom::internal::CookieDeletionFilter_Data;
    using DataAsArrayElement = Pointer<Data>;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <> struct MojomTypeTraits<::network::mojom::CookieOrLineDataView> {
    using Data = ::network::mojom::internal::CookieOrLine_Data;
    using DataAsArrayElement = Data;
    static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

} // namespace internal
} // namespace mojo

namespace network::mojom {

enum class CookieAccessDelegateType : int32_t {

    USE_CONTENT_SETTINGS = 0,

    ALWAYS_LEGACY = 1,

    ALWAYS_NONLEGACY = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, CookieAccessDelegateType value);
inline bool IsKnownEnumValue(CookieAccessDelegateType value)
{
    return internal::CookieAccessDelegateType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookiePriority : int32_t {

    LOW = 0,

    MEDIUM = 1,

    HIGH = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, CookiePriority value);
inline bool IsKnownEnumValue(CookiePriority value)
{
    return internal::CookiePriority_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieSourceScheme : int32_t {

    kUnset = 0,

    kNonSecure = 1,

    kSecure = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, CookieSourceScheme value);
inline bool IsKnownEnumValue(CookieSourceScheme value)
{
    return internal::CookieSourceScheme_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieSameSite : int32_t {

    UNSPECIFIED = -1,

    NO_RESTRICTION = 0,

    LAX_MODE = 1,

    STRICT_MODE = 2,
    kMinValue = -1,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, CookieSameSite value);
inline bool IsKnownEnumValue(CookieSameSite value)
{
    return internal::CookieSameSite_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieEffectiveSameSite : int32_t {

    kNoRestriction = 0,

    kLaxMode = 1,

    kStrictMode = 2,

    kLaxModeAllowUnsafe = 3,

    kUndefined = 4,
    kMinValue = 0,
    kMaxValue = 4,
};

std::ostream& operator<<(std::ostream& os, CookieEffectiveSameSite value);
inline bool IsKnownEnumValue(CookieEffectiveSameSite value)
{
    return internal::CookieEffectiveSameSite_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieExemptionReason : int32_t {

    kNone = 0,

    kUserSetting = 1,

    k3PCDMetadata = 2,

    k3PCDDeprecationTrial = 3,

    kTopLevel3PCDDeprecationTrial = 4,

    k3PCDHeuristics = 5,

    kEnterprisePolicy = 6,

    kStorageAccess = 7,

    kTopLevelStorageAccess = 8,

    kScheme = 9,
    kMinValue = 0,
    kMaxValue = 9,
};

std::ostream& operator<<(std::ostream& os, CookieExemptionReason value);
inline bool IsKnownEnumValue(CookieExemptionReason value)
{
    return internal::CookieExemptionReason_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class ContextType : int32_t {

    CROSS_SITE = 0,

    SAME_SITE_LAX_METHOD_UNSAFE = 1,

    SAME_SITE_LAX = 2,

    SAME_SITE_STRICT = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, ContextType value);
inline bool IsKnownEnumValue(ContextType value)
{
    return internal::ContextType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieSameSiteContextMetadataDowngradeType : int32_t {

    kNoDowngrade = 0,

    kStrictToLax = 1,

    kStrictToCross = 2,

    kLaxToCross = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, CookieSameSiteContextMetadataDowngradeType value);
inline bool IsKnownEnumValue(CookieSameSiteContextMetadataDowngradeType value)
{
    return internal::CookieSameSiteContextMetadataDowngradeType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieSourceType : int32_t {

    kUnknown = 0,

    kHTTP = 1,

    kScript = 2,

    kOther = 3,
    kMinValue = 0,
    kMaxValue = 3,
};

std::ostream& operator<<(std::ostream& os, CookieSourceType value);
inline bool IsKnownEnumValue(CookieSourceType value)
{
    return internal::CookieSourceType_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class ContextRedirectTypeBug1221316 : int32_t {

    kUnset = 0,

    kNoRedirect = 1,

    kCrossSiteRedirect = 2,

    kPartialSameSiteRedirect = 3,

    kAllSameSiteRedirect = 4,
    kMinValue = 0,
    kMaxValue = 4,
};

std::ostream& operator<<(std::ostream& os, ContextRedirectTypeBug1221316 value);
inline bool IsKnownEnumValue(ContextRedirectTypeBug1221316 value)
{
    return internal::ContextRedirectTypeBug1221316_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class HttpMethod : int32_t {

    kUnset = 0,

    kUnknown = 1,

    kGet = 2,

    kHead = 3,

    kPost = 4,

    KPut = 5,

    kDelete = 6,

    kConnect = 7,

    kOptions = 8,

    kTrace = 9,

    kPatch = 10,
    kMinValue = 0,
    kMaxValue = 10,
};

std::ostream& operator<<(std::ostream& os, HttpMethod value);
inline bool IsKnownEnumValue(HttpMethod value)
{
    return internal::HttpMethod_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieAccessSemantics : int32_t {

    UNKNOWN = -1,

    NONLEGACY = 0,

    LEGACY = 1,
    kMinValue = -1,
    kMaxValue = 1,
};

std::ostream& operator<<(std::ostream& os, CookieAccessSemantics value);
inline bool IsKnownEnumValue(CookieAccessSemantics value)
{
    return internal::CookieAccessSemantics_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieChangeCause : int32_t {

    INSERTED = 0,

    EXPLICIT = 1,

    UNKNOWN_DELETION = 2,

    OVERWRITE = 3,

    EXPIRED = 4,

    EVICTED = 5,

    EXPIRED_OVERWRITE = 6,
    kMinValue = 0,
    kMaxValue = 6,
};

std::ostream& operator<<(std::ostream& os, CookieChangeCause value);
inline bool IsKnownEnumValue(CookieChangeCause value)
{
    return internal::CookieChangeCause_Data::IsKnownValue(static_cast<int32_t>(value));
}

enum class CookieDeletionSessionControl : int32_t {

    IGNORE_CONTROL = 0,

    SESSION_COOKIES = 1,

    PERSISTENT_COOKIES = 2,
    kMinValue = 0,
    kMaxValue = 2,
};

std::ostream& operator<<(std::ostream& os, CookieDeletionSessionControl value);
inline bool IsKnownEnumValue(CookieDeletionSessionControl value)
{
    return internal::CookieDeletionSessionControl_Data::IsKnownValue(static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class CookieChangeListenerInterfaceBase { };

using CookieChangeListenerPtrDataView = mojo::InterfacePtrDataView<CookieChangeListenerInterfaceBase>;
using CookieChangeListenerRequestDataView = mojo::InterfaceRequestDataView<CookieChangeListenerInterfaceBase>;
using CookieChangeListenerAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<CookieChangeListenerInterfaceBase>;
using CookieChangeListenerAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<CookieChangeListenerInterfaceBase>;
class CookieManagerInterfaceBase { };

using CookieManagerPtrDataView = mojo::InterfacePtrDataView<CookieManagerInterfaceBase>;
using CookieManagerRequestDataView = mojo::InterfaceRequestDataView<CookieManagerInterfaceBase>;
using CookieManagerAssociatedPtrInfoDataView = mojo::AssociatedInterfacePtrInfoDataView<CookieManagerInterfaceBase>;
using CookieManagerAssociatedRequestDataView = mojo::AssociatedInterfaceRequestDataView<CookieManagerInterfaceBase>;

class CookieManagerParamsDataView {
public:
    CookieManagerParamsDataView() = default;

    CookieManagerParamsDataView(internal::CookieManagerParams_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    bool block_third_party_cookies() const
    {
        return data_->block_third_party_cookies;
    }
    bool tracking_protection_enabled_for_3pcd() const
    {
        return data_->tracking_protection_enabled_for_3pcd;
    }
    bool mitigations_enabled_for_3pcd() const
    {
        return data_->mitigations_enabled_for_3pcd;
    }
    inline void GetContentSettingsDataView(
        mojo::MapDataView<::content_settings::mojom::ContentSettingsType, mojo::ArrayDataView<::content_settings::mojom::ContentSettingPatternSourceDataView>>*
            output);

    template <typename UserType> [[nodiscard]] bool ReadContentSettings(UserType* output)
    {

        auto* pointer = data_->content_settings.Get();
        return mojo::internal::Deserialize<mojo::MapDataView<::content_settings::mojom::ContentSettingsType,
            mojo::ArrayDataView<::content_settings::mojom::ContentSettingPatternSourceDataView>>>(pointer, output, message_);
    }
    inline void GetSecureOriginCookiesAllowedSchemesDataView(mojo::ArrayDataView<mojo::StringDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadSecureOriginCookiesAllowedSchemes(UserType* output)
    {

        auto* pointer = data_->secure_origin_cookies_allowed_schemes.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(pointer, output, message_);
    }
    inline void GetMatchingSchemeCookiesAllowedSchemesDataView(mojo::ArrayDataView<mojo::StringDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadMatchingSchemeCookiesAllowedSchemes(UserType* output)
    {

        auto* pointer = data_->matching_scheme_cookies_allowed_schemes.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(pointer, output, message_);
    }
    inline void GetThirdPartyCookiesAllowedSchemesDataView(mojo::ArrayDataView<mojo::StringDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadThirdPartyCookiesAllowedSchemes(UserType* output)
    {

        auto* pointer = data_->third_party_cookies_allowed_schemes.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(pointer, output, message_);
    }
    bool allow_file_scheme_cookies() const
    {
        return data_->allow_file_scheme_cookies;
    }
    template <typename UserType> [[nodiscard]] bool ReadCookieAccessDelegateType(UserType* output) const
    {
        auto data_value = data_->cookie_access_delegate_type;
        return mojo::internal::Deserialize<::network::mojom::CookieAccessDelegateType>(data_value, output);
    }
    CookieAccessDelegateType cookie_access_delegate_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieAccessDelegateType>(data_->cookie_access_delegate_type));
    }

private:
    internal::CookieManagerParams_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieSameSiteContextMetadataDataView {
public:
    CookieSameSiteContextMetadataDataView() = default;

    CookieSameSiteContextMetadataDataView(internal::CookieSameSiteContextMetadata_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadCrossSiteRedirectDowngrade(UserType* output) const
    {
        auto data_value = data_->cross_site_redirect_downgrade;
        return mojo::internal::Deserialize<::network::mojom::CookieSameSiteContextMetadataDowngradeType>(data_value, output);
    }
    CookieSameSiteContextMetadataDowngradeType cross_site_redirect_downgrade() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(
            static_cast<::network::mojom::CookieSameSiteContextMetadataDowngradeType>(data_->cross_site_redirect_downgrade));
    }
    template <typename UserType> [[nodiscard]] bool ReadRedirectTypeBug1221316(UserType* output) const
    {
        auto data_value = data_->redirect_type_bug_1221316;
        return mojo::internal::Deserialize<::network::mojom::ContextRedirectTypeBug1221316>(data_value, output);
    }
    ContextRedirectTypeBug1221316 redirect_type_bug_1221316() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::ContextRedirectTypeBug1221316>(data_->redirect_type_bug_1221316));
    }
    template <typename UserType> [[nodiscard]] bool ReadHttpMethodBug1221316(UserType* output) const
    {
        auto data_value = data_->http_method_bug_1221316;
        return mojo::internal::Deserialize<::network::mojom::HttpMethod>(data_value, output);
    }
    HttpMethod http_method_bug_1221316() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::HttpMethod>(data_->http_method_bug_1221316));
    }

private:
    internal::CookieSameSiteContextMetadata_Data* data_ = nullptr;
};

class CookieSameSiteContextDataView {
public:
    CookieSameSiteContextDataView() = default;

    CookieSameSiteContextDataView(internal::CookieSameSiteContext_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadContext(UserType* output) const
    {
        auto data_value = data_->context;
        return mojo::internal::Deserialize<::network::mojom::ContextType>(data_value, output);
    }
    ContextType context() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::ContextType>(data_->context));
    }
    template <typename UserType> [[nodiscard]] bool ReadSchemefulContext(UserType* output) const
    {
        auto data_value = data_->schemeful_context;
        return mojo::internal::Deserialize<::network::mojom::ContextType>(data_value, output);
    }
    ContextType schemeful_context() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::ContextType>(data_->schemeful_context));
    }
    inline void GetMetadataDataView(CookieSameSiteContextMetadataDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadMetadata(UserType* output)
    {

        auto* pointer = data_->metadata.Get();
        return mojo::internal::Deserialize<::network::mojom::CookieSameSiteContextMetadataDataView>(pointer, output, message_);
    }
    inline void GetSchemefulMetadataDataView(CookieSameSiteContextMetadataDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSchemefulMetadata(UserType* output)
    {

        auto* pointer = data_->schemeful_metadata.Get();
        return mojo::internal::Deserialize<::network::mojom::CookieSameSiteContextMetadataDataView>(pointer, output, message_);
    }

private:
    internal::CookieSameSiteContext_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieOptionsDataView {
public:
    CookieOptionsDataView() = default;

    CookieOptionsDataView(internal::CookieOptions_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    bool exclude_httponly() const
    {
        return data_->exclude_httponly;
    }
    inline void GetSameSiteCookieContextDataView(CookieSameSiteContextDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadSameSiteCookieContext(UserType* output)
    {

        auto* pointer = data_->same_site_cookie_context.Get();
        return mojo::internal::Deserialize<::network::mojom::CookieSameSiteContextDataView>(pointer, output, message_);
    }
    bool update_access_time() const
    {
        return data_->update_access_time;
    }
    bool return_excluded_cookies() const
    {
        return data_->return_excluded_cookies;
    }

private:
    internal::CookieOptions_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CanonicalCookieDataView {
public:
    CanonicalCookieDataView() = default;

    CanonicalCookieDataView(internal::CanonicalCookie_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadName(UserType* output)
    {

        auto* pointer = data_->name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetValueDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadValue(UserType* output)
    {

        auto* pointer = data_->value.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetDomainDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadDomain(UserType* output)
    {

        auto* pointer = data_->domain.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetPathDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadPath(UserType* output)
    {

        auto* pointer = data_->path.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetCreationDataView(::mojo_base::mojom::TimeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCreation(UserType* output)
    {

        auto* pointer = data_->creation.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(pointer, output, message_);
    }
    inline void GetExpiryDataView(::mojo_base::mojom::TimeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadExpiry(UserType* output)
    {

        auto* pointer = data_->expiry.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(pointer, output, message_);
    }
    inline void GetLastAccessDataView(::mojo_base::mojom::TimeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLastAccess(UserType* output)
    {

        auto* pointer = data_->last_access.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(pointer, output, message_);
    }
    inline void GetLastUpdateDataView(::mojo_base::mojom::TimeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadLastUpdate(UserType* output)
    {

        auto* pointer = data_->last_update.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(pointer, output, message_);
    }
    bool secure() const
    {
        return data_->secure;
    }
    bool httponly() const
    {
        return data_->httponly;
    }
    template <typename UserType> [[nodiscard]] bool ReadSiteRestrictions(UserType* output) const
    {
        auto data_value = data_->site_restrictions;
        return mojo::internal::Deserialize<::network::mojom::CookieSameSite>(data_value, output);
    }
    CookieSameSite site_restrictions() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieSameSite>(data_->site_restrictions));
    }
    template <typename UserType> [[nodiscard]] bool ReadPriority(UserType* output) const
    {
        auto data_value = data_->priority;
        return mojo::internal::Deserialize<::network::mojom::CookiePriority>(data_value, output);
    }
    CookiePriority priority() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookiePriority>(data_->priority));
    }
    template <typename UserType> [[nodiscard]] bool ReadSourceScheme(UserType* output) const
    {
        auto data_value = data_->source_scheme;
        return mojo::internal::Deserialize<::network::mojom::CookieSourceScheme>(data_value, output);
    }
    CookieSourceScheme source_scheme() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieSourceScheme>(data_->source_scheme));
    }
    inline void GetPartitionKeyDataView(::network::mojom::CookiePartitionKeyDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadPartitionKey(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::network::mojom::CookiePartitionKeyDataView, UserType>(),
            "Attempting to read the optional `partition_key` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadPartitionKey` instead "
            "of `ReadPartitionKey if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->partition_key.Get();
        return mojo::internal::Deserialize<::network::mojom::CookiePartitionKeyDataView>(pointer, output, message_);
    }
    int32_t source_port() const
    {
        return data_->source_port;
    }
    template <typename UserType> [[nodiscard]] bool ReadSourceType(UserType* output) const
    {
        auto data_value = data_->source_type;
        return mojo::internal::Deserialize<::network::mojom::CookieSourceType>(data_value, output);
    }
    CookieSourceType source_type() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieSourceType>(data_->source_type));
    }

private:
    internal::CanonicalCookie_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieInclusionStatusDataView {
public:
    CookieInclusionStatusDataView() = default;

    CookieInclusionStatusDataView(internal::CookieInclusionStatus_Data* data, mojo::Message* message)
        : data_(data)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    uint32_t exclusion_reasons() const
    {
        return data_->exclusion_reasons;
    }
    uint32_t warning_reasons() const
    {
        return data_->warning_reasons;
    }
    template <typename UserType> [[nodiscard]] bool ReadExemptionReason(UserType* output) const
    {
        auto data_value = data_->exemption_reason;
        return mojo::internal::Deserialize<::network::mojom::CookieExemptionReason>(data_value, output);
    }
    CookieExemptionReason exemption_reason() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieExemptionReason>(data_->exemption_reason));
    }

private:
    internal::CookieInclusionStatus_Data* data_ = nullptr;
};

class CookieAndLineWithAccessResultDataView {
public:
    CookieAndLineWithAccessResultDataView() = default;

    CookieAndLineWithAccessResultDataView(internal::CookieAndLineWithAccessResult_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetCookieDataView(CanonicalCookieDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookie(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::network::mojom::CanonicalCookieDataView, UserType>(),
            "Attempting to read the optional `cookie` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCookie` instead "
            "of `ReadCookie if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->cookie.Get();
        return mojo::internal::Deserialize<::network::mojom::CanonicalCookieDataView>(pointer, output, message_);
    }
    inline void GetCookieStringDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookieString(UserType* output)
    {

        auto* pointer = data_->cookie_string.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetAccessResultDataView(CookieAccessResultDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAccessResult(UserType* output)
    {

        auto* pointer = data_->access_result.Get();
        return mojo::internal::Deserialize<::network::mojom::CookieAccessResultDataView>(pointer, output, message_);
    }

private:
    internal::CookieAndLineWithAccessResult_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieOrLineWithAccessResultDataView {
public:
    CookieOrLineWithAccessResultDataView() = default;

    CookieOrLineWithAccessResultDataView(internal::CookieOrLineWithAccessResult_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetCookieOrLineDataView(CookieOrLineDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookieOrLine(UserType* output)
    {

        auto* pointer = !data_->cookie_or_line.is_null() ? &data_->cookie_or_line : nullptr;
        return mojo::internal::Deserialize<::network::mojom::CookieOrLineDataView>(pointer, output, message_);
    }
    inline void GetAccessResultDataView(CookieAccessResultDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAccessResult(UserType* output)
    {

        auto* pointer = data_->access_result.Get();
        return mojo::internal::Deserialize<::network::mojom::CookieAccessResultDataView>(pointer, output, message_);
    }

private:
    internal::CookieOrLineWithAccessResult_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieAccessResultDataView {
public:
    CookieAccessResultDataView() = default;

    CookieAccessResultDataView(internal::CookieAccessResult_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    template <typename UserType> [[nodiscard]] bool ReadEffectiveSameSite(UserType* output) const
    {
        auto data_value = data_->effective_same_site;
        return mojo::internal::Deserialize<::network::mojom::CookieEffectiveSameSite>(data_value, output);
    }
    CookieEffectiveSameSite effective_same_site() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieEffectiveSameSite>(data_->effective_same_site));
    }
    template <typename UserType> [[nodiscard]] bool ReadAccessSemantics(UserType* output) const
    {
        auto data_value = data_->access_semantics;
        return mojo::internal::Deserialize<::network::mojom::CookieAccessSemantics>(data_value, output);
    }
    CookieAccessSemantics access_semantics() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieAccessSemantics>(data_->access_semantics));
    }
    inline void GetStatusDataView(CookieInclusionStatusDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadStatus(UserType* output)
    {

        auto* pointer = data_->status.Get();
        return mojo::internal::Deserialize<::network::mojom::CookieInclusionStatusDataView>(pointer, output, message_);
    }
    bool is_allowed_to_access_secure_cookies() const
    {
        return data_->is_allowed_to_access_secure_cookies;
    }

private:
    internal::CookieAccessResult_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieWithAccessResultDataView {
public:
    CookieWithAccessResultDataView() = default;

    CookieWithAccessResultDataView(internal::CookieWithAccessResult_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetCookieDataView(CanonicalCookieDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookie(UserType* output)
    {

        auto* pointer = data_->cookie.Get();
        return mojo::internal::Deserialize<::network::mojom::CanonicalCookieDataView>(pointer, output, message_);
    }
    inline void GetAccessResultDataView(CookieAccessResultDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAccessResult(UserType* output)
    {

        auto* pointer = data_->access_result.Get();
        return mojo::internal::Deserialize<::network::mojom::CookieAccessResultDataView>(pointer, output, message_);
    }

private:
    internal::CookieWithAccessResult_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieChangeInfoDataView {
public:
    CookieChangeInfoDataView() = default;

    CookieChangeInfoDataView(internal::CookieChangeInfo_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetCookieDataView(CanonicalCookieDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookie(UserType* output)
    {

        auto* pointer = data_->cookie.Get();
        return mojo::internal::Deserialize<::network::mojom::CanonicalCookieDataView>(pointer, output, message_);
    }
    inline void GetAccessResultDataView(CookieAccessResultDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadAccessResult(UserType* output)
    {

        auto* pointer = data_->access_result.Get();
        return mojo::internal::Deserialize<::network::mojom::CookieAccessResultDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadCause(UserType* output) const
    {
        auto data_value = data_->cause;
        return mojo::internal::Deserialize<::network::mojom::CookieChangeCause>(data_value, output);
    }
    CookieChangeCause cause() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieChangeCause>(data_->cause));
    }

private:
    internal::CookieChangeInfo_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieDeletionFilterDataView {
public:
    CookieDeletionFilterDataView() = default;

    CookieDeletionFilterDataView(internal::CookieDeletionFilter_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        return !data_;
    }
    inline void GetCreatedAfterTimeDataView(::mojo_base::mojom::TimeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCreatedAfterTime(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDataView, UserType>(),
            "Attempting to read the optional `created_after_time` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCreatedAfterTime` instead "
            "of `ReadCreatedAfterTime if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->created_after_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(pointer, output, message_);
    }
    inline void GetCreatedBeforeTimeDataView(::mojo_base::mojom::TimeDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCreatedBeforeTime(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::mojo_base::mojom::TimeDataView, UserType>(),
            "Attempting to read the optional `created_before_time` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCreatedBeforeTime` instead "
            "of `ReadCreatedBeforeTime if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->created_before_time.Get();
        return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(pointer, output, message_);
    }
    inline void GetExcludingDomainsDataView(mojo::ArrayDataView<mojo::StringDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadExcludingDomains(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::ArrayDataView<mojo::StringDataView>, UserType>(),
            "Attempting to read the optional `excluding_domains` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadExcludingDomains` instead "
            "of `ReadExcludingDomains if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->excluding_domains.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(pointer, output, message_);
    }
    inline void GetIncludingDomainsDataView(mojo::ArrayDataView<mojo::StringDataView>* output);

    template <typename UserType> [[nodiscard]] bool ReadIncludingDomains(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::ArrayDataView<mojo::StringDataView>, UserType>(),
            "Attempting to read the optional `including_domains` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadIncludingDomains` instead "
            "of `ReadIncludingDomains if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->including_domains.Get();
        return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::StringDataView>>(pointer, output, message_);
    }
    inline void GetCookieNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookieName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `cookie_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCookieName` instead "
            "of `ReadCookieName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->cookie_name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetHostNameDataView(mojo::StringDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadHostName(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<mojo::StringDataView, UserType>(),
            "Attempting to read the optional `host_name` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadHostName` instead "
            "of `ReadHostName if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->host_name.Get();
        return mojo::internal::Deserialize<mojo::StringDataView>(pointer, output, message_);
    }
    inline void GetUrlDataView(::url::mojom::UrlDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadUrl(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::url::mojom::UrlDataView, UserType>(),
            "Attempting to read the optional `url` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadUrl` instead "
            "of `ReadUrl if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->url.Get();
        return mojo::internal::Deserialize<::url::mojom::UrlDataView>(pointer, output, message_);
    }
    template <typename UserType> [[nodiscard]] bool ReadSessionControl(UserType* output) const
    {
        auto data_value = data_->session_control;
        return mojo::internal::Deserialize<::network::mojom::CookieDeletionSessionControl>(data_value, output);
    }
    CookieDeletionSessionControl session_control() const
    {
        return ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieDeletionSessionControl>(data_->session_control));
    }
    inline void GetCookiePartitionKeyCollectionDataView(::network::mojom::CookiePartitionKeyCollectionDataView* output);

    template <typename UserType> [[nodiscard]] bool ReadCookiePartitionKeyCollection(UserType* output)
    {

        static_assert(mojo::internal::IsValidUserTypeForOptionalValue<::network::mojom::CookiePartitionKeyCollectionDataView, UserType>(),
            "Attempting to read the optional `cookie_partition_key_collection` field into a type which "
            "cannot represent a null value. Either wrap the destination object "
            "with std::optional, ensure that any corresponding "
            "{Struct/Union/Array/String}Traits define the necessary IsNull and "
            "SetToNull methods, or use `MaybeReadCookiePartitionKeyCollection` instead "
            "of `ReadCookiePartitionKeyCollection if you're fine with null values being "
            "silently ignored in this case.");
        auto* pointer = data_->cookie_partition_key_collection.Get();
        return mojo::internal::Deserialize<::network::mojom::CookiePartitionKeyCollectionDataView>(pointer, output, message_);
    }
    bool partitioned_state_only() const
    {
        return data_->partitioned_state_only;
    }

private:
    internal::CookieDeletionFilter_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

class CookieOrLineDataView {
public:
    using Tag = internal::CookieOrLine_Data::CookieOrLine_Tag;

    CookieOrLineDataView() = default;

    CookieOrLineDataView(internal::CookieOrLine_Data* data, mojo::Message* message)
        : data_(data)
        , message_(message)
    {
    }

    bool is_null() const
    {
        // For inlined unions, |data_| is always non-null. In that case we need to
        // check |data_->is_null()|.
        return !data_ || data_->is_null();
    }

    Tag tag() const
    {
        return data_->tag;
    }
    bool is_cookie() const
    {
        return data_->tag == Tag::kCookie;
    }
    inline void GetCookieDataView(CanonicalCookieDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadCookie(UserType* output) const
    {

        CHECK(is_cookie());
        return mojo::internal::Deserialize<::network::mojom::CanonicalCookieDataView>(data_->data.f_cookie.Get(), output, message_);
    }
    bool is_cookie_string() const
    {
        return data_->tag == Tag::kCookieString;
    }
    inline void GetCookieStringDataView(mojo::StringDataView* output) const;

    template <typename UserType> [[nodiscard]] bool ReadCookieString(UserType* output) const
    {

        CHECK(is_cookie_string());
        return mojo::internal::Deserialize<mojo::StringDataView>(data_->data.f_cookie_string.Get(), output, message_);
    }

private:
    internal::CookieOrLine_Data* data_ = nullptr;
    mojo::Message* message_ = nullptr;
};

} // network::mojom

namespace std {

template <> struct hash<::network::mojom::CookieAccessDelegateType> : public mojo::internal::EnumHashImpl<::network::mojom::CookieAccessDelegateType> { };

template <> struct hash<::network::mojom::CookiePriority> : public mojo::internal::EnumHashImpl<::network::mojom::CookiePriority> { };

template <> struct hash<::network::mojom::CookieSourceScheme> : public mojo::internal::EnumHashImpl<::network::mojom::CookieSourceScheme> { };

template <> struct hash<::network::mojom::CookieSameSite> : public mojo::internal::EnumHashImpl<::network::mojom::CookieSameSite> { };

template <> struct hash<::network::mojom::CookieEffectiveSameSite> : public mojo::internal::EnumHashImpl<::network::mojom::CookieEffectiveSameSite> { };

template <> struct hash<::network::mojom::CookieExemptionReason> : public mojo::internal::EnumHashImpl<::network::mojom::CookieExemptionReason> { };

template <> struct hash<::network::mojom::ContextType> : public mojo::internal::EnumHashImpl<::network::mojom::ContextType> { };

template <>
struct hash<::network::mojom::CookieSameSiteContextMetadataDowngradeType>
    : public mojo::internal::EnumHashImpl<::network::mojom::CookieSameSiteContextMetadataDowngradeType> { };

template <> struct hash<::network::mojom::CookieSourceType> : public mojo::internal::EnumHashImpl<::network::mojom::CookieSourceType> { };

template <>
struct hash<::network::mojom::ContextRedirectTypeBug1221316> : public mojo::internal::EnumHashImpl<::network::mojom::ContextRedirectTypeBug1221316> { };

template <> struct hash<::network::mojom::HttpMethod> : public mojo::internal::EnumHashImpl<::network::mojom::HttpMethod> { };

template <> struct hash<::network::mojom::CookieAccessSemantics> : public mojo::internal::EnumHashImpl<::network::mojom::CookieAccessSemantics> { };

template <> struct hash<::network::mojom::CookieChangeCause> : public mojo::internal::EnumHashImpl<::network::mojom::CookieChangeCause> { };

template <>
struct hash<::network::mojom::CookieDeletionSessionControl> : public mojo::internal::EnumHashImpl<::network::mojom::CookieDeletionSessionControl> { };

} // namespace std

namespace mojo {

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieAccessDelegateType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieAccessDelegateType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieAccessDelegateType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookiePriority, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookiePriority, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookiePriority>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieSourceScheme, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieSourceScheme, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieSourceScheme>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieSameSite, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieSameSite, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieSameSite>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieEffectiveSameSite, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieEffectiveSameSite, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieEffectiveSameSite>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieExemptionReason, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieExemptionReason, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieExemptionReason>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::ContextType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::ContextType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::ContextType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieSameSiteContextMetadataDowngradeType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieSameSiteContextMetadataDowngradeType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(
            ::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieSameSiteContextMetadataDowngradeType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieSourceType, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieSourceType, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieSourceType>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::ContextRedirectTypeBug1221316, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::ContextRedirectTypeBug1221316, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::ContextRedirectTypeBug1221316>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::HttpMethod, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::HttpMethod, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::HttpMethod>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieAccessSemantics, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieAccessSemantics, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieAccessSemantics>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieChangeCause, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieChangeCause, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieChangeCause>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieDeletionSessionControl, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = EnumTraits<::network::mojom::CookieDeletionSessionControl, UserType>;

    static void Serialize(UserType input, int32_t* output)
    {
        *output = static_cast<int32_t>(Traits::ToMojom(input));
    }

    static bool Deserialize(int32_t input, UserType* output)
    {
        return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(static_cast<::network::mojom::CookieDeletionSessionControl>(input)), output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieManagerParamsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieManagerParamsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieManagerParams_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->block_third_party_cookies = Traits::block_third_party_cookies(input);
        fragment->tracking_protection_enabled_for_3pcd = Traits::tracking_protection_enabled_for_3pcd(input);
        fragment->mitigations_enabled_for_3pcd = Traits::mitigations_enabled_for_3pcd(input);
        decltype(Traits::content_settings(input)) in_content_settings = Traits::content_settings(input);
        mojo::internal::MessageFragment<typename decltype(fragment->content_settings)::BaseType> content_settings_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& content_settings_validate_params = mojo::internal::GetMapValidator<
            *&mojo::internal::GetArrayOfEnumsValidator<0, false, ::content_settings::mojom::internal::ContentSettingsType_Data::Validate>(),
            *&mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>()>();
        mojo::internal::Serialize<mojo::MapDataView<::content_settings::mojom::ContentSettingsType,
            mojo::ArrayDataView<::content_settings::mojom::ContentSettingPatternSourceDataView>>>(
            in_content_settings, content_settings_fragment, &content_settings_validate_params);
        fragment->content_settings.Set(content_settings_fragment.is_null() ? nullptr : content_settings_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->content_settings.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null content_settings in CookieManagerParams struct");
        decltype(Traits::secure_origin_cookies_allowed_schemes(input)) in_secure_origin_cookies_allowed_schemes
            = Traits::secure_origin_cookies_allowed_schemes(input);
        mojo::internal::MessageFragment<typename decltype(fragment->secure_origin_cookies_allowed_schemes)::BaseType>
            secure_origin_cookies_allowed_schemes_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& secure_origin_cookies_allowed_schemes_validate_params
            = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
        mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
            in_secure_origin_cookies_allowed_schemes, secure_origin_cookies_allowed_schemes_fragment, &secure_origin_cookies_allowed_schemes_validate_params);
        fragment->secure_origin_cookies_allowed_schemes.Set(
            secure_origin_cookies_allowed_schemes_fragment.is_null() ? nullptr : secure_origin_cookies_allowed_schemes_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->secure_origin_cookies_allowed_schemes.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null secure_origin_cookies_allowed_schemes in CookieManagerParams struct");
        decltype(Traits::matching_scheme_cookies_allowed_schemes(input)) in_matching_scheme_cookies_allowed_schemes
            = Traits::matching_scheme_cookies_allowed_schemes(input);
        mojo::internal::MessageFragment<typename decltype(fragment->matching_scheme_cookies_allowed_schemes)::BaseType>
            matching_scheme_cookies_allowed_schemes_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& matching_scheme_cookies_allowed_schemes_validate_params
            = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
        mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(in_matching_scheme_cookies_allowed_schemes,
            matching_scheme_cookies_allowed_schemes_fragment, &matching_scheme_cookies_allowed_schemes_validate_params);
        fragment->matching_scheme_cookies_allowed_schemes.Set(
            matching_scheme_cookies_allowed_schemes_fragment.is_null() ? nullptr : matching_scheme_cookies_allowed_schemes_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->matching_scheme_cookies_allowed_schemes.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null matching_scheme_cookies_allowed_schemes in CookieManagerParams struct");
        decltype(Traits::third_party_cookies_allowed_schemes(input)) in_third_party_cookies_allowed_schemes
            = Traits::third_party_cookies_allowed_schemes(input);
        mojo::internal::MessageFragment<typename decltype(fragment->third_party_cookies_allowed_schemes)::BaseType>
            third_party_cookies_allowed_schemes_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& third_party_cookies_allowed_schemes_validate_params
            = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
        mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
            in_third_party_cookies_allowed_schemes, third_party_cookies_allowed_schemes_fragment, &third_party_cookies_allowed_schemes_validate_params);
        fragment->third_party_cookies_allowed_schemes.Set(
            third_party_cookies_allowed_schemes_fragment.is_null() ? nullptr : third_party_cookies_allowed_schemes_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->third_party_cookies_allowed_schemes.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null third_party_cookies_allowed_schemes in CookieManagerParams struct");
        fragment->allow_file_scheme_cookies = Traits::allow_file_scheme_cookies(input);
        mojo::internal::Serialize<::network::mojom::CookieAccessDelegateType>(
            Traits::cookie_access_delegate_type(input), &fragment->cookie_access_delegate_type);
    }

    static bool Deserialize(::network::mojom::internal::CookieManagerParams_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieManagerParamsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieSameSiteContextMetadataDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieSameSiteContextMetadataDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieSameSiteContextMetadata_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::network::mojom::CookieSameSiteContextMetadataDowngradeType>(
            Traits::cross_site_redirect_downgrade(input), &fragment->cross_site_redirect_downgrade);
        mojo::internal::Serialize<::network::mojom::ContextRedirectTypeBug1221316>(
            Traits::redirect_type_bug_1221316(input), &fragment->redirect_type_bug_1221316);
        mojo::internal::Serialize<::network::mojom::HttpMethod>(Traits::http_method_bug_1221316(input), &fragment->http_method_bug_1221316);
    }

    static bool Deserialize(::network::mojom::internal::CookieSameSiteContextMetadata_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieSameSiteContextMetadataDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieSameSiteContextDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieSameSiteContextDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieSameSiteContext_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::network::mojom::ContextType>(Traits::context(input), &fragment->context);
        mojo::internal::Serialize<::network::mojom::ContextType>(Traits::schemeful_context(input), &fragment->schemeful_context);
        decltype(Traits::metadata(input)) in_metadata = Traits::metadata(input);
        mojo::internal::MessageFragment<typename decltype(fragment->metadata)::BaseType> metadata_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookieSameSiteContextMetadataDataView>(in_metadata, metadata_fragment);
        fragment->metadata.Set(metadata_fragment.is_null() ? nullptr : metadata_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->metadata.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null metadata in CookieSameSiteContext struct");
        decltype(Traits::schemeful_metadata(input)) in_schemeful_metadata = Traits::schemeful_metadata(input);
        mojo::internal::MessageFragment<typename decltype(fragment->schemeful_metadata)::BaseType> schemeful_metadata_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookieSameSiteContextMetadataDataView>(in_schemeful_metadata, schemeful_metadata_fragment);
        fragment->schemeful_metadata.Set(schemeful_metadata_fragment.is_null() ? nullptr : schemeful_metadata_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->schemeful_metadata.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null schemeful_metadata in CookieSameSiteContext struct");
    }

    static bool Deserialize(::network::mojom::internal::CookieSameSiteContext_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieSameSiteContextDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieOptionsDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieOptionsDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieOptions_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->exclude_httponly = Traits::exclude_httponly(input);
        decltype(Traits::same_site_cookie_context(input)) in_same_site_cookie_context = Traits::same_site_cookie_context(input);
        mojo::internal::MessageFragment<typename decltype(fragment->same_site_cookie_context)::BaseType> same_site_cookie_context_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookieSameSiteContextDataView>(in_same_site_cookie_context, same_site_cookie_context_fragment);
        fragment->same_site_cookie_context.Set(same_site_cookie_context_fragment.is_null() ? nullptr : same_site_cookie_context_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->same_site_cookie_context.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null same_site_cookie_context in CookieOptions struct");
        fragment->update_access_time = Traits::update_access_time(input);
        fragment->return_excluded_cookies = Traits::return_excluded_cookies(input);
    }

    static bool Deserialize(::network::mojom::internal::CookieOptions_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieOptionsDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CanonicalCookieDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CanonicalCookieDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CanonicalCookie_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::name(input)) in_name = Traits::name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->name)::BaseType> name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_name, name_fragment);
        fragment->name.Set(name_fragment.is_null() ? nullptr : name_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->name.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null name in CanonicalCookie struct");
        decltype(Traits::value(input)) in_value = Traits::value(input);
        mojo::internal::MessageFragment<typename decltype(fragment->value)::BaseType> value_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_value, value_fragment);
        fragment->value.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->value.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null value in CanonicalCookie struct");
        decltype(Traits::domain(input)) in_domain = Traits::domain(input);
        mojo::internal::MessageFragment<typename decltype(fragment->domain)::BaseType> domain_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_domain, domain_fragment);
        fragment->domain.Set(domain_fragment.is_null() ? nullptr : domain_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->domain.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null domain in CanonicalCookie struct");
        decltype(Traits::path(input)) in_path = Traits::path(input);
        mojo::internal::MessageFragment<typename decltype(fragment->path)::BaseType> path_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_path, path_fragment);
        fragment->path.Set(path_fragment.is_null() ? nullptr : path_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->path.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null path in CanonicalCookie struct");
        decltype(Traits::creation(input)) in_creation = Traits::creation(input);
        mojo::internal::MessageFragment<typename decltype(fragment->creation)::BaseType> creation_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_creation, creation_fragment);
        fragment->creation.Set(creation_fragment.is_null() ? nullptr : creation_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->creation.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null creation in CanonicalCookie struct");
        decltype(Traits::expiry(input)) in_expiry = Traits::expiry(input);
        mojo::internal::MessageFragment<typename decltype(fragment->expiry)::BaseType> expiry_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_expiry, expiry_fragment);
        fragment->expiry.Set(expiry_fragment.is_null() ? nullptr : expiry_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->expiry.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null expiry in CanonicalCookie struct");
        decltype(Traits::last_access(input)) in_last_access = Traits::last_access(input);
        mojo::internal::MessageFragment<typename decltype(fragment->last_access)::BaseType> last_access_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_last_access, last_access_fragment);
        fragment->last_access.Set(last_access_fragment.is_null() ? nullptr : last_access_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->last_access.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null last_access in CanonicalCookie struct");
        decltype(Traits::last_update(input)) in_last_update = Traits::last_update(input);
        mojo::internal::MessageFragment<typename decltype(fragment->last_update)::BaseType> last_update_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_last_update, last_update_fragment);
        fragment->last_update.Set(last_update_fragment.is_null() ? nullptr : last_update_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->last_update.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null last_update in CanonicalCookie struct");
        fragment->secure = Traits::secure(input);
        fragment->httponly = Traits::httponly(input);
        mojo::internal::Serialize<::network::mojom::CookieSameSite>(Traits::site_restrictions(input), &fragment->site_restrictions);
        mojo::internal::Serialize<::network::mojom::CookiePriority>(Traits::priority(input), &fragment->priority);
        mojo::internal::Serialize<::network::mojom::CookieSourceScheme>(Traits::source_scheme(input), &fragment->source_scheme);
        decltype(Traits::partition_key(input)) in_partition_key = Traits::partition_key(input);
        mojo::internal::MessageFragment<typename decltype(fragment->partition_key)::BaseType> partition_key_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookiePartitionKeyDataView>(in_partition_key, partition_key_fragment);
        fragment->partition_key.Set(partition_key_fragment.is_null() ? nullptr : partition_key_fragment.data());
        fragment->source_port = Traits::source_port(input);
        mojo::internal::Serialize<::network::mojom::CookieSourceType>(Traits::source_type(input), &fragment->source_type);
    }

    static bool Deserialize(::network::mojom::internal::CanonicalCookie_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CanonicalCookieDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieInclusionStatusDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieInclusionStatusDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieInclusionStatus_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        fragment->exclusion_reasons = Traits::exclusion_reasons(input);
        fragment->warning_reasons = Traits::warning_reasons(input);
        mojo::internal::Serialize<::network::mojom::CookieExemptionReason>(Traits::exemption_reason(input), &fragment->exemption_reason);
    }

    static bool Deserialize(::network::mojom::internal::CookieInclusionStatus_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieInclusionStatusDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieAndLineWithAccessResultDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieAndLineWithAccessResultDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieAndLineWithAccessResult_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::cookie(input)) in_cookie = Traits::cookie(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie)::BaseType> cookie_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CanonicalCookieDataView>(in_cookie, cookie_fragment);
        fragment->cookie.Set(cookie_fragment.is_null() ? nullptr : cookie_fragment.data());
        decltype(Traits::cookie_string(input)) in_cookie_string = Traits::cookie_string(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie_string)::BaseType> cookie_string_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_cookie_string, cookie_string_fragment);
        fragment->cookie_string.Set(cookie_string_fragment.is_null() ? nullptr : cookie_string_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->cookie_string.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null cookie_string in CookieAndLineWithAccessResult struct");
        decltype(Traits::access_result(input)) in_access_result = Traits::access_result(input);
        mojo::internal::MessageFragment<typename decltype(fragment->access_result)::BaseType> access_result_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookieAccessResultDataView>(in_access_result, access_result_fragment);
        fragment->access_result.Set(access_result_fragment.is_null() ? nullptr : access_result_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->access_result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null access_result in CookieAndLineWithAccessResult struct");
    }

    static bool Deserialize(::network::mojom::internal::CookieAndLineWithAccessResult_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieAndLineWithAccessResultDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieOrLineWithAccessResultDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieOrLineWithAccessResultDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieOrLineWithAccessResult_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::cookie_or_line(input)) in_cookie_or_line = Traits::cookie_or_line(input);
        mojo::internal::MessageFragment<decltype(fragment->cookie_or_line)> cookie_or_line_fragment(fragment.message());
        cookie_or_line_fragment.Claim(&fragment->cookie_or_line);
        mojo::internal::Serialize<::network::mojom::CookieOrLineDataView>(in_cookie_or_line, cookie_or_line_fragment, true);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->cookie_or_line.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null cookie_or_line in CookieOrLineWithAccessResult struct");
        decltype(Traits::access_result(input)) in_access_result = Traits::access_result(input);
        mojo::internal::MessageFragment<typename decltype(fragment->access_result)::BaseType> access_result_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookieAccessResultDataView>(in_access_result, access_result_fragment);
        fragment->access_result.Set(access_result_fragment.is_null() ? nullptr : access_result_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(fragment->access_result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null access_result in CookieOrLineWithAccessResult struct");
    }

    static bool Deserialize(::network::mojom::internal::CookieOrLineWithAccessResult_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieOrLineWithAccessResultDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieAccessResultDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieAccessResultDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieAccessResult_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        mojo::internal::Serialize<::network::mojom::CookieEffectiveSameSite>(Traits::effective_same_site(input), &fragment->effective_same_site);
        mojo::internal::Serialize<::network::mojom::CookieAccessSemantics>(Traits::access_semantics(input), &fragment->access_semantics);
        decltype(Traits::status(input)) in_status = Traits::status(input);
        mojo::internal::MessageFragment<typename decltype(fragment->status)::BaseType> status_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookieInclusionStatusDataView>(in_status, status_fragment);
        fragment->status.Set(status_fragment.is_null() ? nullptr : status_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->status.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null status in CookieAccessResult struct");
        fragment->is_allowed_to_access_secure_cookies = Traits::is_allowed_to_access_secure_cookies(input);
    }

    static bool Deserialize(::network::mojom::internal::CookieAccessResult_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieAccessResultDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieWithAccessResultDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieWithAccessResultDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieWithAccessResult_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::cookie(input)) in_cookie = Traits::cookie(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie)::BaseType> cookie_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CanonicalCookieDataView>(in_cookie, cookie_fragment);
        fragment->cookie.Set(cookie_fragment.is_null() ? nullptr : cookie_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->cookie.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null cookie in CookieWithAccessResult struct");
        decltype(Traits::access_result(input)) in_access_result = Traits::access_result(input);
        mojo::internal::MessageFragment<typename decltype(fragment->access_result)::BaseType> access_result_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookieAccessResultDataView>(in_access_result, access_result_fragment);
        fragment->access_result.Set(access_result_fragment.is_null() ? nullptr : access_result_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->access_result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null access_result in CookieWithAccessResult struct");
    }

    static bool Deserialize(::network::mojom::internal::CookieWithAccessResult_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieWithAccessResultDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieChangeInfoDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieChangeInfoDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieChangeInfo_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::cookie(input)) in_cookie = Traits::cookie(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie)::BaseType> cookie_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CanonicalCookieDataView>(in_cookie, cookie_fragment);
        fragment->cookie.Set(cookie_fragment.is_null() ? nullptr : cookie_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->cookie.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null cookie in CookieChangeInfo struct");
        decltype(Traits::access_result(input)) in_access_result = Traits::access_result(input);
        mojo::internal::MessageFragment<typename decltype(fragment->access_result)::BaseType> access_result_fragment(fragment.message());
        mojo::internal::Serialize<::network::mojom::CookieAccessResultDataView>(in_access_result, access_result_fragment);
        fragment->access_result.Set(access_result_fragment.is_null() ? nullptr : access_result_fragment.data());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            fragment->access_result.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null access_result in CookieChangeInfo struct");
        mojo::internal::Serialize<::network::mojom::CookieChangeCause>(Traits::cause(input), &fragment->cause);
    }

    static bool Deserialize(::network::mojom::internal::CookieChangeInfo_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieChangeInfoDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieDeletionFilterDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = StructTraits<::network::mojom::CookieDeletionFilterDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, mojo::internal::MessageFragment<::network::mojom::internal::CookieDeletionFilter_Data>& fragment)
    {
        if (CallIsNullIfExists<Traits>(input))
            return;
        fragment.Allocate();
        decltype(Traits::created_after_time(input)) in_created_after_time = Traits::created_after_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->created_after_time)::BaseType> created_after_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_created_after_time, created_after_time_fragment);
        fragment->created_after_time.Set(created_after_time_fragment.is_null() ? nullptr : created_after_time_fragment.data());
        decltype(Traits::created_before_time(input)) in_created_before_time = Traits::created_before_time(input);
        mojo::internal::MessageFragment<typename decltype(fragment->created_before_time)::BaseType> created_before_time_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(in_created_before_time, created_before_time_fragment);
        fragment->created_before_time.Set(created_before_time_fragment.is_null() ? nullptr : created_before_time_fragment.data());
        decltype(Traits::excluding_domains(input)) in_excluding_domains = Traits::excluding_domains(input);
        mojo::internal::MessageFragment<typename decltype(fragment->excluding_domains)::BaseType> excluding_domains_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& excluding_domains_validate_params
            = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
        mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
            in_excluding_domains, excluding_domains_fragment, &excluding_domains_validate_params);
        fragment->excluding_domains.Set(excluding_domains_fragment.is_null() ? nullptr : excluding_domains_fragment.data());
        decltype(Traits::including_domains(input)) in_including_domains = Traits::including_domains(input);
        mojo::internal::MessageFragment<typename decltype(fragment->including_domains)::BaseType> including_domains_fragment(fragment.message());
        constexpr const mojo::internal::ContainerValidateParams& including_domains_validate_params
            = mojo::internal::GetArrayValidator<0, false, &mojo::internal::GetArrayValidator<0, false, nullptr>()>();
        mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
            in_including_domains, including_domains_fragment, &including_domains_validate_params);
        fragment->including_domains.Set(including_domains_fragment.is_null() ? nullptr : including_domains_fragment.data());
        decltype(Traits::cookie_name(input)) in_cookie_name = Traits::cookie_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie_name)::BaseType> cookie_name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_cookie_name, cookie_name_fragment);
        fragment->cookie_name.Set(cookie_name_fragment.is_null() ? nullptr : cookie_name_fragment.data());
        decltype(Traits::host_name(input)) in_host_name = Traits::host_name(input);
        mojo::internal::MessageFragment<typename decltype(fragment->host_name)::BaseType> host_name_fragment(fragment.message());
        mojo::internal::Serialize<mojo::StringDataView>(in_host_name, host_name_fragment);
        fragment->host_name.Set(host_name_fragment.is_null() ? nullptr : host_name_fragment.data());
        decltype(Traits::url(input)) in_url = Traits::url(input);
        mojo::internal::MessageFragment<typename decltype(fragment->url)::BaseType> url_fragment(fragment.message());
        mojo::internal::Serialize<::url::mojom::UrlDataView>(in_url, url_fragment);
        fragment->url.Set(url_fragment.is_null() ? nullptr : url_fragment.data());
        mojo::internal::Serialize<::network::mojom::CookieDeletionSessionControl>(Traits::session_control(input), &fragment->session_control);
        decltype(Traits::cookie_partition_key_collection(input)) in_cookie_partition_key_collection = Traits::cookie_partition_key_collection(input);
        mojo::internal::MessageFragment<typename decltype(fragment->cookie_partition_key_collection)::BaseType> cookie_partition_key_collection_fragment(
            fragment.message());
        mojo::internal::Serialize<::network::mojom::CookiePartitionKeyCollectionDataView>(
            in_cookie_partition_key_collection, cookie_partition_key_collection_fragment);
        fragment->cookie_partition_key_collection.Set(
            cookie_partition_key_collection_fragment.is_null() ? nullptr : cookie_partition_key_collection_fragment.data());
        fragment->partitioned_state_only = Traits::partitioned_state_only(input);
    }

    static bool Deserialize(::network::mojom::internal::CookieDeletionFilter_Data* input, UserType* output, Message* message)
    {
        if (!input)
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieDeletionFilterDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

namespace internal {

template <typename MaybeConstUserType> struct Serializer<::network::mojom::CookieOrLineDataView, MaybeConstUserType> {
    using UserType = typename std::remove_const<MaybeConstUserType>::type;
    using Traits = UnionTraits<::network::mojom::CookieOrLineDataView, UserType>;

    static void Serialize(MaybeConstUserType& input, MessageFragment<::network::mojom::internal::CookieOrLine_Data>& fragment, bool inlined)
    {
        if (CallIsNullIfExists<Traits>(input)) {
            if (inlined)
                fragment->set_null();
            return;
        }

        if (!inlined)
            fragment.Allocate();

        // TODO(azani): Handle unknown and objects.
        // Set the not-null flag.
        fragment->size = kUnionDataSize;
        fragment->tag = Traits::GetTag(input);
        switch (fragment->tag) {
        case ::network::mojom::CookieOrLineDataView::Tag::kCookie: {
            decltype(Traits::cookie(input)) in_cookie = Traits::cookie(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_cookie)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<::network::mojom::CanonicalCookieDataView>(in_cookie, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null cookie in CookieOrLine union");
            fragment->data.f_cookie.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        case ::network::mojom::CookieOrLineDataView::Tag::kCookieString: {
            decltype(Traits::cookie_string(input)) in_cookie_string = Traits::cookie_string(input);
            mojo::internal::MessageFragment<typename decltype(fragment->data.f_cookie_string)::BaseType> value_fragment(fragment.message());
            mojo::internal::Serialize<mojo::StringDataView>(in_cookie_string, value_fragment);
            MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
                value_fragment.is_null(), mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER, "null cookie_string in CookieOrLine union");
            fragment->data.f_cookie_string.Set(value_fragment.is_null() ? nullptr : value_fragment.data());
            break;
        }
        }
    }

    static bool Deserialize(::network::mojom::internal::CookieOrLine_Data* input, UserType* output, Message* message)
    {
        if (!input || input->is_null())
            return CallSetToNullIfExists<Traits>(output);

        ::network::mojom::CookieOrLineDataView data_view(input, message);
        return Traits::Read(data_view, output);
    }
};

} // namespace internal

} // namespace mojo

namespace network::mojom {

inline void CookieManagerParamsDataView::GetContentSettingsDataView(
    mojo::MapDataView<::content_settings::mojom::ContentSettingsType, mojo::ArrayDataView<::content_settings::mojom::ContentSettingPatternSourceDataView>>*
        output)
{
    auto pointer = data_->content_settings.Get();
    *output = mojo::MapDataView<::content_settings::mojom::ContentSettingsType,
        mojo::ArrayDataView<::content_settings::mojom::ContentSettingPatternSourceDataView>>(pointer, message_);
}
inline void CookieManagerParamsDataView::GetSecureOriginCookiesAllowedSchemesDataView(mojo::ArrayDataView<mojo::StringDataView>* output)
{
    auto pointer = data_->secure_origin_cookies_allowed_schemes.Get();
    *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void CookieManagerParamsDataView::GetMatchingSchemeCookiesAllowedSchemesDataView(mojo::ArrayDataView<mojo::StringDataView>* output)
{
    auto pointer = data_->matching_scheme_cookies_allowed_schemes.Get();
    *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void CookieManagerParamsDataView::GetThirdPartyCookiesAllowedSchemesDataView(mojo::ArrayDataView<mojo::StringDataView>* output)
{
    auto pointer = data_->third_party_cookies_allowed_schemes.Get();
    *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}

inline void CookieSameSiteContextDataView::GetMetadataDataView(CookieSameSiteContextMetadataDataView* output)
{
    auto pointer = data_->metadata.Get();
    *output = CookieSameSiteContextMetadataDataView(pointer, message_);
}
inline void CookieSameSiteContextDataView::GetSchemefulMetadataDataView(CookieSameSiteContextMetadataDataView* output)
{
    auto pointer = data_->schemeful_metadata.Get();
    *output = CookieSameSiteContextMetadataDataView(pointer, message_);
}

inline void CookieOptionsDataView::GetSameSiteCookieContextDataView(CookieSameSiteContextDataView* output)
{
    auto pointer = data_->same_site_cookie_context.Get();
    *output = CookieSameSiteContextDataView(pointer, message_);
}

inline void CanonicalCookieDataView::GetNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void CanonicalCookieDataView::GetValueDataView(mojo::StringDataView* output)
{
    auto pointer = data_->value.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void CanonicalCookieDataView::GetDomainDataView(mojo::StringDataView* output)
{
    auto pointer = data_->domain.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void CanonicalCookieDataView::GetPathDataView(mojo::StringDataView* output)
{
    auto pointer = data_->path.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void CanonicalCookieDataView::GetCreationDataView(::mojo_base::mojom::TimeDataView* output)
{
    auto pointer = data_->creation.Get();
    *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void CanonicalCookieDataView::GetExpiryDataView(::mojo_base::mojom::TimeDataView* output)
{
    auto pointer = data_->expiry.Get();
    *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void CanonicalCookieDataView::GetLastAccessDataView(::mojo_base::mojom::TimeDataView* output)
{
    auto pointer = data_->last_access.Get();
    *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void CanonicalCookieDataView::GetLastUpdateDataView(::mojo_base::mojom::TimeDataView* output)
{
    auto pointer = data_->last_update.Get();
    *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void CanonicalCookieDataView::GetPartitionKeyDataView(::network::mojom::CookiePartitionKeyDataView* output)
{
    auto pointer = data_->partition_key.Get();
    *output = ::network::mojom::CookiePartitionKeyDataView(pointer, message_);
}

inline void CookieAndLineWithAccessResultDataView::GetCookieDataView(CanonicalCookieDataView* output)
{
    auto pointer = data_->cookie.Get();
    *output = CanonicalCookieDataView(pointer, message_);
}
inline void CookieAndLineWithAccessResultDataView::GetCookieStringDataView(mojo::StringDataView* output)
{
    auto pointer = data_->cookie_string.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void CookieAndLineWithAccessResultDataView::GetAccessResultDataView(CookieAccessResultDataView* output)
{
    auto pointer = data_->access_result.Get();
    *output = CookieAccessResultDataView(pointer, message_);
}

inline void CookieOrLineWithAccessResultDataView::GetCookieOrLineDataView(CookieOrLineDataView* output)
{
    auto pointer = &data_->cookie_or_line;
    *output = CookieOrLineDataView(pointer, message_);
}
inline void CookieOrLineWithAccessResultDataView::GetAccessResultDataView(CookieAccessResultDataView* output)
{
    auto pointer = data_->access_result.Get();
    *output = CookieAccessResultDataView(pointer, message_);
}

inline void CookieAccessResultDataView::GetStatusDataView(CookieInclusionStatusDataView* output)
{
    auto pointer = data_->status.Get();
    *output = CookieInclusionStatusDataView(pointer, message_);
}

inline void CookieWithAccessResultDataView::GetCookieDataView(CanonicalCookieDataView* output)
{
    auto pointer = data_->cookie.Get();
    *output = CanonicalCookieDataView(pointer, message_);
}
inline void CookieWithAccessResultDataView::GetAccessResultDataView(CookieAccessResultDataView* output)
{
    auto pointer = data_->access_result.Get();
    *output = CookieAccessResultDataView(pointer, message_);
}

inline void CookieChangeInfoDataView::GetCookieDataView(CanonicalCookieDataView* output)
{
    auto pointer = data_->cookie.Get();
    *output = CanonicalCookieDataView(pointer, message_);
}
inline void CookieChangeInfoDataView::GetAccessResultDataView(CookieAccessResultDataView* output)
{
    auto pointer = data_->access_result.Get();
    *output = CookieAccessResultDataView(pointer, message_);
}

inline void CookieDeletionFilterDataView::GetCreatedAfterTimeDataView(::mojo_base::mojom::TimeDataView* output)
{
    auto pointer = data_->created_after_time.Get();
    *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void CookieDeletionFilterDataView::GetCreatedBeforeTimeDataView(::mojo_base::mojom::TimeDataView* output)
{
    auto pointer = data_->created_before_time.Get();
    *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void CookieDeletionFilterDataView::GetExcludingDomainsDataView(mojo::ArrayDataView<mojo::StringDataView>* output)
{
    auto pointer = data_->excluding_domains.Get();
    *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void CookieDeletionFilterDataView::GetIncludingDomainsDataView(mojo::ArrayDataView<mojo::StringDataView>* output)
{
    auto pointer = data_->including_domains.Get();
    *output = mojo::ArrayDataView<mojo::StringDataView>(pointer, message_);
}
inline void CookieDeletionFilterDataView::GetCookieNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->cookie_name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void CookieDeletionFilterDataView::GetHostNameDataView(mojo::StringDataView* output)
{
    auto pointer = data_->host_name.Get();
    *output = mojo::StringDataView(pointer, message_);
}
inline void CookieDeletionFilterDataView::GetUrlDataView(::url::mojom::UrlDataView* output)
{
    auto pointer = data_->url.Get();
    *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void CookieDeletionFilterDataView::GetCookiePartitionKeyCollectionDataView(::network::mojom::CookiePartitionKeyCollectionDataView* output)
{
    auto pointer = data_->cookie_partition_key_collection.Get();
    *output = ::network::mojom::CookiePartitionKeyCollectionDataView(pointer, message_);
}

inline void CookieOrLineDataView::GetCookieDataView(CanonicalCookieDataView* output) const
{
    CHECK(is_cookie());
    *output = CanonicalCookieDataView(data_->data.f_cookie.Get(), message_);
}
inline void CookieOrLineDataView::GetCookieStringDataView(mojo::StringDataView* output) const
{
    CHECK(is_cookie_string());
    *output = mojo::StringDataView(data_->data.f_cookie_string.Get(), message_);
}

} // network::mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieAccessDelegateType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieAccessDelegateType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookiePriority> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookiePriority value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieSourceScheme> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieSourceScheme value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieSameSite> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieSameSite value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieEffectiveSameSite> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieEffectiveSameSite value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieExemptionReason> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieExemptionReason value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::ContextType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::ContextType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieSameSiteContextMetadataDowngradeType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieSameSiteContextMetadataDowngradeType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieSourceType> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieSourceType value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::ContextRedirectTypeBug1221316> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::ContextRedirectTypeBug1221316 value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::HttpMethod> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::HttpMethod value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieAccessSemantics> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieAccessSemantics value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieChangeCause> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieChangeCause value);
};

} // namespace perfetto

namespace perfetto {

template <> struct TraceFormatTraits<::network::mojom::CookieDeletionSessionControl> {
    static void WriteIntoTrace(perfetto::TracedValue context, ::network::mojom::CookieDeletionSessionControl value);
};

} // namespace perfetto

#endif // SERVICES_NETWORK_PUBLIC_MOJOM_COOKIE_MANAGER_MOJOM_SHARED_H_
