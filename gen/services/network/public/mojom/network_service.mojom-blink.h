// services/network/public/mojom/network_service.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_MOJOM_BLINK_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <optional>
#include <type_traits>
#include <utility>

#include "base/types/cxx23_to_underlying.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/network_service.mojom-features.h" // IWYU pragma: export
#include "services/network/public/mojom/network_service.mojom-shared.h" // IWYU pragma: export
#include "services/network/public/mojom/network_service.mojom-blink-forward.h" // IWYU pragma: export
#include "components/content_settings/core/common/content_settings.mojom-blink-forward.h"
#include "mojo/public/mojom/base/byte_string.mojom-blink.h"
#include "mojo/public/mojom/base/file.mojom-blink.h"
#include "mojo/public/mojom/base/memory_pressure_level.mojom-blink-forward.h"
#include "mojo/public/mojom/base/proto_wrapper.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"
#include "mojo/public/mojom/base/values.mojom-blink.h"
#include "sandbox/policy/mojom/context.mojom-blink-forward.h"
#include "sandbox/policy/mojom/sandbox.mojom-blink-forward.h"
#include "services/network/public/mojom/client_security_state.mojom-blink-forward.h"
#include "services/network/public/mojom/first_party_sets.mojom-blink-forward.h"
#include "services/network/public/mojom/host_resolver.mojom-blink-forward.h"
#include "services/network/public/mojom/http_raw_headers.mojom-blink-forward.h"
#include "services/network/public/mojom/ip_address_space.mojom-blink-forward.h"
#include "services/network/public/mojom/key_pinning.mojom-blink-forward.h"
#include "services/network/public/mojom/mutable_network_traffic_annotation_tag.mojom-blink.h"
#include "services/network/public/mojom/net_log.mojom-blink-forward.h"
#include "services/network/public/mojom/network_annotation_monitor.mojom-blink-forward.h"
#include "services/network/public/mojom/network_change_manager.mojom-blink-forward.h"
#include "services/network/public/mojom/network_context.mojom-blink-forward.h"
#include "services/network/public/mojom/network_interface.mojom-blink.h"
#include "services/network/public/mojom/network_interface_change_listener.mojom-blink-forward.h"
#include "services/network/public/mojom/network_param.mojom-blink-forward.h"
#include "services/network/public/mojom/network_quality_estimator_manager.mojom-blink-forward.h"
#include "services/network/public/mojom/network_service_test.mojom-blink-forward.h"
#include "services/network/public/mojom/parsed_headers.mojom-blink-forward.h"
#include "services/network/public/mojom/proxy_config.mojom-blink-forward.h"
#include "services/network/public/mojom/schemeful_site.mojom-blink-forward.h"
#include "services/network/public/mojom/system_dns_resolution.mojom-blink-forward.h"
#include "services/network/public/mojom/trust_tokens.mojom-blink-forward.h"
#include "services/network/public/mojom/url_loader_network_service_observer.mojom-blink-forward.h"
#include "services/network/public/mojom/url_response_head.mojom-blink-forward.h"
#include "url/mojom/origin.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"
#include "services/network/public/mojom/ct_log_info.mojom-blink-forward.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/lib/message_size_estimator.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"

#include "third_party/blink/public/platform/web_common.h"
#if !BLINK_MOJO_IMPL && !INSIDE_BLINK
#error "File must only be imported inside blink"
#endif

namespace network::mojom::blink {

class NetworkServiceProxy;

template <typename ImplRefTraits> class NetworkServiceStub;

class NetworkServiceRequestValidator;
class NetworkServiceResponseValidator;

class BLINK_PLATFORM_EXPORT NetworkService : public NetworkServiceInterfaceBase {
public:
    using IPCStableHashFunction = uint32_t (*)();

    static const char Name_[];
    static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
    static const char* MessageToMethodName_(mojo::Message& message);
    static constexpr auto kServiceSandbox = sandbox::mojom::Sandbox::kNetwork;
    static constexpr uint32_t Version_ = 0;
    static constexpr bool PassesAssociatedKinds_ = false;
    static constexpr bool HasUninterruptableMethods_ = false;

    using Base_ = NetworkServiceInterfaceBase;
    using Proxy_ = NetworkServiceProxy;

    template <typename ImplRefTraits> using Stub_ = NetworkServiceStub<ImplRefTraits>;

    using RequestValidator_ = NetworkServiceRequestValidator;
    using ResponseValidator_ = NetworkServiceResponseValidator;
    enum MethodMinVersions : uint32_t {
        kSetParamsMinVersion = 0,
        kStartNetLogMinVersion = 0,
        kAttachNetLogProxyMinVersion = 0,
        kSetSSLKeyLogFileMinVersion = 0,
        kCreateNetworkContextMinVersion = 0,
        kConfigureStubHostResolverMinVersion = 0,
        kDisableQuicMinVersion = 0,
        kSetUpHttpAuthMinVersion = 0,
        kConfigureHttpAuthPrefsMinVersion = 0,
        kSetRawHeadersAccessMinVersion = 0,
        kSetMaxConnectionsPerProxyChainMinVersion = 0,
        kGetNetworkChangeManagerMinVersion = 0,
        kGetNetworkQualityEstimatorManagerMinVersion = 0,
        kGetDnsConfigChangeManagerMinVersion = 0,
        kGetNetworkListMinVersion = 0,
        kOnTrustStoreChangedMinVersion = 0,
        kOnClientCertStoreChangedMinVersion = 0,
        kSetEncryptionKeyMinVersion = 0,
        kOnMemoryPressureMinVersion = 0,
        kOnPeerToPeerConnectionsCountChangeMinVersion = 0,
        kSetTrustTokenKeyCommitmentsMinVersion = 0,
        kClearSCTAuditingCacheMinVersion = 0,
        kConfigureSCTAuditingMinVersion = 0,
        kUpdateCtLogListMinVersion = 0,
        kUpdateCtKnownPopularSCTsMinVersion = 0,
        kSetCtEnforcementEnabledMinVersion = 0,
        kUpdateKeyPinsListMinVersion = 0,
        kBindTestInterfaceForTestingMinVersion = 0,
        kSetFirstPartySetsMinVersion = 0,
        kSetExplicitlyAllowedPortsMinVersion = 0,
        kUpdateMaskedDomainListMinVersion = 0,
        kParseHeadersMinVersion = 0,
        kEnableDataUseUpdatesMinVersion = 0,
        kSetIPv6ReachabilityOverrideMinVersion = 0,
        kSetNetworkAnnotationMonitorMinVersion = 0,
        kSetTpcdMetadataGrantsMinVersion = 0,
    };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
    struct SetParams_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct StartNetLog_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct AttachNetLogProxy_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetSSLKeyLogFile_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct CreateNetworkContext_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ConfigureStubHostResolver_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct DisableQuic_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetUpHttpAuth_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ConfigureHttpAuthPrefs_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetRawHeadersAccess_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetMaxConnectionsPerProxyChain_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetNetworkChangeManager_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetNetworkQualityEstimatorManager_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetDnsConfigChangeManager_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct GetNetworkList_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnTrustStoreChanged_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnClientCertStoreChanged_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetEncryptionKey_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnMemoryPressure_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct OnPeerToPeerConnectionsCountChange_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetTrustTokenKeyCommitments_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ClearSCTAuditingCache_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ConfigureSCTAuditing_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct UpdateCtLogList_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct UpdateCtKnownPopularSCTs_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetCtEnforcementEnabled_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct UpdateKeyPinsList_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct BindTestInterfaceForTesting_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetFirstPartySets_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetExplicitlyAllowedPorts_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct UpdateMaskedDomainList_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct ParseHeaders_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct EnableDataUseUpdates_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetIPv6ReachabilityOverride_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetNetworkAnnotationMonitor_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
    struct SetTpcdMetadataGrants_Sym {
        NOINLINE static uint32_t IPCStableHash();
    };
#endif // !BUILDFLAG(IS_FUCHSIA)
    virtual ~NetworkService() = default;

    virtual void SetParams(NetworkServiceParamsPtr params) = 0;

    virtual void StartNetLog(::base::File file, uint64_t max_total_size, ::network::mojom::blink::NetLogCaptureMode capture_mode, ::base::Value::Dict constants)
        = 0;

    virtual void AttachNetLogProxy(::mojo::PendingRemote<::network::mojom::blink::NetLogProxySource> proxy_source,
        ::mojo::PendingReceiver<::network::mojom::blink::NetLogProxySink> proxy_sink)
        = 0;

    virtual void SetSSLKeyLogFile(::base::File file) = 0;

    virtual void CreateNetworkContext(
        ::mojo::PendingReceiver<::network::mojom::blink::NetworkContext> context, ::network::mojom::blink::NetworkContextParamsPtr params)
        = 0;

    virtual void ConfigureStubHostResolver(bool insecure_dns_client_enabled, ::network::mojom::blink::SecureDnsMode secure_dns_mode,
        ::network::mojom::blink::DnsOverHttpsConfigPtr dns_over_https_config, bool additional_dns_types_enabled)
        = 0;

    virtual void DisableQuic() = 0;

    virtual void SetUpHttpAuth(HttpAuthStaticParamsPtr http_auth_static_params) = 0;

    virtual void ConfigureHttpAuthPrefs(HttpAuthDynamicParamsPtr http_auth_dynamic_params) = 0;

    virtual void SetRawHeadersAccess(int32_t process_id, const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins) = 0;

    virtual void SetMaxConnectionsPerProxyChain(int32_t max_connections) = 0;

    virtual void GetNetworkChangeManager(::mojo::PendingReceiver<::network::mojom::blink::NetworkChangeManager> network_change_manager) = 0;

    virtual void GetNetworkQualityEstimatorManager(::mojo::PendingReceiver<::network::mojom::blink::NetworkQualityEstimatorManager> receiver) = 0;

    virtual void GetDnsConfigChangeManager(::mojo::PendingReceiver<::network::mojom::blink::DnsConfigChangeManager> receiver) = 0;

    using GetNetworkListCallback = base::OnceCallback<void(const std::optional<WTF::Vector<::net::NetworkInterface>>&)>;

    virtual void GetNetworkList(uint32_t policy, GetNetworkListCallback callback) = 0;

    virtual void OnTrustStoreChanged() = 0;

    virtual void OnClientCertStoreChanged() = 0;

    virtual void SetEncryptionKey(const std::string& encryption_key) = 0;

    virtual void OnMemoryPressure(::mojo_base::mojom::blink::MemoryPressureLevel memory_pressure_level) = 0;

    virtual void OnPeerToPeerConnectionsCountChange(uint32_t count) = 0;

    using SetTrustTokenKeyCommitmentsCallback = base::OnceCallback<void()>;

    virtual void SetTrustTokenKeyCommitments(const WTF::String& raw_commitments, SetTrustTokenKeyCommitmentsCallback callback) = 0;

    virtual void ClearSCTAuditingCache() = 0;

    virtual void ConfigureSCTAuditing(SCTAuditingConfigurationPtr configuration) = 0;

    using UpdateCtLogListCallback = base::OnceCallback<void()>;

    virtual void UpdateCtLogList(WTF::Vector<::network::mojom::blink::CTLogInfoPtr> log_list, UpdateCtLogListCallback callback) = 0;

    using UpdateCtKnownPopularSCTsCallback = base::OnceCallback<void()>;

    virtual void UpdateCtKnownPopularSCTs(const WTF::Vector<WTF::Vector<uint8_t>>& sct_hashes, UpdateCtKnownPopularSCTsCallback callback) = 0;

    using SetCtEnforcementEnabledCallback = base::OnceCallback<void()>;

    virtual void SetCtEnforcementEnabled(bool enabled, SetCtEnforcementEnabledCallback callback) = 0;

    virtual void UpdateKeyPinsList(::network::mojom::blink::PinListPtr pin_list, ::base::Time update_time) = 0;

    virtual void BindTestInterfaceForTesting(::mojo::PendingReceiver<::network::mojom::blink::NetworkServiceTest> receiver) = 0;

    virtual void SetFirstPartySets(::network::mojom::blink::GlobalFirstPartySetsPtr sets) = 0;

    virtual void SetExplicitlyAllowedPorts(const WTF::Vector<uint16_t>& ports) = 0;

    virtual void UpdateMaskedDomainList(::mojo_base::ProtoWrapper masked_domain_list, const WTF::Vector<WTF::String>& exclusion_list) = 0;

    using ParseHeadersCallback = base::OnceCallback<void(::network::mojom::blink::ParsedHeadersPtr)>;

    virtual void ParseHeaders(const ::blink::KURL& url, ::network::mojom::blink::HttpResponseHeadersPtr headers, ParseHeadersCallback callback) = 0;

    virtual void EnableDataUseUpdates(bool enable) = 0;

    virtual void SetIPv6ReachabilityOverride(bool reachability_override) = 0;

    virtual void SetNetworkAnnotationMonitor(::mojo::PendingRemote<::network::mojom::blink::NetworkAnnotationMonitor> remote) = 0;

    virtual void SetTpcdMetadataGrants(WTF::Vector<::content_settings::mojom::blink::ContentSettingPatternSourcePtr> settings) = 0;
};

//class BLINK_PLATFORM_EXPORT NetworkServiceProxy : public NetworkService {
//public:
//    using InterfaceType = NetworkService;
//
//    explicit NetworkServiceProxy(mojo::MessageReceiverWithResponder* receiver);
//
//    void SetParams(NetworkServiceParamsPtr params) final;
//
//    void StartNetLog(::base::File file, uint64_t max_total_size, ::network::mojom::blink::NetLogCaptureMode capture_mode, ::base::Value::Dict constants) final;
//
//    void AttachNetLogProxy(::mojo::PendingRemote<::network::mojom::blink::NetLogProxySource> proxy_source,
//        ::mojo::PendingReceiver<::network::mojom::blink::NetLogProxySink> proxy_sink) final;
//
//    void SetSSLKeyLogFile(::base::File file) final;
//
//    void CreateNetworkContext(
//        ::mojo::PendingReceiver<::network::mojom::blink::NetworkContext> context, ::network::mojom::blink::NetworkContextParamsPtr params) final;
//
//    void ConfigureStubHostResolver(bool insecure_dns_client_enabled, ::network::mojom::blink::SecureDnsMode secure_dns_mode,
//        ::network::mojom::blink::DnsOverHttpsConfigPtr dns_over_https_config, bool additional_dns_types_enabled) final;
//
//    void DisableQuic() final;
//
//    void SetUpHttpAuth(HttpAuthStaticParamsPtr http_auth_static_params) final;
//
//    void ConfigureHttpAuthPrefs(HttpAuthDynamicParamsPtr http_auth_dynamic_params) final;
//
//    void SetRawHeadersAccess(int32_t process_id, const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins) final;
//
//    void SetMaxConnectionsPerProxyChain(int32_t max_connections) final;
//
//    void GetNetworkChangeManager(::mojo::PendingReceiver<::network::mojom::blink::NetworkChangeManager> network_change_manager) final;
//
//    void GetNetworkQualityEstimatorManager(::mojo::PendingReceiver<::network::mojom::blink::NetworkQualityEstimatorManager> receiver) final;
//
//    void GetDnsConfigChangeManager(::mojo::PendingReceiver<::network::mojom::blink::DnsConfigChangeManager> receiver) final;
//
//    void GetNetworkList(uint32_t policy, GetNetworkListCallback callback) final;
//
//    void OnTrustStoreChanged() final;
//
//    void OnClientCertStoreChanged() final;
//
//    void SetEncryptionKey(const std::string& encryption_key) final;
//
//    void OnMemoryPressure(::mojo_base::mojom::blink::MemoryPressureLevel memory_pressure_level) final;
//
//    void OnPeerToPeerConnectionsCountChange(uint32_t count) final;
//
//    void SetTrustTokenKeyCommitments(const WTF::String& raw_commitments, SetTrustTokenKeyCommitmentsCallback callback) final;
//
//    void ClearSCTAuditingCache() final;
//
//    void ConfigureSCTAuditing(SCTAuditingConfigurationPtr configuration) final;
//
//    void UpdateCtLogList(WTF::Vector<::network::mojom::blink::CTLogInfoPtr> log_list, UpdateCtLogListCallback callback) final;
//
//    void UpdateCtKnownPopularSCTs(const WTF::Vector<WTF::Vector<uint8_t>>& sct_hashes, UpdateCtKnownPopularSCTsCallback callback) final;
//
//    void SetCtEnforcementEnabled(bool enabled, SetCtEnforcementEnabledCallback callback) final;
//
//    void UpdateKeyPinsList(::network::mojom::blink::PinListPtr pin_list, ::base::Time update_time) final;
//
//    void BindTestInterfaceForTesting(::mojo::PendingReceiver<::network::mojom::blink::NetworkServiceTest> receiver) final;
//
//    void SetFirstPartySets(::network::mojom::blink::GlobalFirstPartySetsPtr sets) final;
//
//    void SetExplicitlyAllowedPorts(const WTF::Vector<uint16_t>& ports) final;
//
//    void UpdateMaskedDomainList(::mojo_base::ProtoWrapper masked_domain_list, const WTF::Vector<WTF::String>& exclusion_list) final;
//
//    void ParseHeaders(const ::blink::KURL& url, ::network::mojom::blink::HttpResponseHeadersPtr headers, ParseHeadersCallback callback) final;
//
//    void EnableDataUseUpdates(bool enable) final;
//
//    void SetIPv6ReachabilityOverride(bool reachability_override) final;
//
//    void SetNetworkAnnotationMonitor(::mojo::PendingRemote<::network::mojom::blink::NetworkAnnotationMonitor> remote) final;
//
//    void SetTpcdMetadataGrants(WTF::Vector<::content_settings::mojom::blink::ContentSettingPatternSourcePtr> settings) final;
//
//private:
//    mojo::MessageReceiverWithResponder* receiver_;
//};
//class BLINK_PLATFORM_EXPORT NetworkServiceStubDispatch {
//public:
//    static bool Accept(NetworkService* impl, mojo::Message* message);
//    static bool AcceptWithResponder(NetworkService* impl, mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
//};

//template <typename ImplRefTraits = mojo::RawPtrImplRefTraits<NetworkService>> class NetworkServiceStub : public mojo::MessageReceiverWithResponderStatus {
//public:
//    using ImplPointerType = typename ImplRefTraits::PointerType;
//
//    NetworkServiceStub() = default;
//    ~NetworkServiceStub() override = default;
//
//    void set_sink(ImplPointerType sink)
//    {
//        sink_ = std::move(sink);
//    }
//    ImplPointerType& sink()
//    {
//        return sink_;
//    }
//
//    bool Accept(mojo::Message* message) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return NetworkServiceStubDispatch::Accept(ImplRefTraits::GetRawPointer(&sink_), message);
//    }
//
//    bool AcceptWithResponder(mojo::Message* message, std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override
//    {
//        if (ImplRefTraits::IsNull(sink_))
//            return false;
//        return NetworkServiceStubDispatch::AcceptWithResponder(ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
//    }
//
//private:
//    ImplPointerType sink_;
//};
//class BLINK_PLATFORM_EXPORT NetworkServiceRequestValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};
//class BLINK_PLATFORM_EXPORT NetworkServiceResponseValidator : public mojo::MessageReceiver {
//public:
//    bool Accept(mojo::Message* message) override;
//};

class BLINK_PLATFORM_EXPORT HttpAuthStaticParams {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<HttpAuthStaticParams, T>::value>;
    using DataView = HttpAuthStaticParamsDataView;
    using Data_ = internal::HttpAuthStaticParams_Data;

    template <typename... Args> static HttpAuthStaticParamsPtr New(Args&&... args)
    {
        return HttpAuthStaticParamsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static HttpAuthStaticParamsPtr From(const U& u)
    {
        return mojo::TypeConverter<HttpAuthStaticParamsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, HttpAuthStaticParams>::Convert(*this);
    }

    HttpAuthStaticParams()
    : gssapi_library_name()
{
}

    explicit HttpAuthStaticParams(const WTF::String& gssapi_library_name_in)
    : gssapi_library_name(std::move(gssapi_library_name_in)){
}

    ~HttpAuthStaticParams() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = HttpAuthStaticParamsPtr> HttpAuthStaticParamsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<HttpAuthStaticParams::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<HttpAuthStaticParams::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::HttpAuthStaticParams_UnserializedMessageContext<UserType, HttpAuthStaticParams::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<HttpAuthStaticParams::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return HttpAuthStaticParams::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::HttpAuthStaticParams_UnserializedMessageContext<UserType, HttpAuthStaticParams::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<HttpAuthStaticParams::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String gssapi_library_name;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT EnvironmentVariable {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<EnvironmentVariable, T>::value>;
    using DataView = EnvironmentVariableDataView;
    using Data_ = internal::EnvironmentVariable_Data;

    template <typename... Args> static EnvironmentVariablePtr New(Args&&... args)
    {
        return EnvironmentVariablePtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static EnvironmentVariablePtr From(const U& u)
    {
        return mojo::TypeConverter<EnvironmentVariablePtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, EnvironmentVariable>::Convert(*this);
    }

    EnvironmentVariable()
    : name()
    , value()
{
}

    EnvironmentVariable(const WTF::String& name_in, const WTF::String& value_in)
    : name(std::move(name_in))
    , value(std::move(value_in)){
}

    ~EnvironmentVariable() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = EnvironmentVariablePtr> EnvironmentVariablePtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    size_t Hash(size_t seed) const;
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<EnvironmentVariable::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<EnvironmentVariable::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::EnvironmentVariable_UnserializedMessageContext<UserType, EnvironmentVariable::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<EnvironmentVariable::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return EnvironmentVariable::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::EnvironmentVariable_UnserializedMessageContext<UserType, EnvironmentVariable::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<EnvironmentVariable::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    WTF::String name;

    WTF::String value;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT HttpAuthDynamicParams {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<HttpAuthDynamicParams, T>::value>;
    using DataView = HttpAuthDynamicParamsDataView;
    using Data_ = internal::HttpAuthDynamicParams_Data;

    template <typename... Args> static HttpAuthDynamicParamsPtr New(Args&&... args)
    {
        return HttpAuthDynamicParamsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static HttpAuthDynamicParamsPtr From(const U& u)
    {
        return mojo::TypeConverter<HttpAuthDynamicParamsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, HttpAuthDynamicParams>::Convert(*this);
    }

    HttpAuthDynamicParams()
    : allowed_schemes()
    , patterns_allowed_to_use_all_schemes()
    , server_allowlist()
    , delegate_allowlist()
    , delegate_by_kdc_policy(false)
    , negotiate_disable_cname_lookup(false)
    , enable_negotiate_port(false)
    , ntlm_v2_enabled(true)
    , android_negotiate_account_type()
    , allow_gssapi_library_load(true)
    , basic_over_http_enabled(true)
{
}

    HttpAuthDynamicParams(std::optional<WTF::Vector<WTF::String>> allowed_schemes_in,
    WTF::Vector<WTF::String> patterns_allowed_to_use_all_schemes_in, const WTF::String& server_allowlist_in, const WTF::String& delegate_allowlist_in,
    bool delegate_by_kdc_policy_in, bool negotiate_disable_cname_lookup_in, bool enable_negotiate_port_in, bool ntlm_v2_enabled_in,
    const WTF::String& android_negotiate_account_type_in, bool allow_gssapi_library_load_in, bool basic_over_http_enabled_in)
    : allowed_schemes(std::move(allowed_schemes_in))
    , patterns_allowed_to_use_all_schemes(std::move(patterns_allowed_to_use_all_schemes_in))
    , server_allowlist(std::move(server_allowlist_in))
    , delegate_allowlist(std::move(delegate_allowlist_in))
    , delegate_by_kdc_policy(std::move(delegate_by_kdc_policy_in))
    , negotiate_disable_cname_lookup(std::move(negotiate_disable_cname_lookup_in))
    , enable_negotiate_port(std::move(enable_negotiate_port_in))
    , ntlm_v2_enabled(std::move(ntlm_v2_enabled_in))
    , android_negotiate_account_type(std::move(android_negotiate_account_type_in))
    , allow_gssapi_library_load(std::move(allow_gssapi_library_load_in))
    , basic_over_http_enabled(std::move(basic_over_http_enabled_in)){
}

    ~HttpAuthDynamicParams() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = HttpAuthDynamicParamsPtr> HttpAuthDynamicParamsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<HttpAuthDynamicParams::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<HttpAuthDynamicParams::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::HttpAuthDynamicParams_UnserializedMessageContext<UserType, HttpAuthDynamicParams::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<HttpAuthDynamicParams::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return HttpAuthDynamicParams::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::HttpAuthDynamicParams_UnserializedMessageContext<UserType, HttpAuthDynamicParams::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<HttpAuthDynamicParams::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    std::optional<WTF::Vector<WTF::String>> allowed_schemes;

    WTF::Vector<WTF::String> patterns_allowed_to_use_all_schemes;

    WTF::String server_allowlist;

    WTF::String delegate_allowlist;

    bool delegate_by_kdc_policy;

    bool negotiate_disable_cname_lookup;

    bool enable_negotiate_port;

    bool ntlm_v2_enabled;

    WTF::String android_negotiate_account_type;

    bool allow_gssapi_library_load;

    bool basic_over_http_enabled;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT NetworkServiceParams {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<NetworkServiceParams, T>::value>;
    using DataView = NetworkServiceParamsDataView;
    using Data_ = internal::NetworkServiceParams_Data;

    template <typename... Args> static NetworkServiceParamsPtr New(Args&&... args)
    {
        return NetworkServiceParamsPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static NetworkServiceParamsPtr From(const U& u)
    {
        return mojo::TypeConverter<NetworkServiceParamsPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, NetworkServiceParams>::Convert(*this);
    }

    NetworkServiceParams()
    : initial_connection_type(::network::mojom::blink::ConnectionType::CONNECTION_UNKNOWN)
    , initial_connection_subtype(::network::mojom::blink::ConnectionSubtype::SUBTYPE_UNKNOWN)
    , environment()
    , default_observer()
    , first_party_sets_enabled()
    , system_dns_resolver()
    , ip_protection_proxy_bypass_policy()
{
}

    NetworkServiceParams(::network::mojom::blink::ConnectionType initial_connection_type_in,
    ::network::mojom::blink::ConnectionSubtype initial_connection_subtype_in, WTF::Vector<EnvironmentVariablePtr> environment_in,
    ::mojo::PendingRemote<::network::mojom::blink::URLLoaderNetworkServiceObserver> default_observer_in, bool first_party_sets_enabled_in,
    ::mojo::PendingRemote<::network::mojom::blink::SystemDnsResolver> system_dns_resolver_in,
    ::network::mojom::blink::IpProtectionProxyBypassPolicy ip_protection_proxy_bypass_policy_in)
    : initial_connection_type(std::move(initial_connection_type_in))
    , initial_connection_subtype(std::move(initial_connection_subtype_in))
    , environment(std::move(environment_in))
    , default_observer(std::move(default_observer_in))
    , first_party_sets_enabled(std::move(first_party_sets_enabled_in))
    , system_dns_resolver(std::move(system_dns_resolver_in))
    , ip_protection_proxy_bypass_policy(std::move(ip_protection_proxy_bypass_policy_in)){
}

    NetworkServiceParams(const NetworkServiceParams&) = delete;
    NetworkServiceParams& operator=(const NetworkServiceParams&) = delete;

    ~NetworkServiceParams() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = NetworkServiceParamsPtr> NetworkServiceParamsPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<NetworkServiceParams::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(
            std::make_unique<internal::NetworkServiceParams_UnserializedMessageContext<UserType, NetworkServiceParams::DataView>>(0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<NetworkServiceParams::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return NetworkServiceParams::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context = input.TakeUnserializedContext<internal::NetworkServiceParams_UnserializedMessageContext<UserType, NetworkServiceParams::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<NetworkServiceParams::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    ::network::mojom::blink::ConnectionType initial_connection_type;

    ::network::mojom::blink::ConnectionSubtype initial_connection_subtype;

    WTF::Vector<EnvironmentVariablePtr> environment;

    ::mojo::PendingRemote<::network::mojom::blink::URLLoaderNetworkServiceObserver> default_observer;

    bool first_party_sets_enabled;

    ::mojo::PendingRemote<::network::mojom::blink::SystemDnsResolver> system_dns_resolver;

    ::network::mojom::blink::IpProtectionProxyBypassPolicy ip_protection_proxy_bypass_policy;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

class BLINK_PLATFORM_EXPORT SCTAuditingConfiguration {
public:
    template <typename T> using EnableIfSame = std::enable_if_t<std::is_same<SCTAuditingConfiguration, T>::value>;
    using DataView = SCTAuditingConfigurationDataView;
    using Data_ = internal::SCTAuditingConfiguration_Data;

    template <typename... Args> static SCTAuditingConfigurationPtr New(Args&&... args)
    {
        return SCTAuditingConfigurationPtr(std::in_place, std::forward<Args>(args)...);
    }

    template <typename U> static SCTAuditingConfigurationPtr From(const U& u)
    {
        return mojo::TypeConverter<SCTAuditingConfigurationPtr, U>::Convert(u);
    }

    template <typename U> U To() const
    {
        return mojo::TypeConverter<U, SCTAuditingConfiguration>::Convert(*this);
    }

    SCTAuditingConfiguration()
    : sampling_rate()
    , log_expected_ingestion_delay()
    , log_max_ingestion_random_delay()
    , report_uri()
    , hashdance_lookup_uri()
    , traffic_annotation()
    , hashdance_traffic_annotation()
{
}

    SCTAuditingConfiguration(double sampling_rate_in, ::base::TimeDelta log_expected_ingestion_delay_in,
    ::base::TimeDelta log_max_ingestion_random_delay_in, const ::blink::KURL& report_uri_in, const ::blink::KURL& hashdance_lookup_uri_in,
    const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation_in, const ::net::MutableNetworkTrafficAnnotationTag& hashdance_traffic_annotation_in)
    : sampling_rate(std::move(sampling_rate_in))
    , log_expected_ingestion_delay(std::move(log_expected_ingestion_delay_in))
    , log_max_ingestion_random_delay(std::move(log_max_ingestion_random_delay_in))
    , report_uri(std::move(report_uri_in))
    , hashdance_lookup_uri(std::move(hashdance_lookup_uri_in))
    , traffic_annotation(std::move(traffic_annotation_in))
    , hashdance_traffic_annotation(std::move(hashdance_traffic_annotation_in)){
}

    ~SCTAuditingConfiguration() = default;

    // Clone() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Clone() or copy
    // constructor/assignment are available for members.
    template <typename StructPtrType = SCTAuditingConfigurationPtr> SCTAuditingConfigurationPtr Clone() const;

    // Equals() is a template so it is only instantiated if it is used. Thus, the
    // bindings generator does not need to know whether Equals() or == operator
    // are available for members.
    template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr> bool Equals(const T& other) const;

    template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr> bool operator==(const T& rhs) const
    {
        return Equals(rhs);
    }

    template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr> bool operator!=(const T& rhs) const
    {
        return !operator==(rhs);
    }
    template <typename UserType> static WTF::Vector<uint8_t> Serialize(UserType* input)
    {
        return mojo::internal::SerializeImpl<SCTAuditingConfiguration::DataView, WTF::Vector<uint8_t>>(input);
    }

    template <typename UserType> static mojo::Message SerializeAsMessage(UserType* input)
    {
        return mojo::internal::SerializeAsMessageImpl<SCTAuditingConfiguration::DataView>(input);
    }

    // The returned Message is serialized only if the message is moved
    // cross-process or cross-language. Otherwise if the message is Deserialized
    // as the same UserType |input| will just be moved to |output| in
    // DeserializeFromMessage.
    template <typename UserType> static mojo::Message WrapAsMessage(UserType input)
    {
        return mojo::Message(std::make_unique<internal::SCTAuditingConfiguration_UnserializedMessageContext<UserType, SCTAuditingConfiguration::DataView>>(
                                 0, 0, std::move(input)),
            MOJO_CREATE_MESSAGE_FLAG_NONE);
    }

    template <typename UserType> static bool Deserialize(const void* data, size_t data_num_bytes, UserType* output)
    {
        mojo::Message message;
        return mojo::internal::DeserializeImpl<SCTAuditingConfiguration::DataView>(message, data, data_num_bytes, output, Validate);
    }

    template <typename UserType> static bool Deserialize(base::span<const uint8_t> input, UserType* output)
    {
        return SCTAuditingConfiguration::Deserialize(input.empty() ? nullptr : input.data(), input.size(), output);
    }

    template <typename UserType> static bool DeserializeFromMessage(mojo::Message input, UserType* output)
    {
        auto context
            = input.TakeUnserializedContext<internal::SCTAuditingConfiguration_UnserializedMessageContext<UserType, SCTAuditingConfiguration::DataView>>();
        if (context) {
            *output = std::move(context->TakeData());
            return true;
        }
        input.SerializeIfNecessary();
        return mojo::internal::DeserializeImpl<SCTAuditingConfiguration::DataView>(input, input.payload(), input.payload_num_bytes(), output, Validate);
    }

    double sampling_rate;

    ::base::TimeDelta log_expected_ingestion_delay;

    ::base::TimeDelta log_max_ingestion_random_delay;

    ::blink::KURL report_uri;

    ::blink::KURL hashdance_lookup_uri;

    ::net::MutableNetworkTrafficAnnotationTag traffic_annotation;

    ::net::MutableNetworkTrafficAnnotationTag hashdance_traffic_annotation;

    // Serialise this struct into a trace.
    void WriteIntoTrace(perfetto::TracedValue traced_context) const;

private:
    static bool Validate(const void* data, mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr> bool operator<(const T& lhs, const T& rhs);

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr> bool operator<=(const T& lhs, const T& rhs)
{
    return !(rhs < lhs);
}

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr> bool operator>(const T& lhs, const T& rhs)
{
    return rhs < lhs;
}

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr> bool operator>=(const T& lhs, const T& rhs)
{
    return !(lhs < rhs);
}

template <typename StructPtrType> HttpAuthStaticParamsPtr HttpAuthStaticParams::Clone() const
{
    return New(mojo::Clone(gssapi_library_name));
}

template <typename T, HttpAuthStaticParams::EnableIfSame<T>*> bool HttpAuthStaticParams::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->gssapi_library_name, other_struct.gssapi_library_name))
        return false;
    return true;
}

template <typename T, HttpAuthStaticParams::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.gssapi_library_name < rhs.gssapi_library_name)
        return true;
    if (rhs.gssapi_library_name < lhs.gssapi_library_name)
        return false;
    return false;
}
template <typename StructPtrType> HttpAuthDynamicParamsPtr HttpAuthDynamicParams::Clone() const
{
    return New(mojo::Clone(allowed_schemes), mojo::Clone(patterns_allowed_to_use_all_schemes), mojo::Clone(server_allowlist), mojo::Clone(delegate_allowlist),
        mojo::Clone(delegate_by_kdc_policy), mojo::Clone(negotiate_disable_cname_lookup), mojo::Clone(enable_negotiate_port), mojo::Clone(ntlm_v2_enabled),
        mojo::Clone(android_negotiate_account_type), mojo::Clone(allow_gssapi_library_load), mojo::Clone(basic_over_http_enabled));
}

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>*> bool HttpAuthDynamicParams::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->allowed_schemes, other_struct.allowed_schemes))
        return false;
    if (!mojo::Equals(this->patterns_allowed_to_use_all_schemes, other_struct.patterns_allowed_to_use_all_schemes))
        return false;
    if (!mojo::Equals(this->server_allowlist, other_struct.server_allowlist))
        return false;
    if (!mojo::Equals(this->delegate_allowlist, other_struct.delegate_allowlist))
        return false;
    if (!mojo::Equals(this->delegate_by_kdc_policy, other_struct.delegate_by_kdc_policy))
        return false;
    if (!mojo::Equals(this->negotiate_disable_cname_lookup, other_struct.negotiate_disable_cname_lookup))
        return false;
    if (!mojo::Equals(this->enable_negotiate_port, other_struct.enable_negotiate_port))
        return false;
    if (!mojo::Equals(this->ntlm_v2_enabled, other_struct.ntlm_v2_enabled))
        return false;
    if (!mojo::Equals(this->android_negotiate_account_type, other_struct.android_negotiate_account_type))
        return false;
    if (!mojo::Equals(this->allow_gssapi_library_load, other_struct.allow_gssapi_library_load))
        return false;
    if (!mojo::Equals(this->basic_over_http_enabled, other_struct.basic_over_http_enabled))
        return false;
    return true;
}

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.allowed_schemes < rhs.allowed_schemes)
        return true;
    if (rhs.allowed_schemes < lhs.allowed_schemes)
        return false;
    if (lhs.patterns_allowed_to_use_all_schemes < rhs.patterns_allowed_to_use_all_schemes)
        return true;
    if (rhs.patterns_allowed_to_use_all_schemes < lhs.patterns_allowed_to_use_all_schemes)
        return false;
    if (lhs.server_allowlist < rhs.server_allowlist)
        return true;
    if (rhs.server_allowlist < lhs.server_allowlist)
        return false;
    if (lhs.delegate_allowlist < rhs.delegate_allowlist)
        return true;
    if (rhs.delegate_allowlist < lhs.delegate_allowlist)
        return false;
    if (lhs.delegate_by_kdc_policy < rhs.delegate_by_kdc_policy)
        return true;
    if (rhs.delegate_by_kdc_policy < lhs.delegate_by_kdc_policy)
        return false;
    if (lhs.negotiate_disable_cname_lookup < rhs.negotiate_disable_cname_lookup)
        return true;
    if (rhs.negotiate_disable_cname_lookup < lhs.negotiate_disable_cname_lookup)
        return false;
    if (lhs.enable_negotiate_port < rhs.enable_negotiate_port)
        return true;
    if (rhs.enable_negotiate_port < lhs.enable_negotiate_port)
        return false;
    if (lhs.ntlm_v2_enabled < rhs.ntlm_v2_enabled)
        return true;
    if (rhs.ntlm_v2_enabled < lhs.ntlm_v2_enabled)
        return false;
    if (lhs.android_negotiate_account_type < rhs.android_negotiate_account_type)
        return true;
    if (rhs.android_negotiate_account_type < lhs.android_negotiate_account_type)
        return false;
    if (lhs.allow_gssapi_library_load < rhs.allow_gssapi_library_load)
        return true;
    if (rhs.allow_gssapi_library_load < lhs.allow_gssapi_library_load)
        return false;
    if (lhs.basic_over_http_enabled < rhs.basic_over_http_enabled)
        return true;
    if (rhs.basic_over_http_enabled < lhs.basic_over_http_enabled)
        return false;
    return false;
}
template <typename StructPtrType> EnvironmentVariablePtr EnvironmentVariable::Clone() const
{
    return New(mojo::Clone(name), mojo::Clone(value));
}

template <typename T, EnvironmentVariable::EnableIfSame<T>*> bool EnvironmentVariable::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->name, other_struct.name))
        return false;
    if (!mojo::Equals(this->value, other_struct.value))
        return false;
    return true;
}

template <typename T, EnvironmentVariable::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.name < rhs.name)
        return true;
    if (rhs.name < lhs.name)
        return false;
    if (lhs.value < rhs.value)
        return true;
    if (rhs.value < lhs.value)
        return false;
    return false;
}
template <typename StructPtrType> NetworkServiceParamsPtr NetworkServiceParams::Clone() const
{
    return New(mojo::Clone(initial_connection_type), mojo::Clone(initial_connection_subtype), mojo::Clone(environment), mojo::Clone(default_observer),
        mojo::Clone(first_party_sets_enabled), mojo::Clone(system_dns_resolver), mojo::Clone(ip_protection_proxy_bypass_policy));
}

template <typename T, NetworkServiceParams::EnableIfSame<T>*> bool NetworkServiceParams::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->initial_connection_type, other_struct.initial_connection_type))
        return false;
    if (!mojo::Equals(this->initial_connection_subtype, other_struct.initial_connection_subtype))
        return false;
    if (!mojo::Equals(this->environment, other_struct.environment))
        return false;
    if (!mojo::Equals(this->default_observer, other_struct.default_observer))
        return false;
    if (!mojo::Equals(this->first_party_sets_enabled, other_struct.first_party_sets_enabled))
        return false;
    if (!mojo::Equals(this->system_dns_resolver, other_struct.system_dns_resolver))
        return false;
    if (!mojo::Equals(this->ip_protection_proxy_bypass_policy, other_struct.ip_protection_proxy_bypass_policy))
        return false;
    return true;
}

template <typename T, NetworkServiceParams::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.initial_connection_type < rhs.initial_connection_type)
        return true;
    if (rhs.initial_connection_type < lhs.initial_connection_type)
        return false;
    if (lhs.initial_connection_subtype < rhs.initial_connection_subtype)
        return true;
    if (rhs.initial_connection_subtype < lhs.initial_connection_subtype)
        return false;
    if (lhs.environment < rhs.environment)
        return true;
    if (rhs.environment < lhs.environment)
        return false;
    if (lhs.default_observer < rhs.default_observer)
        return true;
    if (rhs.default_observer < lhs.default_observer)
        return false;
    if (lhs.first_party_sets_enabled < rhs.first_party_sets_enabled)
        return true;
    if (rhs.first_party_sets_enabled < lhs.first_party_sets_enabled)
        return false;
    if (lhs.system_dns_resolver < rhs.system_dns_resolver)
        return true;
    if (rhs.system_dns_resolver < lhs.system_dns_resolver)
        return false;
    if (lhs.ip_protection_proxy_bypass_policy < rhs.ip_protection_proxy_bypass_policy)
        return true;
    if (rhs.ip_protection_proxy_bypass_policy < lhs.ip_protection_proxy_bypass_policy)
        return false;
    return false;
}
template <typename StructPtrType> SCTAuditingConfigurationPtr SCTAuditingConfiguration::Clone() const
{
    return New(mojo::Clone(sampling_rate), mojo::Clone(log_expected_ingestion_delay), mojo::Clone(log_max_ingestion_random_delay), mojo::Clone(report_uri),
        mojo::Clone(hashdance_lookup_uri), mojo::Clone(traffic_annotation), mojo::Clone(hashdance_traffic_annotation));
}

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>*> bool SCTAuditingConfiguration::Equals(const T& other_struct) const
{
    if (!mojo::Equals(this->sampling_rate, other_struct.sampling_rate))
        return false;
    if (!mojo::Equals(this->log_expected_ingestion_delay, other_struct.log_expected_ingestion_delay))
        return false;
    if (!mojo::Equals(this->log_max_ingestion_random_delay, other_struct.log_max_ingestion_random_delay))
        return false;
    if (!mojo::Equals(this->report_uri, other_struct.report_uri))
        return false;
    if (!mojo::Equals(this->hashdance_lookup_uri, other_struct.hashdance_lookup_uri))
        return false;
    if (!mojo::Equals(this->traffic_annotation, other_struct.traffic_annotation))
        return false;
    if (!mojo::Equals(this->hashdance_traffic_annotation, other_struct.hashdance_traffic_annotation))
        return false;
    return true;
}

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>*> bool operator<(const T& lhs, const T& rhs)
{
    if (lhs.sampling_rate < rhs.sampling_rate)
        return true;
    if (rhs.sampling_rate < lhs.sampling_rate)
        return false;
    if (lhs.log_expected_ingestion_delay < rhs.log_expected_ingestion_delay)
        return true;
    if (rhs.log_expected_ingestion_delay < lhs.log_expected_ingestion_delay)
        return false;
    if (lhs.log_max_ingestion_random_delay < rhs.log_max_ingestion_random_delay)
        return true;
    if (rhs.log_max_ingestion_random_delay < lhs.log_max_ingestion_random_delay)
        return false;
    if (lhs.report_uri < rhs.report_uri)
        return true;
    if (rhs.report_uri < lhs.report_uri)
        return false;
    if (lhs.hashdance_lookup_uri < rhs.hashdance_lookup_uri)
        return true;
    if (rhs.hashdance_lookup_uri < lhs.hashdance_lookup_uri)
        return false;
    if (lhs.traffic_annotation < rhs.traffic_annotation)
        return true;
    if (rhs.traffic_annotation < lhs.traffic_annotation)
        return false;
    if (lhs.hashdance_traffic_annotation < rhs.hashdance_traffic_annotation)
        return true;
    if (rhs.hashdance_traffic_annotation < lhs.hashdance_traffic_annotation)
        return false;
    return false;
}

} // network::mojom::blink

namespace mojo {

template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::HttpAuthStaticParams::DataView, ::network::mojom::blink::HttpAuthStaticParamsPtr> {
    static bool IsNull(const ::network::mojom::blink::HttpAuthStaticParamsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::blink::HttpAuthStaticParamsPtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::blink::HttpAuthStaticParams::gssapi_library_name)& gssapi_library_name(
        const ::network::mojom::blink::HttpAuthStaticParamsPtr& input)
    {
        return input->gssapi_library_name;
    }

    static bool Read(::network::mojom::blink::HttpAuthStaticParams::DataView input, ::network::mojom::blink::HttpAuthStaticParamsPtr* output);
};

template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::HttpAuthDynamicParams::DataView, ::network::mojom::blink::HttpAuthDynamicParamsPtr> {
    static bool IsNull(const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::blink::HttpAuthDynamicParamsPtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::blink::HttpAuthDynamicParams::allowed_schemes)& allowed_schemes(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->allowed_schemes;
    }

    static const decltype(::network::mojom::blink::HttpAuthDynamicParams::patterns_allowed_to_use_all_schemes)& patterns_allowed_to_use_all_schemes(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->patterns_allowed_to_use_all_schemes;
    }

    static const decltype(::network::mojom::blink::HttpAuthDynamicParams::server_allowlist)& server_allowlist(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->server_allowlist;
    }

    static const decltype(::network::mojom::blink::HttpAuthDynamicParams::delegate_allowlist)& delegate_allowlist(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->delegate_allowlist;
    }

    static decltype(::network::mojom::blink::HttpAuthDynamicParams::delegate_by_kdc_policy) delegate_by_kdc_policy(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->delegate_by_kdc_policy;
    }

    static decltype(::network::mojom::blink::HttpAuthDynamicParams::negotiate_disable_cname_lookup) negotiate_disable_cname_lookup(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->negotiate_disable_cname_lookup;
    }

    static decltype(::network::mojom::blink::HttpAuthDynamicParams::enable_negotiate_port) enable_negotiate_port(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->enable_negotiate_port;
    }

    static decltype(::network::mojom::blink::HttpAuthDynamicParams::ntlm_v2_enabled) ntlm_v2_enabled(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->ntlm_v2_enabled;
    }

    static const decltype(::network::mojom::blink::HttpAuthDynamicParams::android_negotiate_account_type)& android_negotiate_account_type(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->android_negotiate_account_type;
    }

    static decltype(::network::mojom::blink::HttpAuthDynamicParams::allow_gssapi_library_load) allow_gssapi_library_load(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->allow_gssapi_library_load;
    }

    static decltype(::network::mojom::blink::HttpAuthDynamicParams::basic_over_http_enabled) basic_over_http_enabled(
        const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input)
    {
        return input->basic_over_http_enabled;
    }

    static bool Read(::network::mojom::blink::HttpAuthDynamicParams::DataView input, ::network::mojom::blink::HttpAuthDynamicParamsPtr* output);
};

template <> struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::EnvironmentVariable::DataView, ::network::mojom::blink::EnvironmentVariablePtr> {
    static bool IsNull(const ::network::mojom::blink::EnvironmentVariablePtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::blink::EnvironmentVariablePtr* output)
    {
        output->reset();
    }

    static const decltype(::network::mojom::blink::EnvironmentVariable::name)& name(const ::network::mojom::blink::EnvironmentVariablePtr& input)
    {
        return input->name;
    }

    static const decltype(::network::mojom::blink::EnvironmentVariable::value)& value(const ::network::mojom::blink::EnvironmentVariablePtr& input)
    {
        return input->value;
    }

    static bool Read(::network::mojom::blink::EnvironmentVariable::DataView input, ::network::mojom::blink::EnvironmentVariablePtr* output);
};

template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::NetworkServiceParams::DataView, ::network::mojom::blink::NetworkServiceParamsPtr> {
    static bool IsNull(const ::network::mojom::blink::NetworkServiceParamsPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::blink::NetworkServiceParamsPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::blink::NetworkServiceParams::initial_connection_type) initial_connection_type(
        const ::network::mojom::blink::NetworkServiceParamsPtr& input)
    {
        return input->initial_connection_type;
    }

    static decltype(::network::mojom::blink::NetworkServiceParams::initial_connection_subtype) initial_connection_subtype(
        const ::network::mojom::blink::NetworkServiceParamsPtr& input)
    {
        return input->initial_connection_subtype;
    }

    static const decltype(::network::mojom::blink::NetworkServiceParams::environment)& environment(
        const ::network::mojom::blink::NetworkServiceParamsPtr& input)
    {
        return input->environment;
    }

    static decltype(::network::mojom::blink::NetworkServiceParams::default_observer)& default_observer(::network::mojom::blink::NetworkServiceParamsPtr& input)
    {
        return input->default_observer;
    }

    static decltype(::network::mojom::blink::NetworkServiceParams::first_party_sets_enabled) first_party_sets_enabled(
        const ::network::mojom::blink::NetworkServiceParamsPtr& input)
    {
        return input->first_party_sets_enabled;
    }

    static decltype(::network::mojom::blink::NetworkServiceParams::system_dns_resolver)& system_dns_resolver(
        ::network::mojom::blink::NetworkServiceParamsPtr& input)
    {
        return input->system_dns_resolver;
    }

    static decltype(::network::mojom::blink::NetworkServiceParams::ip_protection_proxy_bypass_policy) ip_protection_proxy_bypass_policy(
        const ::network::mojom::blink::NetworkServiceParamsPtr& input)
    {
        return input->ip_protection_proxy_bypass_policy;
    }

    static bool Read(::network::mojom::blink::NetworkServiceParams::DataView input, ::network::mojom::blink::NetworkServiceParamsPtr* output);
};

template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::SCTAuditingConfiguration::DataView, ::network::mojom::blink::SCTAuditingConfigurationPtr> {
    static bool IsNull(const ::network::mojom::blink::SCTAuditingConfigurationPtr& input)
    {
        return !input;
    }
    static void SetToNull(::network::mojom::blink::SCTAuditingConfigurationPtr* output)
    {
        output->reset();
    }

    static decltype(::network::mojom::blink::SCTAuditingConfiguration::sampling_rate) sampling_rate(
        const ::network::mojom::blink::SCTAuditingConfigurationPtr& input)
    {
        return input->sampling_rate;
    }

    static const decltype(::network::mojom::blink::SCTAuditingConfiguration::log_expected_ingestion_delay)& log_expected_ingestion_delay(
        const ::network::mojom::blink::SCTAuditingConfigurationPtr& input)
    {
        return input->log_expected_ingestion_delay;
    }

    static const decltype(::network::mojom::blink::SCTAuditingConfiguration::log_max_ingestion_random_delay)& log_max_ingestion_random_delay(
        const ::network::mojom::blink::SCTAuditingConfigurationPtr& input)
    {
        return input->log_max_ingestion_random_delay;
    }

    static const decltype(::network::mojom::blink::SCTAuditingConfiguration::report_uri)& report_uri(
        const ::network::mojom::blink::SCTAuditingConfigurationPtr& input)
    {
        return input->report_uri;
    }

    static const decltype(::network::mojom::blink::SCTAuditingConfiguration::hashdance_lookup_uri)& hashdance_lookup_uri(
        const ::network::mojom::blink::SCTAuditingConfigurationPtr& input)
    {
        return input->hashdance_lookup_uri;
    }

    static const decltype(::network::mojom::blink::SCTAuditingConfiguration::traffic_annotation)& traffic_annotation(
        const ::network::mojom::blink::SCTAuditingConfigurationPtr& input)
    {
        return input->traffic_annotation;
    }

    static const decltype(::network::mojom::blink::SCTAuditingConfiguration::hashdance_traffic_annotation)& hashdance_traffic_annotation(
        const ::network::mojom::blink::SCTAuditingConfigurationPtr& input)
    {
        return input->hashdance_traffic_annotation;
    }

    static bool Read(::network::mojom::blink::SCTAuditingConfiguration::DataView input, ::network::mojom::blink::SCTAuditingConfigurationPtr* output);
};

} // namespace mojo

#endif // SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_MOJOM_BLINK_H_
