// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: quiche/blind_sign_auth/proto/get_initial_data.proto

#include "quiche/blind_sign_auth/proto/get_initial_data.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace privacy {
namespace ppn {
PROTOBUF_CONSTEXPR GetInitialDataRequest::GetInitialDataRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.service_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.use_attestation_)*/ false, /*decltype(_impl_.location_granularity_)*/ 0, /*decltype(_impl_.validation_version_)*/ int64_t { 0 },
        /*decltype(_impl_.proxy_layer_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct GetInitialDataRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetInitialDataRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetInitialDataRequestDefaultTypeInternal()
    {
    }
    union {
        GetInitialDataRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetInitialDataRequestDefaultTypeInternal
    _GetInitialDataRequest_default_instance_;
PROTOBUF_CONSTEXPR GetInitialDataResponse_PrivacyPassData::GetInitialDataResponse_PrivacyPassData(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.token_key_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.public_metadata_extensions_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct GetInitialDataResponse_PrivacyPassDataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetInitialDataResponse_PrivacyPassDataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetInitialDataResponse_PrivacyPassDataDefaultTypeInternal()
    {
    }
    union {
        GetInitialDataResponse_PrivacyPassData _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetInitialDataResponse_PrivacyPassDataDefaultTypeInternal
    _GetInitialDataResponse_PrivacyPassData_default_instance_;
PROTOBUF_CONSTEXPR GetInitialDataResponse::GetInitialDataResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.at_public_metadata_public_key_)*/ nullptr, /*decltype(_impl_.public_metadata_info_)*/ nullptr,
        /*decltype(_impl_.attestation_)*/ nullptr, /*decltype(_impl_.privacy_pass_data_)*/ nullptr, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct GetInitialDataResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR GetInitialDataResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~GetInitialDataResponseDefaultTypeInternal()
    {
    }
    union {
        GetInitialDataResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetInitialDataResponseDefaultTypeInternal
    _GetInitialDataResponse_default_instance_;
} // namespace ppn
} // namespace privacy
namespace privacy {
namespace ppn {
bool GetInitialDataRequest_LocationGranularity_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
    case 2:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GetInitialDataRequest_LocationGranularity_strings[3] = {};

static const char GetInitialDataRequest_LocationGranularity_names[] = "CITY_GEOS"
                                                                      "COUNTRY"
                                                                      "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GetInitialDataRequest_LocationGranularity_entries[] = {
    { { GetInitialDataRequest_LocationGranularity_names + 0, 9 }, 2 },
    { { GetInitialDataRequest_LocationGranularity_names + 9, 7 }, 1 },
    { { GetInitialDataRequest_LocationGranularity_names + 16, 7 }, 0 },
};

static const int GetInitialDataRequest_LocationGranularity_entries_by_number[] = {
    2, // 0 -> UNKNOWN
    1, // 1 -> COUNTRY
    0, // 2 -> CITY_GEOS
};

const std::string& GetInitialDataRequest_LocationGranularity_Name(GetInitialDataRequest_LocationGranularity value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(GetInitialDataRequest_LocationGranularity_entries,
        GetInitialDataRequest_LocationGranularity_entries_by_number, 3, GetInitialDataRequest_LocationGranularity_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
        GetInitialDataRequest_LocationGranularity_entries, GetInitialDataRequest_LocationGranularity_entries_by_number, 3, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : GetInitialDataRequest_LocationGranularity_strings[idx].get();
}
bool GetInitialDataRequest_LocationGranularity_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetInitialDataRequest_LocationGranularity* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(GetInitialDataRequest_LocationGranularity_entries, 3, name, &int_value);
    if (success) {
        *value = static_cast<GetInitialDataRequest_LocationGranularity>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr GetInitialDataRequest_LocationGranularity GetInitialDataRequest::UNKNOWN;
constexpr GetInitialDataRequest_LocationGranularity GetInitialDataRequest::COUNTRY;
constexpr GetInitialDataRequest_LocationGranularity GetInitialDataRequest::CITY_GEOS;
constexpr GetInitialDataRequest_LocationGranularity GetInitialDataRequest::LocationGranularity_MIN;
constexpr GetInitialDataRequest_LocationGranularity GetInitialDataRequest::LocationGranularity_MAX;
constexpr int GetInitialDataRequest::LocationGranularity_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class GetInitialDataRequest::_Internal {
public:
};

GetInitialDataRequest::GetInitialDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:privacy.ppn.GetInitialDataRequest)
}
GetInitialDataRequest::GetInitialDataRequest(const GetInitialDataRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetInitialDataRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.service_type_) {}, decltype(_impl_.use_attestation_) {}, decltype(_impl_.location_granularity_) {},
        decltype(_impl_.validation_version_) {}, decltype(_impl_.proxy_layer_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.service_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_service_type().empty()) {
        _this->_impl_.service_type_.Set(from._internal_service_type(), _this->GetArenaForAllocation());
    }
    ::memcpy(&_impl_.use_attestation_, &from._impl_.use_attestation_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.proxy_layer_) - reinterpret_cast<char*>(&_impl_.use_attestation_)) + sizeof(_impl_.proxy_layer_));
    // @@protoc_insertion_point(copy_constructor:privacy.ppn.GetInitialDataRequest)
}

inline void GetInitialDataRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.service_type_) {}, decltype(_impl_.use_attestation_) { false }, decltype(_impl_.location_granularity_) { 0 },
        decltype(_impl_.validation_version_) { int64_t { 0 } }, decltype(_impl_.proxy_layer_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.service_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetInitialDataRequest::~GetInitialDataRequest()
{
    // @@protoc_insertion_point(destructor:privacy.ppn.GetInitialDataRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetInitialDataRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.service_type_.Destroy();
}

void GetInitialDataRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetInitialDataRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:privacy.ppn.GetInitialDataRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.service_type_.ClearToEmpty();
    ::memset(&_impl_.use_attestation_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.proxy_layer_) - reinterpret_cast<char*>(&_impl_.use_attestation_)) + sizeof(_impl_.proxy_layer_));
    _internal_metadata_.Clear<std::string>();
}

const char* GetInitialDataRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bool use_attestation = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
                _impl_.use_attestation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string service_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_service_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.GetInitialDataRequest.LocationGranularity location_granularity = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_location_granularity(static_cast<::privacy::ppn::GetInitialDataRequest_LocationGranularity>(val));
            } else
                goto handle_unusual;
            continue;
        // int64 validation_version = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                _impl_.validation_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.ProxyLayer proxy_layer = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_proxy_layer(static_cast<::privacy::ppn::ProxyLayer>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetInitialDataRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:privacy.ppn.GetInitialDataRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bool use_attestation = 1;
    if (this->_internal_use_attestation() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_use_attestation(), target);
    }

    // string service_type = 2;
    if (!this->_internal_service_type().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_service_type().data(),
            static_cast<int>(this->_internal_service_type().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.GetInitialDataRequest.service_type");
        target = stream->WriteStringMaybeAliased(2, this->_internal_service_type(), target);
    }

    // .privacy.ppn.GetInitialDataRequest.LocationGranularity location_granularity = 3;
    if (this->_internal_location_granularity() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(3, this->_internal_location_granularity(), target);
    }

    // int64 validation_version = 4;
    if (this->_internal_validation_version() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_validation_version(), target);
    }

    // .privacy.ppn.ProxyLayer proxy_layer = 5;
    if (this->_internal_proxy_layer() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(5, this->_internal_proxy_layer(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:privacy.ppn.GetInitialDataRequest)
    return target;
}

size_t GetInitialDataRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:privacy.ppn.GetInitialDataRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string service_type = 2;
    if (!this->_internal_service_type().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_service_type());
    }

    // bool use_attestation = 1;
    if (this->_internal_use_attestation() != 0) {
        total_size += 1 + 1;
    }

    // .privacy.ppn.GetInitialDataRequest.LocationGranularity location_granularity = 3;
    if (this->_internal_location_granularity() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_location_granularity());
    }

    // int64 validation_version = 4;
    if (this->_internal_validation_version() != 0) {
        total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_validation_version());
    }

    // .privacy.ppn.ProxyLayer proxy_layer = 5;
    if (this->_internal_proxy_layer() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_proxy_layer());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetInitialDataRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetInitialDataRequest*>(&from));
}

void GetInitialDataRequest::MergeFrom(const GetInitialDataRequest& from)
{
    GetInitialDataRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:privacy.ppn.GetInitialDataRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_service_type().empty()) {
        _this->_internal_set_service_type(from._internal_service_type());
    }
    if (from._internal_use_attestation() != 0) {
        _this->_internal_set_use_attestation(from._internal_use_attestation());
    }
    if (from._internal_location_granularity() != 0) {
        _this->_internal_set_location_granularity(from._internal_location_granularity());
    }
    if (from._internal_validation_version() != 0) {
        _this->_internal_set_validation_version(from._internal_validation_version());
    }
    if (from._internal_proxy_layer() != 0) {
        _this->_internal_set_proxy_layer(from._internal_proxy_layer());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetInitialDataRequest::CopyFrom(const GetInitialDataRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:privacy.ppn.GetInitialDataRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetInitialDataRequest::IsInitialized() const
{
    return true;
}

void GetInitialDataRequest::InternalSwap(GetInitialDataRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.service_type_, lhs_arena, &other->_impl_.service_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(GetInitialDataRequest, _impl_.proxy_layer_)
        + sizeof(GetInitialDataRequest::_impl_.proxy_layer_) - PROTOBUF_FIELD_OFFSET(GetInitialDataRequest, _impl_.use_attestation_)>(
        reinterpret_cast<char*>(&_impl_.use_attestation_), reinterpret_cast<char*>(&other->_impl_.use_attestation_));
}

std::string GetInitialDataRequest::GetTypeName() const
{
    return "privacy.ppn.GetInitialDataRequest";
}

// ===================================================================

class GetInitialDataResponse_PrivacyPassData::_Internal {
public:
};

GetInitialDataResponse_PrivacyPassData::GetInitialDataResponse_PrivacyPassData(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
}
GetInitialDataResponse_PrivacyPassData::GetInitialDataResponse_PrivacyPassData(const GetInitialDataResponse_PrivacyPassData& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetInitialDataResponse_PrivacyPassData* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.token_key_id_) {}, decltype(_impl_.public_metadata_extensions_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.token_key_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_key_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_token_key_id().empty()) {
        _this->_impl_.token_key_id_.Set(from._internal_token_key_id(), _this->GetArenaForAllocation());
    }
    _impl_.public_metadata_extensions_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_metadata_extensions_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_public_metadata_extensions().empty()) {
        _this->_impl_.public_metadata_extensions_.Set(from._internal_public_metadata_extensions(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
}

inline void GetInitialDataResponse_PrivacyPassData::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.token_key_id_) {}, decltype(_impl_.public_metadata_extensions_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.token_key_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_key_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_metadata_extensions_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_metadata_extensions_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetInitialDataResponse_PrivacyPassData::~GetInitialDataResponse_PrivacyPassData()
{
    // @@protoc_insertion_point(destructor:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetInitialDataResponse_PrivacyPassData::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.token_key_id_.Destroy();
    _impl_.public_metadata_extensions_.Destroy();
}

void GetInitialDataResponse_PrivacyPassData::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetInitialDataResponse_PrivacyPassData::Clear()
{
    // @@protoc_insertion_point(message_clear_start:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.token_key_id_.ClearToEmpty();
    _impl_.public_metadata_extensions_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* GetInitialDataResponse_PrivacyPassData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // bytes token_key_id = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_token_key_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes public_metadata_extensions = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_public_metadata_extensions();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetInitialDataResponse_PrivacyPassData::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // bytes token_key_id = 1;
    if (!this->_internal_token_key_id().empty()) {
        target = stream->WriteBytesMaybeAliased(1, this->_internal_token_key_id(), target);
    }

    // bytes public_metadata_extensions = 2;
    if (!this->_internal_public_metadata_extensions().empty()) {
        target = stream->WriteBytesMaybeAliased(2, this->_internal_public_metadata_extensions(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
    return target;
}

size_t GetInitialDataResponse_PrivacyPassData::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // bytes token_key_id = 1;
    if (!this->_internal_token_key_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_token_key_id());
    }

    // bytes public_metadata_extensions = 2;
    if (!this->_internal_public_metadata_extensions().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_public_metadata_extensions());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetInitialDataResponse_PrivacyPassData::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetInitialDataResponse_PrivacyPassData*>(&from));
}

void GetInitialDataResponse_PrivacyPassData::MergeFrom(const GetInitialDataResponse_PrivacyPassData& from)
{
    GetInitialDataResponse_PrivacyPassData* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_token_key_id().empty()) {
        _this->_internal_set_token_key_id(from._internal_token_key_id());
    }
    if (!from._internal_public_metadata_extensions().empty()) {
        _this->_internal_set_public_metadata_extensions(from._internal_public_metadata_extensions());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetInitialDataResponse_PrivacyPassData::CopyFrom(const GetInitialDataResponse_PrivacyPassData& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:privacy.ppn.GetInitialDataResponse.PrivacyPassData)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetInitialDataResponse_PrivacyPassData::IsInitialized() const
{
    return true;
}

void GetInitialDataResponse_PrivacyPassData::InternalSwap(GetInitialDataResponse_PrivacyPassData* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.token_key_id_, lhs_arena, &other->_impl_.token_key_id_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.public_metadata_extensions_, lhs_arena, &other->_impl_.public_metadata_extensions_, rhs_arena);
}

std::string GetInitialDataResponse_PrivacyPassData::GetTypeName() const
{
    return "privacy.ppn.GetInitialDataResponse.PrivacyPassData";
}

// ===================================================================

class GetInitialDataResponse::_Internal {
public:
    static const ::anonymous_tokens::RSABlindSignaturePublicKey& at_public_metadata_public_key(const GetInitialDataResponse* msg);
    static const ::privacy::ppn::PublicMetadataInfo& public_metadata_info(const GetInitialDataResponse* msg);
    static const ::privacy::ppn::PrepareAttestationData& attestation(const GetInitialDataResponse* msg);
    static const ::privacy::ppn::GetInitialDataResponse_PrivacyPassData& privacy_pass_data(const GetInitialDataResponse* msg);
};

const ::anonymous_tokens::RSABlindSignaturePublicKey& GetInitialDataResponse::_Internal::at_public_metadata_public_key(const GetInitialDataResponse* msg)
{
    return *msg->_impl_.at_public_metadata_public_key_;
}
const ::privacy::ppn::PublicMetadataInfo& GetInitialDataResponse::_Internal::public_metadata_info(const GetInitialDataResponse* msg)
{
    return *msg->_impl_.public_metadata_info_;
}
const ::privacy::ppn::PrepareAttestationData& GetInitialDataResponse::_Internal::attestation(const GetInitialDataResponse* msg)
{
    return *msg->_impl_.attestation_;
}
const ::privacy::ppn::GetInitialDataResponse_PrivacyPassData& GetInitialDataResponse::_Internal::privacy_pass_data(const GetInitialDataResponse* msg)
{
    return *msg->_impl_.privacy_pass_data_;
}
void GetInitialDataResponse::clear_at_public_metadata_public_key()
{
    if (GetArenaForAllocation() == nullptr && _impl_.at_public_metadata_public_key_ != nullptr) {
        delete _impl_.at_public_metadata_public_key_;
    }
    _impl_.at_public_metadata_public_key_ = nullptr;
}
void GetInitialDataResponse::clear_public_metadata_info()
{
    if (GetArenaForAllocation() == nullptr && _impl_.public_metadata_info_ != nullptr) {
        delete _impl_.public_metadata_info_;
    }
    _impl_.public_metadata_info_ = nullptr;
}
void GetInitialDataResponse::clear_attestation()
{
    if (GetArenaForAllocation() == nullptr && _impl_.attestation_ != nullptr) {
        delete _impl_.attestation_;
    }
    _impl_.attestation_ = nullptr;
}
GetInitialDataResponse::GetInitialDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:privacy.ppn.GetInitialDataResponse)
}
GetInitialDataResponse::GetInitialDataResponse(const GetInitialDataResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    GetInitialDataResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.at_public_metadata_public_key_) { nullptr }, decltype(_impl_.public_metadata_info_) { nullptr },
        decltype(_impl_.attestation_) { nullptr }, decltype(_impl_.privacy_pass_data_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_at_public_metadata_public_key()) {
        _this->_impl_.at_public_metadata_public_key_ = new ::anonymous_tokens::RSABlindSignaturePublicKey(*from._impl_.at_public_metadata_public_key_);
    }
    if (from._internal_has_public_metadata_info()) {
        _this->_impl_.public_metadata_info_ = new ::privacy::ppn::PublicMetadataInfo(*from._impl_.public_metadata_info_);
    }
    if (from._internal_has_attestation()) {
        _this->_impl_.attestation_ = new ::privacy::ppn::PrepareAttestationData(*from._impl_.attestation_);
    }
    if (from._internal_has_privacy_pass_data()) {
        _this->_impl_.privacy_pass_data_ = new ::privacy::ppn::GetInitialDataResponse_PrivacyPassData(*from._impl_.privacy_pass_data_);
    }
    // @@protoc_insertion_point(copy_constructor:privacy.ppn.GetInitialDataResponse)
}

inline void GetInitialDataResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.at_public_metadata_public_key_) { nullptr }, decltype(_impl_.public_metadata_info_) { nullptr },
        decltype(_impl_.attestation_) { nullptr }, decltype(_impl_.privacy_pass_data_) { nullptr }, /*decltype(_impl_._cached_size_)*/ {} };
}

GetInitialDataResponse::~GetInitialDataResponse()
{
    // @@protoc_insertion_point(destructor:privacy.ppn.GetInitialDataResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void GetInitialDataResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.at_public_metadata_public_key_;
    if (this != internal_default_instance())
        delete _impl_.public_metadata_info_;
    if (this != internal_default_instance())
        delete _impl_.attestation_;
    if (this != internal_default_instance())
        delete _impl_.privacy_pass_data_;
}

void GetInitialDataResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void GetInitialDataResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:privacy.ppn.GetInitialDataResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.at_public_metadata_public_key_ != nullptr) {
        delete _impl_.at_public_metadata_public_key_;
    }
    _impl_.at_public_metadata_public_key_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.public_metadata_info_ != nullptr) {
        delete _impl_.public_metadata_info_;
    }
    _impl_.public_metadata_info_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.attestation_ != nullptr) {
        delete _impl_.attestation_;
    }
    _impl_.attestation_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.privacy_pass_data_ != nullptr) {
        delete _impl_.privacy_pass_data_;
    }
    _impl_.privacy_pass_data_ = nullptr;
    _internal_metadata_.Clear<std::string>();
}

const char* GetInitialDataResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .anonymous_tokens.RSABlindSignaturePublicKey at_public_metadata_public_key = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_at_public_metadata_public_key(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.PublicMetadataInfo public_metadata_info = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                ptr = ctx->ParseMessage(_internal_mutable_public_metadata_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.PrepareAttestationData attestation = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_attestation(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.GetInitialDataResponse.PrivacyPassData privacy_pass_data = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                ptr = ctx->ParseMessage(_internal_mutable_privacy_pass_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* GetInitialDataResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:privacy.ppn.GetInitialDataResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .anonymous_tokens.RSABlindSignaturePublicKey at_public_metadata_public_key = 1;
    if (this->_internal_has_at_public_metadata_public_key()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::at_public_metadata_public_key(this), _Internal::at_public_metadata_public_key(this).GetCachedSize(), target, stream);
    }

    // .privacy.ppn.PublicMetadataInfo public_metadata_info = 2;
    if (this->_internal_has_public_metadata_info()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            2, _Internal::public_metadata_info(this), _Internal::public_metadata_info(this).GetCachedSize(), target, stream);
    }

    // .privacy.ppn.PrepareAttestationData attestation = 3;
    if (this->_internal_has_attestation()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::attestation(this), _Internal::attestation(this).GetCachedSize(), target, stream);
    }

    // .privacy.ppn.GetInitialDataResponse.PrivacyPassData privacy_pass_data = 5;
    if (this->_internal_has_privacy_pass_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            5, _Internal::privacy_pass_data(this), _Internal::privacy_pass_data(this).GetCachedSize(), target, stream);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:privacy.ppn.GetInitialDataResponse)
    return target;
}

size_t GetInitialDataResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:privacy.ppn.GetInitialDataResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .anonymous_tokens.RSABlindSignaturePublicKey at_public_metadata_public_key = 1;
    if (this->_internal_has_at_public_metadata_public_key()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.at_public_metadata_public_key_);
    }

    // .privacy.ppn.PublicMetadataInfo public_metadata_info = 2;
    if (this->_internal_has_public_metadata_info()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.public_metadata_info_);
    }

    // .privacy.ppn.PrepareAttestationData attestation = 3;
    if (this->_internal_has_attestation()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.attestation_);
    }

    // .privacy.ppn.GetInitialDataResponse.PrivacyPassData privacy_pass_data = 5;
    if (this->_internal_has_privacy_pass_data()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.privacy_pass_data_);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void GetInitialDataResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const GetInitialDataResponse*>(&from));
}

void GetInitialDataResponse::MergeFrom(const GetInitialDataResponse& from)
{
    GetInitialDataResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:privacy.ppn.GetInitialDataResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_at_public_metadata_public_key()) {
        _this->_internal_mutable_at_public_metadata_public_key()->::anonymous_tokens::RSABlindSignaturePublicKey::MergeFrom(
            from._internal_at_public_metadata_public_key());
    }
    if (from._internal_has_public_metadata_info()) {
        _this->_internal_mutable_public_metadata_info()->::privacy::ppn::PublicMetadataInfo::MergeFrom(from._internal_public_metadata_info());
    }
    if (from._internal_has_attestation()) {
        _this->_internal_mutable_attestation()->::privacy::ppn::PrepareAttestationData::MergeFrom(from._internal_attestation());
    }
    if (from._internal_has_privacy_pass_data()) {
        _this->_internal_mutable_privacy_pass_data()->::privacy::ppn::GetInitialDataResponse_PrivacyPassData::MergeFrom(from._internal_privacy_pass_data());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetInitialDataResponse::CopyFrom(const GetInitialDataResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:privacy.ppn.GetInitialDataResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool GetInitialDataResponse::IsInitialized() const
{
    return true;
}

void GetInitialDataResponse::InternalSwap(GetInitialDataResponse* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(GetInitialDataResponse, _impl_.privacy_pass_data_)
        + sizeof(GetInitialDataResponse::_impl_.privacy_pass_data_) - PROTOBUF_FIELD_OFFSET(GetInitialDataResponse, _impl_.at_public_metadata_public_key_)>(
        reinterpret_cast<char*>(&_impl_.at_public_metadata_public_key_), reinterpret_cast<char*>(&other->_impl_.at_public_metadata_public_key_));
}

std::string GetInitialDataResponse::GetTypeName() const
{
    return "privacy.ppn.GetInitialDataResponse";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace ppn
} // namespace privacy
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::privacy::ppn::GetInitialDataRequest* Arena::CreateMaybeMessage<::privacy::ppn::GetInitialDataRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::privacy::ppn::GetInitialDataRequest>(arena);
}
template <>
PROTOBUF_NOINLINE ::privacy::ppn::GetInitialDataResponse_PrivacyPassData* Arena::CreateMaybeMessage<::privacy::ppn::GetInitialDataResponse_PrivacyPassData>(
    Arena* arena)
{
    return Arena::CreateMessageInternal<::privacy::ppn::GetInitialDataResponse_PrivacyPassData>(arena);
}
template <> PROTOBUF_NOINLINE ::privacy::ppn::GetInitialDataResponse* Arena::CreateMaybeMessage<::privacy::ppn::GetInitialDataResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::privacy::ppn::GetInitialDataResponse>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
