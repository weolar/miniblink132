// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: quiche/blind_sign_auth/proto/public_metadata.proto

#include "quiche/blind_sign_auth/proto/public_metadata.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace privacy {
namespace ppn {
PROTOBUF_CONSTEXPR PublicMetadata_Location::PublicMetadata_Location(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.country_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.city_geo_id_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PublicMetadata_LocationDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PublicMetadata_LocationDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PublicMetadata_LocationDefaultTypeInternal()
    {
    }
    union {
        PublicMetadata_Location _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicMetadata_LocationDefaultTypeInternal
    _PublicMetadata_Location_default_instance_;
PROTOBUF_CONSTEXPR PublicMetadata::PublicMetadata(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.service_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.exit_location_)*/ nullptr, /*decltype(_impl_.expiration_)*/ nullptr, /*decltype(_impl_.debug_mode_)*/ 0,
        /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PublicMetadataDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PublicMetadataDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PublicMetadataDefaultTypeInternal()
    {
    }
    union {
        PublicMetadata _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicMetadataDefaultTypeInternal _PublicMetadata_default_instance_;
PROTOBUF_CONSTEXPR PublicMetadataInfo::PublicMetadataInfo(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.public_metadata_)*/ nullptr, /*decltype(_impl_.validation_version_)*/ 0, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct PublicMetadataInfoDefaultTypeInternal {
    PROTOBUF_CONSTEXPR PublicMetadataInfoDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~PublicMetadataInfoDefaultTypeInternal()
    {
    }
    union {
        PublicMetadataInfo _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PublicMetadataInfoDefaultTypeInternal _PublicMetadataInfo_default_instance_;
} // namespace ppn
} // namespace privacy
namespace privacy {
namespace ppn {
bool PublicMetadata_DebugMode_IsValid(int value)
{
    switch (value) {
    case 0:
    case 1:
        return true;
    default:
        return false;
    }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> PublicMetadata_DebugMode_strings[2] = {};

static const char PublicMetadata_DebugMode_names[] = "DEBUG_ALL"
                                                     "UNSPECIFIED_DEBUG_MODE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry PublicMetadata_DebugMode_entries[] = {
    { { PublicMetadata_DebugMode_names + 0, 9 }, 1 },
    { { PublicMetadata_DebugMode_names + 9, 22 }, 0 },
};

static const int PublicMetadata_DebugMode_entries_by_number[] = {
    1, // 0 -> UNSPECIFIED_DEBUG_MODE
    0, // 1 -> DEBUG_ALL
};

const std::string& PublicMetadata_DebugMode_Name(PublicMetadata_DebugMode value)
{
    static const bool dummy = ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
        PublicMetadata_DebugMode_entries, PublicMetadata_DebugMode_entries_by_number, 2, PublicMetadata_DebugMode_strings);
    (void)dummy;
    int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(PublicMetadata_DebugMode_entries, PublicMetadata_DebugMode_entries_by_number, 2, value);
    return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() : PublicMetadata_DebugMode_strings[idx].get();
}
bool PublicMetadata_DebugMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PublicMetadata_DebugMode* value)
{
    int int_value;
    bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(PublicMetadata_DebugMode_entries, 2, name, &int_value);
    if (success) {
        *value = static_cast<PublicMetadata_DebugMode>(int_value);
    }
    return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PublicMetadata_DebugMode PublicMetadata::UNSPECIFIED_DEBUG_MODE;
constexpr PublicMetadata_DebugMode PublicMetadata::DEBUG_ALL;
constexpr PublicMetadata_DebugMode PublicMetadata::DebugMode_MIN;
constexpr PublicMetadata_DebugMode PublicMetadata::DebugMode_MAX;
constexpr int PublicMetadata::DebugMode_ARRAYSIZE;
#endif // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class PublicMetadata_Location::_Internal {
public:
};

PublicMetadata_Location::PublicMetadata_Location(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:privacy.ppn.PublicMetadata.Location)
}
PublicMetadata_Location::PublicMetadata_Location(const PublicMetadata_Location& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PublicMetadata_Location* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.country_) {}, decltype(_impl_.city_geo_id_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_country().empty()) {
        _this->_impl_.country_.Set(from._internal_country(), _this->GetArenaForAllocation());
    }
    _impl_.city_geo_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.city_geo_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_city_geo_id().empty()) {
        _this->_impl_.city_geo_id_.Set(from._internal_city_geo_id(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:privacy.ppn.PublicMetadata.Location)
}

inline void PublicMetadata_Location::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.country_) {}, decltype(_impl_.city_geo_id_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.country_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.country_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.city_geo_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.city_geo_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PublicMetadata_Location::~PublicMetadata_Location()
{
    // @@protoc_insertion_point(destructor:privacy.ppn.PublicMetadata.Location)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PublicMetadata_Location::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.country_.Destroy();
    _impl_.city_geo_id_.Destroy();
}

void PublicMetadata_Location::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PublicMetadata_Location::Clear()
{
    // @@protoc_insertion_point(message_clear_start:privacy.ppn.PublicMetadata.Location)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.country_.ClearToEmpty();
    _impl_.city_geo_id_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* PublicMetadata_Location::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string country = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_country();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string city_geo_id = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_city_geo_id();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PublicMetadata_Location::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:privacy.ppn.PublicMetadata.Location)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string country = 1;
    if (!this->_internal_country().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_country().data(),
            static_cast<int>(this->_internal_country().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.PublicMetadata.Location.country");
        target = stream->WriteStringMaybeAliased(1, this->_internal_country(), target);
    }

    // string city_geo_id = 2;
    if (!this->_internal_city_geo_id().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_city_geo_id().data(),
            static_cast<int>(this->_internal_city_geo_id().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.PublicMetadata.Location.city_geo_id");
        target = stream->WriteStringMaybeAliased(2, this->_internal_city_geo_id(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:privacy.ppn.PublicMetadata.Location)
    return target;
}

size_t PublicMetadata_Location::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:privacy.ppn.PublicMetadata.Location)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string country = 1;
    if (!this->_internal_country().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_country());
    }

    // string city_geo_id = 2;
    if (!this->_internal_city_geo_id().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_city_geo_id());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PublicMetadata_Location::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PublicMetadata_Location*>(&from));
}

void PublicMetadata_Location::MergeFrom(const PublicMetadata_Location& from)
{
    PublicMetadata_Location* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:privacy.ppn.PublicMetadata.Location)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_country().empty()) {
        _this->_internal_set_country(from._internal_country());
    }
    if (!from._internal_city_geo_id().empty()) {
        _this->_internal_set_city_geo_id(from._internal_city_geo_id());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PublicMetadata_Location::CopyFrom(const PublicMetadata_Location& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:privacy.ppn.PublicMetadata.Location)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PublicMetadata_Location::IsInitialized() const
{
    return true;
}

void PublicMetadata_Location::InternalSwap(PublicMetadata_Location* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.country_, lhs_arena, &other->_impl_.country_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.city_geo_id_, lhs_arena, &other->_impl_.city_geo_id_, rhs_arena);
}

std::string PublicMetadata_Location::GetTypeName() const
{
    return "privacy.ppn.PublicMetadata.Location";
}

// ===================================================================

class PublicMetadata::_Internal {
public:
    static const ::privacy::ppn::PublicMetadata_Location& exit_location(const PublicMetadata* msg);
    static const ::anonymous_tokens::Timestamp& expiration(const PublicMetadata* msg);
};

const ::privacy::ppn::PublicMetadata_Location& PublicMetadata::_Internal::exit_location(const PublicMetadata* msg)
{
    return *msg->_impl_.exit_location_;
}
const ::anonymous_tokens::Timestamp& PublicMetadata::_Internal::expiration(const PublicMetadata* msg)
{
    return *msg->_impl_.expiration_;
}
void PublicMetadata::clear_expiration()
{
    if (GetArenaForAllocation() == nullptr && _impl_.expiration_ != nullptr) {
        delete _impl_.expiration_;
    }
    _impl_.expiration_ = nullptr;
}
PublicMetadata::PublicMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:privacy.ppn.PublicMetadata)
}
PublicMetadata::PublicMetadata(const PublicMetadata& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PublicMetadata* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.service_type_) {}, decltype(_impl_.exit_location_) { nullptr }, decltype(_impl_.expiration_) { nullptr },
        decltype(_impl_.debug_mode_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.service_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_service_type().empty()) {
        _this->_impl_.service_type_.Set(from._internal_service_type(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_exit_location()) {
        _this->_impl_.exit_location_ = new ::privacy::ppn::PublicMetadata_Location(*from._impl_.exit_location_);
    }
    if (from._internal_has_expiration()) {
        _this->_impl_.expiration_ = new ::anonymous_tokens::Timestamp(*from._impl_.expiration_);
    }
    _this->_impl_.debug_mode_ = from._impl_.debug_mode_;
    // @@protoc_insertion_point(copy_constructor:privacy.ppn.PublicMetadata)
}

inline void PublicMetadata::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.service_type_) {}, decltype(_impl_.exit_location_) { nullptr }, decltype(_impl_.expiration_) { nullptr },
        decltype(_impl_.debug_mode_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.service_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PublicMetadata::~PublicMetadata()
{
    // @@protoc_insertion_point(destructor:privacy.ppn.PublicMetadata)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PublicMetadata::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.service_type_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.exit_location_;
    if (this != internal_default_instance())
        delete _impl_.expiration_;
}

void PublicMetadata::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PublicMetadata::Clear()
{
    // @@protoc_insertion_point(message_clear_start:privacy.ppn.PublicMetadata)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.service_type_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.exit_location_ != nullptr) {
        delete _impl_.exit_location_;
    }
    _impl_.exit_location_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.expiration_ != nullptr) {
        delete _impl_.expiration_;
    }
    _impl_.expiration_ = nullptr;
    _impl_.debug_mode_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* PublicMetadata::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .privacy.ppn.PublicMetadata.Location exit_location = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_exit_location(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // string service_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_service_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .anonymous_tokens.Timestamp expiration = 3;
        case 3:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
                ptr = ctx->ParseMessage(_internal_mutable_expiration(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.PublicMetadata.DebugMode debug_mode = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_debug_mode(static_cast<::privacy::ppn::PublicMetadata_DebugMode>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PublicMetadata::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:privacy.ppn.PublicMetadata)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .privacy.ppn.PublicMetadata.Location exit_location = 1;
    if (this->_internal_has_exit_location()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::exit_location(this), _Internal::exit_location(this).GetCachedSize(), target, stream);
    }

    // string service_type = 2;
    if (!this->_internal_service_type().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_service_type().data(),
            static_cast<int>(this->_internal_service_type().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.PublicMetadata.service_type");
        target = stream->WriteStringMaybeAliased(2, this->_internal_service_type(), target);
    }

    // .anonymous_tokens.Timestamp expiration = 3;
    if (this->_internal_has_expiration()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            3, _Internal::expiration(this), _Internal::expiration(this).GetCachedSize(), target, stream);
    }

    // .privacy.ppn.PublicMetadata.DebugMode debug_mode = 4;
    if (this->_internal_debug_mode() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(4, this->_internal_debug_mode(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:privacy.ppn.PublicMetadata)
    return target;
}

size_t PublicMetadata::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:privacy.ppn.PublicMetadata)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // string service_type = 2;
    if (!this->_internal_service_type().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_service_type());
    }

    // .privacy.ppn.PublicMetadata.Location exit_location = 1;
    if (this->_internal_has_exit_location()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.exit_location_);
    }

    // .anonymous_tokens.Timestamp expiration = 3;
    if (this->_internal_has_expiration()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.expiration_);
    }

    // .privacy.ppn.PublicMetadata.DebugMode debug_mode = 4;
    if (this->_internal_debug_mode() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_debug_mode());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PublicMetadata::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PublicMetadata*>(&from));
}

void PublicMetadata::MergeFrom(const PublicMetadata& from)
{
    PublicMetadata* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:privacy.ppn.PublicMetadata)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (!from._internal_service_type().empty()) {
        _this->_internal_set_service_type(from._internal_service_type());
    }
    if (from._internal_has_exit_location()) {
        _this->_internal_mutable_exit_location()->::privacy::ppn::PublicMetadata_Location::MergeFrom(from._internal_exit_location());
    }
    if (from._internal_has_expiration()) {
        _this->_internal_mutable_expiration()->::anonymous_tokens::Timestamp::MergeFrom(from._internal_expiration());
    }
    if (from._internal_debug_mode() != 0) {
        _this->_internal_set_debug_mode(from._internal_debug_mode());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PublicMetadata::CopyFrom(const PublicMetadata& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:privacy.ppn.PublicMetadata)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PublicMetadata::IsInitialized() const
{
    return true;
}

void PublicMetadata::InternalSwap(PublicMetadata* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.service_type_, lhs_arena, &other->_impl_.service_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PublicMetadata, _impl_.debug_mode_) + sizeof(PublicMetadata::_impl_.debug_mode_)
        - PROTOBUF_FIELD_OFFSET(PublicMetadata, _impl_.exit_location_)>(
        reinterpret_cast<char*>(&_impl_.exit_location_), reinterpret_cast<char*>(&other->_impl_.exit_location_));
}

std::string PublicMetadata::GetTypeName() const
{
    return "privacy.ppn.PublicMetadata";
}

// ===================================================================

class PublicMetadataInfo::_Internal {
public:
    static const ::privacy::ppn::PublicMetadata& public_metadata(const PublicMetadataInfo* msg);
};

const ::privacy::ppn::PublicMetadata& PublicMetadataInfo::_Internal::public_metadata(const PublicMetadataInfo* msg)
{
    return *msg->_impl_.public_metadata_;
}
PublicMetadataInfo::PublicMetadataInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:privacy.ppn.PublicMetadataInfo)
}
PublicMetadataInfo::PublicMetadataInfo(const PublicMetadataInfo& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    PublicMetadataInfo* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.public_metadata_) { nullptr }, decltype(_impl_.validation_version_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    if (from._internal_has_public_metadata()) {
        _this->_impl_.public_metadata_ = new ::privacy::ppn::PublicMetadata(*from._impl_.public_metadata_);
    }
    _this->_impl_.validation_version_ = from._impl_.validation_version_;
    // @@protoc_insertion_point(copy_constructor:privacy.ppn.PublicMetadataInfo)
}

inline void PublicMetadataInfo::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.public_metadata_) { nullptr }, decltype(_impl_.validation_version_) { 0 }, /*decltype(_impl_._cached_size_)*/ {} };
}

PublicMetadataInfo::~PublicMetadataInfo()
{
    // @@protoc_insertion_point(destructor:privacy.ppn.PublicMetadataInfo)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void PublicMetadataInfo::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    if (this != internal_default_instance())
        delete _impl_.public_metadata_;
}

void PublicMetadataInfo::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void PublicMetadataInfo::Clear()
{
    // @@protoc_insertion_point(message_clear_start:privacy.ppn.PublicMetadataInfo)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    if (GetArenaForAllocation() == nullptr && _impl_.public_metadata_ != nullptr) {
        delete _impl_.public_metadata_;
    }
    _impl_.public_metadata_ = nullptr;
    _impl_.validation_version_ = 0;
    _internal_metadata_.Clear<std::string>();
}

const char* PublicMetadataInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // .privacy.ppn.PublicMetadata public_metadata = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                ptr = ctx->ParseMessage(_internal_mutable_public_metadata(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // int32 validation_version = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
                _impl_.validation_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* PublicMetadataInfo::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:privacy.ppn.PublicMetadataInfo)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // .privacy.ppn.PublicMetadata public_metadata = 1;
    if (this->_internal_has_public_metadata()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            1, _Internal::public_metadata(this), _Internal::public_metadata(this).GetCachedSize(), target, stream);
    }

    // int32 validation_version = 2;
    if (this->_internal_validation_version() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_validation_version(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:privacy.ppn.PublicMetadataInfo)
    return target;
}

size_t PublicMetadataInfo::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:privacy.ppn.PublicMetadataInfo)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // .privacy.ppn.PublicMetadata public_metadata = 1;
    if (this->_internal_has_public_metadata()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.public_metadata_);
    }

    // int32 validation_version = 2;
    if (this->_internal_validation_version() != 0) {
        total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_validation_version());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void PublicMetadataInfo::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const PublicMetadataInfo*>(&from));
}

void PublicMetadataInfo::MergeFrom(const PublicMetadataInfo& from)
{
    PublicMetadataInfo* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:privacy.ppn.PublicMetadataInfo)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    if (from._internal_has_public_metadata()) {
        _this->_internal_mutable_public_metadata()->::privacy::ppn::PublicMetadata::MergeFrom(from._internal_public_metadata());
    }
    if (from._internal_validation_version() != 0) {
        _this->_internal_set_validation_version(from._internal_validation_version());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PublicMetadataInfo::CopyFrom(const PublicMetadataInfo& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:privacy.ppn.PublicMetadataInfo)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool PublicMetadataInfo::IsInitialized() const
{
    return true;
}

void PublicMetadataInfo::InternalSwap(PublicMetadataInfo* other)
{
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(PublicMetadataInfo, _impl_.validation_version_)
        + sizeof(PublicMetadataInfo::_impl_.validation_version_) - PROTOBUF_FIELD_OFFSET(PublicMetadataInfo, _impl_.public_metadata_)>(
        reinterpret_cast<char*>(&_impl_.public_metadata_), reinterpret_cast<char*>(&other->_impl_.public_metadata_));
}

std::string PublicMetadataInfo::GetTypeName() const
{
    return "privacy.ppn.PublicMetadataInfo";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace ppn
} // namespace privacy
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::privacy::ppn::PublicMetadata_Location* Arena::CreateMaybeMessage<::privacy::ppn::PublicMetadata_Location>(Arena* arena)
{
    return Arena::CreateMessageInternal<::privacy::ppn::PublicMetadata_Location>(arena);
}
template <> PROTOBUF_NOINLINE ::privacy::ppn::PublicMetadata* Arena::CreateMaybeMessage<::privacy::ppn::PublicMetadata>(Arena* arena)
{
    return Arena::CreateMessageInternal<::privacy::ppn::PublicMetadata>(arena);
}
template <> PROTOBUF_NOINLINE ::privacy::ppn::PublicMetadataInfo* Arena::CreateMaybeMessage<::privacy::ppn::PublicMetadataInfo>(Arena* arena)
{
    return Arena::CreateMessageInternal<::privacy::ppn::PublicMetadataInfo>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
