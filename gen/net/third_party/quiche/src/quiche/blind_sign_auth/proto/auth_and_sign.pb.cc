// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: quiche/blind_sign_auth/proto/auth_and_sign.proto

#include "quiche/blind_sign_auth/proto/auth_and_sign.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace privacy {
namespace ppn {
PROTOBUF_CONSTEXPR AuthAndSignRequest::AuthAndSignRequest(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.blinded_token_)*/ {},
        /*decltype(_impl_.oauth_token_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.service_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.public_key_hash_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.public_metadata_extensions_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.attestation_)*/ nullptr, /*decltype(_impl_.public_metadata_info_)*/ nullptr, /*decltype(_impl_.key_version_)*/ uint64_t { 0u },
        /*decltype(_impl_.key_type_)*/ 0, /*decltype(_impl_.do_not_use_rsa_public_exponent_)*/ false, /*decltype(_impl_.proxy_layer_)*/ 0,
        /*decltype(_impl_.attestation_data_)*/ {}, /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} }
{
}
struct AuthAndSignRequestDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AuthAndSignRequestDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AuthAndSignRequestDefaultTypeInternal()
    {
    }
    union {
        AuthAndSignRequest _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthAndSignRequestDefaultTypeInternal _AuthAndSignRequest_default_instance_;
PROTOBUF_CONSTEXPR AuthAndSignResponse::AuthAndSignResponse(::_pbi::ConstantInitialized)
    : _impl_ { /*decltype(_impl_.blinded_token_signature_)*/ {},
        /*decltype(_impl_.copper_controller_hostname_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.region_token_and_signature_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} },
        /*decltype(_impl_.apn_type_)*/ { &::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized {} }, /*decltype(_impl_._cached_size_)*/ {} }
{
}
struct AuthAndSignResponseDefaultTypeInternal {
    PROTOBUF_CONSTEXPR AuthAndSignResponseDefaultTypeInternal()
        : _instance(::_pbi::ConstantInitialized {})
    {
    }
    ~AuthAndSignResponseDefaultTypeInternal()
    {
    }
    union {
        AuthAndSignResponse _instance;
    };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AuthAndSignResponseDefaultTypeInternal
    _AuthAndSignResponse_default_instance_;
} // namespace ppn
} // namespace privacy
namespace privacy {
namespace ppn {

// ===================================================================

class AuthAndSignRequest::_Internal {
public:
    static const ::privacy::ppn::AndroidAttestationData& android_attestation_data(const AuthAndSignRequest* msg);
    static const ::privacy::ppn::IosAttestationData& ios_attestation_data(const AuthAndSignRequest* msg);
    static const ::privacy::ppn::AttestationData& attestation(const AuthAndSignRequest* msg);
    static const ::privacy::ppn::PublicMetadataInfo& public_metadata_info(const AuthAndSignRequest* msg);
};

const ::privacy::ppn::AndroidAttestationData& AuthAndSignRequest::_Internal::android_attestation_data(const AuthAndSignRequest* msg)
{
    return *msg->_impl_.attestation_data_.android_attestation_data_;
}
const ::privacy::ppn::IosAttestationData& AuthAndSignRequest::_Internal::ios_attestation_data(const AuthAndSignRequest* msg)
{
    return *msg->_impl_.attestation_data_.ios_attestation_data_;
}
const ::privacy::ppn::AttestationData& AuthAndSignRequest::_Internal::attestation(const AuthAndSignRequest* msg)
{
    return *msg->_impl_.attestation_;
}
const ::privacy::ppn::PublicMetadataInfo& AuthAndSignRequest::_Internal::public_metadata_info(const AuthAndSignRequest* msg)
{
    return *msg->_impl_.public_metadata_info_;
}
void AuthAndSignRequest::set_allocated_android_attestation_data(::privacy::ppn::AndroidAttestationData* android_attestation_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_attestation_data();
    if (android_attestation_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(android_attestation_data));
        if (message_arena != submessage_arena) {
            android_attestation_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, android_attestation_data, submessage_arena);
        }
        set_has_android_attestation_data();
        _impl_.attestation_data_.android_attestation_data_ = android_attestation_data;
    }
    // @@protoc_insertion_point(field_set_allocated:privacy.ppn.AuthAndSignRequest.android_attestation_data)
}
void AuthAndSignRequest::clear_android_attestation_data()
{
    if (_internal_has_android_attestation_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.attestation_data_.android_attestation_data_;
        }
        clear_has_attestation_data();
    }
}
void AuthAndSignRequest::set_allocated_ios_attestation_data(::privacy::ppn::IosAttestationData* ios_attestation_data)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    clear_attestation_data();
    if (ios_attestation_data) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena
            = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ios_attestation_data));
        if (message_arena != submessage_arena) {
            ios_attestation_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, ios_attestation_data, submessage_arena);
        }
        set_has_ios_attestation_data();
        _impl_.attestation_data_.ios_attestation_data_ = ios_attestation_data;
    }
    // @@protoc_insertion_point(field_set_allocated:privacy.ppn.AuthAndSignRequest.ios_attestation_data)
}
void AuthAndSignRequest::clear_ios_attestation_data()
{
    if (_internal_has_ios_attestation_data()) {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.attestation_data_.ios_attestation_data_;
        }
        clear_has_attestation_data();
    }
}
void AuthAndSignRequest::clear_attestation()
{
    if (GetArenaForAllocation() == nullptr && _impl_.attestation_ != nullptr) {
        delete _impl_.attestation_;
    }
    _impl_.attestation_ = nullptr;
}
void AuthAndSignRequest::clear_public_metadata_info()
{
    if (GetArenaForAllocation() == nullptr && _impl_.public_metadata_info_ != nullptr) {
        delete _impl_.public_metadata_info_;
    }
    _impl_.public_metadata_info_ = nullptr;
}
AuthAndSignRequest::AuthAndSignRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:privacy.ppn.AuthAndSignRequest)
}
AuthAndSignRequest::AuthAndSignRequest(const AuthAndSignRequest& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AuthAndSignRequest* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.blinded_token_) { from._impl_.blinded_token_ }, decltype(_impl_.oauth_token_) {}, decltype(_impl_.service_type_) {},
        decltype(_impl_.public_key_hash_) {}, decltype(_impl_.public_metadata_extensions_) {}, decltype(_impl_.attestation_) { nullptr },
        decltype(_impl_.public_metadata_info_) { nullptr }, decltype(_impl_.key_version_) {}, decltype(_impl_.key_type_) {},
        decltype(_impl_.do_not_use_rsa_public_exponent_) {}, decltype(_impl_.proxy_layer_) {}, decltype(_impl_.attestation_data_) {},
        /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.oauth_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oauth_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_oauth_token().empty()) {
        _this->_impl_.oauth_token_.Set(from._internal_oauth_token(), _this->GetArenaForAllocation());
    }
    _impl_.service_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_service_type().empty()) {
        _this->_impl_.service_type_.Set(from._internal_service_type(), _this->GetArenaForAllocation());
    }
    _impl_.public_key_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_public_key_hash().empty()) {
        _this->_impl_.public_key_hash_.Set(from._internal_public_key_hash(), _this->GetArenaForAllocation());
    }
    _impl_.public_metadata_extensions_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_metadata_extensions_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_public_metadata_extensions().empty()) {
        _this->_impl_.public_metadata_extensions_.Set(from._internal_public_metadata_extensions(), _this->GetArenaForAllocation());
    }
    if (from._internal_has_attestation()) {
        _this->_impl_.attestation_ = new ::privacy::ppn::AttestationData(*from._impl_.attestation_);
    }
    if (from._internal_has_public_metadata_info()) {
        _this->_impl_.public_metadata_info_ = new ::privacy::ppn::PublicMetadataInfo(*from._impl_.public_metadata_info_);
    }
    ::memcpy(&_impl_.key_version_, &from._impl_.key_version_,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.proxy_layer_) - reinterpret_cast<char*>(&_impl_.key_version_)) + sizeof(_impl_.proxy_layer_));
    clear_has_attestation_data();
    switch (from.attestation_data_case()) {
    case kAndroidAttestationData: {
        _this->_internal_mutable_android_attestation_data()->::privacy::ppn::AndroidAttestationData::MergeFrom(from._internal_android_attestation_data());
        break;
    }
    case kIosAttestationData: {
        _this->_internal_mutable_ios_attestation_data()->::privacy::ppn::IosAttestationData::MergeFrom(from._internal_ios_attestation_data());
        break;
    }
    case ATTESTATION_DATA_NOT_SET: {
        break;
    }
    }
    // @@protoc_insertion_point(copy_constructor:privacy.ppn.AuthAndSignRequest)
}

inline void AuthAndSignRequest::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.blinded_token_) { arena }, decltype(_impl_.oauth_token_) {}, decltype(_impl_.service_type_) {},
        decltype(_impl_.public_key_hash_) {}, decltype(_impl_.public_metadata_extensions_) {}, decltype(_impl_.attestation_) { nullptr },
        decltype(_impl_.public_metadata_info_) { nullptr }, decltype(_impl_.key_version_) { uint64_t { 0u } }, decltype(_impl_.key_type_) { 0 },
        decltype(_impl_.do_not_use_rsa_public_exponent_) { false }, decltype(_impl_.proxy_layer_) { 0 }, decltype(_impl_.attestation_data_) {},
        /*decltype(_impl_._cached_size_)*/ {}, /*decltype(_impl_._oneof_case_)*/ {} };
    _impl_.oauth_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.oauth_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_hash_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_key_hash_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_metadata_extensions_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.public_metadata_extensions_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    clear_has_attestation_data();
}

AuthAndSignRequest::~AuthAndSignRequest()
{
    // @@protoc_insertion_point(destructor:privacy.ppn.AuthAndSignRequest)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AuthAndSignRequest::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.blinded_token_.~RepeatedPtrField();
    _impl_.oauth_token_.Destroy();
    _impl_.service_type_.Destroy();
    _impl_.public_key_hash_.Destroy();
    _impl_.public_metadata_extensions_.Destroy();
    if (this != internal_default_instance())
        delete _impl_.attestation_;
    if (this != internal_default_instance())
        delete _impl_.public_metadata_info_;
    if (has_attestation_data()) {
        clear_attestation_data();
    }
}

void AuthAndSignRequest::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AuthAndSignRequest::clear_attestation_data()
{
    // @@protoc_insertion_point(one_of_clear_start:privacy.ppn.AuthAndSignRequest)
    switch (attestation_data_case()) {
    case kAndroidAttestationData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.attestation_data_.android_attestation_data_;
        }
        break;
    }
    case kIosAttestationData: {
        if (GetArenaForAllocation() == nullptr) {
            delete _impl_.attestation_data_.ios_attestation_data_;
        }
        break;
    }
    case ATTESTATION_DATA_NOT_SET: {
        break;
    }
    }
    _impl_._oneof_case_[0] = ATTESTATION_DATA_NOT_SET;
}

void AuthAndSignRequest::Clear()
{
    // @@protoc_insertion_point(message_clear_start:privacy.ppn.AuthAndSignRequest)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.blinded_token_.Clear();
    _impl_.oauth_token_.ClearToEmpty();
    _impl_.service_type_.ClearToEmpty();
    _impl_.public_key_hash_.ClearToEmpty();
    _impl_.public_metadata_extensions_.ClearToEmpty();
    if (GetArenaForAllocation() == nullptr && _impl_.attestation_ != nullptr) {
        delete _impl_.attestation_;
    }
    _impl_.attestation_ = nullptr;
    if (GetArenaForAllocation() == nullptr && _impl_.public_metadata_info_ != nullptr) {
        delete _impl_.public_metadata_info_;
    }
    _impl_.public_metadata_info_ = nullptr;
    ::memset(&_impl_.key_version_, 0,
        static_cast<size_t>(reinterpret_cast<char*>(&_impl_.proxy_layer_) - reinterpret_cast<char*>(&_impl_.key_version_)) + sizeof(_impl_.proxy_layer_));
    clear_attestation_data();
    _internal_metadata_.Clear<std::string>();
}

const char* AuthAndSignRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // string oauth_token = 1;
        case 1:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
                auto str = _internal_mutable_oauth_token();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string service_type = 2;
        case 2:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
                auto str = _internal_mutable_service_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // repeated string blinded_token = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_blinded_token();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    CHK_(::_pbi::VerifyUTF8(str, nullptr));
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // string public_key_hash = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_public_key_hash();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.AndroidAttestationData android_attestation_data = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                ptr = ctx->ParseMessage(_internal_mutable_android_attestation_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.IosAttestationData ios_attestation_data = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                ptr = ctx->ParseMessage(_internal_mutable_ios_attestation_data(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.AttestationData attestation = 8;
        case 8:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
                ptr = ctx->ParseMessage(_internal_mutable_attestation(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.KeyType key_type = 10;
        case 10:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_key_type(static_cast<::privacy::ppn::KeyType>(val));
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.PublicMetadataInfo public_metadata_info = 11;
        case 11:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
                ptr = ctx->ParseMessage(_internal_mutable_public_metadata_info(), ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // uint64 key_version = 12;
        case 12:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
                _impl_.key_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bytes public_metadata_extensions = 14;
        case 14:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
                auto str = _internal_mutable_public_metadata_extensions();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // bool do_not_use_rsa_public_exponent = 15;
        case 15:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
                _impl_.do_not_use_rsa_public_exponent_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
            } else
                goto handle_unusual;
            continue;
        // .privacy.ppn.ProxyLayer proxy_layer = 16;
        case 16:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
                uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                CHK_(ptr);
                _internal_set_proxy_layer(static_cast<::privacy::ppn::ProxyLayer>(val));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AuthAndSignRequest::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:privacy.ppn.AuthAndSignRequest)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // string oauth_token = 1;
    if (!this->_internal_oauth_token().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_oauth_token().data(),
            static_cast<int>(this->_internal_oauth_token().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.AuthAndSignRequest.oauth_token");
        target = stream->WriteStringMaybeAliased(1, this->_internal_oauth_token(), target);
    }

    // string service_type = 2;
    if (!this->_internal_service_type().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_service_type().data(),
            static_cast<int>(this->_internal_service_type().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.AuthAndSignRequest.service_type");
        target = stream->WriteStringMaybeAliased(2, this->_internal_service_type(), target);
    }

    // repeated string blinded_token = 4;
    for (int i = 0, n = this->_internal_blinded_token_size(); i < n; i++) {
        const auto& s = this->_internal_blinded_token(i);
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s.data(), static_cast<int>(s.length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "privacy.ppn.AuthAndSignRequest.blinded_token");
        target = stream->WriteString(4, s, target);
    }

    // string public_key_hash = 5;
    if (!this->_internal_public_key_hash().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_public_key_hash().data(),
            static_cast<int>(this->_internal_public_key_hash().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.AuthAndSignRequest.public_key_hash");
        target = stream->WriteStringMaybeAliased(5, this->_internal_public_key_hash(), target);
    }

    // .privacy.ppn.AndroidAttestationData android_attestation_data = 6;
    if (_internal_has_android_attestation_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            6, _Internal::android_attestation_data(this), _Internal::android_attestation_data(this).GetCachedSize(), target, stream);
    }

    // .privacy.ppn.IosAttestationData ios_attestation_data = 7;
    if (_internal_has_ios_attestation_data()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            7, _Internal::ios_attestation_data(this), _Internal::ios_attestation_data(this).GetCachedSize(), target, stream);
    }

    // .privacy.ppn.AttestationData attestation = 8;
    if (this->_internal_has_attestation()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            8, _Internal::attestation(this), _Internal::attestation(this).GetCachedSize(), target, stream);
    }

    // .privacy.ppn.KeyType key_type = 10;
    if (this->_internal_key_type() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(10, this->_internal_key_type(), target);
    }

    // .privacy.ppn.PublicMetadataInfo public_metadata_info = 11;
    if (this->_internal_has_public_metadata_info()) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::InternalWriteMessage(
            11, _Internal::public_metadata_info(this), _Internal::public_metadata_info(this).GetCachedSize(), target, stream);
    }

    // uint64 key_version = 12;
    if (this->_internal_key_version() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteUInt64ToArray(12, this->_internal_key_version(), target);
    }

    // bytes public_metadata_extensions = 14;
    if (!this->_internal_public_metadata_extensions().empty()) {
        target = stream->WriteBytesMaybeAliased(14, this->_internal_public_metadata_extensions(), target);
    }

    // bool do_not_use_rsa_public_exponent = 15;
    if (this->_internal_do_not_use_rsa_public_exponent() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_do_not_use_rsa_public_exponent(), target);
    }

    // .privacy.ppn.ProxyLayer proxy_layer = 16;
    if (this->_internal_proxy_layer() != 0) {
        target = stream->EnsureSpace(target);
        target = ::_pbi::WireFormatLite::WriteEnumToArray(16, this->_internal_proxy_layer(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:privacy.ppn.AuthAndSignRequest)
    return target;
}

size_t AuthAndSignRequest::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:privacy.ppn.AuthAndSignRequest)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string blinded_token = 4;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.blinded_token_.size());
    for (int i = 0, n = _impl_.blinded_token_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.blinded_token_.Get(i));
    }

    // string oauth_token = 1;
    if (!this->_internal_oauth_token().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_oauth_token());
    }

    // string service_type = 2;
    if (!this->_internal_service_type().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_service_type());
    }

    // string public_key_hash = 5;
    if (!this->_internal_public_key_hash().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_public_key_hash());
    }

    // bytes public_metadata_extensions = 14;
    if (!this->_internal_public_metadata_extensions().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(this->_internal_public_metadata_extensions());
    }

    // .privacy.ppn.AttestationData attestation = 8;
    if (this->_internal_has_attestation()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.attestation_);
    }

    // .privacy.ppn.PublicMetadataInfo public_metadata_info = 11;
    if (this->_internal_has_public_metadata_info()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.public_metadata_info_);
    }

    // uint64 key_version = 12;
    if (this->_internal_key_version() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_key_version());
    }

    // .privacy.ppn.KeyType key_type = 10;
    if (this->_internal_key_type() != 0) {
        total_size += 1 + ::_pbi::WireFormatLite::EnumSize(this->_internal_key_type());
    }

    // bool do_not_use_rsa_public_exponent = 15;
    if (this->_internal_do_not_use_rsa_public_exponent() != 0) {
        total_size += 1 + 1;
    }

    // .privacy.ppn.ProxyLayer proxy_layer = 16;
    if (this->_internal_proxy_layer() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::EnumSize(this->_internal_proxy_layer());
    }

    switch (attestation_data_case()) {
    // .privacy.ppn.AndroidAttestationData android_attestation_data = 6;
    case kAndroidAttestationData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.attestation_data_.android_attestation_data_);
        break;
    }
    // .privacy.ppn.IosAttestationData ios_attestation_data = 7;
    case kIosAttestationData: {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(*_impl_.attestation_data_.ios_attestation_data_);
        break;
    }
    case ATTESTATION_DATA_NOT_SET: {
        break;
    }
    }
    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AuthAndSignRequest::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AuthAndSignRequest*>(&from));
}

void AuthAndSignRequest::MergeFrom(const AuthAndSignRequest& from)
{
    AuthAndSignRequest* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:privacy.ppn.AuthAndSignRequest)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.blinded_token_.MergeFrom(from._impl_.blinded_token_);
    if (!from._internal_oauth_token().empty()) {
        _this->_internal_set_oauth_token(from._internal_oauth_token());
    }
    if (!from._internal_service_type().empty()) {
        _this->_internal_set_service_type(from._internal_service_type());
    }
    if (!from._internal_public_key_hash().empty()) {
        _this->_internal_set_public_key_hash(from._internal_public_key_hash());
    }
    if (!from._internal_public_metadata_extensions().empty()) {
        _this->_internal_set_public_metadata_extensions(from._internal_public_metadata_extensions());
    }
    if (from._internal_has_attestation()) {
        _this->_internal_mutable_attestation()->::privacy::ppn::AttestationData::MergeFrom(from._internal_attestation());
    }
    if (from._internal_has_public_metadata_info()) {
        _this->_internal_mutable_public_metadata_info()->::privacy::ppn::PublicMetadataInfo::MergeFrom(from._internal_public_metadata_info());
    }
    if (from._internal_key_version() != 0) {
        _this->_internal_set_key_version(from._internal_key_version());
    }
    if (from._internal_key_type() != 0) {
        _this->_internal_set_key_type(from._internal_key_type());
    }
    if (from._internal_do_not_use_rsa_public_exponent() != 0) {
        _this->_internal_set_do_not_use_rsa_public_exponent(from._internal_do_not_use_rsa_public_exponent());
    }
    if (from._internal_proxy_layer() != 0) {
        _this->_internal_set_proxy_layer(from._internal_proxy_layer());
    }
    switch (from.attestation_data_case()) {
    case kAndroidAttestationData: {
        _this->_internal_mutable_android_attestation_data()->::privacy::ppn::AndroidAttestationData::MergeFrom(from._internal_android_attestation_data());
        break;
    }
    case kIosAttestationData: {
        _this->_internal_mutable_ios_attestation_data()->::privacy::ppn::IosAttestationData::MergeFrom(from._internal_ios_attestation_data());
        break;
    }
    case ATTESTATION_DATA_NOT_SET: {
        break;
    }
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthAndSignRequest::CopyFrom(const AuthAndSignRequest& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:privacy.ppn.AuthAndSignRequest)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AuthAndSignRequest::IsInitialized() const
{
    return true;
}

void AuthAndSignRequest::InternalSwap(AuthAndSignRequest* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.blinded_token_.InternalSwap(&other->_impl_.blinded_token_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.oauth_token_, lhs_arena, &other->_impl_.oauth_token_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.service_type_, lhs_arena, &other->_impl_.service_type_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.public_key_hash_, lhs_arena, &other->_impl_.public_key_hash_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.public_metadata_extensions_, lhs_arena, &other->_impl_.public_metadata_extensions_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::memswap<PROTOBUF_FIELD_OFFSET(AuthAndSignRequest, _impl_.proxy_layer_) + sizeof(AuthAndSignRequest::_impl_.proxy_layer_)
        - PROTOBUF_FIELD_OFFSET(AuthAndSignRequest, _impl_.attestation_)>(
        reinterpret_cast<char*>(&_impl_.attestation_), reinterpret_cast<char*>(&other->_impl_.attestation_));
    swap(_impl_.attestation_data_, other->_impl_.attestation_data_);
    swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

std::string AuthAndSignRequest::GetTypeName() const
{
    return "privacy.ppn.AuthAndSignRequest";
}

// ===================================================================

class AuthAndSignResponse::_Internal {
public:
};

AuthAndSignResponse::AuthAndSignResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned)
{
    SharedCtor(arena, is_message_owned);
    // @@protoc_insertion_point(arena_constructor:privacy.ppn.AuthAndSignResponse)
}
AuthAndSignResponse::AuthAndSignResponse(const AuthAndSignResponse& from)
    : ::PROTOBUF_NAMESPACE_ID::MessageLite()
{
    AuthAndSignResponse* const _this = this;
    (void)_this;
    new (&_impl_) Impl_ { decltype(_impl_.blinded_token_signature_) { from._impl_.blinded_token_signature_ }, decltype(_impl_.copper_controller_hostname_) {},
        decltype(_impl_.region_token_and_signature_) {}, decltype(_impl_.apn_type_) {}, /*decltype(_impl_._cached_size_)*/ {} };

    _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
    _impl_.copper_controller_hostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.copper_controller_hostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_copper_controller_hostname().empty()) {
        _this->_impl_.copper_controller_hostname_.Set(from._internal_copper_controller_hostname(), _this->GetArenaForAllocation());
    }
    _impl_.region_token_and_signature_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_token_and_signature_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_region_token_and_signature().empty()) {
        _this->_impl_.region_token_and_signature_.Set(from._internal_region_token_and_signature(), _this->GetArenaForAllocation());
    }
    _impl_.apn_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apn_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (!from._internal_apn_type().empty()) {
        _this->_impl_.apn_type_.Set(from._internal_apn_type(), _this->GetArenaForAllocation());
    }
    // @@protoc_insertion_point(copy_constructor:privacy.ppn.AuthAndSignResponse)
}

inline void AuthAndSignResponse::SharedCtor(::_pb::Arena* arena, bool is_message_owned)
{
    (void)arena;
    (void)is_message_owned;
    new (&_impl_) Impl_ { decltype(_impl_.blinded_token_signature_) { arena }, decltype(_impl_.copper_controller_hostname_) {},
        decltype(_impl_.region_token_and_signature_) {}, decltype(_impl_.apn_type_) {}, /*decltype(_impl_._cached_size_)*/ {} };
    _impl_.copper_controller_hostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.copper_controller_hostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_token_and_signature_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.region_token_and_signature_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apn_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.apn_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

AuthAndSignResponse::~AuthAndSignResponse()
{
    // @@protoc_insertion_point(destructor:privacy.ppn.AuthAndSignResponse)
    if (auto* arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
        (void)arena;
        return;
    }
    SharedDtor();
}

inline void AuthAndSignResponse::SharedDtor()
{
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    _impl_.blinded_token_signature_.~RepeatedPtrField();
    _impl_.copper_controller_hostname_.Destroy();
    _impl_.region_token_and_signature_.Destroy();
    _impl_.apn_type_.Destroy();
}

void AuthAndSignResponse::SetCachedSize(int size) const
{
    _impl_._cached_size_.Set(size);
}

void AuthAndSignResponse::Clear()
{
    // @@protoc_insertion_point(message_clear_start:privacy.ppn.AuthAndSignResponse)
    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    _impl_.blinded_token_signature_.Clear();
    _impl_.copper_controller_hostname_.ClearToEmpty();
    _impl_.region_token_and_signature_.ClearToEmpty();
    _impl_.apn_type_.ClearToEmpty();
    _internal_metadata_.Clear<std::string>();
}

const char* AuthAndSignResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx)
{
#define CHK_(x)                                                                                                                                                \
    if (PROTOBUF_PREDICT_FALSE(!(x)))                                                                                                                          \
    goto failure
    while (!ctx->Done(&ptr)) {
        uint32_t tag;
        ptr = ::_pbi::ReadTag(ptr, &tag);
        switch (tag >> 3) {
        // repeated string blinded_token_signature = 4;
        case 4:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
                ptr -= 1;
                do {
                    ptr += 1;
                    auto str = _internal_add_blinded_token_signature();
                    ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(ptr);
                    CHK_(::_pbi::VerifyUTF8(str, nullptr));
                    if (!ctx->DataAvailable(ptr))
                        break;
                } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
            } else
                goto handle_unusual;
            continue;
        // string copper_controller_hostname = 5;
        case 5:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
                auto str = _internal_mutable_copper_controller_hostname();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string region_token_and_signature = 6;
        case 6:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
                auto str = _internal_mutable_region_token_and_signature();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        // string apn_type = 7;
        case 7:
            if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
                auto str = _internal_mutable_apn_type();
                ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
                CHK_(ptr);
                CHK_(::_pbi::VerifyUTF8(str, nullptr));
            } else
                goto handle_unusual;
            continue;
        default:
            goto handle_unusual;
        } // switch
    handle_unusual:
        if ((tag == 0) || ((tag & 7) == 4)) {
            CHK_(ptr);
            ctx->SetLastTag(tag);
            goto message_done;
        }
        ptr = UnknownFieldParse(tag, _internal_metadata_.mutable_unknown_fields<std::string>(), ptr, ctx);
        CHK_(ptr != nullptr);
    } // while
message_done:
    return ptr;
failure:
    ptr = nullptr;
    goto message_done;
#undef CHK_
}

uint8_t* AuthAndSignResponse::_InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const
{
    // @@protoc_insertion_point(serialize_to_array_start:privacy.ppn.AuthAndSignResponse)
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    // repeated string blinded_token_signature = 4;
    for (int i = 0, n = this->_internal_blinded_token_signature_size(); i < n; i++) {
        const auto& s = this->_internal_blinded_token_signature(i);
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s.data(), static_cast<int>(s.length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE, "privacy.ppn.AuthAndSignResponse.blinded_token_signature");
        target = stream->WriteString(4, s, target);
    }

    // string copper_controller_hostname = 5;
    if (!this->_internal_copper_controller_hostname().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_copper_controller_hostname().data(),
            static_cast<int>(this->_internal_copper_controller_hostname().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.AuthAndSignResponse.copper_controller_hostname");
        target = stream->WriteStringMaybeAliased(5, this->_internal_copper_controller_hostname(), target);
    }

    // string region_token_and_signature = 6;
    if (!this->_internal_region_token_and_signature().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_region_token_and_signature().data(),
            static_cast<int>(this->_internal_region_token_and_signature().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.AuthAndSignResponse.region_token_and_signature");
        target = stream->WriteStringMaybeAliased(6, this->_internal_region_token_and_signature(), target);
    }

    // string apn_type = 7;
    if (!this->_internal_apn_type().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(this->_internal_apn_type().data(),
            static_cast<int>(this->_internal_apn_type().length()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
            "privacy.ppn.AuthAndSignResponse.apn_type");
        target = stream->WriteStringMaybeAliased(7, this->_internal_apn_type(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
            static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
    }
    // @@protoc_insertion_point(serialize_to_array_end:privacy.ppn.AuthAndSignResponse)
    return target;
}

size_t AuthAndSignResponse::ByteSizeLong() const
{
    // @@protoc_insertion_point(message_byte_size_start:privacy.ppn.AuthAndSignResponse)
    size_t total_size = 0;

    uint32_t cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void)cached_has_bits;

    // repeated string blinded_token_signature = 4;
    total_size += 1 * ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.blinded_token_signature_.size());
    for (int i = 0, n = _impl_.blinded_token_signature_.size(); i < n; i++) {
        total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(_impl_.blinded_token_signature_.Get(i));
    }

    // string copper_controller_hostname = 5;
    if (!this->_internal_copper_controller_hostname().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_copper_controller_hostname());
    }

    // string region_token_and_signature = 6;
    if (!this->_internal_region_token_and_signature().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_region_token_and_signature());
    }

    // string apn_type = 7;
    if (!this->_internal_apn_type().empty()) {
        total_size += 1 + ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(this->_internal_apn_type());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
    }
    int cached_size = ::_pbi::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void AuthAndSignResponse::CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)
{
    MergeFrom(*::_pbi::DownCast<const AuthAndSignResponse*>(&from));
}

void AuthAndSignResponse::MergeFrom(const AuthAndSignResponse& from)
{
    AuthAndSignResponse* const _this = this;
    // @@protoc_insertion_point(class_specific_merge_from_start:privacy.ppn.AuthAndSignResponse)
    GOOGLE_DCHECK_NE(&from, _this);
    uint32_t cached_has_bits = 0;
    (void)cached_has_bits;

    _this->_impl_.blinded_token_signature_.MergeFrom(from._impl_.blinded_token_signature_);
    if (!from._internal_copper_controller_hostname().empty()) {
        _this->_internal_set_copper_controller_hostname(from._internal_copper_controller_hostname());
    }
    if (!from._internal_region_token_and_signature().empty()) {
        _this->_internal_set_region_token_and_signature(from._internal_region_token_and_signature());
    }
    if (!from._internal_apn_type().empty()) {
        _this->_internal_set_apn_type(from._internal_apn_type());
    }
    _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AuthAndSignResponse::CopyFrom(const AuthAndSignResponse& from)
{
    // @@protoc_insertion_point(class_specific_copy_from_start:privacy.ppn.AuthAndSignResponse)
    if (&from == this)
        return;
    Clear();
    MergeFrom(from);
}

bool AuthAndSignResponse::IsInitialized() const
{
    return true;
}

void AuthAndSignResponse::InternalSwap(AuthAndSignResponse* other)
{
    using std::swap;
    auto* lhs_arena = GetArenaForAllocation();
    auto* rhs_arena = other->GetArenaForAllocation();
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    _impl_.blinded_token_signature_.InternalSwap(&other->_impl_.blinded_token_signature_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.copper_controller_hostname_, lhs_arena, &other->_impl_.copper_controller_hostname_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
        &_impl_.region_token_and_signature_, lhs_arena, &other->_impl_.region_token_and_signature_, rhs_arena);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(&_impl_.apn_type_, lhs_arena, &other->_impl_.apn_type_, rhs_arena);
}

std::string AuthAndSignResponse::GetTypeName() const
{
    return "privacy.ppn.AuthAndSignResponse";
}

// @@protoc_insertion_point(namespace_scope)
} // namespace ppn
} // namespace privacy
PROTOBUF_NAMESPACE_OPEN
template <> PROTOBUF_NOINLINE ::privacy::ppn::AuthAndSignRequest* Arena::CreateMaybeMessage<::privacy::ppn::AuthAndSignRequest>(Arena* arena)
{
    return Arena::CreateMessageInternal<::privacy::ppn::AuthAndSignRequest>(arena);
}
template <> PROTOBUF_NOINLINE ::privacy::ppn::AuthAndSignResponse* Arena::CreateMaybeMessage<::privacy::ppn::AuthAndSignResponse>(Arena* arena)
{
    return Arena::CreateMessageInternal<::privacy::ppn::AuthAndSignResponse>(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
