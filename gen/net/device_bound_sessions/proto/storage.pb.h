// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net/device_bound_sessions/proto/storage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/map.h> // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
} // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto {
    static const uint32_t offsets[];
};
namespace net {
namespace device_bound_sessions {
namespace proto {
class CookieCraving;
struct CookieCravingDefaultTypeInternal;
extern CookieCravingDefaultTypeInternal _CookieCraving_default_instance_;
class SerializedCookiePartitionKey;
struct SerializedCookiePartitionKeyDefaultTypeInternal;
extern SerializedCookiePartitionKeyDefaultTypeInternal _SerializedCookiePartitionKey_default_instance_;
class Session;
struct SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class SessionInclusionRules;
struct SessionInclusionRulesDefaultTypeInternal;
extern SessionInclusionRulesDefaultTypeInternal _SessionInclusionRules_default_instance_;
class SiteSessions;
struct SiteSessionsDefaultTypeInternal;
extern SiteSessionsDefaultTypeInternal _SiteSessions_default_instance_;
class SiteSessions_SessionsEntry_DoNotUse;
struct SiteSessions_SessionsEntry_DoNotUseDefaultTypeInternal;
extern SiteSessions_SessionsEntry_DoNotUseDefaultTypeInternal _SiteSessions_SessionsEntry_DoNotUse_default_instance_;
class UrlRule;
struct UrlRuleDefaultTypeInternal;
extern UrlRuleDefaultTypeInternal _UrlRule_default_instance_;
} // namespace proto
} // namespace device_bound_sessions
} // namespace net
PROTOBUF_NAMESPACE_OPEN
template <>::net::device_bound_sessions::proto::CookieCraving* Arena::CreateMaybeMessage<::net::device_bound_sessions::proto::CookieCraving>(Arena*);
template <>
::net::device_bound_sessions::proto::SerializedCookiePartitionKey* Arena::CreateMaybeMessage<::net::device_bound_sessions::proto::SerializedCookiePartitionKey>(
    Arena*);
template <>::net::device_bound_sessions::proto::Session* Arena::CreateMaybeMessage<::net::device_bound_sessions::proto::Session>(Arena*);
template <>
::net::device_bound_sessions::proto::SessionInclusionRules* Arena::CreateMaybeMessage<::net::device_bound_sessions::proto::SessionInclusionRules>(Arena*);
template <>::net::device_bound_sessions::proto::SiteSessions* Arena::CreateMaybeMessage<::net::device_bound_sessions::proto::SiteSessions>(Arena*);
template <>
::net::device_bound_sessions::proto::SiteSessions_SessionsEntry_DoNotUse*
Arena::CreateMaybeMessage<::net::device_bound_sessions::proto::SiteSessions_SessionsEntry_DoNotUse>(Arena*);
template <>::net::device_bound_sessions::proto::UrlRule* Arena::CreateMaybeMessage<::net::device_bound_sessions::proto::UrlRule>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace net {
namespace device_bound_sessions {
namespace proto {

enum RuleType : int { RULE_TYPE_UNSPECIFIED = 0, EXCLUDE = 1, INCLUDE = 2 };
bool RuleType_IsValid(int value);
constexpr RuleType RuleType_MIN = RULE_TYPE_UNSPECIFIED;
constexpr RuleType RuleType_MAX = INCLUDE;
constexpr int RuleType_ARRAYSIZE = RuleType_MAX + 1;

const std::string& RuleType_Name(RuleType value);
template <typename T> inline const std::string& RuleType_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, RuleType>::value || ::std::is_integral<T>::value, "Incorrect type passed to function RuleType_Name.");
    return RuleType_Name(static_cast<RuleType>(enum_t_value));
}
bool RuleType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RuleType* value);
enum CookieSameSite : int { COOKIE_SAME_SITE_UNSPECIFIED = 0, NO_RESTRICTION = 1, LAX_MODE = 2, STRICT_MODE = 3 };
bool CookieSameSite_IsValid(int value);
constexpr CookieSameSite CookieSameSite_MIN = COOKIE_SAME_SITE_UNSPECIFIED;
constexpr CookieSameSite CookieSameSite_MAX = STRICT_MODE;
constexpr int CookieSameSite_ARRAYSIZE = CookieSameSite_MAX + 1;

const std::string& CookieSameSite_Name(CookieSameSite value);
template <typename T> inline const std::string& CookieSameSite_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, CookieSameSite>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CookieSameSite_Name.");
    return CookieSameSite_Name(static_cast<CookieSameSite>(enum_t_value));
}
bool CookieSameSite_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CookieSameSite* value);
enum CookieSourceScheme : int { UNSET = 0, NON_SECURE = 1, SECURE = 2 };
bool CookieSourceScheme_IsValid(int value);
constexpr CookieSourceScheme CookieSourceScheme_MIN = UNSET;
constexpr CookieSourceScheme CookieSourceScheme_MAX = SECURE;
constexpr int CookieSourceScheme_ARRAYSIZE = CookieSourceScheme_MAX + 1;

const std::string& CookieSourceScheme_Name(CookieSourceScheme value);
template <typename T> inline const std::string& CookieSourceScheme_Name(T enum_t_value)
{
    static_assert(::std::is_same<T, CookieSourceScheme>::value || ::std::is_integral<T>::value, "Incorrect type passed to function CookieSourceScheme_Name.");
    return CookieSourceScheme_Name(static_cast<CookieSourceScheme>(enum_t_value));
}
bool CookieSourceScheme_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CookieSourceScheme* value);
// ===================================================================

class UrlRule final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:net.device_bound_sessions.proto.UrlRule) */ {
public:
    inline UrlRule()
        : UrlRule(nullptr)
    {
    }
    ~UrlRule() override;
    explicit PROTOBUF_CONSTEXPR UrlRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    UrlRule(const UrlRule& from);
    UrlRule(UrlRule&& from) noexcept
        : UrlRule()
    {
        *this = ::std::move(from);
    }

    inline UrlRule& operator=(const UrlRule& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UrlRule& operator=(UrlRule&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const UrlRule& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UrlRule* internal_default_instance()
    {
        return reinterpret_cast<const UrlRule*>(&_UrlRule_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    friend void swap(UrlRule& a, UrlRule& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(UrlRule* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UrlRule* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UrlRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<UrlRule>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const UrlRule& from);
    void MergeFrom(const UrlRule& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(UrlRule* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "net.device_bound_sessions.proto.UrlRule";
    }

protected:
    explicit UrlRule(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kHostMatcherRuleFieldNumber = 2,
        kPathPrefixFieldNumber = 3,
        kRuleTypeFieldNumber = 1,
    };
    // optional string host_matcher_rule = 2;
    bool has_host_matcher_rule() const;

private:
    bool _internal_has_host_matcher_rule() const;

public:
    void clear_host_matcher_rule();
    const std::string& host_matcher_rule() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_host_matcher_rule(ArgT0&& arg0, ArgT... args);
    std::string* mutable_host_matcher_rule();
    PROTOBUF_NODISCARD std::string* release_host_matcher_rule();
    void set_allocated_host_matcher_rule(std::string* host_matcher_rule);

private:
    const std::string& _internal_host_matcher_rule() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_matcher_rule(const std::string& value);
    std::string* _internal_mutable_host_matcher_rule();

public:
    // optional string path_prefix = 3;
    bool has_path_prefix() const;

private:
    bool _internal_has_path_prefix() const;

public:
    void clear_path_prefix();
    const std::string& path_prefix() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_path_prefix(ArgT0&& arg0, ArgT... args);
    std::string* mutable_path_prefix();
    PROTOBUF_NODISCARD std::string* release_path_prefix();
    void set_allocated_path_prefix(std::string* path_prefix);

private:
    const std::string& _internal_path_prefix() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_path_prefix(const std::string& value);
    std::string* _internal_mutable_path_prefix();

public:
    // optional .net.device_bound_sessions.proto.RuleType rule_type = 1;
    bool has_rule_type() const;

private:
    bool _internal_has_rule_type() const;

public:
    void clear_rule_type();
    ::net::device_bound_sessions::proto::RuleType rule_type() const;
    void set_rule_type(::net::device_bound_sessions::proto::RuleType value);

private:
    ::net::device_bound_sessions::proto::RuleType _internal_rule_type() const;
    void _internal_set_rule_type(::net::device_bound_sessions::proto::RuleType value);

public:
    // @@protoc_insertion_point(class_scope:net.device_bound_sessions.proto.UrlRule)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_matcher_rule_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_prefix_;
        int rule_type_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class SessionInclusionRules final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:net.device_bound_sessions.proto.SessionInclusionRules) */ {
public:
    inline SessionInclusionRules()
        : SessionInclusionRules(nullptr)
    {
    }
    ~SessionInclusionRules() override;
    explicit PROTOBUF_CONSTEXPR SessionInclusionRules(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SessionInclusionRules(const SessionInclusionRules& from);
    SessionInclusionRules(SessionInclusionRules&& from) noexcept
        : SessionInclusionRules()
    {
        *this = ::std::move(from);
    }

    inline SessionInclusionRules& operator=(const SessionInclusionRules& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SessionInclusionRules& operator=(SessionInclusionRules&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SessionInclusionRules& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SessionInclusionRules* internal_default_instance()
    {
        return reinterpret_cast<const SessionInclusionRules*>(&_SessionInclusionRules_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;

    friend void swap(SessionInclusionRules& a, SessionInclusionRules& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SessionInclusionRules* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SessionInclusionRules* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SessionInclusionRules* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SessionInclusionRules>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SessionInclusionRules& from);
    void MergeFrom(const SessionInclusionRules& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SessionInclusionRules* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "net.device_bound_sessions.proto.SessionInclusionRules";
    }

protected:
    explicit SessionInclusionRules(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kUrlRulesFieldNumber = 3,
        kOriginFieldNumber = 1,
        kDoIncludeSiteFieldNumber = 2,
    };
    // repeated .net.device_bound_sessions.proto.UrlRule url_rules = 3;
    int url_rules_size() const;

private:
    int _internal_url_rules_size() const;

public:
    void clear_url_rules();
    ::net::device_bound_sessions::proto::UrlRule* mutable_url_rules(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::UrlRule>* mutable_url_rules();

private:
    const ::net::device_bound_sessions::proto::UrlRule& _internal_url_rules(int index) const;
    ::net::device_bound_sessions::proto::UrlRule* _internal_add_url_rules();

public:
    const ::net::device_bound_sessions::proto::UrlRule& url_rules(int index) const;
    ::net::device_bound_sessions::proto::UrlRule* add_url_rules();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::UrlRule>& url_rules() const;

    // optional string origin = 1;
    bool has_origin() const;

private:
    bool _internal_has_origin() const;

public:
    void clear_origin();
    const std::string& origin() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_origin(ArgT0&& arg0, ArgT... args);
    std::string* mutable_origin();
    PROTOBUF_NODISCARD std::string* release_origin();
    void set_allocated_origin(std::string* origin);

private:
    const std::string& _internal_origin() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_origin(const std::string& value);
    std::string* _internal_mutable_origin();

public:
    // optional bool do_include_site = 2;
    bool has_do_include_site() const;

private:
    bool _internal_has_do_include_site() const;

public:
    void clear_do_include_site();
    bool do_include_site() const;
    void set_do_include_site(bool value);

private:
    bool _internal_do_include_site() const;
    void _internal_set_do_include_site(bool value);

public:
    // @@protoc_insertion_point(class_scope:net.device_bound_sessions.proto.SessionInclusionRules)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::UrlRule> url_rules_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr origin_;
        bool do_include_site_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class SerializedCookiePartitionKey final
    : public ::PROTOBUF_NAMESPACE_ID::
          MessageLite /* @@protoc_insertion_point(class_definition:net.device_bound_sessions.proto.SerializedCookiePartitionKey) */ {
public:
    inline SerializedCookiePartitionKey()
        : SerializedCookiePartitionKey(nullptr)
    {
    }
    ~SerializedCookiePartitionKey() override;
    explicit PROTOBUF_CONSTEXPR SerializedCookiePartitionKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SerializedCookiePartitionKey(const SerializedCookiePartitionKey& from);
    SerializedCookiePartitionKey(SerializedCookiePartitionKey&& from) noexcept
        : SerializedCookiePartitionKey()
    {
        *this = ::std::move(from);
    }

    inline SerializedCookiePartitionKey& operator=(const SerializedCookiePartitionKey& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SerializedCookiePartitionKey& operator=(SerializedCookiePartitionKey&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SerializedCookiePartitionKey& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SerializedCookiePartitionKey* internal_default_instance()
    {
        return reinterpret_cast<const SerializedCookiePartitionKey*>(&_SerializedCookiePartitionKey_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;

    friend void swap(SerializedCookiePartitionKey& a, SerializedCookiePartitionKey& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SerializedCookiePartitionKey* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SerializedCookiePartitionKey* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SerializedCookiePartitionKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SerializedCookiePartitionKey>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SerializedCookiePartitionKey& from);
    void MergeFrom(const SerializedCookiePartitionKey& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SerializedCookiePartitionKey* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "net.device_bound_sessions.proto.SerializedCookiePartitionKey";
    }

protected:
    explicit SerializedCookiePartitionKey(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kTopLevelSiteFieldNumber = 1,
        kHasCrossSiteAncestorFieldNumber = 2,
    };
    // optional string top_level_site = 1;
    bool has_top_level_site() const;

private:
    bool _internal_has_top_level_site() const;

public:
    void clear_top_level_site();
    const std::string& top_level_site() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_top_level_site(ArgT0&& arg0, ArgT... args);
    std::string* mutable_top_level_site();
    PROTOBUF_NODISCARD std::string* release_top_level_site();
    void set_allocated_top_level_site(std::string* top_level_site);

private:
    const std::string& _internal_top_level_site() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_top_level_site(const std::string& value);
    std::string* _internal_mutable_top_level_site();

public:
    // optional bool has_cross_site_ancestor = 2;
    bool has_has_cross_site_ancestor() const;

private:
    bool _internal_has_has_cross_site_ancestor() const;

public:
    void clear_has_cross_site_ancestor();
    bool has_cross_site_ancestor() const;
    void set_has_cross_site_ancestor(bool value);

private:
    bool _internal_has_cross_site_ancestor() const;
    void _internal_set_has_cross_site_ancestor(bool value);

public:
    // @@protoc_insertion_point(class_scope:net.device_bound_sessions.proto.SerializedCookiePartitionKey)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr top_level_site_;
        bool has_cross_site_ancestor_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CookieCraving final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:net.device_bound_sessions.proto.CookieCraving) */ {
public:
    inline CookieCraving()
        : CookieCraving(nullptr)
    {
    }
    ~CookieCraving() override;
    explicit PROTOBUF_CONSTEXPR CookieCraving(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    CookieCraving(const CookieCraving& from);
    CookieCraving(CookieCraving&& from) noexcept
        : CookieCraving()
    {
        *this = ::std::move(from);
    }

    inline CookieCraving& operator=(const CookieCraving& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CookieCraving& operator=(CookieCraving&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const CookieCraving& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CookieCraving* internal_default_instance()
    {
        return reinterpret_cast<const CookieCraving*>(&_CookieCraving_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;

    friend void swap(CookieCraving& a, CookieCraving& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(CookieCraving* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CookieCraving* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CookieCraving* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<CookieCraving>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const CookieCraving& from);
    void MergeFrom(const CookieCraving& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(CookieCraving* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "net.device_bound_sessions.proto.CookieCraving";
    }

protected:
    explicit CookieCraving(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kNameFieldNumber = 1,
        kDomainFieldNumber = 2,
        kPathFieldNumber = 3,
        kSerializedPartitionKeyFieldNumber = 10,
        kSecureFieldNumber = 4,
        kHttponlyFieldNumber = 5,
        kSourcePortFieldNumber = 6,
        kCreationTimeFieldNumber = 7,
        kSameSiteFieldNumber = 8,
        kSourceSchemeFieldNumber = 9,
    };
    // optional string name = 1;
    bool has_name() const;

private:
    bool _internal_has_name() const;

public:
    void clear_name();
    const std::string& name() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_name(ArgT0&& arg0, ArgT... args);
    std::string* mutable_name();
    PROTOBUF_NODISCARD std::string* release_name();
    void set_allocated_name(std::string* name);

private:
    const std::string& _internal_name() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
    std::string* _internal_mutable_name();

public:
    // optional string domain = 2;
    bool has_domain() const;

private:
    bool _internal_has_domain() const;

public:
    void clear_domain();
    const std::string& domain() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_domain(ArgT0&& arg0, ArgT... args);
    std::string* mutable_domain();
    PROTOBUF_NODISCARD std::string* release_domain();
    void set_allocated_domain(std::string* domain);

private:
    const std::string& _internal_domain() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
    std::string* _internal_mutable_domain();

public:
    // optional string path = 3;
    bool has_path() const;

private:
    bool _internal_has_path() const;

public:
    void clear_path();
    const std::string& path() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_path(ArgT0&& arg0, ArgT... args);
    std::string* mutable_path();
    PROTOBUF_NODISCARD std::string* release_path();
    void set_allocated_path(std::string* path);

private:
    const std::string& _internal_path() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
    std::string* _internal_mutable_path();

public:
    // optional .net.device_bound_sessions.proto.SerializedCookiePartitionKey serialized_partition_key = 10;
    bool has_serialized_partition_key() const;

private:
    bool _internal_has_serialized_partition_key() const;

public:
    void clear_serialized_partition_key();
    const ::net::device_bound_sessions::proto::SerializedCookiePartitionKey& serialized_partition_key() const;
    PROTOBUF_NODISCARD ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* release_serialized_partition_key();
    ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* mutable_serialized_partition_key();
    void set_allocated_serialized_partition_key(::net::device_bound_sessions::proto::SerializedCookiePartitionKey* serialized_partition_key);

private:
    const ::net::device_bound_sessions::proto::SerializedCookiePartitionKey& _internal_serialized_partition_key() const;
    ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* _internal_mutable_serialized_partition_key();

public:
    void unsafe_arena_set_allocated_serialized_partition_key(::net::device_bound_sessions::proto::SerializedCookiePartitionKey* serialized_partition_key);
    ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* unsafe_arena_release_serialized_partition_key();

    // optional bool secure = 4;
    bool has_secure() const;

private:
    bool _internal_has_secure() const;

public:
    void clear_secure();
    bool secure() const;
    void set_secure(bool value);

private:
    bool _internal_secure() const;
    void _internal_set_secure(bool value);

public:
    // optional bool httponly = 5;
    bool has_httponly() const;

private:
    bool _internal_has_httponly() const;

public:
    void clear_httponly();
    bool httponly() const;
    void set_httponly(bool value);

private:
    bool _internal_httponly() const;
    void _internal_set_httponly(bool value);

public:
    // optional int32 source_port = 6;
    bool has_source_port() const;

private:
    bool _internal_has_source_port() const;

public:
    void clear_source_port();
    int32_t source_port() const;
    void set_source_port(int32_t value);

private:
    int32_t _internal_source_port() const;
    void _internal_set_source_port(int32_t value);

public:
    // optional int64 creation_time = 7;
    bool has_creation_time() const;

private:
    bool _internal_has_creation_time() const;

public:
    void clear_creation_time();
    int64_t creation_time() const;
    void set_creation_time(int64_t value);

private:
    int64_t _internal_creation_time() const;
    void _internal_set_creation_time(int64_t value);

public:
    // optional .net.device_bound_sessions.proto.CookieSameSite same_site = 8;
    bool has_same_site() const;

private:
    bool _internal_has_same_site() const;

public:
    void clear_same_site();
    ::net::device_bound_sessions::proto::CookieSameSite same_site() const;
    void set_same_site(::net::device_bound_sessions::proto::CookieSameSite value);

private:
    ::net::device_bound_sessions::proto::CookieSameSite _internal_same_site() const;
    void _internal_set_same_site(::net::device_bound_sessions::proto::CookieSameSite value);

public:
    // optional .net.device_bound_sessions.proto.CookieSourceScheme source_scheme = 9;
    bool has_source_scheme() const;

private:
    bool _internal_has_source_scheme() const;

public:
    void clear_source_scheme();
    ::net::device_bound_sessions::proto::CookieSourceScheme source_scheme() const;
    void set_source_scheme(::net::device_bound_sessions::proto::CookieSourceScheme value);

private:
    ::net::device_bound_sessions::proto::CookieSourceScheme _internal_source_scheme() const;
    void _internal_set_source_scheme(::net::device_bound_sessions::proto::CookieSourceScheme value);

public:
    // @@protoc_insertion_point(class_scope:net.device_bound_sessions.proto.CookieCraving)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
        ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* serialized_partition_key_;
        bool secure_;
        bool httponly_;
        int32_t source_port_;
        int64_t creation_time_;
        int same_site_;
        int source_scheme_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class Session final : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:net.device_bound_sessions.proto.Session) */ {
public:
    inline Session()
        : Session(nullptr)
    {
    }
    ~Session() override;
    explicit PROTOBUF_CONSTEXPR Session(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    Session(const Session& from);
    Session(Session&& from) noexcept
        : Session()
    {
        *this = ::std::move(from);
    }

    inline Session& operator=(const Session& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Session& operator=(Session&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const Session& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Session* internal_default_instance()
    {
        return reinterpret_cast<const Session*>(&_Session_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;

    friend void swap(Session& a, Session& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(Session* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Session* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Session* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<Session>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const Session& from);
    void MergeFrom(const Session& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Session* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "net.device_bound_sessions.proto.Session";
    }

protected:
    explicit Session(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kCookieCravingsFieldNumber = 7,
        kIdFieldNumber = 1,
        kRefreshUrlFieldNumber = 2,
        kWrappedKeyFieldNumber = 5,
        kSessionInclusionRulesFieldNumber = 6,
        kExpiryTimeFieldNumber = 4,
        kShouldDeferWhenExpiredFieldNumber = 3,
    };
    // repeated .net.device_bound_sessions.proto.CookieCraving cookie_cravings = 7;
    int cookie_cravings_size() const;

private:
    int _internal_cookie_cravings_size() const;

public:
    void clear_cookie_cravings();
    ::net::device_bound_sessions::proto::CookieCraving* mutable_cookie_cravings(int index);
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::CookieCraving>* mutable_cookie_cravings();

private:
    const ::net::device_bound_sessions::proto::CookieCraving& _internal_cookie_cravings(int index) const;
    ::net::device_bound_sessions::proto::CookieCraving* _internal_add_cookie_cravings();

public:
    const ::net::device_bound_sessions::proto::CookieCraving& cookie_cravings(int index) const;
    ::net::device_bound_sessions::proto::CookieCraving* add_cookie_cravings();
    const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::CookieCraving>& cookie_cravings() const;

    // optional string id = 1;
    bool has_id() const;

private:
    bool _internal_has_id() const;

public:
    void clear_id();
    const std::string& id() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_id(ArgT0&& arg0, ArgT... args);
    std::string* mutable_id();
    PROTOBUF_NODISCARD std::string* release_id();
    void set_allocated_id(std::string* id);

private:
    const std::string& _internal_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
    std::string* _internal_mutable_id();

public:
    // optional string refresh_url = 2;
    bool has_refresh_url() const;

private:
    bool _internal_has_refresh_url() const;

public:
    void clear_refresh_url();
    const std::string& refresh_url() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_refresh_url(ArgT0&& arg0, ArgT... args);
    std::string* mutable_refresh_url();
    PROTOBUF_NODISCARD std::string* release_refresh_url();
    void set_allocated_refresh_url(std::string* refresh_url);

private:
    const std::string& _internal_refresh_url() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_url(const std::string& value);
    std::string* _internal_mutable_refresh_url();

public:
    // optional bytes wrapped_key = 5;
    bool has_wrapped_key() const;

private:
    bool _internal_has_wrapped_key() const;

public:
    void clear_wrapped_key();
    const std::string& wrapped_key() const;
    template <typename ArgT0 = const std::string&, typename... ArgT> void set_wrapped_key(ArgT0&& arg0, ArgT... args);
    std::string* mutable_wrapped_key();
    PROTOBUF_NODISCARD std::string* release_wrapped_key();
    void set_allocated_wrapped_key(std::string* wrapped_key);

private:
    const std::string& _internal_wrapped_key() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_wrapped_key(const std::string& value);
    std::string* _internal_mutable_wrapped_key();

public:
    // optional .net.device_bound_sessions.proto.SessionInclusionRules session_inclusion_rules = 6;
    bool has_session_inclusion_rules() const;

private:
    bool _internal_has_session_inclusion_rules() const;

public:
    void clear_session_inclusion_rules();
    const ::net::device_bound_sessions::proto::SessionInclusionRules& session_inclusion_rules() const;
    PROTOBUF_NODISCARD ::net::device_bound_sessions::proto::SessionInclusionRules* release_session_inclusion_rules();
    ::net::device_bound_sessions::proto::SessionInclusionRules* mutable_session_inclusion_rules();
    void set_allocated_session_inclusion_rules(::net::device_bound_sessions::proto::SessionInclusionRules* session_inclusion_rules);

private:
    const ::net::device_bound_sessions::proto::SessionInclusionRules& _internal_session_inclusion_rules() const;
    ::net::device_bound_sessions::proto::SessionInclusionRules* _internal_mutable_session_inclusion_rules();

public:
    void unsafe_arena_set_allocated_session_inclusion_rules(::net::device_bound_sessions::proto::SessionInclusionRules* session_inclusion_rules);
    ::net::device_bound_sessions::proto::SessionInclusionRules* unsafe_arena_release_session_inclusion_rules();

    // optional int64 expiry_time = 4;
    bool has_expiry_time() const;

private:
    bool _internal_has_expiry_time() const;

public:
    void clear_expiry_time();
    int64_t expiry_time() const;
    void set_expiry_time(int64_t value);

private:
    int64_t _internal_expiry_time() const;
    void _internal_set_expiry_time(int64_t value);

public:
    // optional bool should_defer_when_expired = 3;
    bool has_should_defer_when_expired() const;

private:
    bool _internal_has_should_defer_when_expired() const;

public:
    void clear_should_defer_when_expired();
    bool should_defer_when_expired() const;
    void set_should_defer_when_expired(bool value);

private:
    bool _internal_should_defer_when_expired() const;
    void _internal_set_should_defer_when_expired(bool value);

public:
    // @@protoc_insertion_point(class_scope:net.device_bound_sessions.proto.Session)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
        ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::CookieCraving> cookie_cravings_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_url_;
        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wrapped_key_;
        ::net::device_bound_sessions::proto::SessionInclusionRules* session_inclusion_rules_;
        int64_t expiry_time_;
        bool should_defer_when_expired_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class SiteSessions_SessionsEntry_DoNotUse
    : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<SiteSessions_SessionsEntry_DoNotUse, std::string, ::net::device_bound_sessions::proto::Session,
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
    typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<SiteSessions_SessionsEntry_DoNotUse, std::string, ::net::device_bound_sessions::proto::Session,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE>
        SuperType;
    SiteSessions_SessionsEntry_DoNotUse();
    explicit PROTOBUF_CONSTEXPR SiteSessions_SessionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
    explicit SiteSessions_SessionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
    void MergeFrom(const SiteSessions_SessionsEntry_DoNotUse& other);
    static const SiteSessions_SessionsEntry_DoNotUse* internal_default_instance()
    {
        return reinterpret_cast<const SiteSessions_SessionsEntry_DoNotUse*>(&_SiteSessions_SessionsEntry_DoNotUse_default_instance_);
    }
    static bool ValidateKey(void*)
    {
        return true;
    }
    static bool ValidateValue(void*)
    {
        return true;
    }
    friend struct ::TableStruct_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto;
};

// -------------------------------------------------------------------

class SiteSessions final
    : public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:net.device_bound_sessions.proto.SiteSessions) */ {
public:
    inline SiteSessions()
        : SiteSessions(nullptr)
    {
    }
    ~SiteSessions() override;
    explicit PROTOBUF_CONSTEXPR SiteSessions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

    SiteSessions(const SiteSessions& from);
    SiteSessions(SiteSessions&& from) noexcept
        : SiteSessions()
    {
        *this = ::std::move(from);
    }

    inline SiteSessions& operator=(const SiteSessions& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline SiteSessions& operator=(SiteSessions&& from) noexcept
    {
        if (this == &from)
            return *this;
        if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
            && GetOwningArena() != nullptr
#endif // !PROTOBUF_FORCE_COPY_IN_MOVE
        ) {
            InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }

    inline const std::string& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
    }
    inline std::string* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields<std::string>();
    }

    static const SiteSessions& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const SiteSessions* internal_default_instance()
    {
        return reinterpret_cast<const SiteSessions*>(&_SiteSessions_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;

    friend void swap(SiteSessions& a, SiteSessions& b)
    {
        a.Swap(&b);
    }
    PROTOBUF_NOINLINE void Swap(SiteSessions* other)
    {
        if (other == this)
            return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() != nullptr && GetOwningArena() == other->GetOwningArena()) {
#else // PROTOBUF_FORCE_COPY_IN_SWAP
        if (GetOwningArena() == other->GetOwningArena()) {
#endif // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        } else {
            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(SiteSessions* other)
    {
        if (other == this)
            return;
        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    SiteSessions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final
    {
        return CreateMaybeMessage<SiteSessions>(arena);
    }
    void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) final;
    void CopyFrom(const SiteSessions& from);
    void MergeFrom(const SiteSessions& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
    uint8_t* _InternalSerialize(uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
    int GetCachedSize() const final
    {
        return _impl_._cached_size_.Get();
    }

private:
    void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(SiteSessions* other);

private:
    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName()
    {
        return "net.device_bound_sessions.proto.SiteSessions";
    }

protected:
    explicit SiteSessions(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned = false);

public:
    std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------

    enum : int {
        kSessionsFieldNumber = 1,
    };
    // map<string, .net.device_bound_sessions.proto.Session> sessions = 1;
    int sessions_size() const;

private:
    int _internal_sessions_size() const;

public:
    void clear_sessions();

private:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::net::device_bound_sessions::proto::Session>& _internal_sessions() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::net::device_bound_sessions::proto::Session>* _internal_mutable_sessions();

public:
    const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::net::device_bound_sessions::proto::Session>& sessions() const;
    ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::net::device_bound_sessions::proto::Session>* mutable_sessions();

    // @@protoc_insertion_point(class_scope:net.device_bound_sessions.proto.SiteSessions)
private:
    class _Internal;

    template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
    typedef void InternalArenaConstructable_;
    typedef void DestructorSkippable_;
    struct Impl_ {
        ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<SiteSessions_SessionsEntry_DoNotUse, std::string, ::net::device_bound_sessions::proto::Session,
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE>
            sessions_;
        mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    };
    union {
        Impl_ _impl_;
    };
    friend struct ::TableStruct_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// UrlRule

// optional .net.device_bound_sessions.proto.RuleType rule_type = 1;
inline bool UrlRule::_internal_has_rule_type() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool UrlRule::has_rule_type() const
{
    return _internal_has_rule_type();
}
inline void UrlRule::clear_rule_type()
{
    _impl_.rule_type_ = 0;
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::net::device_bound_sessions::proto::RuleType UrlRule::_internal_rule_type() const
{
    return static_cast<::net::device_bound_sessions::proto::RuleType>(_impl_.rule_type_);
}
inline ::net::device_bound_sessions::proto::RuleType UrlRule::rule_type() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.UrlRule.rule_type)
    return _internal_rule_type();
}
inline void UrlRule::_internal_set_rule_type(::net::device_bound_sessions::proto::RuleType value)
{
    assert(::net::device_bound_sessions::proto::RuleType_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.rule_type_ = value;
}
inline void UrlRule::set_rule_type(::net::device_bound_sessions::proto::RuleType value)
{
    _internal_set_rule_type(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.UrlRule.rule_type)
}

// optional string host_matcher_rule = 2;
inline bool UrlRule::_internal_has_host_matcher_rule() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool UrlRule::has_host_matcher_rule() const
{
    return _internal_has_host_matcher_rule();
}
inline void UrlRule::clear_host_matcher_rule()
{
    _impl_.host_matcher_rule_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UrlRule::host_matcher_rule() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.UrlRule.host_matcher_rule)
    return _internal_host_matcher_rule();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UrlRule::set_host_matcher_rule(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.host_matcher_rule_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.UrlRule.host_matcher_rule)
}
inline std::string* UrlRule::mutable_host_matcher_rule()
{
    std::string* _s = _internal_mutable_host_matcher_rule();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.UrlRule.host_matcher_rule)
    return _s;
}
inline const std::string& UrlRule::_internal_host_matcher_rule() const
{
    return _impl_.host_matcher_rule_.Get();
}
inline void UrlRule::_internal_set_host_matcher_rule(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.host_matcher_rule_.Set(value, GetArenaForAllocation());
}
inline std::string* UrlRule::_internal_mutable_host_matcher_rule()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.host_matcher_rule_.Mutable(GetArenaForAllocation());
}
inline std::string* UrlRule::release_host_matcher_rule()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.UrlRule.host_matcher_rule)
    if (!_internal_has_host_matcher_rule()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.host_matcher_rule_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.host_matcher_rule_.IsDefault()) {
        _impl_.host_matcher_rule_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UrlRule::set_allocated_host_matcher_rule(std::string* host_matcher_rule)
{
    if (host_matcher_rule != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.host_matcher_rule_.SetAllocated(host_matcher_rule, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.host_matcher_rule_.IsDefault()) {
        _impl_.host_matcher_rule_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.UrlRule.host_matcher_rule)
}

// optional string path_prefix = 3;
inline bool UrlRule::_internal_has_path_prefix() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool UrlRule::has_path_prefix() const
{
    return _internal_has_path_prefix();
}
inline void UrlRule::clear_path_prefix()
{
    _impl_.path_prefix_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UrlRule::path_prefix() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.UrlRule.path_prefix)
    return _internal_path_prefix();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void UrlRule::set_path_prefix(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.path_prefix_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.UrlRule.path_prefix)
}
inline std::string* UrlRule::mutable_path_prefix()
{
    std::string* _s = _internal_mutable_path_prefix();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.UrlRule.path_prefix)
    return _s;
}
inline const std::string& UrlRule::_internal_path_prefix() const
{
    return _impl_.path_prefix_.Get();
}
inline void UrlRule::_internal_set_path_prefix(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.path_prefix_.Set(value, GetArenaForAllocation());
}
inline std::string* UrlRule::_internal_mutable_path_prefix()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.path_prefix_.Mutable(GetArenaForAllocation());
}
inline std::string* UrlRule::release_path_prefix()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.UrlRule.path_prefix)
    if (!_internal_has_path_prefix()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.path_prefix_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.path_prefix_.IsDefault()) {
        _impl_.path_prefix_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void UrlRule::set_allocated_path_prefix(std::string* path_prefix)
{
    if (path_prefix != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.path_prefix_.SetAllocated(path_prefix, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.path_prefix_.IsDefault()) {
        _impl_.path_prefix_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.UrlRule.path_prefix)
}

// -------------------------------------------------------------------

// SessionInclusionRules

// optional string origin = 1;
inline bool SessionInclusionRules::_internal_has_origin() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SessionInclusionRules::has_origin() const
{
    return _internal_has_origin();
}
inline void SessionInclusionRules::clear_origin()
{
    _impl_.origin_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionInclusionRules::origin() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.SessionInclusionRules.origin)
    return _internal_origin();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SessionInclusionRules::set_origin(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.origin_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.SessionInclusionRules.origin)
}
inline std::string* SessionInclusionRules::mutable_origin()
{
    std::string* _s = _internal_mutable_origin();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.SessionInclusionRules.origin)
    return _s;
}
inline const std::string& SessionInclusionRules::_internal_origin() const
{
    return _impl_.origin_.Get();
}
inline void SessionInclusionRules::_internal_set_origin(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.origin_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionInclusionRules::_internal_mutable_origin()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.origin_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionInclusionRules::release_origin()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.SessionInclusionRules.origin)
    if (!_internal_has_origin()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.origin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.origin_.IsDefault()) {
        _impl_.origin_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SessionInclusionRules::set_allocated_origin(std::string* origin)
{
    if (origin != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.origin_.SetAllocated(origin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.origin_.IsDefault()) {
        _impl_.origin_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.SessionInclusionRules.origin)
}

// optional bool do_include_site = 2;
inline bool SessionInclusionRules::_internal_has_do_include_site() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SessionInclusionRules::has_do_include_site() const
{
    return _internal_has_do_include_site();
}
inline void SessionInclusionRules::clear_do_include_site()
{
    _impl_.do_include_site_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SessionInclusionRules::_internal_do_include_site() const
{
    return _impl_.do_include_site_;
}
inline bool SessionInclusionRules::do_include_site() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.SessionInclusionRules.do_include_site)
    return _internal_do_include_site();
}
inline void SessionInclusionRules::_internal_set_do_include_site(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.do_include_site_ = value;
}
inline void SessionInclusionRules::set_do_include_site(bool value)
{
    _internal_set_do_include_site(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.SessionInclusionRules.do_include_site)
}

// repeated .net.device_bound_sessions.proto.UrlRule url_rules = 3;
inline int SessionInclusionRules::_internal_url_rules_size() const
{
    return _impl_.url_rules_.size();
}
inline int SessionInclusionRules::url_rules_size() const
{
    return _internal_url_rules_size();
}
inline void SessionInclusionRules::clear_url_rules()
{
    _impl_.url_rules_.Clear();
}
inline ::net::device_bound_sessions::proto::UrlRule* SessionInclusionRules::mutable_url_rules(int index)
{
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.SessionInclusionRules.url_rules)
    return _impl_.url_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::UrlRule>* SessionInclusionRules::mutable_url_rules()
{
    // @@protoc_insertion_point(field_mutable_list:net.device_bound_sessions.proto.SessionInclusionRules.url_rules)
    return &_impl_.url_rules_;
}
inline const ::net::device_bound_sessions::proto::UrlRule& SessionInclusionRules::_internal_url_rules(int index) const
{
    return _impl_.url_rules_.Get(index);
}
inline const ::net::device_bound_sessions::proto::UrlRule& SessionInclusionRules::url_rules(int index) const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.SessionInclusionRules.url_rules)
    return _internal_url_rules(index);
}
inline ::net::device_bound_sessions::proto::UrlRule* SessionInclusionRules::_internal_add_url_rules()
{
    return _impl_.url_rules_.Add();
}
inline ::net::device_bound_sessions::proto::UrlRule* SessionInclusionRules::add_url_rules()
{
    ::net::device_bound_sessions::proto::UrlRule* _add = _internal_add_url_rules();
    // @@protoc_insertion_point(field_add:net.device_bound_sessions.proto.SessionInclusionRules.url_rules)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::UrlRule>& SessionInclusionRules::url_rules() const
{
    // @@protoc_insertion_point(field_list:net.device_bound_sessions.proto.SessionInclusionRules.url_rules)
    return _impl_.url_rules_;
}

// -------------------------------------------------------------------

// SerializedCookiePartitionKey

// optional string top_level_site = 1;
inline bool SerializedCookiePartitionKey::_internal_has_top_level_site() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool SerializedCookiePartitionKey::has_top_level_site() const
{
    return _internal_has_top_level_site();
}
inline void SerializedCookiePartitionKey::clear_top_level_site()
{
    _impl_.top_level_site_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SerializedCookiePartitionKey::top_level_site() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.SerializedCookiePartitionKey.top_level_site)
    return _internal_top_level_site();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void SerializedCookiePartitionKey::set_top_level_site(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.top_level_site_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.SerializedCookiePartitionKey.top_level_site)
}
inline std::string* SerializedCookiePartitionKey::mutable_top_level_site()
{
    std::string* _s = _internal_mutable_top_level_site();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.SerializedCookiePartitionKey.top_level_site)
    return _s;
}
inline const std::string& SerializedCookiePartitionKey::_internal_top_level_site() const
{
    return _impl_.top_level_site_.Get();
}
inline void SerializedCookiePartitionKey::_internal_set_top_level_site(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.top_level_site_.Set(value, GetArenaForAllocation());
}
inline std::string* SerializedCookiePartitionKey::_internal_mutable_top_level_site()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.top_level_site_.Mutable(GetArenaForAllocation());
}
inline std::string* SerializedCookiePartitionKey::release_top_level_site()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.SerializedCookiePartitionKey.top_level_site)
    if (!_internal_has_top_level_site()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.top_level_site_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.top_level_site_.IsDefault()) {
        _impl_.top_level_site_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void SerializedCookiePartitionKey::set_allocated_top_level_site(std::string* top_level_site)
{
    if (top_level_site != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.top_level_site_.SetAllocated(top_level_site, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.top_level_site_.IsDefault()) {
        _impl_.top_level_site_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.SerializedCookiePartitionKey.top_level_site)
}

// optional bool has_cross_site_ancestor = 2;
inline bool SerializedCookiePartitionKey::_internal_has_has_cross_site_ancestor() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool SerializedCookiePartitionKey::has_has_cross_site_ancestor() const
{
    return _internal_has_has_cross_site_ancestor();
}
inline void SerializedCookiePartitionKey::clear_has_cross_site_ancestor()
{
    _impl_.has_cross_site_ancestor_ = false;
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool SerializedCookiePartitionKey::_internal_has_cross_site_ancestor() const
{
    return _impl_.has_cross_site_ancestor_;
}
inline bool SerializedCookiePartitionKey::has_cross_site_ancestor() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.SerializedCookiePartitionKey.has_cross_site_ancestor)
    return _internal_has_cross_site_ancestor();
}
inline void SerializedCookiePartitionKey::_internal_set_has_cross_site_ancestor(bool value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.has_cross_site_ancestor_ = value;
}
inline void SerializedCookiePartitionKey::set_has_cross_site_ancestor(bool value)
{
    _internal_set_has_cross_site_ancestor(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.SerializedCookiePartitionKey.has_cross_site_ancestor)
}

// -------------------------------------------------------------------

// CookieCraving

// optional string name = 1;
inline bool CookieCraving::_internal_has_name() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool CookieCraving::has_name() const
{
    return _internal_has_name();
}
inline void CookieCraving::clear_name()
{
    _impl_.name_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CookieCraving::name() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.name)
    return _internal_name();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CookieCraving::set_name(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.name)
}
inline std::string* CookieCraving::mutable_name()
{
    std::string* _s = _internal_mutable_name();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.CookieCraving.name)
    return _s;
}
inline const std::string& CookieCraving::_internal_name() const
{
    return _impl_.name_.Get();
}
inline void CookieCraving::_internal_set_name(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* CookieCraving::_internal_mutable_name()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* CookieCraving::release_name()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.CookieCraving.name)
    if (!_internal_has_name()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CookieCraving::set_allocated_name(std::string* name)
{
    if (name != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.name_.IsDefault()) {
        _impl_.name_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.CookieCraving.name)
}

// optional string domain = 2;
inline bool CookieCraving::_internal_has_domain() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool CookieCraving::has_domain() const
{
    return _internal_has_domain();
}
inline void CookieCraving::clear_domain()
{
    _impl_.domain_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CookieCraving::domain() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.domain)
    return _internal_domain();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CookieCraving::set_domain(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.domain_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.domain)
}
inline std::string* CookieCraving::mutable_domain()
{
    std::string* _s = _internal_mutable_domain();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.CookieCraving.domain)
    return _s;
}
inline const std::string& CookieCraving::_internal_domain() const
{
    return _impl_.domain_.Get();
}
inline void CookieCraving::_internal_set_domain(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.domain_.Set(value, GetArenaForAllocation());
}
inline std::string* CookieCraving::_internal_mutable_domain()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.domain_.Mutable(GetArenaForAllocation());
}
inline std::string* CookieCraving::release_domain()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.CookieCraving.domain)
    if (!_internal_has_domain()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.domain_.IsDefault()) {
        _impl_.domain_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CookieCraving::set_allocated_domain(std::string* domain)
{
    if (domain != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.domain_.IsDefault()) {
        _impl_.domain_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.CookieCraving.domain)
}

// optional string path = 3;
inline bool CookieCraving::_internal_has_path() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool CookieCraving::has_path() const
{
    return _internal_has_path();
}
inline void CookieCraving::clear_path()
{
    _impl_.path_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CookieCraving::path() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.path)
    return _internal_path();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void CookieCraving::set_path(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.path_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.path)
}
inline std::string* CookieCraving::mutable_path()
{
    std::string* _s = _internal_mutable_path();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.CookieCraving.path)
    return _s;
}
inline const std::string& CookieCraving::_internal_path() const
{
    return _impl_.path_.Get();
}
inline void CookieCraving::_internal_set_path(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* CookieCraving::_internal_mutable_path()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* CookieCraving::release_path()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.CookieCraving.path)
    if (!_internal_has_path()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.path_.IsDefault()) {
        _impl_.path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void CookieCraving::set_allocated_path(std::string* path)
{
    if (path != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.path_.IsDefault()) {
        _impl_.path_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.CookieCraving.path)
}

// optional bool secure = 4;
inline bool CookieCraving::_internal_has_secure() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool CookieCraving::has_secure() const
{
    return _internal_has_secure();
}
inline void CookieCraving::clear_secure()
{
    _impl_.secure_ = false;
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool CookieCraving::_internal_secure() const
{
    return _impl_.secure_;
}
inline bool CookieCraving::secure() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.secure)
    return _internal_secure();
}
inline void CookieCraving::_internal_set_secure(bool value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.secure_ = value;
}
inline void CookieCraving::set_secure(bool value)
{
    _internal_set_secure(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.secure)
}

// optional bool httponly = 5;
inline bool CookieCraving::_internal_has_httponly() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool CookieCraving::has_httponly() const
{
    return _internal_has_httponly();
}
inline void CookieCraving::clear_httponly()
{
    _impl_.httponly_ = false;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool CookieCraving::_internal_httponly() const
{
    return _impl_.httponly_;
}
inline bool CookieCraving::httponly() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.httponly)
    return _internal_httponly();
}
inline void CookieCraving::_internal_set_httponly(bool value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.httponly_ = value;
}
inline void CookieCraving::set_httponly(bool value)
{
    _internal_set_httponly(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.httponly)
}

// optional int32 source_port = 6;
inline bool CookieCraving::_internal_has_source_port() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
    return value;
}
inline bool CookieCraving::has_source_port() const
{
    return _internal_has_source_port();
}
inline void CookieCraving::clear_source_port()
{
    _impl_.source_port_ = 0;
    _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t CookieCraving::_internal_source_port() const
{
    return _impl_.source_port_;
}
inline int32_t CookieCraving::source_port() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.source_port)
    return _internal_source_port();
}
inline void CookieCraving::_internal_set_source_port(int32_t value)
{
    _impl_._has_bits_[0] |= 0x00000040u;
    _impl_.source_port_ = value;
}
inline void CookieCraving::set_source_port(int32_t value)
{
    _internal_set_source_port(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.source_port)
}

// optional int64 creation_time = 7;
inline bool CookieCraving::_internal_has_creation_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
    return value;
}
inline bool CookieCraving::has_creation_time() const
{
    return _internal_has_creation_time();
}
inline void CookieCraving::clear_creation_time()
{
    _impl_.creation_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int64_t CookieCraving::_internal_creation_time() const
{
    return _impl_.creation_time_;
}
inline int64_t CookieCraving::creation_time() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.creation_time)
    return _internal_creation_time();
}
inline void CookieCraving::_internal_set_creation_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000080u;
    _impl_.creation_time_ = value;
}
inline void CookieCraving::set_creation_time(int64_t value)
{
    _internal_set_creation_time(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.creation_time)
}

// optional .net.device_bound_sessions.proto.CookieSameSite same_site = 8;
inline bool CookieCraving::_internal_has_same_site() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
    return value;
}
inline bool CookieCraving::has_same_site() const
{
    return _internal_has_same_site();
}
inline void CookieCraving::clear_same_site()
{
    _impl_.same_site_ = 0;
    _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::net::device_bound_sessions::proto::CookieSameSite CookieCraving::_internal_same_site() const
{
    return static_cast<::net::device_bound_sessions::proto::CookieSameSite>(_impl_.same_site_);
}
inline ::net::device_bound_sessions::proto::CookieSameSite CookieCraving::same_site() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.same_site)
    return _internal_same_site();
}
inline void CookieCraving::_internal_set_same_site(::net::device_bound_sessions::proto::CookieSameSite value)
{
    assert(::net::device_bound_sessions::proto::CookieSameSite_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000100u;
    _impl_.same_site_ = value;
}
inline void CookieCraving::set_same_site(::net::device_bound_sessions::proto::CookieSameSite value)
{
    _internal_set_same_site(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.same_site)
}

// optional .net.device_bound_sessions.proto.CookieSourceScheme source_scheme = 9;
inline bool CookieCraving::_internal_has_source_scheme() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
    return value;
}
inline bool CookieCraving::has_source_scheme() const
{
    return _internal_has_source_scheme();
}
inline void CookieCraving::clear_source_scheme()
{
    _impl_.source_scheme_ = 0;
    _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::net::device_bound_sessions::proto::CookieSourceScheme CookieCraving::_internal_source_scheme() const
{
    return static_cast<::net::device_bound_sessions::proto::CookieSourceScheme>(_impl_.source_scheme_);
}
inline ::net::device_bound_sessions::proto::CookieSourceScheme CookieCraving::source_scheme() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.source_scheme)
    return _internal_source_scheme();
}
inline void CookieCraving::_internal_set_source_scheme(::net::device_bound_sessions::proto::CookieSourceScheme value)
{
    assert(::net::device_bound_sessions::proto::CookieSourceScheme_IsValid(value));
    _impl_._has_bits_[0] |= 0x00000200u;
    _impl_.source_scheme_ = value;
}
inline void CookieCraving::set_source_scheme(::net::device_bound_sessions::proto::CookieSourceScheme value)
{
    _internal_set_source_scheme(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.CookieCraving.source_scheme)
}

// optional .net.device_bound_sessions.proto.SerializedCookiePartitionKey serialized_partition_key = 10;
inline bool CookieCraving::_internal_has_serialized_partition_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.serialized_partition_key_ != nullptr);
    return value;
}
inline bool CookieCraving::has_serialized_partition_key() const
{
    return _internal_has_serialized_partition_key();
}
inline void CookieCraving::clear_serialized_partition_key()
{
    if (_impl_.serialized_partition_key_ != nullptr)
        _impl_.serialized_partition_key_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::net::device_bound_sessions::proto::SerializedCookiePartitionKey& CookieCraving::_internal_serialized_partition_key() const
{
    const ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* p = _impl_.serialized_partition_key_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::net::device_bound_sessions::proto::SerializedCookiePartitionKey&>(
                            ::net::device_bound_sessions::proto::_SerializedCookiePartitionKey_default_instance_);
}
inline const ::net::device_bound_sessions::proto::SerializedCookiePartitionKey& CookieCraving::serialized_partition_key() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.CookieCraving.serialized_partition_key)
    return _internal_serialized_partition_key();
}
inline void CookieCraving::unsafe_arena_set_allocated_serialized_partition_key(
    ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* serialized_partition_key)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.serialized_partition_key_);
    }
    _impl_.serialized_partition_key_ = serialized_partition_key;
    if (serialized_partition_key) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.device_bound_sessions.proto.CookieCraving.serialized_partition_key)
}
inline ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* CookieCraving::release_serialized_partition_key()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* temp = _impl_.serialized_partition_key_;
    _impl_.serialized_partition_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* CookieCraving::unsafe_arena_release_serialized_partition_key()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.CookieCraving.serialized_partition_key)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* temp = _impl_.serialized_partition_key_;
    _impl_.serialized_partition_key_ = nullptr;
    return temp;
}
inline ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* CookieCraving::_internal_mutable_serialized_partition_key()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.serialized_partition_key_ == nullptr) {
        auto* p = CreateMaybeMessage<::net::device_bound_sessions::proto::SerializedCookiePartitionKey>(GetArenaForAllocation());
        _impl_.serialized_partition_key_ = p;
    }
    return _impl_.serialized_partition_key_;
}
inline ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* CookieCraving::mutable_serialized_partition_key()
{
    ::net::device_bound_sessions::proto::SerializedCookiePartitionKey* _msg = _internal_mutable_serialized_partition_key();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.CookieCraving.serialized_partition_key)
    return _msg;
}
inline void CookieCraving::set_allocated_serialized_partition_key(::net::device_bound_sessions::proto::SerializedCookiePartitionKey* serialized_partition_key)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.serialized_partition_key_;
    }
    if (serialized_partition_key) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(serialized_partition_key);
        if (message_arena != submessage_arena) {
            serialized_partition_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, serialized_partition_key, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.serialized_partition_key_ = serialized_partition_key;
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.CookieCraving.serialized_partition_key)
}

// -------------------------------------------------------------------

// Session

// optional string id = 1;
inline bool Session::_internal_has_id() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    return value;
}
inline bool Session::has_id() const
{
    return _internal_has_id();
}
inline void Session::clear_id()
{
    _impl_.id_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Session::id() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.Session.id)
    return _internal_id();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Session::set_id(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.id_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.Session.id)
}
inline std::string* Session::mutable_id()
{
    std::string* _s = _internal_mutable_id();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.Session.id)
    return _s;
}
inline const std::string& Session::_internal_id() const
{
    return _impl_.id_.Get();
}
inline void Session::_internal_set_id(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000001u;
    _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_id()
{
    _impl_._has_bits_[0] |= 0x00000001u;
    return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_id()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.Session.id)
    if (!_internal_has_id()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000001u;
    auto* p = _impl_.id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_.IsDefault()) {
        _impl_.id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Session::set_allocated_id(std::string* id)
{
    if (id != nullptr) {
        _impl_._has_bits_[0] |= 0x00000001u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.id_.IsDefault()) {
        _impl_.id_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.Session.id)
}

// optional string refresh_url = 2;
inline bool Session::_internal_has_refresh_url() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
    return value;
}
inline bool Session::has_refresh_url() const
{
    return _internal_has_refresh_url();
}
inline void Session::clear_refresh_url()
{
    _impl_.refresh_url_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Session::refresh_url() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.Session.refresh_url)
    return _internal_refresh_url();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Session::set_refresh_url(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.refresh_url_.Set(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.Session.refresh_url)
}
inline std::string* Session::mutable_refresh_url()
{
    std::string* _s = _internal_mutable_refresh_url();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.Session.refresh_url)
    return _s;
}
inline const std::string& Session::_internal_refresh_url() const
{
    return _impl_.refresh_url_.Get();
}
inline void Session::_internal_set_refresh_url(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000002u;
    _impl_.refresh_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_refresh_url()
{
    _impl_._has_bits_[0] |= 0x00000002u;
    return _impl_.refresh_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_refresh_url()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.Session.refresh_url)
    if (!_internal_has_refresh_url()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000002u;
    auto* p = _impl_.refresh_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.refresh_url_.IsDefault()) {
        _impl_.refresh_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Session::set_allocated_refresh_url(std::string* refresh_url)
{
    if (refresh_url != nullptr) {
        _impl_._has_bits_[0] |= 0x00000002u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000002u;
    }
    _impl_.refresh_url_.SetAllocated(refresh_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.refresh_url_.IsDefault()) {
        _impl_.refresh_url_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.Session.refresh_url)
}

// optional bool should_defer_when_expired = 3;
inline bool Session::_internal_has_should_defer_when_expired() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
    return value;
}
inline bool Session::has_should_defer_when_expired() const
{
    return _internal_has_should_defer_when_expired();
}
inline void Session::clear_should_defer_when_expired()
{
    _impl_.should_defer_when_expired_ = false;
    _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool Session::_internal_should_defer_when_expired() const
{
    return _impl_.should_defer_when_expired_;
}
inline bool Session::should_defer_when_expired() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.Session.should_defer_when_expired)
    return _internal_should_defer_when_expired();
}
inline void Session::_internal_set_should_defer_when_expired(bool value)
{
    _impl_._has_bits_[0] |= 0x00000020u;
    _impl_.should_defer_when_expired_ = value;
}
inline void Session::set_should_defer_when_expired(bool value)
{
    _internal_set_should_defer_when_expired(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.Session.should_defer_when_expired)
}

// optional int64 expiry_time = 4;
inline bool Session::_internal_has_expiry_time() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
    return value;
}
inline bool Session::has_expiry_time() const
{
    return _internal_has_expiry_time();
}
inline void Session::clear_expiry_time()
{
    _impl_.expiry_time_ = int64_t { 0 };
    _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t Session::_internal_expiry_time() const
{
    return _impl_.expiry_time_;
}
inline int64_t Session::expiry_time() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.Session.expiry_time)
    return _internal_expiry_time();
}
inline void Session::_internal_set_expiry_time(int64_t value)
{
    _impl_._has_bits_[0] |= 0x00000010u;
    _impl_.expiry_time_ = value;
}
inline void Session::set_expiry_time(int64_t value)
{
    _internal_set_expiry_time(value);
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.Session.expiry_time)
}

// optional bytes wrapped_key = 5;
inline bool Session::_internal_has_wrapped_key() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
    return value;
}
inline bool Session::has_wrapped_key() const
{
    return _internal_has_wrapped_key();
}
inline void Session::clear_wrapped_key()
{
    _impl_.wrapped_key_.ClearToEmpty();
    _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Session::wrapped_key() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.Session.wrapped_key)
    return _internal_wrapped_key();
}
template <typename ArgT0, typename... ArgT> inline PROTOBUF_ALWAYS_INLINE void Session::set_wrapped_key(ArgT0&& arg0, ArgT... args)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.wrapped_key_.SetBytes(static_cast<ArgT0&&>(arg0), args..., GetArenaForAllocation());
    // @@protoc_insertion_point(field_set:net.device_bound_sessions.proto.Session.wrapped_key)
}
inline std::string* Session::mutable_wrapped_key()
{
    std::string* _s = _internal_mutable_wrapped_key();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.Session.wrapped_key)
    return _s;
}
inline const std::string& Session::_internal_wrapped_key() const
{
    return _impl_.wrapped_key_.Get();
}
inline void Session::_internal_set_wrapped_key(const std::string& value)
{
    _impl_._has_bits_[0] |= 0x00000004u;
    _impl_.wrapped_key_.Set(value, GetArenaForAllocation());
}
inline std::string* Session::_internal_mutable_wrapped_key()
{
    _impl_._has_bits_[0] |= 0x00000004u;
    return _impl_.wrapped_key_.Mutable(GetArenaForAllocation());
}
inline std::string* Session::release_wrapped_key()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.Session.wrapped_key)
    if (!_internal_has_wrapped_key()) {
        return nullptr;
    }
    _impl_._has_bits_[0] &= ~0x00000004u;
    auto* p = _impl_.wrapped_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.wrapped_key_.IsDefault()) {
        _impl_.wrapped_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    return p;
}
inline void Session::set_allocated_wrapped_key(std::string* wrapped_key)
{
    if (wrapped_key != nullptr) {
        _impl_._has_bits_[0] |= 0x00000004u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000004u;
    }
    _impl_.wrapped_key_.SetAllocated(wrapped_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if (_impl_.wrapped_key_.IsDefault()) {
        _impl_.wrapped_key_.Set("", GetArenaForAllocation());
    }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.Session.wrapped_key)
}

// optional .net.device_bound_sessions.proto.SessionInclusionRules session_inclusion_rules = 6;
inline bool Session::_internal_has_session_inclusion_rules() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.session_inclusion_rules_ != nullptr);
    return value;
}
inline bool Session::has_session_inclusion_rules() const
{
    return _internal_has_session_inclusion_rules();
}
inline void Session::clear_session_inclusion_rules()
{
    if (_impl_.session_inclusion_rules_ != nullptr)
        _impl_.session_inclusion_rules_->Clear();
    _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::net::device_bound_sessions::proto::SessionInclusionRules& Session::_internal_session_inclusion_rules() const
{
    const ::net::device_bound_sessions::proto::SessionInclusionRules* p = _impl_.session_inclusion_rules_;
    return p != nullptr ? *p
                        : reinterpret_cast<const ::net::device_bound_sessions::proto::SessionInclusionRules&>(
                            ::net::device_bound_sessions::proto::_SessionInclusionRules_default_instance_);
}
inline const ::net::device_bound_sessions::proto::SessionInclusionRules& Session::session_inclusion_rules() const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.Session.session_inclusion_rules)
    return _internal_session_inclusion_rules();
}
inline void Session::unsafe_arena_set_allocated_session_inclusion_rules(::net::device_bound_sessions::proto::SessionInclusionRules* session_inclusion_rules)
{
    if (GetArenaForAllocation() == nullptr) {
        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.session_inclusion_rules_);
    }
    _impl_.session_inclusion_rules_ = session_inclusion_rules;
    if (session_inclusion_rules) {
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:net.device_bound_sessions.proto.Session.session_inclusion_rules)
}
inline ::net::device_bound_sessions::proto::SessionInclusionRules* Session::release_session_inclusion_rules()
{
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::net::device_bound_sessions::proto::SessionInclusionRules* temp = _impl_.session_inclusion_rules_;
    _impl_.session_inclusion_rules_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    if (GetArenaForAllocation() == nullptr) {
        delete old;
    }
#else // PROTOBUF_FORCE_COPY_IN_RELEASE
    if (GetArenaForAllocation() != nullptr) {
        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
#endif // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return temp;
}
inline ::net::device_bound_sessions::proto::SessionInclusionRules* Session::unsafe_arena_release_session_inclusion_rules()
{
    // @@protoc_insertion_point(field_release:net.device_bound_sessions.proto.Session.session_inclusion_rules)
    _impl_._has_bits_[0] &= ~0x00000008u;
    ::net::device_bound_sessions::proto::SessionInclusionRules* temp = _impl_.session_inclusion_rules_;
    _impl_.session_inclusion_rules_ = nullptr;
    return temp;
}
inline ::net::device_bound_sessions::proto::SessionInclusionRules* Session::_internal_mutable_session_inclusion_rules()
{
    _impl_._has_bits_[0] |= 0x00000008u;
    if (_impl_.session_inclusion_rules_ == nullptr) {
        auto* p = CreateMaybeMessage<::net::device_bound_sessions::proto::SessionInclusionRules>(GetArenaForAllocation());
        _impl_.session_inclusion_rules_ = p;
    }
    return _impl_.session_inclusion_rules_;
}
inline ::net::device_bound_sessions::proto::SessionInclusionRules* Session::mutable_session_inclusion_rules()
{
    ::net::device_bound_sessions::proto::SessionInclusionRules* _msg = _internal_mutable_session_inclusion_rules();
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.Session.session_inclusion_rules)
    return _msg;
}
inline void Session::set_allocated_session_inclusion_rules(::net::device_bound_sessions::proto::SessionInclusionRules* session_inclusion_rules)
{
    ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
    if (message_arena == nullptr) {
        delete _impl_.session_inclusion_rules_;
    }
    if (session_inclusion_rules) {
        ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_inclusion_rules);
        if (message_arena != submessage_arena) {
            session_inclusion_rules = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(message_arena, session_inclusion_rules, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000008u;
    } else {
        _impl_._has_bits_[0] &= ~0x00000008u;
    }
    _impl_.session_inclusion_rules_ = session_inclusion_rules;
    // @@protoc_insertion_point(field_set_allocated:net.device_bound_sessions.proto.Session.session_inclusion_rules)
}

// repeated .net.device_bound_sessions.proto.CookieCraving cookie_cravings = 7;
inline int Session::_internal_cookie_cravings_size() const
{
    return _impl_.cookie_cravings_.size();
}
inline int Session::cookie_cravings_size() const
{
    return _internal_cookie_cravings_size();
}
inline void Session::clear_cookie_cravings()
{
    _impl_.cookie_cravings_.Clear();
}
inline ::net::device_bound_sessions::proto::CookieCraving* Session::mutable_cookie_cravings(int index)
{
    // @@protoc_insertion_point(field_mutable:net.device_bound_sessions.proto.Session.cookie_cravings)
    return _impl_.cookie_cravings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::CookieCraving>* Session::mutable_cookie_cravings()
{
    // @@protoc_insertion_point(field_mutable_list:net.device_bound_sessions.proto.Session.cookie_cravings)
    return &_impl_.cookie_cravings_;
}
inline const ::net::device_bound_sessions::proto::CookieCraving& Session::_internal_cookie_cravings(int index) const
{
    return _impl_.cookie_cravings_.Get(index);
}
inline const ::net::device_bound_sessions::proto::CookieCraving& Session::cookie_cravings(int index) const
{
    // @@protoc_insertion_point(field_get:net.device_bound_sessions.proto.Session.cookie_cravings)
    return _internal_cookie_cravings(index);
}
inline ::net::device_bound_sessions::proto::CookieCraving* Session::_internal_add_cookie_cravings()
{
    return _impl_.cookie_cravings_.Add();
}
inline ::net::device_bound_sessions::proto::CookieCraving* Session::add_cookie_cravings()
{
    ::net::device_bound_sessions::proto::CookieCraving* _add = _internal_add_cookie_cravings();
    // @@protoc_insertion_point(field_add:net.device_bound_sessions.proto.Session.cookie_cravings)
    return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<::net::device_bound_sessions::proto::CookieCraving>& Session::cookie_cravings() const
{
    // @@protoc_insertion_point(field_list:net.device_bound_sessions.proto.Session.cookie_cravings)
    return _impl_.cookie_cravings_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SiteSessions

// map<string, .net.device_bound_sessions.proto.Session> sessions = 1;
inline int SiteSessions::_internal_sessions_size() const
{
    return _impl_.sessions_.size();
}
inline int SiteSessions::sessions_size() const
{
    return _internal_sessions_size();
}
inline void SiteSessions::clear_sessions()
{
    _impl_.sessions_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::net::device_bound_sessions::proto::Session>& SiteSessions::_internal_sessions() const
{
    return _impl_.sessions_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::net::device_bound_sessions::proto::Session>& SiteSessions::sessions() const
{
    // @@protoc_insertion_point(field_map:net.device_bound_sessions.proto.SiteSessions.sessions)
    return _internal_sessions();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::net::device_bound_sessions::proto::Session>* SiteSessions::_internal_mutable_sessions()
{
    return _impl_.sessions_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map<std::string, ::net::device_bound_sessions::proto::Session>* SiteSessions::mutable_sessions()
{
    // @@protoc_insertion_point(field_mutable_map:net.device_bound_sessions.proto.SiteSessions.sessions)
    return _internal_mutable_sessions();
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// @@protoc_insertion_point(namespace_scope)

} // namespace proto
} // namespace device_bound_sessions
} // namespace net

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum<::net::device_bound_sessions::proto::RuleType> : ::std::true_type { };
template <> struct is_proto_enum<::net::device_bound_sessions::proto::CookieSameSite> : ::std::true_type { };
template <> struct is_proto_enum<::net::device_bound_sessions::proto::CookieSourceScheme> : ::std::true_type { };

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_2fdevice_5fbound_5fsessions_2fproto_2fstorage_2eproto
